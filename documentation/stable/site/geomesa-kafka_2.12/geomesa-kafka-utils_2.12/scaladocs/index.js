Index.PACKAGES = {"org.locationtech" : [], "org.locationtech.geomesa" : [], "org.locationtech.geomesa.kafka.versions" : [{"name" : "org.locationtech.geomesa.kafka.versions.KafkaAdminVersions", "shortDescription" : "Reflection wrapper for AdminClient\/Admin methods", "object" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html", "members_object" : [{"label" : "deleteConsumerGroupOffsets", "tail" : "(admin: AdminClient, groupId: String, partitions: Set[TopicPartition]): Unit", "member" : "org.locationtech.geomesa.kafka.versions.KafkaAdminVersions.deleteConsumerGroupOffsets", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#deleteConsumerGroupOffsets(admin:org.apache.kafka.clients.admin.AdminClient,groupId:String,partitions:java.util.Set[org.apache.kafka.common.TopicPartition]):Unit", "kind" : "def"}, {"label" : "logger", "tail" : ": Logger", "member" : "com.typesafe.scalalogging.LazyLogging.logger", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#logger:com.typesafe.scalalogging.Logger", "kind" : "lazy val"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaAdminVersions$.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}], "kind" : "object"}, {"name" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions", "shortDescription" : "Reflection wrapper for KafkaConsumer methods between kafka versions 0.9, 0.10, 1.0, 1.1, 2.0, and 2.1", "object" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html", "members_object" : [{"label" : "offsetsForTimes", "tail" : "(consumer: Consumer[_, _], topic: String, partitions: Seq[Int], time: Long): Map[Int, Long]", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.offsetsForTimes", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#offsetsForTimes(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:String,partitions:Seq[Int],time:Long):Map[Int,Long]", "kind" : "def"}, {"label" : "endOffsets", "tail" : "(consumer: Consumer[_, _], topic: String, partitions: Seq[Int]): Map[Int, Long]", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.endOffsets", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#endOffsets(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:String,partitions:Seq[Int]):Map[Int,Long]", "kind" : "def"}, {"label" : "beginningOffsets", "tail" : "(consumer: Consumer[_, _], topic: String, partitions: Seq[Int]): Map[Int, Long]", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.beginningOffsets", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#beginningOffsets(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:String,partitions:Seq[Int]):Map[Int,Long]", "kind" : "def"}, {"label" : "subscribe", "tail" : "(consumer: Consumer[_, _], topic: String, listener: ConsumerRebalanceListener): Unit", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.subscribe", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#subscribe(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:String,listener:org.apache.kafka.clients.consumer.ConsumerRebalanceListener):Unit", "kind" : "def"}, {"label" : "subscribe", "tail" : "(consumer: Consumer[_, _], topic: String): Unit", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.subscribe", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#subscribe(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:String):Unit", "kind" : "def"}, {"label" : "resume", "tail" : "(consumer: Consumer[_, _], topic: TopicPartition): Unit", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.resume", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#resume(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:org.apache.kafka.common.TopicPartition):Unit", "kind" : "def"}, {"label" : "pause", "tail" : "(consumer: Consumer[_, _], topic: TopicPartition): Unit", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.pause", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#pause(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:org.apache.kafka.common.TopicPartition):Unit", "kind" : "def"}, {"label" : "seekToBeginning", "tail" : "(consumer: Consumer[_, _], topic: TopicPartition): Unit", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.seekToBeginning", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#seekToBeginning(consumer:org.apache.kafka.clients.consumer.Consumer[_,_],topic:org.apache.kafka.common.TopicPartition):Unit", "kind" : "def"}, {"label" : "poll", "tail" : "(consumer: Consumer[K, V], timeout: Duration): ConsumerRecords[K, V]", "member" : "org.locationtech.geomesa.kafka.versions.KafkaConsumerVersions.poll", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#poll[K,V](consumer:org.apache.kafka.clients.consumer.Consumer[K,V],timeout:java.time.Duration):org.apache.kafka.clients.consumer.ConsumerRecords[K,V]", "kind" : "def"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/KafkaConsumerVersions$.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}], "kind" : "object"}, {"name" : "org.locationtech.geomesa.kafka.versions.RecordVersions", "shortDescription" : "Reflection wrapper for ProducerRecord and ConsumerRecord methods between kafka versions0.9, 0.10, 1.0, 1.1, and 2.0", "object" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html", "members_object" : [{"label" : "getTimestamp", "tail" : "(record: ConsumerRecord[_, _]): Long", "member" : "org.locationtech.geomesa.kafka.versions.RecordVersions.getTimestamp", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#getTimestamp(record:org.apache.kafka.clients.consumer.ConsumerRecord[_,_]):Long", "kind" : "def"}, {"label" : "getHeaders", "tail" : "(record: ConsumerRecord[_, _]): Map[String, Array[Byte]]", "member" : "org.locationtech.geomesa.kafka.versions.RecordVersions.getHeaders", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#getHeaders(record:org.apache.kafka.clients.consumer.ConsumerRecord[_,_]):Map[String,Array[Byte]]", "kind" : "def"}, {"label" : "setHeader", "tail" : "(record: ProducerRecord[_, _], key: String, value: Array[Byte]): Unit", "member" : "org.locationtech.geomesa.kafka.versions.RecordVersions.setHeader", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#setHeader(record:org.apache.kafka.clients.producer.ProducerRecord[_,_],key:String,value:Array[Byte]):Unit", "kind" : "def"}, {"label" : "logger", "tail" : ": Logger", "member" : "com.typesafe.scalalogging.LazyLogging.logger", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#logger:com.typesafe.scalalogging.Logger", "kind" : "lazy val"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/versions\/RecordVersions$.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}], "kind" : "object"}], "org.locationtech.geomesa.kafka" : [], "org" : [], "org.locationtech.geomesa.kafka.consumer" : [{"name" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer", "shortDescription" : "", "members_class" : [{"label" : "isOpen", "tail" : "(): Boolean", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.isOpen", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#isOpen:Boolean", "kind" : "def"}, {"label" : "close", "tail" : "(): Unit", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.close", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#close():Unit", "kind" : "def"}, {"label" : "startConsumers", "tail" : "(handler: Option[ConsumerErrorHandler]): Unit", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.startConsumers", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#startConsumers(handler:Option[org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerErrorHandler]):Unit", "kind" : "def"}, {"member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer#<init>", "error" : "unsupported entity"}, {"label" : "logger", "tail" : ": Logger", "member" : "com.typesafe.scalalogging.LazyLogging.logger", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#logger:com.typesafe.scalalogging.Logger", "kind" : "lazy val"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}, {"label" : "createConsumerRunnable", "tail" : "(id: String, consumer: Consumer[Array[Byte], Array[Byte]], handler: ConsumerErrorHandler): Runnable", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.createConsumerRunnable", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html#createConsumerRunnable(id:String,consumer:org.apache.kafka.clients.consumer.Consumer[Array[Byte],Array[Byte]],handler:org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerErrorHandler):Runnable", "kind" : "abstract def"}], "class" : "org\/locationtech\/geomesa\/kafka\/consumer\/BaseThreadedConsumer.html", "kind" : "class"}, {"name" : "org.locationtech.geomesa.kafka.consumer.BatchConsumer", "shortDescription" : "Consumer that will process messages in batch, with guaranteed at-least-once processing", "object" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html", "members_class" : [{"label" : "ConsumerRunnable", "tail" : "", "member" : "org.locationtech.geomesa.kafka.consumer.BatchConsumer.ConsumerRunnable", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#ConsumerRunnableextendsRunnable", "kind" : "class"}, {"label" : "ConsumerCoordinator", "tail" : "", "member" : "org.locationtech.geomesa.kafka.consumer.BatchConsumer.ConsumerCoordinator", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#ConsumerCoordinatorextendsRunnable", "kind" : "class"}, {"label" : "createConsumerRunnable", "tail" : "(id: String, consumer: Consumer[Array[Byte], Array[Byte]], handler: ConsumerErrorHandler): Runnable", "member" : "org.locationtech.geomesa.kafka.consumer.BatchConsumer.createConsumerRunnable", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#createConsumerRunnable(id:String,consumer:org.apache.kafka.clients.consumer.Consumer[Array[Byte],Array[Byte]],handler:org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerErrorHandler):Runnable", "kind" : "def"}, {"member" : "org.locationtech.geomesa.kafka.consumer.BatchConsumer#<init>", "error" : "unsupported entity"}, {"label" : "isOpen", "tail" : "(): Boolean", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.isOpen", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#isOpen:Boolean", "kind" : "def"}, {"label" : "close", "tail" : "(): Unit", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.close", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#close():Unit", "kind" : "def"}, {"label" : "startConsumers", "tail" : "(handler: Option[ConsumerErrorHandler]): Unit", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.startConsumers", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#startConsumers(handler:Option[org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerErrorHandler]):Unit", "kind" : "def"}, {"label" : "logger", "tail" : ": Logger", "member" : "com.typesafe.scalalogging.LazyLogging.logger", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#logger:com.typesafe.scalalogging.Logger", "kind" : "lazy val"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}, {"label" : "consume", "tail" : "(records: Seq[ConsumerRecord[Array[Byte], Array[Byte]]]): BatchResult", "member" : "org.locationtech.geomesa.kafka.consumer.BatchConsumer.consume", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html#consume(records:Seq[org.apache.kafka.clients.consumer.ConsumerRecord[Array[Byte],Array[Byte]]]):org.locationtech.geomesa.kafka.consumer.BatchConsumer.BatchResult.BatchResult", "kind" : "abstract def"}], "members_object" : [{"label" : "BatchResult", "tail" : "", "member" : "org.locationtech.geomesa.kafka.consumer.BatchConsumer.BatchResult", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#BatchResult", "kind" : "object"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer$.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}], "class" : "org\/locationtech\/geomesa\/kafka\/consumer\/BatchConsumer.html", "kind" : "class"}, {"name" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer", "shortDescription" : "", "object" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html", "members_class" : [{"label" : "ConsumerRunnable", "tail" : "", "member" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerRunnable", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#ConsumerRunnableextendsRunnable", "kind" : "class"}, {"label" : "createConsumerRunnable", "tail" : "(id: String, consumer: Consumer[Array[Byte], Array[Byte]], handler: ConsumerErrorHandler): Runnable", "member" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.createConsumerRunnable", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#createConsumerRunnable(id:String,consumer:org.apache.kafka.clients.consumer.Consumer[Array[Byte],Array[Byte]],handler:org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerErrorHandler):Runnable", "kind" : "def"}, {"member" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer#<init>", "error" : "unsupported entity"}, {"label" : "isOpen", "tail" : "(): Boolean", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.isOpen", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#isOpen:Boolean", "kind" : "def"}, {"label" : "close", "tail" : "(): Unit", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.close", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#close():Unit", "kind" : "def"}, {"label" : "startConsumers", "tail" : "(handler: Option[ConsumerErrorHandler]): Unit", "member" : "org.locationtech.geomesa.kafka.consumer.BaseThreadedConsumer.startConsumers", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#startConsumers(handler:Option[org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerErrorHandler]):Unit", "kind" : "def"}, {"label" : "logger", "tail" : ": Logger", "member" : "com.typesafe.scalalogging.LazyLogging.logger", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#logger:com.typesafe.scalalogging.Logger", "kind" : "lazy val"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}, {"label" : "consume", "tail" : "(record: ConsumerRecord[Array[Byte], Array[Byte]]): Unit", "member" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.consume", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html#consume(record:org.apache.kafka.clients.consumer.ConsumerRecord[Array[Byte],Array[Byte]]):Unit", "kind" : "abstract def"}], "members_object" : [{"label" : "LogOffsetCommitCallback", "tail" : "", "member" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.LogOffsetCommitCallback", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#LogOffsetCommitCallbackextendsOffsetCommitCallback", "kind" : "class"}, {"label" : "LoggingConsumerErrorHandler", "tail" : "", "member" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.LoggingConsumerErrorHandler", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#LoggingConsumerErrorHandlerextendsThreadedConsumer.ConsumerErrorHandler", "kind" : "class"}, {"label" : "ConsumerErrorHandler", "tail" : "", "member" : "org.locationtech.geomesa.kafka.consumer.ThreadedConsumer.ConsumerErrorHandler", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#ConsumerErrorHandlerextendsAnyRef", "kind" : "trait"}, {"label" : "synchronized", "tail" : "(arg0: ⇒ T0): T0", "member" : "scala.AnyRef.synchronized", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#synchronized[T0](x$1:=>T0):T0", "kind" : "final def"}, {"label" : "##", "tail" : "(): Int", "member" : "scala.AnyRef.##", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html###():Int", "kind" : "final def"}, {"label" : "!=", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.!=", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#!=(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "==", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.==", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#==(x$1:Any):Boolean", "kind" : "final def"}, {"label" : "ne", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.ne", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#ne(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "eq", "tail" : "(arg0: AnyRef): Boolean", "member" : "scala.AnyRef.eq", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#eq(x$1:AnyRef):Boolean", "kind" : "final def"}, {"label" : "finalize", "tail" : "(): Unit", "member" : "scala.AnyRef.finalize", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#finalize():Unit", "kind" : "def"}, {"label" : "wait", "tail" : "(arg0: Long, arg1: Int): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#wait(x$1:Long,x$2:Int):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(arg0: Long): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#wait(x$1:Long):Unit", "kind" : "final def"}, {"label" : "wait", "tail" : "(): Unit", "member" : "scala.AnyRef.wait", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#wait():Unit", "kind" : "final def"}, {"label" : "notifyAll", "tail" : "(): Unit", "member" : "scala.AnyRef.notifyAll", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#notifyAll():Unit", "kind" : "final def"}, {"label" : "notify", "tail" : "(): Unit", "member" : "scala.AnyRef.notify", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#notify():Unit", "kind" : "final def"}, {"label" : "toString", "tail" : "(): String", "member" : "scala.AnyRef.toString", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#toString():String", "kind" : "def"}, {"label" : "clone", "tail" : "(): AnyRef", "member" : "scala.AnyRef.clone", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#clone():Object", "kind" : "def"}, {"label" : "equals", "tail" : "(arg0: Any): Boolean", "member" : "scala.AnyRef.equals", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#equals(x$1:Any):Boolean", "kind" : "def"}, {"label" : "hashCode", "tail" : "(): Int", "member" : "scala.AnyRef.hashCode", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#hashCode():Int", "kind" : "def"}, {"label" : "getClass", "tail" : "(): Class[_]", "member" : "scala.AnyRef.getClass", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#getClass():Class[_]", "kind" : "final def"}, {"label" : "asInstanceOf", "tail" : "(): T0", "member" : "scala.Any.asInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#asInstanceOf[T0]:T0", "kind" : "final def"}, {"label" : "isInstanceOf", "tail" : "(): Boolean", "member" : "scala.Any.isInstanceOf", "link" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer$.html#isInstanceOf[T0]:Boolean", "kind" : "final def"}], "class" : "org\/locationtech\/geomesa\/kafka\/consumer\/ThreadedConsumer.html", "kind" : "class"}]};