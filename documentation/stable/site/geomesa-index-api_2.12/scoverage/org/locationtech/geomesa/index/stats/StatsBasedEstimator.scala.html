<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          org/locationtech/geomesa/index/stats/StatsBasedEstimator.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier, monospace;'>1 <span style=''>/***********************************************************************
</span>2 <span style=''> * Copyright (c) 2013-2024 Commonwealth Computer Research, Inc.
</span>3 <span style=''> * All rights reserved. This program and the accompanying materials
</span>4 <span style=''> * are made available under the terms of the Apache License, Version 2.0
</span>5 <span style=''> * which accompanies this distribution and is available at
</span>6 <span style=''> * http://www.opensource.org/licenses/apache2.0.php.
</span>7 <span style=''> ***********************************************************************/
</span>8 <span style=''>
</span>9 <span style=''>package org.locationtech.geomesa.index.stats
</span>10 <span style=''>
</span>11 <span style=''>import org.geotools.api.feature.simple.SimpleFeatureType
</span>12 <span style=''>import org.geotools.api.filter._
</span>13 <span style=''>import org.geotools.api.filter.expression.PropertyName
</span>14 <span style=''>import org.locationtech.geomesa.curve.{BinnedTime, Z2SFC, Z3SFC}
</span>15 <span style=''>import org.locationtech.geomesa.filter.Bounds.Bound
</span>16 <span style=''>import org.locationtech.geomesa.filter._
</span>17 <span style=''>import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
</span>18 <span style=''>import org.locationtech.geomesa.utils.geotools._
</span>19 <span style=''>import org.locationtech.geomesa.zorder.sfcurve.IndexRange
</span>20 <span style=''>import org.locationtech.jts.geom.Geometry
</span>21 <span style=''>
</span>22 <span style=''>import java.time.ZonedDateTime
</span>23 <span style=''>import java.util.Date
</span>24 <span style=''>import scala.collection.JavaConverters._
</span>25 <span style=''>
</span>26 <span style=''>/**
</span>27 <span style=''>  * Estimate query counts based on cached stats.
</span>28 <span style=''>  *
</span>29 <span style=''>  * Although this trait only requires a generic GeoMesaStats implementation mixin, it has been written based
</span>30 <span style=''>  * on `MetadataBackedStats`. In particular, getCount(Filter.INCLUDE) is expected to look up the stat and
</span>31 <span style=''>  * not invoke any methods in this trait. Also, only Frequency and Z3Histograms are split out by time interval,
</span>32 <span style=''>  * so filters are only passed in when reading those two types.
</span>33 <span style=''>  */
</span>34 <span style=''>trait StatsBasedEstimator {
</span>35 <span style=''>
</span>36 <span style=''>  stats: GeoMesaStats =&gt;
</span>37 <span style=''>
</span>38 <span style=''>  import StatsBasedEstimator.{ErrorThresholds, ZHistogramPrecision}
</span>39 <span style=''>
</span>40 <span style=''>  /**
</span>41 <span style=''>    * Estimates the count for a given filter, based off the per-attribute metadata we have stored
</span>42 <span style=''>    *
</span>43 <span style=''>    * @param sft simple feature type
</span>44 <span style=''>    * @param filter filter to apply - should have been run through QueryPlanFilterVisitor so all props are right
</span>45 <span style=''>    * @return estimated count, if available
</span>46 <span style=''>    */
</span>47 <span style=''>  protected def estimateCount(sft: SimpleFeatureType, filter: Filter): Option[Long] = {
</span>48 <span style=''>    filter match {
</span>49 <span style=''>      case Filter.INCLUDE =&gt; </span><span style='background: #AEF1AE'>getCount(sft)</span><span style=''>
</span>50 <span style=''>      case Filter.EXCLUDE =&gt; </span><span style='background: #F0ADAD'>Some(0L)</span><span style=''>
</span>51 <span style=''>
</span>52 <span style=''>      case a: And =&gt; </span><span style='background: #AEF1AE'>estimateAndCount(sft, a)</span><span style=''>
</span>53 <span style=''>      case o: Or  =&gt; </span><span style='background: #AEF1AE'>estimateOrCount(sft, o)</span><span style=''>
</span>54 <span style=''>      case n: Not =&gt; </span><span style='background: #AEF1AE'>estimateNotCount(sft, n)</span><span style=''>
</span>55 <span style=''>
</span>56 <span style=''>      case i: Id =&gt; </span><span style='background: #AEF1AE'>Some(i.getIdentifiers.size)</span><span style=''>
</span>57 <span style=''>      case _ </span><span style='background: #AEF1AE'>=&gt;
</span>58 <span style=''></span><span style='background: #AEF1AE'>        // single filter - equals, between, less than, etc
</span>59 <span style=''></span><span style='background: #AEF1AE'>        val attribute = FilterHelper.propertyNames(filter, sft).headOption
</span>60 <span style=''></span><span style='background: #AEF1AE'>        attribute.flatMap(estimateAttributeCount(sft, filter, _))</span><span style=''>
</span>61 <span style=''>    }
</span>62 <span style=''>  }
</span>63 <span style=''>
</span>64 <span style=''>  /**
</span>65 <span style=''>    * Estimate counts for AND filters. Since it's an AND, we calculate the child counts and
</span>66 <span style=''>    * return the minimum.
</span>67 <span style=''>    *
</span>68 <span style=''>    * We check for spatio-temporal filters first, as those are the only ones that operate on 2+ properties.
</span>69 <span style=''>    *
</span>70 <span style=''>    * @param sft simple feature type
</span>71 <span style=''>    * @param filter AND filter
</span>72 <span style=''>    * @return estimated count, if available
</span>73 <span style=''>    */
</span>74 <span style=''>  private def estimateAndCount(sft: SimpleFeatureType, filter: And): Option[Long] = {
</span>75 <span style=''>    val stCount = </span><span style='background: #AEF1AE'>estimateSpatioTemporalCount(sft, filter)</span><span style=''>
</span>76 <span style=''>    // note: we might over count if we get bbox1 AND bbox2, as we don't intersect them
</span>77 <span style=''>    val individualCounts = </span><span style='background: #AEF1AE'>filter.getChildren.asScala.flatMap(estimateCount(sft, _))</span><span style=''>
</span>78 <span style=''>    val counts = (</span><span style='background: #AEF1AE'>stCount ++ individualCounts</span><span style=''>)
</span>79 <span style=''>    if (</span><span style='background: #AEF1AE'>counts.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>None</span><span style=''> } else { </span><span style='background: #AEF1AE'>Some(counts.min)</span><span style=''> }
</span>80 <span style=''>  }
</span>81 <span style=''>
</span>82 <span style=''>  /**
</span>83 <span style=''>    * Estimate counts for OR filters. Because this is an OR, we sum up the child counts
</span>84 <span style=''>    *
</span>85 <span style=''>    * @param sft simple feature type
</span>86 <span style=''>    * @param filter OR filter
</span>87 <span style=''>    * @return estimated count, if available
</span>88 <span style=''>    */
</span>89 <span style=''>  private def estimateOrCount(sft: SimpleFeatureType, filter: Or): Option[Long] = {
</span>90 <span style=''>    // estimate for each child separately and sum
</span>91 <span style=''>    // note that we might double count some values if the filter is complex
</span>92 <span style=''>    val counts = </span><span style='background: #AEF1AE'>filter.getChildren.asScala.flatMap(estimateCount(sft, _))</span><span style=''>
</span>93 <span style=''>    if (</span><span style='background: #AEF1AE'>counts.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>None</span><span style=''> } else { </span><span style='background: #AEF1AE'>Some(counts.sum)</span><span style=''> }
</span>94 <span style=''>  }
</span>95 <span style=''>
</span>96 <span style=''>  /**
</span>97 <span style=''>    * Estimates the count for NOT filters
</span>98 <span style=''>    *
</span>99 <span style=''>    * @param sft simple feature type
</span>100 <span style=''>    * @param filter filter
</span>101 <span style=''>    * @return count, if available
</span>102 <span style=''>    */
</span>103 <span style=''>  private def estimateNotCount(sft: SimpleFeatureType, filter: Not): Option[Long] = {
</span>104 <span style=''>    </span><span style='background: #AEF1AE'>filter.getFilter</span><span style=''> match {
</span>105 <span style=''>      case f: PropertyIsNull =&gt;
</span>106 <span style=''>        // special handling for 'is not null'
</span>107 <span style=''>        </span><span style='background: #AEF1AE'>f.getExpression match {
</span>108 <span style=''></span><span style='background: #AEF1AE'>          case p: PropertyName =&gt; estimateRangeCount(sft, p.getPropertyName, Seq((None, None)))
</span>109 <span style=''></span><span style='background: #AEF1AE'>          case _ =&gt; </span><span style='background: #F0ADAD'>estimateCount(sft, Filter.INCLUDE)</span><span style='background: #AEF1AE'> // not something we can handle...
</span>110 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>111 <span style=''>
</span>112 <span style=''>      case f =&gt;
</span>113 <span style=''>        </span><span style='background: #AEF1AE'>for {
</span>114 <span style=''></span><span style='background: #AEF1AE'>          all &lt;- estimateCount(sft, Filter.INCLUDE)
</span>115 <span style=''></span><span style='background: #AEF1AE'>          neg &lt;- estimateCount(sft, f)
</span>116 <span style=''></span><span style='background: #AEF1AE'>        } yield {
</span>117 <span style=''></span><span style='background: #AEF1AE'>          math.max(0, all - neg)</span><span style=''>
</span>118 <span style=''>        }
</span>119 <span style=''>    }
</span>120 <span style=''>  }
</span>121 <span style=''>
</span>122 <span style=''>  /**
</span>123 <span style=''>    * Estimate spatio-temporal counts for an AND filter.
</span>124 <span style=''>    *
</span>125 <span style=''>    * @param sft simple feature type
</span>126 <span style=''>    * @param filter complex filter
</span>127 <span style=''>    * @return count, if available
</span>128 <span style=''>    */
</span>129 <span style=''>  private def estimateSpatioTemporalCount(sft: SimpleFeatureType, filter: And): Option[Long] = {
</span>130 <span style=''>    // currently we don't consider if the spatial predicate is actually AND'd with the temporal predicate...
</span>131 <span style=''>    // TODO add filterhelper method that accurately pulls out the st values
</span>132 <span style=''>    </span><span style='background: #AEF1AE'>for {
</span>133 <span style=''></span><span style='background: #AEF1AE'>      geomField  &lt;- Option(sft.getGeomField)
</span>134 <span style=''></span><span style='background: #AEF1AE'>      dateField  &lt;- sft.getDtgField
</span>135 <span style=''></span><span style='background: #AEF1AE'>      geometries =  FilterHelper.extractGeometries(filter, geomField, sft.isPoints)
</span>136 <span style=''></span><span style='background: #AEF1AE'>      if geometries.nonEmpty
</span>137 <span style=''></span><span style='background: #AEF1AE'>      intervals  =  FilterHelper.extractIntervals(filter, dateField)
</span>138 <span style=''></span><span style='background: #AEF1AE'>      if intervals.nonEmpty
</span>139 <span style=''></span><span style='background: #AEF1AE'>      bounds     &lt;- stats.getMinMax[Date](sft, dateField)
</span>140 <span style=''></span><span style='background: #AEF1AE'>    } yield {
</span>141 <span style=''></span><span style='background: #AEF1AE'>      if (geometries.disjoint || intervals.disjoint) { </span><span style='background: #F0ADAD'>0L</span><span style='background: #AEF1AE'> } else {
</span>142 <span style=''></span><span style='background: #AEF1AE'>        val inRangeIntervals = {
</span>143 <span style=''></span><span style='background: #AEF1AE'>          val minTime = bounds.min.getTime
</span>144 <span style=''></span><span style='background: #AEF1AE'>          val maxTime = bounds.max.getTime
</span>145 <span style=''></span><span style='background: #AEF1AE'>          intervals.values.filter { i =&gt;
</span>146 <span style=''></span><span style='background: #AEF1AE'>            i.lower.value.forall(_.toInstant.toEpochMilli &lt;= maxTime) &amp;&amp;
</span>147 <span style=''></span><span style='background: #AEF1AE'>                i.upper.value.forall(_.toInstant.toEpochMilli &gt;= minTime)
</span>148 <span style=''></span><span style='background: #AEF1AE'>          }
</span>149 <span style=''></span><span style='background: #AEF1AE'>        }
</span>150 <span style=''></span><span style='background: #AEF1AE'>        val period = sft.getZ3Interval
</span>151 <span style=''></span><span style='background: #AEF1AE'>        stats.getZ3Histogram(sft, geomField, dateField, period, 0, filter) match {
</span>152 <span style=''></span><span style='background: #AEF1AE'>          case None =&gt; 0L
</span>153 <span style=''></span><span style='background: #AEF1AE'>          case Some(histogram) =&gt;
</span>154 <span style=''></span><span style='background: #AEF1AE'>            // time range for a chunk is 0 to 1 week (in seconds)
</span>155 <span style=''></span><span style='background: #AEF1AE'>            val sfc = Z3SFC(period)
</span>156 <span style=''></span><span style='background: #AEF1AE'>            val (tmin, tmax) = (sfc.time.min.toLong, sfc.time.max.toLong)
</span>157 <span style=''></span><span style='background: #AEF1AE'>            val xy = geometries.values.map(GeometryUtils.bounds)
</span>158 <span style=''></span><span style='background: #AEF1AE'>
</span>159 <span style=''></span><span style='background: #AEF1AE'>            def getIndices(t1: Long, t2: Long): Seq[Int] = {
</span>160 <span style=''></span><span style='background: #AEF1AE'>              val w = histogram.timeBins.head // z3 histogram bounds are fixed, so indices should be the same
</span>161 <span style=''></span><span style='background: #AEF1AE'>              val zs = sfc.ranges(xy, Seq((t1, t2)), ZHistogramPrecision)
</span>162 <span style=''></span><span style='background: #AEF1AE'>              zs.flatMap(r =&gt; histogram.directIndex(w, r.lower) to histogram.directIndex(w, r.upper))
</span>163 <span style=''></span><span style='background: #AEF1AE'>            }
</span>164 <span style=''></span><span style='background: #AEF1AE'>            lazy val middleIndices = getIndices(tmin, tmax)
</span>165 <span style=''></span><span style='background: #AEF1AE'>
</span>166 <span style=''></span><span style='background: #AEF1AE'>            // build up our indices by week so that we can deduplicate them afterwards
</span>167 <span style=''></span><span style='background: #AEF1AE'>            val timeBinsAndIndices = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(Seq.empty)
</span>168 <span style=''></span><span style='background: #AEF1AE'>
</span>169 <span style=''></span><span style='background: #AEF1AE'>            val dateToBins = BinnedTime.dateToBinnedTime(period)
</span>170 <span style=''></span><span style='background: #AEF1AE'>            val boundsToDates = BinnedTime.boundsToIndexableDates(period)
</span>171 <span style=''></span><span style='background: #AEF1AE'>            val binnedTimes = inRangeIntervals.map { interval =&gt;
</span>172 <span style=''></span><span style='background: #AEF1AE'>              val (lower, upper) = boundsToDates(interval.bounds)
</span>173 <span style=''></span><span style='background: #AEF1AE'>              val BinnedTime(lb, lt) = dateToBins(lower)
</span>174 <span style=''></span><span style='background: #AEF1AE'>              val BinnedTime(ub, ut) = dateToBins(upper)
</span>175 <span style=''></span><span style='background: #AEF1AE'>              (Range.inclusive(lb, ub).map(_.toShort), lt, ut)
</span>176 <span style=''></span><span style='background: #AEF1AE'>            }
</span>177 <span style=''></span><span style='background: #AEF1AE'>
</span>178 <span style=''></span><span style='background: #AEF1AE'>            // the z3 index breaks time into 1 week chunks, so create a range for each week in our range
</span>179 <span style=''></span><span style='background: #AEF1AE'>            binnedTimes.foreach { case (bins, lt, ut) =&gt;
</span>180 <span style=''></span><span style='background: #AEF1AE'>              if (bins.length == 1) {
</span>181 <span style=''></span><span style='background: #AEF1AE'>                timeBinsAndIndices(bins.head) ++= getIndices(lt, ut)
</span>182 <span style=''></span><span style='background: #AEF1AE'>              } else {
</span>183 <span style=''></span><span style='background: #AEF1AE'>                val head +: middle :+ last = bins.toList
</span>184 <span style=''></span><span style='background: #AEF1AE'>                timeBinsAndIndices(head) ++= getIndices(lt, tmax)
</span>185 <span style=''></span><span style='background: #AEF1AE'>                timeBinsAndIndices(last) ++= getIndices(tmin, ut)
</span>186 <span style=''></span><span style='background: #AEF1AE'>                middle.foreach(m =&gt; </span><span style='background: #F0ADAD'>timeBinsAndIndices(m) ++= middleIndices</span><span style='background: #AEF1AE'>)
</span>187 <span style=''></span><span style='background: #AEF1AE'>              }
</span>188 <span style=''></span><span style='background: #AEF1AE'>            }
</span>189 <span style=''></span><span style='background: #AEF1AE'>
</span>190 <span style=''></span><span style='background: #AEF1AE'>            timeBinsAndIndices.map { case (b, indices) =&gt; indices.distinct.map(histogram.count(b, _)).sum }.sum
</span>191 <span style=''></span><span style='background: #AEF1AE'>        }
</span>192 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>193 <span style=''>    }
</span>194 <span style=''>  }
</span>195 <span style=''>
</span>196 <span style=''>  /**
</span>197 <span style=''>    * Estimates the count for attribute filters (equals, less than, during, etc)
</span>198 <span style=''>    *
</span>199 <span style=''>    * @param sft simple feature type
</span>200 <span style=''>    * @param filter filter
</span>201 <span style=''>    * @param attribute attribute name to estimate
</span>202 <span style=''>    * @return count, if available
</span>203 <span style=''>    */
</span>204 <span style=''>  private def estimateAttributeCount(sft: SimpleFeatureType, filter: Filter, attribute: String): Option[Long] = {
</span>205 <span style=''>    import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor
</span>206 <span style=''>
</span>207 <span style=''>    if (</span><span style='background: #AEF1AE'>attribute == sft.getGeomField</span><span style=''>) {
</span>208 <span style=''>      </span><span style='background: #AEF1AE'>estimateSpatialCount(sft, filter)</span><span style=''>
</span>209 <span style=''>    } else </span><span style='background: #AEF1AE'>if (sft.getDtgField.contains(attribute)) {
</span>210 <span style=''></span><span style='background: #AEF1AE'>      estimateTemporalCount(sft, filter)
</span>211 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>212 <span style=''></span><span style='background: #AEF1AE'>      // we have an attribute filter
</span>213 <span style=''></span><span style='background: #AEF1AE'>      val extractedBounds = for {
</span>214 <span style=''></span><span style='background: #AEF1AE'>        descriptor &lt;- Option(sft.getDescriptor(attribute))
</span>215 <span style=''></span><span style='background: #AEF1AE'>        binding    =  if (descriptor.isList) { </span><span style='background: #F0ADAD'>descriptor.getListType()</span><span style='background: #AEF1AE'> } else { descriptor.getType.getBinding }
</span>216 <span style=''></span><span style='background: #AEF1AE'>      } yield {
</span>217 <span style=''></span><span style='background: #AEF1AE'>        FilterHelper.extractAttributeBounds(filter, attribute, binding.asInstanceOf[Class[Any]])
</span>218 <span style=''></span><span style='background: #AEF1AE'>      }
</span>219 <span style=''></span><span style='background: #AEF1AE'>      extractedBounds.flatMap { bounds =&gt;
</span>220 <span style=''></span><span style='background: #AEF1AE'>        if (bounds.disjoint) {
</span>221 <span style=''></span><span style='background: #AEF1AE'>          </span><span style='background: #F0ADAD'>Some(0L)</span><span style='background: #AEF1AE'> // disjoint range
</span>222 <span style=''></span><span style='background: #AEF1AE'>        } else if (!bounds.values.exists(_.isBounded)) {
</span>223 <span style=''></span><span style='background: #AEF1AE'>          </span><span style='background: #F0ADAD'>estimateCount(sft, Filter.INCLUDE)</span><span style='background: #AEF1AE'> // inclusive filter
</span>224 <span style=''></span><span style='background: #AEF1AE'>        } else {
</span>225 <span style=''></span><span style='background: #AEF1AE'>          val boundsValues = bounds.values.map(b =&gt; (b.lower.value, b.upper.value))
</span>226 <span style=''></span><span style='background: #AEF1AE'>          val (equalsBounds, rangeBounds) = boundsValues.partition { case (l, r) =&gt; l == r }
</span>227 <span style=''></span><span style='background: #AEF1AE'>          val equalsCount = if (equalsBounds.isEmpty) { Some(0L) } else {
</span>228 <span style=''></span><span style='background: #AEF1AE'>            // compare equals estimate with range estimate and take the smaller
</span>229 <span style=''></span><span style='background: #AEF1AE'>            val equals = estimateEqualsCount(sft, filter, attribute, equalsBounds.map(_._1.get))
</span>230 <span style=''></span><span style='background: #AEF1AE'>            val range  = estimateRangeCount(sft, attribute, equalsBounds)
</span>231 <span style=''></span><span style='background: #AEF1AE'>            (equals, range) match {
</span>232 <span style=''></span><span style='background: #AEF1AE'>              case (Some(e), Some(r)) =&gt; Some(math.min(e, r))
</span>233 <span style=''></span><span style='background: #AEF1AE'>              case (None, r) =&gt; r
</span>234 <span style=''></span><span style='background: #AEF1AE'>              case (e, None) =&gt; e
</span>235 <span style=''></span><span style='background: #AEF1AE'>            }
</span>236 <span style=''></span><span style='background: #AEF1AE'>          }
</span>237 <span style=''></span><span style='background: #AEF1AE'>          val rangeCount = if (rangeBounds.isEmpty) { Some(0L) } else {
</span>238 <span style=''></span><span style='background: #AEF1AE'>            estimateRangeCount(sft, attribute, rangeBounds)
</span>239 <span style=''></span><span style='background: #AEF1AE'>          }
</span>240 <span style=''></span><span style='background: #AEF1AE'>          for { e &lt;- equalsCount; r &lt;- rangeCount } yield { e + r }
</span>241 <span style=''></span><span style='background: #AEF1AE'>        }
</span>242 <span style=''></span><span style='background: #AEF1AE'>      }
</span>243 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>244 <span style=''>  }
</span>245 <span style=''>
</span>246 <span style=''>  /**
</span>247 <span style=''>    * Estimates counts from spatial predicates. Non-spatial predicates will be ignored.
</span>248 <span style=''>    *
</span>249 <span style=''>    * @param filter filter to evaluate
</span>250 <span style=''>    * @return estimated count, if available
</span>251 <span style=''>    */
</span>252 <span style=''>  private def estimateSpatialCount(sft: SimpleFeatureType, filter: Filter): Option[Long] = {
</span>253 <span style=''>    val geometries = </span><span style='background: #AEF1AE'>FilterHelper.extractGeometries(filter, sft.getGeomField, sft.isPoints)</span><span style=''>
</span>254 <span style=''>    if (</span><span style='background: #AEF1AE'>geometries.isEmpty</span><span style=''>) {
</span>255 <span style=''>      </span><span style='background: #F0ADAD'>None</span><span style=''>
</span>256 <span style=''>    } else </span><span style='background: #AEF1AE'>if (geometries.disjoint) {
</span>257 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>Some(0L)</span><span style='background: #AEF1AE'>
</span>258 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>259 <span style=''></span><span style='background: #AEF1AE'>      val zero = GeometryUtils.zeroPoint
</span>260 <span style=''></span><span style='background: #AEF1AE'>      stats.getHistogram[Geometry](sft, sft.getGeomField, 0, zero, zero).map { histogram =&gt;
</span>261 <span style=''></span><span style='background: #AEF1AE'>        val (zLo, zHi) = {
</span>262 <span style=''></span><span style='background: #AEF1AE'>          val (xmin, ymin, _, _) = GeometryUtils.bounds(histogram.min)
</span>263 <span style=''></span><span style='background: #AEF1AE'>          val (_, _, xmax, ymax) = GeometryUtils.bounds(histogram.max)
</span>264 <span style=''></span><span style='background: #AEF1AE'>          (Z2SFC.index(xmin, ymin), Z2SFC.index(xmax, ymax))
</span>265 <span style=''></span><span style='background: #AEF1AE'>        }
</span>266 <span style=''></span><span style='background: #AEF1AE'>        def inRange(r: IndexRange) = r.lower &lt; zHi &amp;&amp; r.upper &gt; zLo
</span>267 <span style=''></span><span style='background: #AEF1AE'>
</span>268 <span style=''></span><span style='background: #AEF1AE'>        val ranges = Z2SFC.ranges(geometries.values.map(GeometryUtils.bounds), ZHistogramPrecision)
</span>269 <span style=''></span><span style='background: #AEF1AE'>        val indices = ranges.filter(inRange).flatMap { range =&gt;
</span>270 <span style=''></span><span style='background: #AEF1AE'>          val loIndex = Some(histogram.directIndex(range.lower)).filter(_ != -1).getOrElse(0)
</span>271 <span style=''></span><span style='background: #AEF1AE'>          val hiIndex = Some(histogram.directIndex(range.upper)).filter(_ != -1).getOrElse(histogram.length - 1)
</span>272 <span style=''></span><span style='background: #AEF1AE'>          loIndex to hiIndex
</span>273 <span style=''></span><span style='background: #AEF1AE'>        }
</span>274 <span style=''></span><span style='background: #AEF1AE'>        if (indices.isEmpty) { 0L } else { indices.distinct.map(histogram.count).sum }
</span>275 <span style=''></span><span style='background: #AEF1AE'>      }
</span>276 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>277 <span style=''>  }
</span>278 <span style=''>
</span>279 <span style=''>  /**
</span>280 <span style=''>    * Estimates counts from temporal predicates. Non-temporal predicates will be ignored.
</span>281 <span style=''>    *
</span>282 <span style=''>    * @param sft simple feature type
</span>283 <span style=''>    * @param filter filter to evaluate
</span>284 <span style=''>    * @return estimated count, if available
</span>285 <span style=''>    */
</span>286 <span style=''>  private def estimateTemporalCount(sft: SimpleFeatureType, filter: Filter): Option[Long] = {
</span>287 <span style=''>    </span><span style='background: #AEF1AE'>for {
</span>288 <span style=''></span><span style='background: #AEF1AE'>      dateField &lt;- sft.getDtgField
</span>289 <span style=''></span><span style='background: #AEF1AE'>      intervals =  FilterHelper.extractIntervals(filter, dateField)
</span>290 <span style=''></span><span style='background: #AEF1AE'>      if intervals.nonEmpty
</span>291 <span style=''></span><span style='background: #AEF1AE'>      histogram &lt;- stats.getHistogram[Date](sft, dateField, 0, new Date(), new Date())
</span>292 <span style=''></span><span style='background: #AEF1AE'>    } yield {
</span>293 <span style=''></span><span style='background: #AEF1AE'>      def inRange(interval: Bounds[ZonedDateTime]) = {
</span>294 <span style=''></span><span style='background: #AEF1AE'>        interval.lower.value.forall(_.toInstant.toEpochMilli &lt;= histogram.max.getTime) &amp;&amp;
</span>295 <span style=''></span><span style='background: #AEF1AE'>            interval.upper.value.forall(_.toInstant.toEpochMilli &gt;= histogram.min.getTime)
</span>296 <span style=''></span><span style='background: #AEF1AE'>      }
</span>297 <span style=''></span><span style='background: #AEF1AE'>
</span>298 <span style=''></span><span style='background: #AEF1AE'>      if (intervals.disjoint) { </span><span style='background: #F0ADAD'>0L</span><span style='background: #AEF1AE'> } else {
</span>299 <span style=''></span><span style='background: #AEF1AE'>        val indices = intervals.values.filter(inRange).flatMap { interval =&gt;
</span>300 <span style=''></span><span style='background: #AEF1AE'>          val loIndex = interval.lower.value.map(i =&gt; histogram.indexOf(Date.from(i.toInstant))).filter(_ != -1).getOrElse(0)
</span>301 <span style=''></span><span style='background: #AEF1AE'>          val hiIndex = interval.upper.value.map(i =&gt; histogram.indexOf(Date.from(i.toInstant))).filter(_ != -1).getOrElse(</span><span style='background: #F0ADAD'>histogram.length - 1</span><span style='background: #AEF1AE'>)
</span>302 <span style=''></span><span style='background: #AEF1AE'>          loIndex to hiIndex
</span>303 <span style=''></span><span style='background: #AEF1AE'>        }
</span>304 <span style=''></span><span style='background: #AEF1AE'>        if (indices.isEmpty) { 0L } else { indices.distinct.map(histogram.count).sum }
</span>305 <span style=''></span><span style='background: #AEF1AE'>      }
</span>306 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>307 <span style=''>  }
</span>308 <span style=''>
</span>309 <span style=''>  /**
</span>310 <span style=''>    * Estimates an equals predicate. Uses frequency (count min sketch) for estimated value.
</span>311 <span style=''>    *
</span>312 <span style=''>    * @param sft simple feature type
</span>313 <span style=''>    * @param attribute attribute to evaluate
</span>314 <span style=''>    * @param values values to be estimated
</span>315 <span style=''>    * @return estimated count, if available.
</span>316 <span style=''>    */
</span>317 <span style=''>  private def estimateEqualsCount(
</span>318 <span style=''>      sft: SimpleFeatureType,
</span>319 <span style=''>      filter: Filter,
</span>320 <span style=''>      attribute: String,
</span>321 <span style=''>      values: Seq[Any]): Option[Long] = {
</span>322 <span style=''>    </span><span style='background: #AEF1AE'>stats.getFrequency[Any](sft, attribute, 0, filter).map { freq =&gt;
</span>323 <span style=''></span><span style='background: #AEF1AE'>      // frequency estimates will never return less than the actual number, but will often return more
</span>324 <span style=''></span><span style='background: #AEF1AE'>      // frequency has ~0.5% error rate based on the total number of features in the data set
</span>325 <span style=''></span><span style='background: #AEF1AE'>      // we adjust the raw estimate based on the absolute error rate
</span>326 <span style=''></span><span style='background: #AEF1AE'>
</span>327 <span style=''></span><span style='background: #AEF1AE'>      val absoluteError = math.floor(freq.size * freq.eps)
</span>328 <span style=''></span><span style='background: #AEF1AE'>      val counts = if (absoluteError &lt; 1.0) { values.map(freq.count) } else {
</span>329 <span style=''></span><span style='background: #AEF1AE'>        values.map { v =&gt;
</span>330 <span style=''></span><span style='background: #AEF1AE'>          val estimate = freq.count(v)
</span>331 <span style=''></span><span style='background: #AEF1AE'>          if (estimate == 0L) {
</span>332 <span style=''></span><span style='background: #AEF1AE'>            </span><span style='background: #F0ADAD'>0L</span><span style='background: #AEF1AE'>
</span>333 <span style=''></span><span style='background: #AEF1AE'>          } else if (estimate &gt; absoluteError) {
</span>334 <span style=''></span><span style='background: #AEF1AE'>            val relativeError = absoluteError / estimate
</span>335 <span style=''></span><span style='background: #AEF1AE'>            estimate - (ErrorThresholds.dropWhile(_ &lt;= relativeError).head * 0.5 * absoluteError).toLong
</span>336 <span style=''></span><span style='background: #AEF1AE'>          } else {
</span>337 <span style=''></span><span style='background: #AEF1AE'>            val relativeError = estimate / absoluteError
</span>338 <span style=''></span><span style='background: #AEF1AE'>            (ErrorThresholds.dropWhile(_ &lt; relativeError).head * 0.5 * estimate).toLong
</span>339 <span style=''></span><span style='background: #AEF1AE'>          }
</span>340 <span style=''></span><span style='background: #AEF1AE'>        }
</span>341 <span style=''></span><span style='background: #AEF1AE'>      }
</span>342 <span style=''></span><span style='background: #AEF1AE'>      counts.sum
</span>343 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>344 <span style=''>  }
</span>345 <span style=''>
</span>346 <span style=''>  /**
</span>347 <span style=''>    * Estimates a potentially unbounded range predicate. Uses a binned histogram for estimated value.
</span>348 <span style=''>    *
</span>349 <span style=''>    * @param sft simple feature type
</span>350 <span style=''>    * @param attribute attribute to evaluate
</span>351 <span style=''>    * @param ranges ranges of values - may be unbounded (indicated by a None)
</span>352 <span style=''>    * @return estimated count, if available
</span>353 <span style=''>    */
</span>354 <span style=''>  private def estimateRangeCount(
</span>355 <span style=''>      sft: SimpleFeatureType,
</span>356 <span style=''>      attribute: String,
</span>357 <span style=''>      ranges: Seq[(Option[Any], Option[Any])]): Option[Long] = {
</span>358 <span style=''>    </span><span style='background: #AEF1AE'>stats.getHistogram[Any](sft, attribute, 0, 0, 0).map { histogram =&gt;
</span>359 <span style=''></span><span style='background: #AEF1AE'>      val inRangeRanges = ranges.filter {
</span>360 <span style=''></span><span style='background: #AEF1AE'>        case (None, None)         =&gt; true // inclusive filter
</span>361 <span style=''></span><span style='background: #AEF1AE'>        case (Some(lo), None)     =&gt; histogram.defaults.min(lo, histogram.max) == lo
</span>362 <span style=''></span><span style='background: #AEF1AE'>        case (None, Some(up))     =&gt; histogram.defaults.max(up, histogram.min) == up
</span>363 <span style=''></span><span style='background: #AEF1AE'>        case (Some(lo), Some(up)) =&gt;
</span>364 <span style=''></span><span style='background: #AEF1AE'>          histogram.defaults.min(lo, histogram.max) == lo &amp;&amp; histogram.defaults.max(up, histogram.min) == up
</span>365 <span style=''></span><span style='background: #AEF1AE'>      }
</span>366 <span style=''></span><span style='background: #AEF1AE'>      val indices = inRangeRanges.flatMap { case (lower, upper) =&gt;
</span>367 <span style=''></span><span style='background: #AEF1AE'>        val lowerIndex = lower.map(histogram.indexOf).filter(_ != -1).getOrElse(0)
</span>368 <span style=''></span><span style='background: #AEF1AE'>        val upperIndex = upper.map(histogram.indexOf).filter(_ != -1).getOrElse(histogram.length - 1)
</span>369 <span style=''></span><span style='background: #AEF1AE'>        lowerIndex to upperIndex
</span>370 <span style=''></span><span style='background: #AEF1AE'>      }
</span>371 <span style=''></span><span style='background: #AEF1AE'>      if (indices.isEmpty) { 0L } else { indices.distinct.map(histogram.count).sum }
</span>372 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>373 <span style=''>  }
</span>374 <span style=''>}
</span>375 <span style=''>
</span>376 <span style=''>object StatsBasedEstimator {
</span>377 <span style=''>
</span>378 <span style=''>  // we only need enough precision to cover the number of bins (e.g. 2^n == bins), plus 2 for unused bits
</span>379 <span style=''>  val ZHistogramPrecision: Int = </span><span style='background: #AEF1AE'>math.ceil(math.log(GeoMesaStats.MaxHistogramSize) / math.log(2)).toInt + 2</span><span style=''>
</span>380 <span style=''>
</span>381 <span style=''>  val ErrorThresholds: Seq[Double] = </span><span style='background: #AEF1AE'>Seq(0.1, 0.3, 0.5, 0.7, 0.9, 1.0)</span><span style=''>
</span>382 <span style=''>
</span>383 <span style=''>  /**
</span>384 <span style=''>    * Extracts date bounds from a filter. None is used to indicate a disjoint date range, otherwise
</span>385 <span style=''>    * there will be a bounds object (which may be unbounded).
</span>386 <span style=''>    *
</span>387 <span style=''>    * @param sft simple feature type
</span>388 <span style=''>    * @param filter filter
</span>389 <span style=''>    * @return None, if disjoint filters, otherwise date bounds (which may be unbounded)
</span>390 <span style=''>    */
</span>391 <span style=''>  private [stats] def extractDates(sft: SimpleFeatureType, filter: Filter): Option[Bounds[Date]] = {
</span>392 <span style=''>    </span><span style='background: #F0ADAD'>sft.getDtgField</span><span style=''> match {
</span>393 <span style=''>      case None =&gt; </span><span style='background: #F0ADAD'>Some(Bounds.everything)</span><span style=''>
</span>394 <span style=''>      case Some(dtg) </span><span style='background: #F0ADAD'>=&gt;
</span>395 <span style=''></span><span style='background: #F0ADAD'>        val intervals = FilterHelper.extractIntervals(filter, dtg)
</span>396 <span style=''></span><span style='background: #F0ADAD'>        if (intervals.disjoint) { None } else {
</span>397 <span style=''></span><span style='background: #F0ADAD'>          // don't consider gaps, just get the endpoints of the intervals
</span>398 <span style=''></span><span style='background: #F0ADAD'>          val dateTimes = intervals.values.reduceOption[Bounds[ZonedDateTime]] { case (left, right) =&gt;
</span>399 <span style=''></span><span style='background: #F0ADAD'>            val lower = Bounds.smallerLowerBound(left.lower, right.lower)
</span>400 <span style=''></span><span style='background: #F0ADAD'>            val upper = Bounds.largerUpperBound(left.upper, right.upper)
</span>401 <span style=''></span><span style='background: #F0ADAD'>            Bounds(lower, upper)
</span>402 <span style=''></span><span style='background: #F0ADAD'>          }
</span>403 <span style=''></span><span style='background: #F0ADAD'>          val lower = dateTimes.map(d =&gt; Bound(d.lower.value.map(i =&gt; Date.from(i.toInstant)), d.lower.inclusive))
</span>404 <span style=''></span><span style='background: #F0ADAD'>          val upper = dateTimes.map(d =&gt; Bound(d.upper.value.map(i =&gt; Date.from(i.toInstant)), d.upper.inclusive))
</span>405 <span style=''></span><span style='background: #F0ADAD'>          Some(Bounds(lower.getOrElse(Bound.unbounded[Date]), upper.getOrElse(Bound.unbounded[Date])))
</span>406 <span style=''></span><span style='background: #F0ADAD'>        }</span><span style=''>
</span>407 <span style=''>    }
</span>408 <span style=''>  }
</span>409 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Tests</th>
        <th>Code</th>
      </tr><tr>
        <td>
          49
        </td>
        <td>
          12258
        </td>
        <td>
          2174
          -
          2187
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getCount(sft, StatsBasedEstimator.this.getCount$default$2, StatsBasedEstimator.this.getCount$default$3, StatsBasedEstimator.this.getCount$default$4)
        </td>
      </tr><tr>
        <td>
          49
        </td>
        <td>
          12259
        </td>
        <td>
          2174
          -
          2187
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getCount(sft, StatsBasedEstimator.this.getCount$default$2, StatsBasedEstimator.this.getCount$default$3, StatsBasedEstimator.this.getCount$default$4)
        </td>
      </tr><tr>
        <td>
          50
        </td>
        <td>
          12260
        </td>
        <td>
          2217
          -
          2225
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          50
        </td>
        <td>
          12261
        </td>
        <td>
          2217
          -
          2225
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          52
        </td>
        <td>
          12262
        </td>
        <td>
          2248
          -
          2272
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateAndCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateAndCount(sft, a)
        </td>
      </tr><tr>
        <td>
          52
        </td>
        <td>
          12263
        </td>
        <td>
          2248
          -
          2272
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateAndCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateAndCount(sft, a)
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          12264
        </td>
        <td>
          2294
          -
          2317
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateOrCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateOrCount(sft, o)
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          12265
        </td>
        <td>
          2294
          -
          2317
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateOrCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateOrCount(sft, o)
        </td>
      </tr><tr>
        <td>
          54
        </td>
        <td>
          12266
        </td>
        <td>
          2339
          -
          2363
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateNotCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateNotCount(sft, n)
        </td>
      </tr><tr>
        <td>
          54
        </td>
        <td>
          12267
        </td>
        <td>
          2339
          -
          2363
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateNotCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateNotCount(sft, n)
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          12268
        </td>
        <td>
          2390
          -
          2411
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.getIdentifiers().size().toLong
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          12269
        </td>
        <td>
          2385
          -
          2412
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](i.getIdentifiers().size().toLong)
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          12270
        </td>
        <td>
          2385
          -
          2412
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](i.getIdentifiers().size().toLong)
        </td>
      </tr><tr>
        <td>
          57
        </td>
        <td>
          12274
        </td>
        <td>
          2426
          -
          2628
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val attribute: Option[String] = org.locationtech.geomesa.filter.FilterHelper.propertyNames(filter, sft).headOption;
  attribute.flatMap[Long](((x$1: String) =&gt; StatsBasedEstimator.this.estimateAttributeCount(sft, filter, x$1)))
}
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          12271
        </td>
        <td>
          2512
          -
          2562
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableLike.headOption
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.propertyNames(filter, sft).headOption
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          12272
        </td>
        <td>
          2589
          -
          2627
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateAttributeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateAttributeCount(sft, filter, x$1)
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          12273
        </td>
        <td>
          2571
          -
          2628
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          attribute.flatMap[Long](((x$1: String) =&gt; StatsBasedEstimator.this.estimateAttributeCount(sft, filter, x$1)))
        </td>
      </tr><tr>
        <td>
          75
        </td>
        <td>
          12275
        </td>
        <td>
          3107
          -
          3147
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateSpatioTemporalCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateSpatioTemporalCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          12276
        </td>
        <td>
          3262
          -
          3280
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.BinaryLogicOperator.getChildren
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          filter.getChildren()
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          12277
        </td>
        <td>
          3297
          -
          3318
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, x$2)
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          12278
        </td>
        <td>
          3297
          -
          3318
        </td>
        <td>
          ApplyImplicitView
        </td>
        <td>
          scala.Option.option2Iterable
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$2))
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          12279
        </td>
        <td>
          3296
          -
          3296
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Buffer.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          mutable.this.Buffer.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          12280
        </td>
        <td>
          3262
          -
          3319
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.JavaConverters.asScalaBufferConverter[org.geotools.api.filter.Filter](filter.getChildren()).asScala.flatMap[Long, scala.collection.mutable.Buffer[Long]](((x$2: org.geotools.api.filter.Filter) =&gt; scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$2))))(mutable.this.Buffer.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          12281
        </td>
        <td>
          3346
          -
          3346
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          12282
        </td>
        <td>
          3338
          -
          3365
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Option.option2Iterable[Long](stCount).++[Long, Iterable[Long]](individualCounts)(collection.this.Iterable.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          12283
        </td>
        <td>
          3375
          -
          3389
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.IterableLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.isEmpty
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          12284
        </td>
        <td>
          3393
          -
          3397
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          12285
        </td>
        <td>
          3393
          -
          3397
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          12286
        </td>
        <td>
          3419
          -
          3419
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Ordering.Long
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Ordering.Long
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          12287
        </td>
        <td>
          3412
          -
          3422
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.min[Long](math.this.Ordering.Long)
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          12288
        </td>
        <td>
          3407
          -
          3423
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.min[Long](math.this.Ordering.Long))
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          12289
        </td>
        <td>
          3407
          -
          3423
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.min[Long](math.this.Ordering.Long))
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          12290
        </td>
        <td>
          3876
          -
          3894
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.BinaryLogicOperator.getChildren
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          filter.getChildren()
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          12291
        </td>
        <td>
          3911
          -
          3932
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, x$3)
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          12292
        </td>
        <td>
          3911
          -
          3932
        </td>
        <td>
          ApplyImplicitView
        </td>
        <td>
          scala.Option.option2Iterable
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$3))
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          12293
        </td>
        <td>
          3910
          -
          3910
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Buffer.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          mutable.this.Buffer.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          12294
        </td>
        <td>
          3876
          -
          3933
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.JavaConverters.asScalaBufferConverter[org.geotools.api.filter.Filter](filter.getChildren()).asScala.flatMap[Long, scala.collection.mutable.Buffer[Long]](((x$3: org.geotools.api.filter.Filter) =&gt; scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$3))))(mutable.this.Buffer.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          12295
        </td>
        <td>
          3942
          -
          3956
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.isEmpty
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          12296
        </td>
        <td>
          3960
          -
          3964
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          12297
        </td>
        <td>
          3960
          -
          3964
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          12298
        </td>
        <td>
          3986
          -
          3986
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          12299
        </td>
        <td>
          3979
          -
          3989
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          12300
        </td>
        <td>
          3974
          -
          3990
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.sum[Long](math.this.Numeric.LongIsIntegral))
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          12301
        </td>
        <td>
          3974
          -
          3990
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.sum[Long](math.this.Numeric.LongIsIntegral))
        </td>
      </tr><tr>
        <td>
          104
        </td>
        <td>
          12302
        </td>
        <td>
          4247
          -
          4263
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.Not.getFilter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          filter.getFilter()
        </td>
      </tr><tr>
        <td>
          107
        </td>
        <td>
          12303
        </td>
        <td>
          4358
          -
          4373
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.PropertyIsNull.getExpression
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          f.getExpression()
        </td>
      </tr><tr>
        <td>
          107
        </td>
        <td>
          12314
        </td>
        <td>
          4358
          -
          4576
        </td>
        <td>
          Match
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          f.getExpression() match {
  case (p @ (_: org.geotools.api.filter.expression.PropertyName)) =&gt; StatsBasedEstimator.this.estimateRangeCount(sft, p.getPropertyName(), scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)))
  case _ =&gt; StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
}
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          12304
        </td>
        <td>
          4440
          -
          4457
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.expression.PropertyName.getPropertyName
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          p.getPropertyName()
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          12305
        </td>
        <td>
          4464
          -
          4468
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          12306
        </td>
        <td>
          4470
          -
          4474
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          12307
        </td>
        <td>
          4463
          -
          4475
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          12308
        </td>
        <td>
          4459
          -
          4476
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None))
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          12309
        </td>
        <td>
          4416
          -
          4477
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, p.getPropertyName(), scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)))
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          12310
        </td>
        <td>
          4416
          -
          4477
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, p.getPropertyName(), scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)))
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          12311
        </td>
        <td>
          4517
          -
          4531
        </td>
        <td>
          Select
        </td>
        <td>
          org.geotools.api.filter.Filter.INCLUDE
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.geotools.api.filter.Filter.INCLUDE
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          12312
        </td>
        <td>
          4498
          -
          4532
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          12313
        </td>
        <td>
          4498
          -
          4532
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          12315
        </td>
        <td>
          4644
          -
          4658
        </td>
        <td>
          Select
        </td>
        <td>
          org.geotools.api.filter.Filter.INCLUDE
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.geotools.api.filter.Filter.INCLUDE
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          12320
        </td>
        <td>
          4602
          -
          4749
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE).flatMap[Long](((all: Long) =&gt; StatsBasedEstimator.this.estimateCount(sft, f).map[Long](((neg: Long) =&gt; scala.math.`package`.max(0L, all.-(neg))))))
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          12321
        </td>
        <td>
          4602
          -
          4749
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE).flatMap[Long](((all: Long) =&gt; StatsBasedEstimator.this.estimateCount(sft, f).map[Long](((neg: Long) =&gt; scala.math.`package`.max(0L, all.-(neg))))))
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          12319
        </td>
        <td>
          4670
          -
          4749
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, f).map[Long](((neg: Long) =&gt; scala.math.`package`.max(0L, all.-(neg))))
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          12316
        </td>
        <td>
          4736
          -
          4737
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          12317
        </td>
        <td>
          4739
          -
          4748
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          all.-(neg)
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          12318
        </td>
        <td>
          4727
          -
          4749
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.max
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.max(0L, all.-(neg))
        </td>
      </tr><tr>
        <td>
          133
        </td>
        <td>
          12322
        </td>
        <td>
          5272
          -
          5288
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          133
        </td>
        <td>
          12424
        </td>
        <td>
          5239
          -
          8235
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Option.apply[String](org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField).flatMap[Long](((geomField: String) =&gt; org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.map[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])](((dateField: String) =&gt; {
  val geometries: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry] = org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, geomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints);
  scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]](dateField, geometries)
})).withFilter(((x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)) =&gt; geometries.nonEmpty
})).map[((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])](((x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (x$14 @ (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _))) =&gt; {
    val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4);
    scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
  }
})).withFilter(((x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; intervals.nonEmpty
})).flatMap[Long](((x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
    0L
  else
    {
      val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
        val minTime: Long = bounds.min.getTime();
        val maxTime: Long = bounds.max.getTime();
        intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
      };
      val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
      StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
        case scala.None =&gt; 0L
        case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
          val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
            case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
          };
          val tmin: Long = x$6._1;
          val tmax: Long = x$6._2;
          val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
            ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
          })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
          def getIndices(t1: Long, t2: Long): Seq[Int] = {
            val w: Short = histogram.timeBins.head;
            val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
            zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
          };
          &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
          val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
          val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
          val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
          val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
              case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
            };
            val lower: java.time.ZonedDateTime = x$7._1;
            val upper: java.time.ZonedDateTime = x$7._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
            };
            val lb: Short = x$8._1;
            val lt: Long = x$8._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
            };
            val ub: Short = x$9._1;
            val ut: Long = x$9._2;
            scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
          }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
          binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
            case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
              {
                &lt;synthetic&gt; val ev$1: Short = bins.head;
                timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
              }
            else
              {
                &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                  case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
                };
                val head: Short = x$11._1;
                val middle: List[Short] = x$11._2;
                val last: Short = x$11._3;
                timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
                timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
                middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
              }
          }));
          timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        }
      }
    }))
}))))
        </td>
      </tr><tr>
        <td>
          134
        </td>
        <td>
          12325
        </td>
        <td>
          5296
          -
          5296
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]](dateField, geometries)
        </td>
      </tr><tr>
        <td>
          134
        </td>
        <td>
          12329
        </td>
        <td>
          5296
          -
          5296
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
        </td>
      </tr><tr>
        <td>
          134
        </td>
        <td>
          12423
        </td>
        <td>
          5296
          -
          8235
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.WithFilter.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.map[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])](((dateField: String) =&gt; {
  val geometries: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry] = org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, geomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints);
  scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]](dateField, geometries)
})).withFilter(((x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)) =&gt; geometries.nonEmpty
})).map[((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])](((x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (x$14 @ (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _))) =&gt; {
    val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4);
    scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
  }
})).withFilter(((x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; intervals.nonEmpty
})).flatMap[Long](((x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
    0L
  else
    {
      val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
        val minTime: Long = bounds.min.getTime();
        val maxTime: Long = bounds.max.getTime();
        intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
      };
      val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
      StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
        case scala.None =&gt; 0L
        case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
          val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
            case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
          };
          val tmin: Long = x$6._1;
          val tmax: Long = x$6._2;
          val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
            ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
          })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
          def getIndices(t1: Long, t2: Long): Seq[Int] = {
            val w: Short = histogram.timeBins.head;
            val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
            zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
          };
          &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
          val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
          val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
          val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
          val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
              case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
            };
            val lower: java.time.ZonedDateTime = x$7._1;
            val upper: java.time.ZonedDateTime = x$7._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
            };
            val lb: Short = x$8._1;
            val lt: Long = x$8._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
            };
            val ub: Short = x$9._1;
            val ut: Long = x$9._2;
            scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
          }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
          binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
            case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
              {
                &lt;synthetic&gt; val ev$1: Short = bins.head;
                timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
              }
            else
              {
                &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                  case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
                };
                val head: Short = x$11._1;
                val middle: List[Short] = x$11._2;
                val last: Short = x$11._3;
                timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
                timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
                middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
              }
          }));
          timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        }
      }
    }))
}))
        </td>
      </tr><tr>
        <td>
          135
        </td>
        <td>
          12323
        </td>
        <td>
          5396
          -
          5408
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.isPoints
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints
        </td>
      </tr><tr>
        <td>
          135
        </td>
        <td>
          12324
        </td>
        <td>
          5346
          -
          5409
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, geomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints)
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          12326
        </td>
        <td>
          5419
          -
          5438
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.nonEmpty
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          12327
        </td>
        <td>
          5419
          -
          5438
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.nonEmpty
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          12328
        </td>
        <td>
          5459
          -
          5507
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4)
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          12330
        </td>
        <td>
          5445
          -
          5507
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4);
  scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
}
        </td>
      </tr><tr>
        <td>
          138
        </td>
        <td>
          12331
        </td>
        <td>
          5517
          -
          5535
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          138
        </td>
        <td>
          12332
        </td>
        <td>
          5517
          -
          5535
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          12333
        </td>
        <td>
          5571
          -
          5571
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getMinMax$default$3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax$default$3[java.util.Date]
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          12334
        </td>
        <td>
          5571
          -
          5571
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getMinMax$default$4
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          12421
        </td>
        <td>
          5542
          -
          8235
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
  0L
else
  {
    val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
      val minTime: Long = bounds.min.getTime();
      val maxTime: Long = bounds.max.getTime();
      intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
    };
    val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
    StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
      case scala.None =&gt; 0L
      case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
        val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
          case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
        };
        val tmin: Long = x$6._1;
        val tmax: Long = x$6._2;
        val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
          ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
        })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
        def getIndices(t1: Long, t2: Long): Seq[Int] = {
          val w: Short = histogram.timeBins.head;
          val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
          zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
        };
        &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
        val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
        val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
        val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
        val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
            case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
          };
          val lower: java.time.ZonedDateTime = x$7._1;
          val upper: java.time.ZonedDateTime = x$7._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
          };
          val lb: Short = x$8._1;
          val lt: Long = x$8._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
          };
          val ub: Short = x$9._1;
          val ut: Long = x$9._2;
          scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
        }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
        binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
          case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
            {
              &lt;synthetic&gt; val ev$1: Short = bins.head;
              timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
            }
          else
            {
              &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
              };
              val head: Short = x$11._1;
              val middle: List[Short] = x$11._2;
              val last: Short = x$11._3;
              timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
              timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
              middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
            }
        }));
        timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
      }
    }
  }))
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          12422
        </td>
        <td>
          5542
          -
          8235
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
  0L
else
  {
    val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
      val minTime: Long = bounds.min.getTime();
      val maxTime: Long = bounds.max.getTime();
      intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
    };
    val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
    StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
      case scala.None =&gt; 0L
      case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
        val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
          case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
        };
        val tmin: Long = x$6._1;
        val tmax: Long = x$6._2;
        val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
          ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
        })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
        def getIndices(t1: Long, t2: Long): Seq[Int] = {
          val w: Short = histogram.timeBins.head;
          val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
          zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
        };
        &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
        val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
        val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
        val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
        val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
            case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
          };
          val lower: java.time.ZonedDateTime = x$7._1;
          val upper: java.time.ZonedDateTime = x$7._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
          };
          val lb: Short = x$8._1;
          val lt: Long = x$8._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
          };
          val ub: Short = x$9._1;
          val ut: Long = x$9._2;
          scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
        }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
        binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
          case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
            {
              &lt;synthetic&gt; val ev$1: Short = bins.head;
              timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
            }
          else
            {
              &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
              };
              val head: Short = x$11._1;
              val middle: List[Short] = x$11._2;
              val last: Short = x$11._3;
              timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
              timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
              middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
            }
        }));
        timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
      }
    }
  }))
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          12335
        </td>
        <td>
          5641
          -
          5659
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.disjoint
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          12336
        </td>
        <td>
          5618
          -
          5659
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.disjoint.||(intervals.disjoint)
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          12337
        </td>
        <td>
          5663
          -
          5665
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          12338
        </td>
        <td>
          5663
          -
          5665
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          12420
        </td>
        <td>
          5673
          -
          8235
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
    val minTime: Long = bounds.min.getTime();
    val maxTime: Long = bounds.max.getTime();
    intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
  };
  val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
  StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
    case scala.None =&gt; 0L
    case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
      val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
        case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
      };
      val tmin: Long = x$6._1;
      val tmax: Long = x$6._2;
      val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
        ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
      })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
      def getIndices(t1: Long, t2: Long): Seq[Int] = {
        val w: Short = histogram.timeBins.head;
        val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
        zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
      };
      &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
      val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
      val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
      val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
      val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
          case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
        };
        val lower: java.time.ZonedDateTime = x$7._1;
        val upper: java.time.ZonedDateTime = x$7._2;
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
          case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
        };
        val lb: Short = x$8._1;
        val lt: Long = x$8._2;
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
          case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
        };
        val ub: Short = x$9._1;
        val ut: Long = x$9._2;
        scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
      }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
      binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
        case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
          {
            &lt;synthetic&gt; val ev$1: Short = bins.head;
            timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
          }
        else
          {
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
              case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
            };
            val head: Short = x$11._1;
            val middle: List[Short] = x$11._2;
            val last: Short = x$11._3;
            timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
            timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
            middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
          }
      }));
      timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }
  }
}
        </td>
      </tr><tr>
        <td>
          143
        </td>
        <td>
          12339
        </td>
        <td>
          5732
          -
          5750
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.min.getTime()
        </td>
      </tr><tr>
        <td>
          144
        </td>
        <td>
          12340
        </td>
        <td>
          5775
          -
          5793
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.max.getTime()
        </td>
      </tr><tr>
        <td>
          145
        </td>
        <td>
          12345
        </td>
        <td>
          5804
          -
          5993
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
        </td>
      </tr><tr>
        <td>
          146
        </td>
        <td>
          12341
        </td>
        <td>
          5868
          -
          5903
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$4.toInstant().toEpochMilli().&lt;=(maxTime)
        </td>
      </tr><tr>
        <td>
          146
        </td>
        <td>
          12344
        </td>
        <td>
          5847
          -
          5981
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))
        </td>
      </tr><tr>
        <td>
          147
        </td>
        <td>
          12342
        </td>
        <td>
          5945
          -
          5980
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$5.toInstant().toEpochMilli().&gt;=(minTime)
        </td>
      </tr><tr>
        <td>
          147
        </td>
        <td>
          12343
        </td>
        <td>
          5924
          -
          5981
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime)))
        </td>
      </tr><tr>
        <td>
          150
        </td>
        <td>
          12346
        </td>
        <td>
          6025
          -
          6042
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getZ3Interval
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval
        </td>
      </tr><tr>
        <td>
          151
        </td>
        <td>
          12347
        </td>
        <td>
          6107
          -
          6108
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          151
        </td>
        <td>
          12348
        </td>
        <td>
          6051
          -
          6117
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getZ3Histogram
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7)
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          12349
        </td>
        <td>
          6149
          -
          6151
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          12350
        </td>
        <td>
          6149
          -
          6151
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          12419
        </td>
        <td>
          6183
          -
          8217
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
    case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
  };
  val tmin: Long = x$6._1;
  val tmax: Long = x$6._2;
  val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
    ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
  })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
  def getIndices(t1: Long, t2: Long): Seq[Int] = {
    val w: Short = histogram.timeBins.head;
    val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
    zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
  };
  &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
  val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
  val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
  val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
  val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
      case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
    };
    val lower: java.time.ZonedDateTime = x$7._1;
    val upper: java.time.ZonedDateTime = x$7._2;
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
      case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
    };
    val lb: Short = x$8._1;
    val lt: Long = x$8._2;
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
      case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
    };
    val ub: Short = x$9._1;
    val ut: Long = x$9._2;
    scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
  }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
  binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
    case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
      {
        &lt;synthetic&gt; val ev$1: Short = bins.head;
        timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
      }
    else
      {
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
          case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
        };
        val head: Short = x$11._1;
        val middle: List[Short] = x$11._2;
        val last: Short = x$11._3;
        timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
        timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
        middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
      }
  }));
  timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}
        </td>
      </tr><tr>
        <td>
          155
        </td>
        <td>
          12351
        </td>
        <td>
          6274
          -
          6287
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.Z3SFC.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.Z3SFC.apply(period)
        </td>
      </tr><tr>
        <td>
          156
        </td>
        <td>
          12352
        </td>
        <td>
          6305
          -
          6305
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$6._1
        </td>
      </tr><tr>
        <td>
          156
        </td>
        <td>
          12353
        </td>
        <td>
          6311
          -
          6311
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$6._2
        </td>
      </tr><tr>
        <td>
          157
        </td>
        <td>
          12354
        </td>
        <td>
          6405
          -
          6425
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry)
        </td>
      </tr><tr>
        <td>
          157
        </td>
        <td>
          12355
        </td>
        <td>
          6404
          -
          6404
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]
        </td>
      </tr><tr>
        <td>
          157
        </td>
        <td>
          12356
        </td>
        <td>
          6383
          -
          6426
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
  ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
})(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)])
        </td>
      </tr><tr>
        <td>
          160
        </td>
        <td>
          12357
        </td>
        <td>
          6511
          -
          6534
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.IterableLike.head
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.timeBins.head
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          12358
        </td>
        <td>
          6641
          -
          6649
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Long, Long](t1, t2)
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          12359
        </td>
        <td>
          6637
          -
          6650
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2))
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          12360
        </td>
        <td>
          6652
          -
          6671
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.ZHistogramPrecision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ZHistogramPrecision
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          12361
        </td>
        <td>
          6622
          -
          6672
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.Z3SFC.ranges
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          12362
        </td>
        <td>
          6728
          -
          6735
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.zorder.sfcurve.IndexRange.lower
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          12363
        </td>
        <td>
          6703
          -
          6736
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Z3Histogram.directIndex
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.directIndex(w, r.lower)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          12364
        </td>
        <td>
          6765
          -
          6772
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.zorder.sfcurve.IndexRange.upper
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.upper
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          12365
        </td>
        <td>
          6740
          -
          6773
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Z3Histogram.directIndex
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.directIndex(w, r.upper)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          12366
        </td>
        <td>
          6703
          -
          6773
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          12367
        </td>
        <td>
          6697
          -
          6697
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          12368
        </td>
        <td>
          6687
          -
          6774
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          167
        </td>
        <td>
          12369
        </td>
        <td>
          7043
          -
          7052
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.empty[Nothing]
        </td>
      </tr><tr>
        <td>
          167
        </td>
        <td>
          12370
        </td>
        <td>
          6974
          -
          7053
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.Map.withDefaultValue
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing])
        </td>
      </tr><tr>
        <td>
          169
        </td>
        <td>
          12371
        </td>
        <td>
          7084
          -
          7119
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period)
        </td>
      </tr><tr>
        <td>
          170
        </td>
        <td>
          12372
        </td>
        <td>
          7152
          -
          7193
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period)
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          12385
        </td>
        <td>
          7245
          -
          7245
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          12386
        </td>
        <td>
          7224
          -
          7515
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
    case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
  };
  val lower: java.time.ZonedDateTime = x$7._1;
  val upper: java.time.ZonedDateTime = x$7._2;
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
    case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
  };
  val lb: Short = x$8._1;
  val lt: Long = x$8._2;
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
    case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
  };
  val ub: Short = x$9._1;
  val ut: Long = x$9._2;
  scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
}))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)])
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          12373
        </td>
        <td>
          7278
          -
          7278
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7._1
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          12374
        </td>
        <td>
          7285
          -
          7285
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7._2
        </td>
      </tr><tr>
        <td>
          173
        </td>
        <td>
          12375
        </td>
        <td>
          7354
          -
          7354
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._1
        </td>
      </tr><tr>
        <td>
          173
        </td>
        <td>
          12376
        </td>
        <td>
          7358
          -
          7358
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._2
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          12377
        </td>
        <td>
          7411
          -
          7411
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._1
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          12378
        </td>
        <td>
          7415
          -
          7415
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._2
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          12379
        </td>
        <td>
          7470
          -
          7472
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Short.toInt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          lb.toInt
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          12380
        </td>
        <td>
          7474
          -
          7476
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Short.toInt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ub.toInt
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          12381
        </td>
        <td>
          7482
          -
          7491
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toShort
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10.toShort
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          12382
        </td>
        <td>
          7481
          -
          7481
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[Short]
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          12383
        </td>
        <td>
          7454
          -
          7492
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short])
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          12384
        </td>
        <td>
          7453
          -
          7501
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
        </td>
      </tr><tr>
        <td>
          179
        </td>
        <td>
          12410
        </td>
        <td>
          7634
          -
          8104
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
  case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
    {
      &lt;synthetic&gt; val ev$1: Short = bins.head;
      timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
    }
  else
    {
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
        case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
      };
      val head: Short = x$11._1;
      val middle: List[Short] = x$11._2;
      val last: Short = x$11._3;
      timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
      timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
      middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
    }
}))
        </td>
      </tr><tr>
        <td>
          180
        </td>
        <td>
          12387
        </td>
        <td>
          7697
          -
          7713
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bins.length.==(1)
        </td>
      </tr><tr>
        <td>
          180
        </td>
        <td>
          12409
        </td>
        <td>
          7693
          -
          8090
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (bins.length.==(1))
  {
    &lt;synthetic&gt; val ev$1: Short = bins.head;
    timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
  }
else
  {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
      case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
    };
    val head: Short = x$11._1;
    val middle: List[Short] = x$11._2;
    val last: Short = x$11._3;
    timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
    timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
    middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
  }
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          12388
        </td>
        <td>
          7767
          -
          7785
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.getIndices
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          getIndices(lt, ut)
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          12389
        </td>
        <td>
          7763
          -
          7763
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          12390
        </td>
        <td>
          7733
          -
          7785
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          12391
        </td>
        <td>
          7733
          -
          7785
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          12392
        </td>
        <td>
          7733
          -
          7785
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; val ev$1: Short = bins.head;
  timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
}
        </td>
      </tr><tr>
        <td>
          182
        </td>
        <td>
          12408
        </td>
        <td>
          7807
          -
          8090
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
    case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
  };
  val head: Short = x$11._1;
  val middle: List[Short] = x$11._2;
  val last: Short = x$11._3;
  timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
  timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
  middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
}
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          12393
        </td>
        <td>
          7829
          -
          7829
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._1
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          12394
        </td>
        <td>
          7837
          -
          7837
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._2
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          12395
        </td>
        <td>
          7847
          -
          7847
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._3
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          12396
        </td>
        <td>
          7911
          -
          7931
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.getIndices
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          getIndices(lt, tmax)
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          12397
        </td>
        <td>
          7907
          -
          7907
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          12398
        </td>
        <td>
          7882
          -
          7931
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          12399
        </td>
        <td>
          7882
          -
          7931
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          12400
        </td>
        <td>
          7977
          -
          7997
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.getIndices
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          getIndices(tmin, ut)
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          12401
        </td>
        <td>
          7973
          -
          7973
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          12402
        </td>
        <td>
          7948
          -
          7997
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          12403
        </td>
        <td>
          7948
          -
          7997
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          12404
        </td>
        <td>
          8056
          -
          8056
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          12405
        </td>
        <td>
          8034
          -
          8073
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          12406
        </td>
        <td>
          8034
          -
          8073
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          12407
        </td>
        <td>
          8014
          -
          8074
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.List.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12411
        </td>
        <td>
          8185
          -
          8206
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Z3Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(b, x$12)
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12412
        </td>
        <td>
          8184
          -
          8184
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12413
        </td>
        <td>
          8208
          -
          8208
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12414
        </td>
        <td>
          8164
          -
          8211
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12415
        </td>
        <td>
          8164
          -
          8211
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12416
        </td>
        <td>
          8141
          -
          8141
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          mutable.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12417
        </td>
        <td>
          8214
          -
          8214
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          12418
        </td>
        <td>
          8118
          -
          8217
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          207
        </td>
        <td>
          12425
        </td>
        <td>
          8731
          -
          8747
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          207
        </td>
        <td>
          12426
        </td>
        <td>
          8718
          -
          8747
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          attribute.==(org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField)
        </td>
      </tr><tr>
        <td>
          208
        </td>
        <td>
          12427
        </td>
        <td>
          8757
          -
          8790
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateSpatialCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateSpatialCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          208
        </td>
        <td>
          12428
        </td>
        <td>
          8757
          -
          8790
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateSpatialCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateSpatialCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          209
        </td>
        <td>
          12429
        </td>
        <td>
          8806
          -
          8841
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.contains
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.contains[String](attribute)
        </td>
      </tr><tr>
        <td>
          209
        </td>
        <td>
          12481
        </td>
        <td>
          8802
          -
          10441
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.contains[String](attribute))
  StatsBasedEstimator.this.estimateTemporalCount(sft, filter)
else
  {
    val extractedBounds: Option[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]] = scala.Option.apply[org.geotools.api.feature.type.AttributeDescriptor](sft.getDescriptor(attribute)).map[(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }](((descriptor: org.geotools.api.feature.type.AttributeDescriptor) =&gt; {
  val binding: Class[_] = if (org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList)
    org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
  else
    descriptor.getType().getBinding();
  scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
})).map[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]](((x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }) =&gt; (x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) @unchecked) match {
      case (_1: org.geotools.api.feature.type.AttributeDescriptor, _2: Class[_$2])(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2])((descriptor @ _), (binding @ _)) =&gt; org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
    }));
    extractedBounds.flatMap[Long](((bounds: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]) =&gt; if (bounds.disjoint)
      scala.Some.apply[Long](0L)
    else
      if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
        StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
      else
        {
          val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
            case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
          })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
            case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
          };
          val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
          val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
          val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
            scala.Some.apply[Long](0L)
          else
            {
              val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
              val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
              scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
                case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
                case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
                case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
              }
            };
          val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
            scala.Some.apply[Long](0L)
          else
            StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
          equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
        }))
  }
        </td>
      </tr><tr>
        <td>
          210
        </td>
        <td>
          12430
        </td>
        <td>
          8851
          -
          8885
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateTemporalCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateTemporalCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          210
        </td>
        <td>
          12431
        </td>
        <td>
          8851
          -
          8885
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateTemporalCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateTemporalCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          211
        </td>
        <td>
          12480
        </td>
        <td>
          8897
          -
          10441
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val extractedBounds: Option[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]] = scala.Option.apply[org.geotools.api.feature.type.AttributeDescriptor](sft.getDescriptor(attribute)).map[(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }](((descriptor: org.geotools.api.feature.type.AttributeDescriptor) =&gt; {
  val binding: Class[_] = if (org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList)
    org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
  else
    descriptor.getType().getBinding();
  scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
})).map[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]](((x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }) =&gt; (x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) @unchecked) match {
    case (_1: org.geotools.api.feature.type.AttributeDescriptor, _2: Class[_$2])(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2])((descriptor @ _), (binding @ _)) =&gt; org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
  }));
  extractedBounds.flatMap[Long](((bounds: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]) =&gt; if (bounds.disjoint)
    scala.Some.apply[Long](0L)
  else
    if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
      StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
    else
      {
        val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
          case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
        })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
          case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
        };
        val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
        val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
        val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
          scala.Some.apply[Long](0L)
        else
          {
            val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
            val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
            scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
              case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
              case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
              case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
            }
          };
        val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
          scala.Some.apply[Long](0L)
        else
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
        equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
      }))
}
        </td>
      </tr><tr>
        <td>
          214
        </td>
        <td>
          12432
        </td>
        <td>
          8999
          -
          9027
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.feature.simple.SimpleFeatureType.getDescriptor
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sft.getDescriptor(attribute)
        </td>
      </tr><tr>
        <td>
          214
        </td>
        <td>
          12438
        </td>
        <td>
          8978
          -
          8978
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
        </td>
      </tr><tr>
        <td>
          214
        </td>
        <td>
          12442
        </td>
        <td>
          8964
          -
          9254
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Option.apply[org.geotools.api.feature.type.AttributeDescriptor](sft.getDescriptor(attribute)).map[(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }](((descriptor: org.geotools.api.feature.type.AttributeDescriptor) =&gt; {
  val binding: Class[_] = if (org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList)
    org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
  else
    descriptor.getType().getBinding();
  scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
})).map[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]](((x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }) =&gt; (x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) @unchecked) match {
  case (_1: org.geotools.api.feature.type.AttributeDescriptor, _2: Class[_$2])(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2])((descriptor @ _), (binding @ _)) =&gt; org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
}))
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          12433
        </td>
        <td>
          9055
          -
          9072
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor.isList
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          12434
        </td>
        <td>
          9076
          -
          9100
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor.getListType
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          12435
        </td>
        <td>
          9076
          -
          9100
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor.getListType
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          12436
        </td>
        <td>
          9110
          -
          9139
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.feature.type.PropertyType.getBinding
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          descriptor.getType().getBinding()
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          12437
        </td>
        <td>
          9110
          -
          9139
        </td>
        <td>
          Block
        </td>
        <td>
          org.geotools.api.feature.type.PropertyType.getBinding
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          descriptor.getType().getBinding()
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          12439
        </td>
        <td>
          9221
          -
          9253
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          binding.asInstanceOf[Class[Any]]
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          12440
        </td>
        <td>
          9166
          -
          9254
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          12441
        </td>
        <td>
          9166
          -
          9254
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
        </td>
      </tr><tr>
        <td>
          219
        </td>
        <td>
          12479
        </td>
        <td>
          9269
          -
          10435
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          extractedBounds.flatMap[Long](((bounds: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]) =&gt; if (bounds.disjoint)
  scala.Some.apply[Long](0L)
else
  if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
    StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
  else
    {
      val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
        case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
      })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
        case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
      };
      val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
      val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
      val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
        scala.Some.apply[Long](0L)
      else
        {
          val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
          val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
          scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
            case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
            case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
            case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
          }
        };
      val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
        scala.Some.apply[Long](0L)
      else
        StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
      equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
    }))
        </td>
      </tr><tr>
        <td>
          220
        </td>
        <td>
          12443
        </td>
        <td>
          9317
          -
          9332
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.disjoint
        </td>
      </tr><tr>
        <td>
          221
        </td>
        <td>
          12444
        </td>
        <td>
          9346
          -
          9354
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          221
        </td>
        <td>
          12445
        </td>
        <td>
          9346
          -
          9354
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          12446
        </td>
        <td>
          9414
          -
          9425
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.isBounded
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$19.isBounded
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          12447
        </td>
        <td>
          9392
          -
          9426
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          12478
        </td>
        <td>
          9388
          -
          10427
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
  StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
else
  {
    val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
      case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
    })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
      case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
    };
    val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
    val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
    val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
      scala.Some.apply[Long](0L)
    else
      {
        val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
        val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
        scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
          case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
          case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
          case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
        }
      };
    val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
      scala.Some.apply[Long](0L)
    else
      StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
    equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
  }
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          12448
        </td>
        <td>
          9459
          -
          9473
        </td>
        <td>
          Select
        </td>
        <td>
          org.geotools.api.filter.Filter.INCLUDE
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.geotools.api.filter.Filter.INCLUDE
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          12449
        </td>
        <td>
          9440
          -
          9474
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          12450
        </td>
        <td>
          9440
          -
          9474
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          224
        </td>
        <td>
          12477
        </td>
        <td>
          9510
          -
          10427
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
  })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
    case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
  };
  val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
  val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
  val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
    scala.Some.apply[Long](0L)
  else
    {
      val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
      val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
      scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
        case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
        case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
        case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
      }
    };
  val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
    scala.Some.apply[Long](0L)
  else
    StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
  equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
}
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          12451
        </td>
        <td>
          9565
          -
          9578
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.value
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          b.lower.value
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          12452
        </td>
        <td>
          9580
          -
          9593
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.value
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          b.upper.value
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          12453
        </td>
        <td>
          9564
          -
          9594
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          12454
        </td>
        <td>
          9558
          -
          9558
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          12455
        </td>
        <td>
          9541
          -
          9595
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])])
        </td>
      </tr><tr>
        <td>
          226
        </td>
        <td>
          12456
        </td>
        <td>
          9611
          -
          9611
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$20._1
        </td>
      </tr><tr>
        <td>
          226
        </td>
        <td>
          12457
        </td>
        <td>
          9625
          -
          9625
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$20._2
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          12458
        </td>
        <td>
          9721
          -
          9741
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          equalsBounds.isEmpty
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          12459
        </td>
        <td>
          9745
          -
          9753
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          12460
        </td>
        <td>
          9745
          -
          9753
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          12468
        </td>
        <td>
          9761
          -
          10205
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
  val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
  scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
    case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
    case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
    case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
  }
}
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          12461
        </td>
        <td>
          9929
          -
          9937
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Option.get
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$21._1.get
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          12462
        </td>
        <td>
          9928
          -
          9928
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Any]
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          12463
        </td>
        <td>
          9912
          -
          9938
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any])
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          12464
        </td>
        <td>
          9868
          -
          9939
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateEqualsCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]))
        </td>
      </tr><tr>
        <td>
          230
        </td>
        <td>
          12465
        </td>
        <td>
          9965
          -
          10013
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds)
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          12466
        </td>
        <td>
          10096
          -
          10110
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.min(e, r)
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          12467
        </td>
        <td>
          10091
          -
          10111
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](scala.math.`package`.min(e, r))
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          12469
        </td>
        <td>
          10237
          -
          10256
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rangeBounds.isEmpty
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          12470
        </td>
        <td>
          10260
          -
          10268
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          12471
        </td>
        <td>
          10260
          -
          10268
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          238
        </td>
        <td>
          12472
        </td>
        <td>
          10290
          -
          10337
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds)
        </td>
      </tr><tr>
        <td>
          238
        </td>
        <td>
          12473
        </td>
        <td>
          10290
          -
          10337
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds)
        </td>
      </tr><tr>
        <td>
          240
        </td>
        <td>
          12474
        </td>
        <td>
          10410
          -
          10415
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          e.+(r)
        </td>
      </tr><tr>
        <td>
          240
        </td>
        <td>
          12475
        </td>
        <td>
          10384
          -
          10415
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rangeCount.map[Long](((r: Long) =&gt; e.+(r)))
        </td>
      </tr><tr>
        <td>
          240
        </td>
        <td>
          12476
        </td>
        <td>
          10360
          -
          10415
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          12482
        </td>
        <td>
          10790
          -
          10806
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          12483
        </td>
        <td>
          10808
          -
          10820
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.isPoints
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          12484
        </td>
        <td>
          10751
          -
          10821
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints)
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          12485
        </td>
        <td>
          10830
          -
          10848
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.isEmpty
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          12486
        </td>
        <td>
          10858
          -
          10862
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          12487
        </td>
        <td>
          10858
          -
          10862
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          12488
        </td>
        <td>
          10878
          -
          10897
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.disjoint
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          12525
        </td>
        <td>
          10874
          -
          11881
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (geometries.disjoint)
  scala.Some.apply[Long](0L)
else
  {
    val zero: org.locationtech.jts.geom.Point = org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint;
    StatsBasedEstimator.this.getHistogram[org.locationtech.jts.geom.Geometry](sft, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, 0, zero, zero, StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry], StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[org.locationtech.jts.geom.Geometry]) =&gt; {
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$24: (Long, Long) = ({
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$22: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.min): (Double, Double, Double, Double) @unchecked) match {
          case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)((xmin @ _), (ymin @ _), _, _) =&gt; scala.Tuple2.apply[Double, Double](xmin, ymin)
        };
        val xmin: Double = x$22._1;
        val ymin: Double = x$22._2;
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$23: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.max): (Double, Double, Double, Double) @unchecked) match {
          case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)(_, _, (xmax @ _), (ymax @ _)) =&gt; scala.Tuple2.apply[Double, Double](xmax, ymax)
        };
        val xmax: Double = x$23._1;
        val ymax: Double = x$23._2;
        scala.Tuple2.apply[Long, Long](org.locationtech.geomesa.curve.Z2SFC.index(xmin, ymin, org.locationtech.geomesa.curve.Z2SFC.index$default$3), org.locationtech.geomesa.curve.Z2SFC.index(xmax, ymax, org.locationtech.geomesa.curve.Z2SFC.index$default$3))
      }: (Long, Long) @unchecked) match {
        case (_1: Long, _2: Long)(Long, Long)((zLo @ _), (zHi @ _)) =&gt; scala.Tuple2.apply[Long, Long](zLo, zHi)
      };
      val zLo: Long = x$24._1;
      val zHi: Long = x$24._2;
      def inRange(r: org.locationtech.geomesa.zorder.sfcurve.IndexRange): Boolean = r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo));
      val ranges: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
        ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
      })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3);
      val indices: Seq[Int] = ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
        val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
        val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
        scala.Predef.intWrapper(loIndex).to(hiIndex)
      }))(collection.this.Seq.canBuildFrom[Int]);
      if (indices.isEmpty)
        0L
      else
        indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }))
  }
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          12489
        </td>
        <td>
          10907
          -
          10915
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          12490
        </td>
        <td>
          10907
          -
          10915
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          12524
        </td>
        <td>
          10927
          -
          11881
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val zero: org.locationtech.jts.geom.Point = org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint;
  StatsBasedEstimator.this.getHistogram[org.locationtech.jts.geom.Geometry](sft, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, 0, zero, zero, StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry], StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[org.locationtech.jts.geom.Geometry]) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$24: (Long, Long) = ({
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$22: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.min): (Double, Double, Double, Double) @unchecked) match {
        case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)((xmin @ _), (ymin @ _), _, _) =&gt; scala.Tuple2.apply[Double, Double](xmin, ymin)
      };
      val xmin: Double = x$22._1;
      val ymin: Double = x$22._2;
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$23: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.max): (Double, Double, Double, Double) @unchecked) match {
        case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)(_, _, (xmax @ _), (ymax @ _)) =&gt; scala.Tuple2.apply[Double, Double](xmax, ymax)
      };
      val xmax: Double = x$23._1;
      val ymax: Double = x$23._2;
      scala.Tuple2.apply[Long, Long](org.locationtech.geomesa.curve.Z2SFC.index(xmin, ymin, org.locationtech.geomesa.curve.Z2SFC.index$default$3), org.locationtech.geomesa.curve.Z2SFC.index(xmax, ymax, org.locationtech.geomesa.curve.Z2SFC.index$default$3))
    }: (Long, Long) @unchecked) match {
      case (_1: Long, _2: Long)(Long, Long)((zLo @ _), (zHi @ _)) =&gt; scala.Tuple2.apply[Long, Long](zLo, zHi)
    };
    val zLo: Long = x$24._1;
    val zHi: Long = x$24._2;
    def inRange(r: org.locationtech.geomesa.zorder.sfcurve.IndexRange): Boolean = r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo));
    val ranges: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
      ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
    })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3);
    val indices: Seq[Int] = ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
      val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
      val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
      scala.Predef.intWrapper(loIndex).to(hiIndex)
    }))(collection.this.Seq.canBuildFrom[Int]);
    if (indices.isEmpty)
      0L
    else
      indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
  }))
}
        </td>
      </tr><tr>
        <td>
          259
        </td>
        <td>
          12491
        </td>
        <td>
          10946
          -
          10969
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          12492
        </td>
        <td>
          11010
          -
          11026
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          12493
        </td>
        <td>
          11028
          -
          11029
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          12494
        </td>
        <td>
          10994
          -
          10994
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$6
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          12495
        </td>
        <td>
          10994
          -
          10994
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$7
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          12523
        </td>
        <td>
          10976
          -
          11875
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[org.locationtech.jts.geom.Geometry](sft, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, 0, zero, zero, StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry], StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[org.locationtech.jts.geom.Geometry]) =&gt; {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$24: (Long, Long) = ({
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$22: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.min): (Double, Double, Double, Double) @unchecked) match {
      case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)((xmin @ _), (ymin @ _), _, _) =&gt; scala.Tuple2.apply[Double, Double](xmin, ymin)
    };
    val xmin: Double = x$22._1;
    val ymin: Double = x$22._2;
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$23: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.max): (Double, Double, Double, Double) @unchecked) match {
      case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)(_, _, (xmax @ _), (ymax @ _)) =&gt; scala.Tuple2.apply[Double, Double](xmax, ymax)
    };
    val xmax: Double = x$23._1;
    val ymax: Double = x$23._2;
    scala.Tuple2.apply[Long, Long](org.locationtech.geomesa.curve.Z2SFC.index(xmin, ymin, org.locationtech.geomesa.curve.Z2SFC.index$default$3), org.locationtech.geomesa.curve.Z2SFC.index(xmax, ymax, org.locationtech.geomesa.curve.Z2SFC.index$default$3))
  }: (Long, Long) @unchecked) match {
    case (_1: Long, _2: Long)(Long, Long)((zLo @ _), (zHi @ _)) =&gt; scala.Tuple2.apply[Long, Long](zLo, zHi)
  };
  val zLo: Long = x$24._1;
  val zHi: Long = x$24._2;
  def inRange(r: org.locationtech.geomesa.zorder.sfcurve.IndexRange): Boolean = r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo));
  val ranges: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
    ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
  })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3);
  val indices: Seq[Int] = ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
    val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
    val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
    scala.Predef.intWrapper(loIndex).to(hiIndex)
  }))(collection.this.Seq.canBuildFrom[Int]);
  if (indices.isEmpty)
    0L
  else
    indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))
        </td>
      </tr><tr>
        <td>
          261
        </td>
        <td>
          12496
        </td>
        <td>
          11075
          -
          11075
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$24._1
        </td>
      </tr><tr>
        <td>
          261
        </td>
        <td>
          12497
        </td>
        <td>
          11080
          -
          11080
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$24._2
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          12498
        </td>
        <td>
          11356
          -
          11369
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.upper.&gt;(zLo)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          12499
        </td>
        <td>
          11339
          -
          11369
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          12500
        </td>
        <td>
          11427
          -
          11447
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry)
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          12501
        </td>
        <td>
          11426
          -
          11426
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          12502
        </td>
        <td>
          11405
          -
          11448
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
  ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
})(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)])
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          12503
        </td>
        <td>
          11450
          -
          11469
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.ZHistogramPrecision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ZHistogramPrecision
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          12504
        </td>
        <td>
          11392
          -
          11470
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.Z2SFC.ranges
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
  ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
})(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3)
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          12505
        </td>
        <td>
          11507
          -
          11514
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.inRange
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRange(r)
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          12513
        </td>
        <td>
          11524
          -
          11524
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          12514
        </td>
        <td>
          11493
          -
          11780
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
  val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
  val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
  scala.Predef.intWrapper(loIndex).to(hiIndex)
}))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          12506
        </td>
        <td>
          11559
          -
          11628
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          12507
        </td>
        <td>
          11680
          -
          11691
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.zorder.sfcurve.IndexRange.upper
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          range.upper
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          12508
        </td>
        <td>
          11658
          -
          11692
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.directIndex
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.directIndex(range.upper)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          12509
        </td>
        <td>
          11701
          -
          11708
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$26.!=(-1)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          12510
        </td>
        <td>
          11720
          -
          11740
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.length.-(1)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          12511
        </td>
        <td>
          11653
          -
          11741
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          12512
        </td>
        <td>
          11752
          -
          11770
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(loIndex).to(hiIndex)
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12515
        </td>
        <td>
          11793
          -
          11808
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.isEmpty
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12516
        </td>
        <td>
          11812
          -
          11814
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12517
        </td>
        <td>
          11812
          -
          11814
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12518
        </td>
        <td>
          11845
          -
          11860
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(i)
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12519
        </td>
        <td>
          11844
          -
          11844
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12520
        </td>
        <td>
          11862
          -
          11862
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12521
        </td>
        <td>
          11824
          -
          11865
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          12522
        </td>
        <td>
          11824
          -
          11865
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          288
        </td>
        <td>
          12527
        </td>
        <td>
          12226
          -
          12226
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](dateField, intervals)
        </td>
      </tr><tr>
        <td>
          288
        </td>
        <td>
          12566
        </td>
        <td>
          12214
          -
          13228
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.WithFilter.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.map[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])](((dateField: String) =&gt; {
  val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4);
  scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](dateField, intervals)
})).withFilter(((x$31: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$31: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((dateField @ _), (intervals @ _)) =&gt; intervals.nonEmpty
})).flatMap[Long](((x$32: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$32: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((dateField @ _), (intervals @ _)) =&gt; StatsBasedEstimator.this.getHistogram[java.util.Date](sft, dateField, 0, new java.util.Date(), new java.util.Date(), StatsBasedEstimator.this.getHistogram$default$6[java.util.Date], StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[java.util.Date]) =&gt; {
    def inRange(interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]): Boolean = interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))));
    if (intervals.disjoint)
      0L
    else
      {
        val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
          val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
          val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
          scala.Predef.intWrapper(loIndex).to(hiIndex)
        }))(collection.this.Seq.canBuildFrom[Int]);
        if (indices.isEmpty)
          0L
        else
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
      }
  }))
}))
        </td>
      </tr><tr>
        <td>
          289
        </td>
        <td>
          12526
        </td>
        <td>
          12274
          -
          12322
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4)
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          12528
        </td>
        <td>
          12332
          -
          12350
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          12529
        </td>
        <td>
          12332
          -
          12350
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          12530
        </td>
        <td>
          12411
          -
          12412
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          12531
        </td>
        <td>
          12414
          -
          12424
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new java.util.Date()
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          12532
        </td>
        <td>
          12426
          -
          12436
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new java.util.Date()
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          12533
        </td>
        <td>
          12388
          -
          12388
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$6
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$6[java.util.Date]
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          12534
        </td>
        <td>
          12388
          -
          12388
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$7
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          12564
        </td>
        <td>
          12357
          -
          13228
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[java.util.Date](sft, dateField, 0, new java.util.Date(), new java.util.Date(), StatsBasedEstimator.this.getHistogram$default$6[java.util.Date], StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[java.util.Date]) =&gt; {
  def inRange(interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]): Boolean = interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))));
  if (intervals.disjoint)
    0L
  else
    {
      val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
        val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
        val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
        scala.Predef.intWrapper(loIndex).to(hiIndex)
      }))(collection.this.Seq.canBuildFrom[Int]);
      if (indices.isEmpty)
        0L
      else
        indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }
}))
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          12565
        </td>
        <td>
          12357
          -
          13228
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[java.util.Date](sft, dateField, 0, new java.util.Date(), new java.util.Date(), StatsBasedEstimator.this.getHistogram$default$6[java.util.Date], StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[java.util.Date]) =&gt; {
  def inRange(interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]): Boolean = interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))));
  if (intervals.disjoint)
    0L
  else
    {
      val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
        val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
        val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
        scala.Predef.intWrapper(loIndex).to(hiIndex)
      }))(collection.this.Seq.canBuildFrom[Int]);
      if (indices.isEmpty)
        0L
      else
        indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }
}))
        </td>
      </tr><tr>
        <td>
          294
        </td>
        <td>
          12535
        </td>
        <td>
          12571
          -
          12592
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.max.getTime()
        </td>
      </tr><tr>
        <td>
          294
        </td>
        <td>
          12536
        </td>
        <td>
          12543
          -
          12592
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime())
        </td>
      </tr><tr>
        <td>
          294
        </td>
        <td>
          12540
        </td>
        <td>
          12515
          -
          12687
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))))
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          12537
        </td>
        <td>
          12665
          -
          12686
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.min.getTime()
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          12538
        </td>
        <td>
          12637
          -
          12686
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime())
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          12539
        </td>
        <td>
          12609
          -
          12687
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime())))
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          12541
        </td>
        <td>
          12707
          -
          12725
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.disjoint
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          12542
        </td>
        <td>
          12729
          -
          12731
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          12543
        </td>
        <td>
          12729
          -
          12731
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          12563
        </td>
        <td>
          12739
          -
          13222
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
    val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
    val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
    scala.Predef.intWrapper(loIndex).to(hiIndex)
  }))(collection.this.Seq.canBuildFrom[Int]);
  if (indices.isEmpty)
    0L
  else
    indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          12544
        </td>
        <td>
          12787
          -
          12794
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.inRange
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRange(interval)
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          12553
        </td>
        <td>
          12804
          -
          12804
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          12554
        </td>
        <td>
          12763
          -
          13127
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
  val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
  val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
  scala.Predef.intWrapper(loIndex).to(hiIndex)
}))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          300
        </td>
        <td>
          12545
        </td>
        <td>
          12842
          -
          12943
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          12546
        </td>
        <td>
          13026
          -
          13037
        </td>
        <td>
          Apply
        </td>
        <td>
          java.time.chrono.ChronoZonedDateTime.toInstant
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.toInstant()
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          12547
        </td>
        <td>
          13016
          -
          13038
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.from
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Date.from(i.toInstant())
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          12548
        </td>
        <td>
          12998
          -
          13039
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.indexOf(java.util.Date.from(i.toInstant()))
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          12549
        </td>
        <td>
          13048
          -
          13055
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$30.!=(-1)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          12550
        </td>
        <td>
          13067
          -
          13087
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          histogram.length.-(1)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          12551
        </td>
        <td>
          12968
          -
          13088
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1))
        </td>
      </tr><tr>
        <td>
          302
        </td>
        <td>
          12552
        </td>
        <td>
          13099
          -
          13117
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(loIndex).to(hiIndex)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12555
        </td>
        <td>
          13140
          -
          13155
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.isEmpty
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12556
        </td>
        <td>
          13159
          -
          13161
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12557
        </td>
        <td>
          13159
          -
          13161
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12558
        </td>
        <td>
          13192
          -
          13207
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(i)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12559
        </td>
        <td>
          13191
          -
          13191
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12560
        </td>
        <td>
          13209
          -
          13209
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12561
        </td>
        <td>
          13171
          -
          13212
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          12562
        </td>
        <td>
          13171
          -
          13212
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          322
        </td>
        <td>
          12567
        </td>
        <td>
          13713
          -
          13714
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          322
        </td>
        <td>
          12568
        </td>
        <td>
          13691
          -
          13691
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getFrequency$default$5
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getFrequency$default$5[Any]
        </td>
      </tr><tr>
        <td>
          322
        </td>
        <td>
          12599
        </td>
        <td>
          13673
          -
          14681
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getFrequency[Any](sft, attribute, 0, filter, StatsBasedEstimator.this.getFrequency$default$5[Any]).map[Long](((freq: org.locationtech.geomesa.utils.stats.Frequency[Any]) =&gt; {
  val absoluteError: Double = scala.math.`package`.floor(freq.size.*(freq.eps));
  val counts: Seq[Long] = if (absoluteError.&lt;(1.0))
    values.map[Long, Seq[Long]]({
      ((value: Any) =&gt; freq.count(value))
    })(collection.this.Seq.canBuildFrom[Long])
  else
    values.map[Long, Seq[Long]](((v: Any) =&gt; {
      val estimate: Long = freq.count(v);
      if (estimate.==(0L))
        0L
      else
        if (estimate.&gt;(absoluteError))
          {
            val relativeError: Double = absoluteError./(estimate);
            estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
          }
        else
          {
            val relativeError: Double = estimate./(absoluteError);
            StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
          }
    }))(collection.this.Seq.canBuildFrom[Long]);
  counts.sum[Long](math.this.Numeric.LongIsIntegral)
}))
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          12569
        </td>
        <td>
          14054
          -
          14062
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.eps
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          12570
        </td>
        <td>
          14042
          -
          14062
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.size.*(freq.eps)
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          12571
        </td>
        <td>
          14031
          -
          14063
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.floor
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.floor(freq.size.*(freq.eps))
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          12572
        </td>
        <td>
          14087
          -
          14106
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          absoluteError.&lt;(1.0)
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          12573
        </td>
        <td>
          14121
          -
          14131
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.count(value)
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          12574
        </td>
        <td>
          14120
          -
          14120
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          12575
        </td>
        <td>
          14110
          -
          14132
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]]({
  ((value: Any) =&gt; freq.count(value))
})(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          12576
        </td>
        <td>
          14110
          -
          14132
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]]({
  ((value: Any) =&gt; freq.count(value))
})(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          12594
        </td>
        <td>
          14161
          -
          14161
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          12595
        </td>
        <td>
          14150
          -
          14650
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]](((v: Any) =&gt; {
  val estimate: Long = freq.count(v);
  if (estimate.==(0L))
    0L
  else
    if (estimate.&gt;(absoluteError))
      {
        val relativeError: Double = absoluteError./(estimate);
        estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
      }
    else
      {
        val relativeError: Double = estimate./(absoluteError);
        StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
      }
}))(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          12596
        </td>
        <td>
          14150
          -
          14650
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]](((v: Any) =&gt; {
  val estimate: Long = freq.count(v);
  if (estimate.==(0L))
    0L
  else
    if (estimate.&gt;(absoluteError))
      {
        val relativeError: Double = absoluteError./(estimate);
        estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
      }
    else
      {
        val relativeError: Double = estimate./(absoluteError);
        StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
      }
}))(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          330
        </td>
        <td>
          12577
        </td>
        <td>
          14193
          -
          14206
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.count(v)
        </td>
      </tr><tr>
        <td>
          331
        </td>
        <td>
          12578
        </td>
        <td>
          14221
          -
          14235
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate.==(0L)
        </td>
      </tr><tr>
        <td>
          332
        </td>
        <td>
          12579
        </td>
        <td>
          14251
          -
          14253
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          332
        </td>
        <td>
          12580
        </td>
        <td>
          14251
          -
          14253
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          333
        </td>
        <td>
          12581
        </td>
        <td>
          14275
          -
          14299
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate.&gt;(absoluteError)
        </td>
      </tr><tr>
        <td>
          333
        </td>
        <td>
          12587
        </td>
        <td>
          14301
          -
          14476
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val relativeError: Double = absoluteError./(estimate);
  estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
}
        </td>
      </tr><tr>
        <td>
          333
        </td>
        <td>
          12593
        </td>
        <td>
          14271
          -
          14640
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (estimate.&gt;(absoluteError))
  {
    val relativeError: Double = absoluteError./(estimate);
    estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
  }
else
  {
    val relativeError: Double = estimate./(absoluteError);
    StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
  }
        </td>
      </tr><tr>
        <td>
          334
        </td>
        <td>
          12582
        </td>
        <td>
          14335
          -
          14359
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          absoluteError./(estimate)
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          12583
        </td>
        <td>
          14410
          -
          14428
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$33.&lt;=(relativeError)
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          12584
        </td>
        <td>
          14437
          -
          14440
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0.5
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          12585
        </td>
        <td>
          14383
          -
          14464
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Double.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          12586
        </td>
        <td>
          14372
          -
          14464
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
        </td>
      </tr><tr>
        <td>
          336
        </td>
        <td>
          12592
        </td>
        <td>
          14482
          -
          14640
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val relativeError: Double = estimate./(absoluteError);
  StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
}
        </td>
      </tr><tr>
        <td>
          337
        </td>
        <td>
          12588
        </td>
        <td>
          14516
          -
          14540
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate./(absoluteError)
        </td>
      </tr><tr>
        <td>
          338
        </td>
        <td>
          12589
        </td>
        <td>
          14580
          -
          14597
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$34.&lt;(relativeError)
        </td>
      </tr><tr>
        <td>
          338
        </td>
        <td>
          12590
        </td>
        <td>
          14606
          -
          14609
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0.5
        </td>
      </tr><tr>
        <td>
          338
        </td>
        <td>
          12591
        </td>
        <td>
          14553
          -
          14628
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Double.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
        </td>
      </tr><tr>
        <td>
          342
        </td>
        <td>
          12597
        </td>
        <td>
          14672
          -
          14672
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          342
        </td>
        <td>
          12598
        </td>
        <td>
          14665
          -
          14675
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          12600
        </td>
        <td>
          15210
          -
          15211
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          12601
        </td>
        <td>
          15213
          -
          15214
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          12602
        </td>
        <td>
          15216
          -
          15217
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          12603
        </td>
        <td>
          15188
          -
          15188
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$6
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$6[Any]
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          12604
        </td>
        <td>
          15188
          -
          15188
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$7
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$7[Any]
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          12633
        </td>
        <td>
          15170
          -
          16049
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[Any](sft, attribute, 0, 0, 0, StatsBasedEstimator.this.getHistogram$default$6[Any], StatsBasedEstimator.this.getHistogram$default$7[Any]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[Any]) =&gt; {
  val inRangeRanges: Seq[(Option[Any], Option[Any])] = ranges.filter(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, scala.None) =&gt; true
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), scala.None) =&gt; histogram.defaults.min(lo, histogram.max).==(lo)
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.max(up, histogram.min).==(up)
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
  }));
  val indices: Seq[Int] = inRangeRanges.flatMap[Int, Seq[Int]](((x0$2: (Option[Any], Option[Any])) =&gt; x0$2 match {
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((lower @ _), (upper @ _)) =&gt; {
      val lowerIndex: Int = lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0);
      val upperIndex: Int = upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1));
      scala.Predef.intWrapper(lowerIndex).to(upperIndex)
    }
  }))(collection.this.Seq.canBuildFrom[Int]);
  if (indices.isEmpty)
    0L
  else
    indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))
        </td>
      </tr><tr>
        <td>
          359
        </td>
        <td>
          12615
        </td>
        <td>
          15264
          -
          15665
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ranges.filter(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, scala.None) =&gt; true
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), scala.None) =&gt; histogram.defaults.min(lo, histogram.max).==(lo)
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.max(up, histogram.min).==(up)
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
}))
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          12605
        </td>
        <td>
          15317
          -
          15321
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          12606
        </td>
        <td>
          15317
          -
          15321
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          361
        </td>
        <td>
          12607
        </td>
        <td>
          15379
          -
          15426
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo)
        </td>
      </tr><tr>
        <td>
          361
        </td>
        <td>
          12608
        </td>
        <td>
          15379
          -
          15426
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo)
        </td>
      </tr><tr>
        <td>
          362
        </td>
        <td>
          12609
        </td>
        <td>
          15464
          -
          15511
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.max(up, histogram.min).==(up)
        </td>
      </tr><tr>
        <td>
          362
        </td>
        <td>
          12610
        </td>
        <td>
          15464
          -
          15511
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.max(up, histogram.min).==(up)
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          12611
        </td>
        <td>
          15586
          -
          15599
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.max
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.max
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          12612
        </td>
        <td>
          15610
          -
          15657
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.max(up, histogram.min).==(up)
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          12613
        </td>
        <td>
          15559
          -
          15657
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          12614
        </td>
        <td>
          15559
          -
          15657
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
        </td>
      </tr><tr>
        <td>
          366
        </td>
        <td>
          12622
        </td>
        <td>
          15730
          -
          15950
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val lowerIndex: Int = lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0);
  val upperIndex: Int = upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1));
  scala.Predef.intWrapper(lowerIndex).to(upperIndex)
}
        </td>
      </tr><tr>
        <td>
          366
        </td>
        <td>
          12623
        </td>
        <td>
          15708
          -
          15708
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          366
        </td>
        <td>
          12624
        </td>
        <td>
          15686
          -
          15958
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRangeRanges.flatMap[Int, Seq[Int]](((x0$2: (Option[Any], Option[Any])) =&gt; x0$2 match {
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((lower @ _), (upper @ _)) =&gt; {
    val lowerIndex: Int = lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0);
    val upperIndex: Int = upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1));
    scala.Predef.intWrapper(lowerIndex).to(upperIndex)
  }
}))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          367
        </td>
        <td>
          12616
        </td>
        <td>
          15758
          -
          15815
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          12617
        </td>
        <td>
          15851
          -
          15868
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.indexOf(value)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          12618
        </td>
        <td>
          15877
          -
          15884
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$36.!=(-1)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          12619
        </td>
        <td>
          15896
          -
          15916
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.length.-(1)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          12620
        </td>
        <td>
          15841
          -
          15917
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1))
        </td>
      </tr><tr>
        <td>
          369
        </td>
        <td>
          12621
        </td>
        <td>
          15926
          -
          15950
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(lowerIndex).to(upperIndex)
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12625
        </td>
        <td>
          15969
          -
          15984
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.isEmpty
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12626
        </td>
        <td>
          15988
          -
          15990
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12627
        </td>
        <td>
          15988
          -
          15990
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12628
        </td>
        <td>
          16021
          -
          16036
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(i)
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12629
        </td>
        <td>
          16020
          -
          16020
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12630
        </td>
        <td>
          16038
          -
          16038
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12631
        </td>
        <td>
          16000
          -
          16041
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          12632
        </td>
        <td>
          16000
          -
          16041
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          379
        </td>
        <td>
          12634
        </td>
        <td>
          16226
          -
          16300
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.ceil(scala.math.`package`.log(GeoMesaStats.MaxHistogramSize.toDouble)./(scala.math.`package`.log(2.0))).toInt.+(2)
        </td>
      </tr><tr>
        <td>
          381
        </td>
        <td>
          12635
        </td>
        <td>
          16339
          -
          16372
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[Double](0.1, 0.3, 0.5, 0.7, 0.9, 1.0)
        </td>
      </tr><tr>
        <td>
          392
        </td>
        <td>
          12636
        </td>
        <td>
          16812
          -
          16827
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getDtgField
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          12637
        </td>
        <td>
          16860
          -
          16877
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.everything
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.everything[java.util.Date]
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          12638
        </td>
        <td>
          16855
          -
          16878
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.everything[java.util.Date])
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          12639
        </td>
        <td>
          16855
          -
          16878
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.everything[java.util.Date])
        </td>
      </tr><tr>
        <td>
          394
        </td>
        <td>
          12672
        </td>
        <td>
          16900
          -
          17729
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          {
  val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dtg, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4);
  if (intervals.disjoint)
    scala.None
  else
    {
      val dateTimes: Option[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = intervals.values.reduceOption[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](((x0$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], x1$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](x0$1, x1$1) match {
        case (_1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], _2: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])(org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])((left @ _), (right @ _)) =&gt; {
          val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
          val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
          org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
        }
      }));
      val lower: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)));
      val upper: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)));
      scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])))
    }
}
        </td>
      </tr><tr>
        <td>
          395
        </td>
        <td>
          12640
        </td>
        <td>
          16927
          -
          16969
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dtg, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$4)
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          12641
        </td>
        <td>
          16982
          -
          17000
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          intervals.disjoint
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          12642
        </td>
        <td>
          17004
          -
          17008
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          12643
        </td>
        <td>
          17004
          -
          17008
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          12671
        </td>
        <td>
          17016
          -
          17729
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          {
  val dateTimes: Option[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = intervals.values.reduceOption[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](((x0$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], x1$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](x0$1, x1$1) match {
    case (_1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], _2: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])(org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])((left @ _), (right @ _)) =&gt; {
      val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
      val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
      org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
    }
  }));
  val lower: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)));
  val upper: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)));
  scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])))
}
        </td>
      </tr><tr>
        <td>
          398
        </td>
        <td>
          12651
        </td>
        <td>
          17192
          -
          17374
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          {
  val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
  val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
  org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
}
        </td>
      </tr><tr>
        <td>
          398
        </td>
        <td>
          12652
        </td>
        <td>
          17118
          -
          17386
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.reduceOption
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          intervals.values.reduceOption[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](((x0$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], x1$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](x0$1, x1$1) match {
  case (_1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], _2: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])(org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])((left @ _), (right @ _)) =&gt; {
    val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
    val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
    org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
  }
}))
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          12644
        </td>
        <td>
          17244
          -
          17254
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.lower
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          left.lower
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          12645
        </td>
        <td>
          17256
          -
          17267
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.lower
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          right.lower
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          12646
        </td>
        <td>
          17219
          -
          17268
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.smallerLowerBound
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower)
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          12647
        </td>
        <td>
          17317
          -
          17327
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.upper
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          left.upper
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          12648
        </td>
        <td>
          17329
          -
          17340
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.upper
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          right.upper
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          12649
        </td>
        <td>
          17293
          -
          17341
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.largerUpperBound
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper)
        </td>
      </tr><tr>
        <td>
          401
        </td>
        <td>
          12650
        </td>
        <td>
          17354
          -
          17374
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          12653
        </td>
        <td>
          17467
          -
          17478
        </td>
        <td>
          Apply
        </td>
        <td>
          java.time.chrono.ChronoZonedDateTime.toInstant
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          i.toInstant()
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          12654
        </td>
        <td>
          17457
          -
          17479
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.from
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          java.util.Date.from(i.toInstant())
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          12655
        </td>
        <td>
          17434
          -
          17480
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant())))
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          12656
        </td>
        <td>
          17482
          -
          17499
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.inclusive
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.lower.inclusive
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          12657
        </td>
        <td>
          17428
          -
          17500
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          12658
        </td>
        <td>
          17409
          -
          17501
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)))
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          12659
        </td>
        <td>
          17582
          -
          17593
        </td>
        <td>
          Apply
        </td>
        <td>
          java.time.chrono.ChronoZonedDateTime.toInstant
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          i.toInstant()
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          12660
        </td>
        <td>
          17572
          -
          17594
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.from
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          java.util.Date.from(i.toInstant())
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          12661
        </td>
        <td>
          17549
          -
          17595
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant())))
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          12662
        </td>
        <td>
          17597
          -
          17614
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.inclusive
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.upper.inclusive
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          12663
        </td>
        <td>
          17543
          -
          17615
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          12664
        </td>
        <td>
          17524
          -
          17616
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)))
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          12665
        </td>
        <td>
          17655
          -
          17676
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          12666
        </td>
        <td>
          17639
          -
          17677
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          12667
        </td>
        <td>
          17695
          -
          17716
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          12668
        </td>
        <td>
          17679
          -
          17717
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          12669
        </td>
        <td>
          17632
          -
          17718
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]))
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          12670
        </td>
        <td>
          17627
          -
          17719
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])))
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>