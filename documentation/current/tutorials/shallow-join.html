

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>GeoMesa Spark: Aggregating and Visualizing Data &mdash; GeoMesa 1.3.2-SNAPSHOT Manuals</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme_custom.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/sphinx_tabs/tabs.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/sphinx_tabs/semantic-ui-2.2.7/segment.min.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/sphinx_tabs/semantic-ui-2.2.7/menu.min.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/sphinx_tabs/semantic-ui-2.2.7/tab.min.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="GeoMesa 1.3.2-SNAPSHOT Manuals" href="../index.html"/>
        <link rel="up" title="Tutorials" href="index.html"/>
        <link rel="next" title="Web Processing Services (WPS) Tube Select" href="geomesa-tubeselect.html"/>
        <link rel="prev" title="GeoMesa Spark: Basic Analysis" href="spark.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> GeoMesa
          

          
          </a>

          
            
            
              <div class="version">
                1.3.2-SNAPSHOT
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer/index.html">Developer Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-in-out">Data In/Out</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#data-analysis">Data Analysis</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="spark.html">GeoMesa Spark: Basic Analysis</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">GeoMesa Spark: Aggregating and Visualizing Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#background">Background</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-up-tutorial-code">Set Up Tutorial Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-rdds">Create RDDs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#grouping-by-polygons">Grouping by polygons</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-new-simple-feature-type">Creating a New Simple Feature Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregating-by-key">Aggregating by Key</a></li>
<li class="toctree-l4"><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="geomesa-tubeselect.html">Web Processing Services (WPS) Tube Select</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#security">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#indexing-and-queries">Indexing and Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#about-tutorial-versions">About Tutorial Versions</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GeoMesa</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Tutorials</a> &raquo;</li>
        
      <li>GeoMesa Spark: Aggregating and Visualizing Data</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/tutorials/shallow-join.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="geomesa-spark-aggregating-and-visualizing-data">
<h1>GeoMesa Spark: Aggregating and Visualizing Data<a class="headerlink" href="#geomesa-spark-aggregating-and-visualizing-data" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will show you how to:</p>
<ol class="arabic simple">
<li>Use GeoMesa with <a class="reference external" href="http://spark.apache.org/">Apache Spark</a> in Scala.</li>
<li>Calculate aggregate statistics using a covering set of polygons.</li>
<li>Create a new simple feature type to represent this aggregation.</li>
<li>Use <a class="reference external" href="http://jupyter.org/">Jupyter</a> and <a class="reference external" href="http://leafletjs.com/">Leaflet</a> to visualize the result.</li>
</ol>
<p>The end of the tutorial provides a link to a downloadable Jupyter notebook with all the necessary code.</p>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://spark.apache.org">Apache Spark</a> is a &#8220;fast and general engine
for large-scale data processing&#8221;. Spark presents an abstraction called a
Resilient Distributed Dataset (RDD) that facilitates expressing
transformations, filters, and aggregations, and efficiently executes the
computation across a distributed set of resources. Spark manages the
lineage of a block of transformed data so that if a node goes down,
Spark can restart the computation for just the missing blocks.</p>
<p><a class="reference external" href="http://jupyter.org/">Jupyter Notebook</a> is an interactive web interface
for a kernel, which is an environment for running the code of a language. Jupyter allows you quickly prototype by
writing code in runnable cells, computing a final result as you go. Visualization of data is also easily done through
integration of Jupyter cell &#8220;magics&#8221; (special directives for functionality outside of the kernel) to create JavaScript and
HTML outputs.</p>
<p>Here, we will combine these two services to demonstrate an operation we are naming &#8220;Shallow Join&#8221;. This operation
is a means of imposing a small, covering set of geospatial data onto a much larger set of data. We essentially perform
an inner join with the geospatial predicate, then aggregate over the result. All of this is done in a distributed fashion
using Spark.</p>
<p>In our example, <a class="reference external" href="http://gdeltproject.org/">GDELT</a> data has point geometries for each event, but we do not directly
know in which country it took place. We &#8220;join&#8221; this geometry against the polygons of the covering set in order to
calculate statistics for a geographical region. However, the example is general enough to support statistics for any
data set with numerical fields or other non-point geometries such as LineStrings or polygons.</p>
</div>
<div class="section" id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>You will need access to a Hadoop 2.2 or better installation with Yarn as well as an Accumulo 1.7 or 1.8 database.</p>
<p>You will need to have ingested GDELT data using GeoMesa. Instructions are available in <a class="reference internal" href="geomesa-examples-gdelt.html"><span class="doc">Map-Reduce Ingest of GDELT</span></a>.</p>
<p class="last">You will need to have ingested a shapefile of polygons outlining your regions of choice. In this tutorial we use
<a class="reference external" href="http://thematicmapping.org/downloads/world_borders.php">this</a> shapefile of countries.</p>
</div>
<p>You will also need:</p>
<ul class="simple">
<li>a <a class="reference external" href="http://spark.apache.org/">Spark</a> 2.0.0 or later distribution</li>
<li>Accumulo user credentials with appropriate permissions to query your data</li>
<li><a class="reference external" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java JDK 8</a></li>
<li>a <a class="reference external" href="https://github.com/jupyter/notebook">Jupyter Notebook</a> server with the <a class="reference external" href="https://toree.incubator.apache.org/">Apache Toree</a> Scala kernel installed</li>
</ul>
</div>
<div class="section" id="set-up-tutorial-code">
<h2>Set Up Tutorial Code<a class="headerlink" href="#set-up-tutorial-code" title="Permalink to this headline">¶</a></h2>
<p>Clone the geomesa-tutorials project, and go into the <code class="docutils literal"><span class="pre">geomesa-examples-spark</span></code> directory:</p>
<blockquote>
<div>$ git clone <a class="reference external" href="https://github.com/geomesa/geomesa-tutorials.git">https://github.com/geomesa/geomesa-tutorials.git</a>
$ cd geomesa-tutorials/geomesa-examples-spark</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The code in this tutorial is written in <a class="reference external" href="http://scala-lang.org/">Scala</a>.</p>
</div>
</div>
<div class="section" id="create-rdds">
<h2>Create RDDs<a class="headerlink" href="#create-rdds" title="Permalink to this headline">¶</a></h2>
<p>The code described below is found in the <code class="docutils literal"><span class="pre">com.example.geomesa.spark.ShallowJoin</span></code> class
in the <code class="docutils literal"><span class="pre">src/main/scala</span></code> directory.</p>
<p>First, set up the parameters and initialize each of the desired data stores.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">gdeltDsParams</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="s">&quot;instanceId&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;instance&quot;</span><span class="o">,</span>
  <span class="s">&quot;zookeepers&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;zoo1,zoo2,zoo3&quot;</span><span class="o">,</span>
  <span class="s">&quot;user&quot;</span>       <span class="o">-&gt;</span> <span class="s">&quot;user&quot;</span><span class="o">,</span>
  <span class="s">&quot;password&quot;</span>   <span class="o">-&gt;</span> <span class="s">&quot;*****&quot;</span><span class="o">,</span>
  <span class="s">&quot;auths&quot;</span>      <span class="o">-&gt;</span> <span class="s">&quot;USER,ADMIN&quot;</span><span class="o">,</span>
  <span class="s">&quot;tableName&quot;</span>  <span class="o">-&gt;</span> <span class="s">&quot;geomesa_catalog&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">countriesDsParams</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="s">&quot;instanceId&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;instance&quot;</span><span class="o">,</span>
  <span class="s">&quot;zookeepers&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;zoo1,zoo2,zoo3&quot;</span><span class="o">,</span>
  <span class="s">&quot;user&quot;</span>       <span class="o">-&gt;</span> <span class="s">&quot;user&quot;</span><span class="o">,</span>
  <span class="s">&quot;password&quot;</span>   <span class="o">-&gt;</span> <span class="s">&quot;*****&quot;</span><span class="o">,</span>
  <span class="s">&quot;auths&quot;</span>      <span class="o">-&gt;</span> <span class="s">&quot;USER,ADMIN&quot;</span><span class="o">,</span>
  <span class="s">&quot;tableName&quot;</span>  <span class="o">-&gt;</span> <span class="s">&quot;countries_catalog&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">gdeltDs</span> <span class="k">=</span> <span class="nc">DataStoreFinder</span><span class="o">.</span><span class="n">getDataStore</span><span class="o">(</span><span class="n">gdeltDsParams</span><span class="o">)</span>
<span class="k">val</span> <span class="n">countriesDs</span> <span class="k">=</span> <span class="nc">DataStoreFinder</span><span class="o">.</span><span class="n">getDataStore</span><span class="o">(</span><span class="n">countriesDsParams</span><span class="o">)</span>
</pre></div>
</div>
<p>Next, initialize a <code class="docutils literal"><span class="pre">SparkContext</span></code> and get the <code class="docutils literal"><span class="pre">SpatialRDDProvider</span></code> for
each data store:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">conf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SparkConf</span><span class="o">().</span><span class="n">setAppName</span><span class="o">(</span><span class="s">&quot;testSpark&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">sc</span> <span class="k">=</span> <span class="nc">SparkContext</span><span class="o">.</span><span class="n">getOrCreate</span><span class="o">(</span><span class="n">conf</span><span class="o">)</span>

<span class="k">val</span> <span class="n">rddProviderCountries</span> <span class="k">=</span> <span class="nc">GeoMesaSpark</span><span class="o">(</span><span class="n">countriesDsParams</span><span class="o">)</span>
<span class="k">val</span> <span class="n">rddProviderGdelt</span>     <span class="k">=</span> <span class="nc">GeoMesaSpark</span><span class="o">(</span><span class="n">gdeltDsParams</span><span class="o">)</span>
</pre></div>
</div>
<p>Now we can initialize RDDs for each of the two sources.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">countriesRdd</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">SimpleFeature</span><span class="o">]</span> <span class="k">=</span> <span class="n">rddProviderCountries</span><span class="o">.</span><span class="n">rdd</span><span class="o">(</span><span class="k">new</span> <span class="nc">Configuration</span><span class="o">(),</span> <span class="n">sc</span><span class="o">,</span> <span class="n">countriesDsParams</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Query</span><span class="o">(</span><span class="s">&quot;states&quot;</span><span class="o">))</span>
<span class="k">val</span> <span class="n">gdeltRdd</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">SimpleFeature</span><span class="o">]</span> <span class="k">=</span> <span class="n">rddProviderGdelt</span><span class="o">.</span><span class="n">rdd</span><span class="o">(</span><span class="k">new</span> <span class="nc">Configuration</span><span class="o">(),</span> <span class="n">sc</span><span class="o">,</span> <span class="n">gdeltDsParams</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Query</span><span class="o">(</span><span class="s">&quot;gdelt&quot;</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="grouping-by-polygons">
<h2>Grouping by polygons<a class="headerlink" href="#grouping-by-polygons" title="Permalink to this headline">¶</a></h2>
<p>To perform our shallow join, we send our smaller data set, countries, to each of the partitions of the larger data set,
GDELT events. This is accomplished through a Spark broadcast, which serializes the desired data and sends it to each of the
nodes in the cluster. This way it is only copied once per task. Note also that we collect the countries RDD into
an Array before broadcasting. Spark does not allow broadcasting of RDDs, and due to the small size of the data set, we
can safely collect data onto the driver node without a risk of running out of memory.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">broadcastedRegions</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span><span class="n">countriesRdd</span><span class="o">.</span><span class="n">collect</span><span class="o">)</span>
</pre></div>
</div>
<p>With the covering set available on each partition, we can iterate over the GDELT events and key them by the region they
were contained in. In <code class="docutils literal"><span class="pre">mapPartitions</span></code>, <code class="docutils literal"><span class="pre">iter</span></code> is an iterator to all the elements (in this case Simple Features) on
the partition. Here we transform each iterator and store the result into a new RDD.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">keyedData</span> <span class="k">=</span> <span class="n">gdeltRdd</span><span class="o">.</span><span class="n">mapPartitions</span> <span class="o">{</span> <span class="n">iter</span> <span class="k">=&gt;</span>
    <span class="k">import</span> <span class="nn">org.locationtech.geomesa.utils.geotools.Conversions._</span>

    <span class="n">iter</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">sf</span> <span class="k">=&gt;</span>
        <span class="c1">// Iterate over regions until a match is found</span>
        <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">broadcastedRegions</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">iterator</span>
        <span class="k">var</span> <span class="n">container</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">cover</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
          <span class="c1">// If the cover&#39;s polygon contains the feature,</span>
          <span class="c1">// or in the case of non-point geoms, if they intersect, set the container</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">cover</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">intersects</span><span class="o">(</span><span class="n">sf</span><span class="o">.</span><span class="n">geometry</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">container</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">cover</span><span class="o">.</span><span class="n">getAttribute</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
          <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// return the found country as the key</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">container</span><span class="o">.</span><span class="n">isDefined</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">Some</span><span class="o">(</span><span class="n">container</span><span class="o">.</span><span class="n">get</span><span class="o">,</span> <span class="n">sf</span><span class="o">)</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="nc">None</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Our new RDD is now of type <code class="docutils literal"><span class="pre">RDD[(String,</span> <span class="pre">SimpleFeature)]</span></code> and can be used for a Spark <code class="docutils literal"><span class="pre">reduceByKey</span></code> operation, but
first, we need to create a simple feature type to represent the aggregated data.</p>
</div>
<div class="section" id="creating-a-new-simple-feature-type">
<h2>Creating a New Simple Feature Type<a class="headerlink" href="#creating-a-new-simple-feature-type" title="Permalink to this headline">¶</a></h2>
<p>We first loop through the types of a sample feature from the GDELT RDD to decide what fields can be aggregated.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">countableTypes</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&quot;Integer&quot;</span><span class="o">,</span> <span class="s">&quot;Long&quot;</span><span class="o">,</span> <span class="s">&quot;Double&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">typeNames</span> <span class="k">=</span> <span class="n">gdeltRdd</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">getType</span><span class="o">.</span><span class="n">getTypes</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">.</span><span class="n">map</span><span class="o">{</span><span class="n">t</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">getBinding</span><span class="o">.</span><span class="n">getSimpleName</span><span class="o">.</span><span class="n">toString</span><span class="o">}</span>
<span class="k">val</span> <span class="n">countableIndices</span> <span class="k">=</span> <span class="n">typeNames</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">index</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">featureType</span> <span class="k">=</span> <span class="n">typeNames</span><span class="o">(</span><span class="n">index</span><span class="o">)</span>
    <span class="c1">// Only grab countable types, skipping the ID field</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">countableTypes</span> <span class="n">contains</span> <span class="n">featureType</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Some</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">featureType</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">None</span>
    <span class="o">}</span>
<span class="o">}.</span><span class="n">toArray</span>
<span class="k">val</span> <span class="n">countable</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span><span class="n">countableIndices</span><span class="o">)</span>
</pre></div>
</div>
<p>With these fields, we can create a Simple Feature Type to store their averages and totals, prefixing each one with
&#8220;total_&#8221; and &#8220;avg_&#8221;. Of course, it may not make sense to aggregate ID fields or fields that are already an average,
should they appear, but this approach makes it easy if the fields are not known ahead of time.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">sftBuilder</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SftBuilder</span><span class="o">()</span>
<span class="n">sftBuilder</span><span class="o">.</span><span class="n">stringType</span><span class="o">(</span><span class="s">&quot;country&quot;</span><span class="o">)</span>
<span class="n">sftBuilder</span><span class="o">.</span><span class="n">multiPolygon</span><span class="o">(</span><span class="s">&quot;geom&quot;</span><span class="o">)</span>
<span class="n">sftBuilder</span><span class="o">.</span><span class="n">intType</span><span class="o">(</span><span class="s">&quot;count&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">featureProperties</span> <span class="k">=</span> <span class="n">gdeltRdd</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">getProperties</span><span class="o">.</span><span class="n">toSeq</span>
<span class="n">countableIndices</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">clazz</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">featureName</span> <span class="k">=</span> <span class="n">featureProperties</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">index</span><span class="o">).</span><span class="n">getName</span>
    <span class="n">clazz</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="s">&quot;Integer&quot;</span> <span class="k">=&gt;</span> <span class="n">sftBuilder</span><span class="o">.</span><span class="n">intType</span><span class="o">(</span><span class="s">&quot;total_&quot;</span> <span class="o">+</span> <span class="n">featureName</span><span class="o">)</span>
        <span class="k">case</span> <span class="s">&quot;Long&quot;</span> <span class="k">=&gt;</span> <span class="n">sftBuilder</span><span class="o">.</span><span class="n">longType</span><span class="o">(</span><span class="s">&quot;total_&quot;</span> <span class="o">+</span> <span class="n">featureName</span><span class="o">)</span>
        <span class="k">case</span> <span class="s">&quot;Double&quot;</span> <span class="k">=&gt;</span> <span class="n">sftBuilder</span><span class="o">.</span><span class="n">doubleType</span><span class="o">(</span><span class="s">&quot;total_&quot;</span> <span class="o">+</span> <span class="n">featureName</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">sftBuilder</span><span class="o">.</span><span class="n">doubleType</span><span class="o">(</span><span class="s">&quot;avg_&quot;</span><span class="o">+</span><span class="n">featureProperties</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">index</span><span class="o">).</span><span class="n">getName</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">val</span> <span class="n">coverSft</span> <span class="k">=</span> <span class="nc">SimpleFeatureTypes</span><span class="o">.</span><span class="n">createType</span><span class="o">(</span><span class="s">&quot;aggregate&quot;</span><span class="o">,</span><span class="n">sftBuilder</span><span class="o">.</span><span class="n">getSpec</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregating-by-key">
<h2>Aggregating by Key<a class="headerlink" href="#aggregating-by-key" title="Permalink to this headline">¶</a></h2>
<p>To begin aggregating we first send our new Simple Feature Type to each of the executors so that they can create and
serialize Simple Features of that type.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="nc">GeoMesaSpark</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">coverSft</span><span class="o">))</span>

<span class="k">val</span> <span class="n">newSfts</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span><span class="nc">GeoMesaSparkKryoRegistrator</span><span class="o">.</span><span class="n">typeCache</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">sft</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">sft</span><span class="o">.</span><span class="n">getTypeName</span><span class="o">,</span> <span class="nc">SimpleFeatureTypes</span><span class="o">.</span><span class="n">encodeType</span><span class="o">(</span><span class="n">sft</span><span class="o">))</span>
<span class="o">}.</span><span class="n">toArray</span><span class="o">)</span>

<span class="n">keyedData</span><span class="o">.</span><span class="n">foreachPartition</span> <span class="o">{</span> <span class="n">iter</span> <span class="k">=&gt;</span>
    <span class="n">newSfts</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">spec</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">newSft</span> <span class="k">=</span> <span class="nc">SimpleFeatureTypes</span><span class="o">.</span><span class="n">createType</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">spec</span><span class="o">)</span>
        <span class="nc">GeoMesaSparkKryoRegistrator</span><span class="o">.</span><span class="n">putType</span><span class="o">(</span><span class="n">newSft</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Now we can apply a <code class="docutils literal"><span class="pre">reduceByKey</span></code> operation to the keyed RDD. This Spark operation will take pairs of RDD elements of
the same key, apply the given function, and replace them with the result. Here, we have three cases for reduction.</p>
<ol class="arabic simple">
<li>The two Simple Features have not been aggregated into one of a new type.</li>
<li>The two Simple Features have both been aggregated into one of a new type.</li>
<li>One of the Simple Features has been aggregated (but not both).</li>
</ol>
<p>For the sake of brevity, we will only show the first case, with the other two following similar patterns.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="c1">// Grab each feature&#39;s properties</span>
<span class="k">val</span> <span class="n">featurePropertiesA</span> <span class="k">=</span> <span class="n">featureA</span><span class="o">.</span><span class="n">getProperties</span><span class="o">.</span><span class="n">toSeq</span>
<span class="k">val</span> <span class="n">featurePropertiesB</span> <span class="k">=</span> <span class="n">featureB</span><span class="o">.</span><span class="n">getProperties</span><span class="o">.</span><span class="n">toSeq</span>
<span class="c1">// Create a new aggregate feature to hold the result</span>
<span class="k">val</span> <span class="n">featureFields</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">&quot;empty&quot;</span><span class="o">,</span> <span class="n">featureA</span><span class="o">.</span><span class="n">geometry</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Seq</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">aggregateSft</span><span class="o">.</span><span class="n">getTypes</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">2</span><span class="o">)(</span><span class="s">&quot;0&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">aggregateFeature</span> <span class="k">=</span> <span class="nc">ScalaSimpleFeatureFactory</span><span class="o">.</span><span class="n">buildFeature</span><span class="o">(</span><span class="n">aggregateSft</span><span class="o">,</span> <span class="n">featureFields</span><span class="o">,</span> <span class="n">featureA</span><span class="o">.</span><span class="n">getID</span><span class="o">)</span>

<span class="c1">// Loop over the countable properties and sum them for both gdelt simple features</span>
<span class="n">countable</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">clazz</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">propA</span> <span class="k">=</span> <span class="n">featurePropertiesA</span><span class="o">(</span><span class="n">index</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">propB</span> <span class="k">=</span> <span class="n">featurePropertiesB</span><span class="o">(</span><span class="n">index</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">valA</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">propA</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">propA</span><span class="o">.</span><span class="n">getValue</span>
    <span class="k">val</span> <span class="n">valB</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">propB</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">propB</span><span class="o">.</span><span class="n">getValue</span>

    <span class="k">val</span> <span class="n">sum</span>  <span class="k">=</span> <span class="o">(</span><span class="n">valA</span><span class="o">,</span> <span class="n">valB</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Integer</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Integer</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">java.lang.Long</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">java.lang.Long</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">java.lang.Double</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">java.lang.Double</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;Couldn&#39;t match countable type.&quot;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="c1">// Set the total</span>
    <span class="k">if</span><span class="o">(</span> <span class="n">propA</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">aggregateFeature</span><span class="o">.</span><span class="n">setAttribute</span><span class="o">(</span><span class="s">&quot;total_&quot;</span><span class="o">+</span> <span class="n">propA</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span>

<span class="o">}</span>
<span class="n">aggregateFeature</span><span class="o">.</span><span class="n">setAttribute</span><span class="o">(</span><span class="s">&quot;count&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
<span class="n">aggregateFeature</span>
</pre></div>
</div>
<p>Spark also provides a <code class="docutils literal"><span class="pre">combineByKey</span></code> operation that also divides nicely into these three cases, but is slightly more
logically complex.</p>
<p>With the totals and counts calculated, we can now compute the averages for each field. Also, while iterating, we can add
the country name and geometry to each feature. To do that, we first broadcast a map of name to geometry.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">countryMap</span><span class="k">:</span> <span class="kt">scala.collection.Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Geometry</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">countriesRdd</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">sf</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">sf</span><span class="o">.</span><span class="n">getAttribute</span><span class="o">(</span><span class="s">&quot;NAME&quot;</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">sf</span><span class="o">.</span><span class="n">getAttribute</span><span class="o">(</span><span class="s">&quot;the_geom&quot;</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Geometry</span><span class="o">])</span>
    <span class="o">}.</span><span class="n">collectAsMap</span>

<span class="k">val</span> <span class="n">broadcastedCountryMap</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="o">(</span><span class="n">countryMap</span><span class="o">)</span>
</pre></div>
</div>
<p>Then we can transform the aggregate RDD into one with averages and geometries added.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">averaged</span> <span class="k">=</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">mapPartitions</span> <span class="o">{</span> <span class="n">iter</span> <span class="k">=&gt;</span>
    <span class="k">import</span> <span class="nn">org.locationtech.geomesa.utils.geotools.Conversions.RichSimpleFeature</span>

    <span class="n">iter</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">countryName</span><span class="o">,</span> <span class="n">sf</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sf</span><span class="o">.</span><span class="n">getType</span><span class="o">.</span><span class="n">getTypeName</span> <span class="o">==</span> <span class="s">&quot;aggregate&quot;</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sf</span><span class="o">.</span><span class="n">getProperties</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">prop</span> <span class="k">=&gt;</span>
                <span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">toString</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;total_&quot;</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">val</span> <span class="n">count</span> <span class="k">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">get</span><span class="o">[</span><span class="kt">Integer</span><span class="o">](</span><span class="s">&quot;count&quot;</span><span class="o">)</span>
                    <span class="k">val</span> <span class="n">avg</span> <span class="k">=</span> <span class="o">(</span><span class="n">prop</span><span class="o">.</span><span class="n">getValue</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
                            <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Integer</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">count</span>
                            <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">java.lang.Long</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">count</span>
                            <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">java.lang.Double</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">count</span>
                            <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">s&quot;couldn&#39;t match </span><span class="si">$name</span><span class="s">&quot;</span><span class="o">)</span>
                    <span class="o">}</span>

                    <span class="n">sf</span><span class="o">.</span><span class="n">setAttribute</span><span class="o">(</span><span class="s">&quot;avg_&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">6</span><span class="o">),</span> <span class="n">avg</span><span class="o">)</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">sf</span><span class="o">.</span><span class="n">setAttribute</span><span class="o">(</span><span class="s">&quot;country&quot;</span><span class="o">,</span> <span class="n">countryName</span><span class="o">)</span>
            <span class="n">sf</span><span class="o">.</span><span class="n">setDefaultGeometry</span><span class="o">(</span><span class="n">broadcastedCountryMap</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">countryName</span><span class="o">,</span><span class="kc">null</span><span class="o">))</span>
            <span class="nc">Some</span><span class="o">(</span><span class="n">sf</span><span class="o">)</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">None</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>At this point, we have created a new Simple Feature Type representing aggregated data and an RDD of Simple Features of
this type. The above code can all be compiled and submitted as a Spark job, but if placed into a Jupyter Notebook, the
RDD can be kept in memory and even quickly tweaked while continuously updating visualizations.</p>
<p>With a Jupyter notebook server running with the Apache Toree kernel (see <a class="reference internal" href="../user/spark/jupyter.html"><span class="doc">Deploying GeoMesa Spark with Jupyter Notebook</span></a>), create a notebook
with the above code. The next section highlights how to create visualizations with the aggregated data.</p>
<p>While there are many ways to visualize data from an RDD, here we choose to demonstrate the use of Leaflet, a JavaScript
library for creating interactive maps, for easy integration of the map image with Jupyter Notebook. To use, either
install it through Jupyter&#8217;s <code class="docutils literal"><span class="pre">nbextensions</span></code> tool, or place the following HTML in your notebook to import it properly.
Note that we preface it with <code class="docutils literal"><span class="pre">%%HTML</span></code>, a Jupyter cell magic, indicating that the cell should be interpreted as HTML.</p>
<div class="highlight-HTML"><div class="highlight"><pre><span></span>%%HTML
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css&quot;</span> <span class="p">/&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The problem of getting data from an RDD in the Scala Kernel to client-side JavaScript can also be solved in many ways.
One option is to save the RDD to a GeoMesa schema and use the GeoServer Manager API to publish a WMS layer. Leaflet
is capable of then reading a WMS layer into its map via HTTP. A more direct route, however, is to export the RDD as GeoJSON.
To do this, use Toree&#8217;s <code class="docutils literal"><span class="pre">AddDeps</span></code> magic to add the GeoTool GeoJSON dependency on the fly.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>%AddDeps org.geotools gt-geojson <span class="m">14</span>.1 --transitive --repository http://download.osgeo.org/webdav/geotools
</pre></div>
</div>
<p>We can then transform the RDD of Simple Features to an RDD of strings, collect those strings from each partition,
join them, and write them to a file.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.geotools.geojson.feature.FeatureJSON</span>
<span class="k">import</span> <span class="nn">java.io.StringWriter</span>
<span class="k">val</span> <span class="n">geoJsonWriters</span> <span class="k">=</span> <span class="n">averaged</span><span class="o">.</span><span class="n">mapPartitions</span><span class="o">{</span> <span class="n">iter</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">featureJson</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FeatureJSON</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">strRep</span> <span class="k">=</span> <span class="n">iter</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="n">sf</span> <span class="k">=&gt;</span>
        <span class="n">featureJson</span><span class="o">.</span><span class="n">toString</span><span class="o">(</span><span class="n">sf</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="c1">// Join all the features on this partition</span>
    <span class="nc">Iterator</span><span class="o">(</span><span class="n">strRep</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">// Collect these strings and joing them into a JSON array</span>
<span class="k">val</span> <span class="n">geoJsonString</span> <span class="k">=</span> <span class="n">geoJsonWriters</span><span class="o">.</span><span class="n">collect</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;[&quot;</span><span class="o">,</span><span class="s">&quot;,&quot;</span><span class="o">,</span><span class="s">&quot;]&quot;</span><span class="o">)</span>

<span class="c1">// Write to file</span>
</pre></div>
</div>
<p>In order to modify the DOM of the HTML document from within a Jupyter cell, we must set up a Mutation Observer to correctly
respond to asynchronous changes. We attach the observer to <code class="docutils literal"><span class="pre">element</span></code>, which refers to the cell from which the JavaScript
code is run. Within this observer, we instantiate a new Leaflet map, and add a base layer from OSM.</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">// Initialize the map</span>
    <span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="s1">&#39;map&#39;</span><span class="p">).</span><span class="nx">setView</span><span class="p">([</span><span class="mf">35.4746</span><span class="p">,</span><span class="o">-</span><span class="mf">44.7022</span><span class="p">],</span><span class="mi">3</span><span class="p">);</span>
    <span class="c1">// Add the base layer</span>
    <span class="nx">L</span><span class="p">.</span><span class="nx">tileLayer</span><span class="p">(</span><span class="s2">&quot;http://{s}.tile.osm.org/{z}/{x}/{y}.png&quot;</span><span class="p">).</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">()</span>
<span class="p">})).</span><span class="nx">observe</span><span class="p">(</span><span class="nx">element</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">{</span><span class="nx">childList</span><span class="o">:</span> <span class="kc">true</span><span class="p">})</span>
</pre></div>
</div>
<p>Inside the Leaflet we create a tile layer from the GeoJSON file we created. There are further options of
creating a layer from an image file or from a GeoServer WMS layer.</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">rawFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
<span class="nx">rawFile</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">rawFile</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">===</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">rawFile</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">200</span> <span class="o">||</span> <span class="nx">rawFile</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">allText</span> <span class="o">=</span> <span class="nx">rawFile</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span>
            <span class="kd">var</span> <span class="nx">gdeltJson</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">allText</span><span class="p">)</span>
            <span class="nx">L</span><span class="p">.</span><span class="nx">geoJson</span><span class="p">(</span><span class="nx">gdeltJson</span><span class="p">).</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span>
            <span class="c1">// Css override</span>
            <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;svg&#39;</span><span class="p">).</span><span class="nx">css</span><span class="p">(</span><span class="s2">&quot;max-width&quot;</span><span class="p">,</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">rawFile</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="s2">&quot;aggregateGdelt.json&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">rawFile</span><span class="p">.</span><span class="nx">send</span><span class="p">()</span>
</pre></div>
</div>
<p>There are many opportunities here to style these layers such as coloring polygons by attributes. Here we color each
country&#8217;s polygon by its average Goldstein scale, indicating how events are contributing to the stability of a country
during that time range.</p>
<div class="figure">
<img alt="../_images/aggregate-GDELT.png" src="../_images/aggregate-GDELT.png" />
</div>
<p>The final result of the analysis described in this tutorial is found in the Jupyter notebook: <a class="reference download internal" href="../_downloads/shallow-join-gdelt.ipynb" download=""><code class="xref download docutils literal"><span class="pre">_static/geomesa-examples-jupyter/shallow-join-gdelt.ipynb</span></code></a>.
You can find a static render of this notebook on <a class="reference external" href="https://github.com/locationtech/geomesa/blob/master/docs/tutorials/_static/geomesa-examples-jupyter/shallow-join-gdelt.ipynb">Github</a>.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="geomesa-tubeselect.html" class="btn btn-neutral float-right" title="Web Processing Services (WPS) Tube Select" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="spark.html" class="btn btn-neutral" title="GeoMesa Spark: Basic Analysis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>

<div role="contentinfo">
  <p>
    &copy; Copyright 2013-2017 <a href="https://www.ccri.com/">Commonwealth Computer Research, Inc.</a>
    <br/>
    Licensed under the <a href="http://www.opensource.org/licenses/apache2.0.php">Apache License, Version 2.0</a>
  </p>
</div>

Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>



</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.3.2-SNAPSHOT',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="../_static/sphinx_tabs/tabs.js"></script>
      <script type="text/javascript" src="../_static/sphinx_tabs/semantic-ui-2.2.7/tab.min.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>