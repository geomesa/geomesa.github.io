<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaOutputFormat.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Jobs</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.jobs.mapreduce</a> &gt; <span class="el_source">GeoMesaOutputFormat.scala</span></div><h1>GeoMesaOutputFormat.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.jobs.mapreduce

import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.io.Text
import org.apache.hadoop.mapreduce._
import org.apache.hadoop.mapreduce.lib.output.NullOutputFormat
import org.geotools.api.data._
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.data._
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.utils.FeatureWriterHelper
import org.locationtech.geomesa.jobs.GeoMesaConfigurator
import org.locationtech.geomesa.jobs.mapreduce.GeoMesaOutputFormat.GeoMesaRecordWriter
import org.locationtech.geomesa.utils.index.IndexMode
import org.locationtech.geomesa.utils.io.CloseQuietly

import java.io.IOException
import scala.collection.mutable.ArrayBuffer

/**
  * Output format that writes simple features using GeoMesaDataStore's FeatureWriterAppend. Can write only
  * specific indices if desired
  */
<span class="nc" id="L33">class GeoMesaOutputFormat extends OutputFormat[Text, SimpleFeature] {</span>

  import scala.collection.JavaConverters._

  override def getRecordWriter(context: TaskAttemptContext): RecordWriter[Text, SimpleFeature] = {
<span class="nc" id="L38">    val params = GeoMesaConfigurator.getDataStoreOutParams(context.getConfiguration)</span>
<span class="nc" id="L39">    val indices = GeoMesaConfigurator.getIndicesOut(context.getConfiguration)</span>
<span class="nc" id="L40">    new GeoMesaRecordWriter(params, indices, context)</span>
  }

  override def checkOutputSpecs(context: JobContext): Unit = {
    val params =
<span class="nc" id="L45">      GeoMesaConfigurator.getDataStoreOutParams(context.getConfiguration)</span>
        .asJava.asInstanceOf[java.util.Map[String, java.io.Serializable]]
<span class="nc bnc" id="L47" title="All 2 branches missed.">    if (!DataStoreFinder.getAvailableDataStores.asScala.exists(_.canProcess(params))) {</span>
<span class="nc" id="L48">      throw new IOException(&quot;Data store connection parameters are not set&quot;)</span>
    }
  }

  override def getOutputCommitter(context: TaskAttemptContext): OutputCommitter =
<span class="nc" id="L53">    new NullOutputFormat[Text, SimpleFeature]().getOutputCommitter(context)</span>
}

<span class="nc" id="L56">object GeoMesaOutputFormat {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L60">  object OutputCounters {</span>
<span class="nc" id="L61">    val Group   = &quot;org.locationtech.geomesa.jobs.output&quot;</span>
<span class="nc" id="L62">    val Written = &quot;written&quot;</span>
<span class="nc" id="L63">    val Failed  = &quot;failed&quot;</span>
  }

  /**
    * Configure the data store you will be writing to
    *
    * @param conf conf
    * @param params data store parameters
    * @param sft simple feature type to write, must exist already in the store
    * @param indices indices to write, or all indices
    */
<span class="nc" id="L74">  def setOutput(</span>
      conf: Configuration,
      params: Map[String, String],
      sft: SimpleFeatureType,
<span class="nc" id="L78">      indices: Option[Seq[String]] = None): Unit = {</span>
<span class="nc" id="L79">    GeoMesaConfigurator.setDataStoreOutParams(conf, params)</span>
<span class="nc" id="L80">    GeoMesaConfigurator.setSerialization(conf, sft)</span>
<span class="nc" id="L81">    indices.foreach(GeoMesaConfigurator.setIndicesOut(conf, _))</span>
  }

  /**
   * Helper for java interop
   *
   * @param conf conf
   * @param params data store parameters
   * @param sft simple feature type to write, must exist already in the store
   */
  def setOutputJava(
      conf: Configuration,
      params: java.util.Map[String, String],
      sft: SimpleFeatureType): Unit = {
<span class="nc" id="L95">    setOutput(conf, params.asScala.toMap, sft)</span>
  }

  /**
    * Record writer for GeoMesa datastores.
    *
    * All feature types must exist already in the datastore. The input key is ignored.
    */
<span class="nc bnc" id="L103" title="All 4 branches missed.">  class GeoMesaRecordWriter(params: Map[String, String], indices: Option[Seq[String]], context: TaskAttemptContext)</span>
<span class="nc" id="L104">      extends RecordWriter[Text, SimpleFeature] with LazyLogging {</span>

<span class="nc" id="L106">    private val ds = DataStoreFinder.getDataStore(params.asJava)</span>

<span class="nc" id="L108">    private val writers = ArrayBuffer.empty[FeatureWriter[SimpleFeatureType, SimpleFeature]]</span>
<span class="nc" id="L109">    private val helpers = scala.collection.mutable.Map.empty[String, FeatureWriterHelper]</span>

<span class="nc" id="L111">    private val written = context.getCounter(OutputCounters.Group, OutputCounters.Written)</span>
<span class="nc" id="L112">    private val failed = context.getCounter(OutputCounters.Group, OutputCounters.Failed)</span>

    override def write(key: Text, value: SimpleFeature): Unit = {
      try {
<span class="nc" id="L116">        val sftName = value.getFeatureType.getTypeName</span>
<span class="nc" id="L117">        val helper = helpers.getOrElseUpdate(sftName, createWriter(sftName))</span>
<span class="nc" id="L118">        helper.write(value)</span>
<span class="nc" id="L119">        written.increment(1)</span>
      } catch {
        case e: Exception =&gt;
<span class="nc bnc" id="L122" title="All 2 branches missed.">          logger.error(s&quot;Error writing feature '${DataUtilities.encodeFeature(value)}'&quot;, e)</span>
<span class="nc" id="L123">          failed.increment(1)</span>
      }
    }

    private def createWriter(typeName: String): FeatureWriterHelper = {
<span class="nc" id="L128">      val writer = ds match {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        case gm: GeoMesaDataStore[_] =&gt;</span>
<span class="nc" id="L130">          val sft = gm.getSchema(typeName)</span>
<span class="nc" id="L131">          val i = indices match {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            case Some(names) =&gt; names.map(gm.manager.index(sft, _, IndexMode.Write))</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            case None =&gt; gm.manager.indices(sft, mode = IndexMode.Write)</span>
          }
<span class="nc" id="L135">          gm.getIndexWriterAppend(typeName, i)</span>

        case _ =&gt;
<span class="nc" id="L138">          indices.foreach { i =&gt;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            logger.warn(s&quot;Ignoring index config '${i.mkString(&quot;,&quot;)}' for non-geomesa data store $ds&quot;)</span>
          }
<span class="nc" id="L141">          ds.getFeatureWriterAppend(typeName, Transaction.AUTO_COMMIT)</span>
      }
<span class="nc" id="L143">      writers += writer</span>
<span class="nc" id="L144">      FeatureWriterHelper(writer)</span>
    }

    override def close(context: TaskAttemptContext): Unit = {
<span class="nc" id="L148">      CloseQuietly(writers)</span>
<span class="nc" id="L149">      ds.dispose()</span>
    }
  }
<span class="nc" id="L152">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>