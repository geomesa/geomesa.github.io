<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaConfigurator.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Jobs</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.jobs</a> &gt; <span class="el_source">GeoMesaConfigurator.scala</span></div><h1>GeoMesaConfigurator.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * Portions Crown Copyright (c) 2016-2025 Dstl
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.jobs

import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.io.serializer.WritableSerialization
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.index.api.QueryPlan.{FeatureReducer, ResultsToFeatures}
import org.locationtech.geomesa.index.conf.QueryHints
import org.locationtech.geomesa.index.utils.Reprojection.QueryReferenceSystems
import org.locationtech.geomesa.jobs.mapreduce.SimpleFeatureSerialization
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.text.StringSerialization

/**
 * Common place for setting and getting values out of the mapreduce config
 */
<span class="nc" id="L25">object GeoMesaConfigurator {</span>

<span class="nc" id="L27">  object Keys {</span>
<span class="nc" id="L28">    val Prefix: String = &quot;org.locationtech.geomesa&quot;</span>

<span class="nc" id="L30">    val DsOutParams    : String = s&quot;$Prefix.out.params&quot;</span>
<span class="nc" id="L31">    val IndicesOut     : String = s&quot;$Prefix.out.indices&quot;</span>

<span class="nc" id="L33">    val SftNames       : String = s&quot;$Prefix.sfts&quot;</span>
<span class="nc" id="L34">    val Filter         : String = s&quot;$Prefix.filter&quot;</span>
<span class="nc" id="L35">    val ToFeatures     : String = s&quot;$Prefix.to.features&quot;</span>
<span class="nc" id="L36">    val FeatureReducer : String = s&quot;$Prefix.reducer&quot;</span>
<span class="nc" id="L37">    val Sorting        : String = s&quot;$Prefix.sort&quot;</span>
<span class="nc" id="L38">    val Projection     : String = s&quot;$Prefix.reproject&quot;</span>

<span class="nc" id="L40">    val DesiredSplits  : String = s&quot;$Prefix.mapreduce.split.count.strongHint&quot;</span>
<span class="nc" id="L41">    val Serializers    : String = &quot;io.serializations&quot;</span>
  }

<span class="nc" id="L44">  private val WritableSerialization      = classOf[WritableSerialization].getName</span>
<span class="nc" id="L45">  private val SimpleFeatureSerialization = classOf[SimpleFeatureSerialization].getName</span>
<span class="nc" id="L46">  private val SerializationString        = s&quot;$WritableSerialization,$SimpleFeatureSerialization&quot;</span>

  // set/get the connection parameters for an output format
  def setDataStoreOutParams(conf: Configuration, params: Map[String, String]): Unit =
<span class="nc" id="L50">    conf.set(Keys.DsOutParams, StringSerialization.encodeMap(params))</span>
  def getDataStoreOutParams(conf: Configuration): Map[String, String] =
<span class="nc" id="L52">    StringSerialization.decodeMap(conf.get(Keys.DsOutParams))</span>

  def setIndicesOut(conf: Configuration, indices: Seq[String]): Unit =
<span class="nc" id="L55">    conf.set(Keys.IndicesOut, StringSerialization.encodeSeq(indices))</span>
  def getIndicesOut(conf: Configuration): Option[Seq[String]] =
<span class="nc" id="L57">    Option(conf.get(Keys.IndicesOut)).map(StringSerialization.decodeSeq)</span>

  // set/get the cql filter
<span class="nc" id="L60">  def setFilter(conf: Configuration, filter: String): Unit = conf.set(Keys.Filter, filter)</span>
<span class="nc" id="L61">  def getFilter(conf: Configuration): Option[String] = Option(conf.get(Keys.Filter))</span>

  def setResultsToFeatures(conf: Configuration, resultsToFeatures: ResultsToFeatures[_]): Unit = {
<span class="nc" id="L64">    conf.set(Keys.ToFeatures, ResultsToFeatures.serialize(resultsToFeatures))</span>
<span class="nc" id="L65">    setSerialization(conf, resultsToFeatures.schema)</span>
  }
  def getResultsToFeatures[T](conf: Configuration): ResultsToFeatures[T] =
<span class="nc" id="L68">    ResultsToFeatures.deserialize(conf.get(Keys.ToFeatures))</span>

  def setReducer(conf: Configuration, reducer: FeatureReducer): Unit =
<span class="nc" id="L71">    conf.set(Keys.FeatureReducer, FeatureReducer.serialize(reducer))</span>
  def getReducer(conf: Configuration): Option[FeatureReducer] =
<span class="nc" id="L73">    Option(conf.get(Keys.FeatureReducer)).map(FeatureReducer.deserialize)</span>

  def setSorting(conf: Configuration, sort: Seq[(String, Boolean)]): Unit =
<span class="nc bnc" id="L76" title="All 2 branches missed.">    conf.set(Keys.Sorting, StringSerialization.encodeSeq(sort.flatMap { case (f, r) =&gt; Seq(f, r.toString) }))</span>
  def getSorting(conf: Configuration): Option[Seq[(String, Boolean)]] = {
<span class="nc" id="L78">    Option(conf.get(Keys.Sorting)).map { s =&gt;</span>
<span class="nc bnc" id="L79" title="All 6 branches missed.">      StringSerialization.decodeSeq(s).grouped(2).map { case Seq(f, r) =&gt; (f, r.toBoolean) }.toList</span>
    }
  }

  def setProjection(conf: Configuration, crs: QueryReferenceSystems): Unit =
<span class="nc" id="L84">    conf.set(Keys.Projection, QueryHints.Internal.toProjectionHint(crs))</span>
  def getProjection(conf: Configuration): Option[QueryReferenceSystems] =
<span class="nc" id="L86">    Option(conf.get(Keys.Projection)).map(QueryHints.Internal.fromProjectionHint)</span>

  /**
    * Configure serialization for a simple feature type
    *
    * @param conf conf
    * @param sft simple feature type
    */
  def setSerialization(conf: Configuration, sft: SimpleFeatureType): Unit = {
    // register the feature serializer
<span class="nc" id="L96">    conf.get(Keys.Serializers) match {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      case null =&gt; conf.set(Keys.Serializers, SerializationString)</span>
      case existing =&gt;
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (!existing.contains(SimpleFeatureSerialization)) {</span>
<span class="nc" id="L100">          conf.set(Keys.Serializers, Seq(existing, SimpleFeatureSerialization).mkString(&quot;,&quot;))</span>
        }
    }

    // set the schema in the config
<span class="nc" id="L105">    val spec = SimpleFeatureTypes.encodeType(sft, includeUserData = true)</span>
    // note: use the spec hash code to ensure that duplicate type names don't conflict
<span class="nc" id="L107">    val key = s&quot;${(sft.getTypeName + spec).hashCode}:${sft.getTypeName}&quot;</span>
    // store the type name and hash under a common key for all types
<span class="nc" id="L109">    conf.get(Keys.SftNames) match {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">      case null =&gt; conf.set(Keys.SftNames, key)</span>
      case encoded =&gt;
<span class="nc" id="L112">        val existing = StringSerialization.decodeSeq(encoded)</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (!existing.contains(key)) {</span>
<span class="nc" id="L114">          conf.set(Keys.SftNames, StringSerialization.encodeSeq(existing :+ key))</span>
        }
    }
    // store the spec under the unique key
<span class="nc" id="L118">    conf.set(s&quot;${Keys.SftNames}.$key&quot;, spec)</span>
  }

  /**
    * Get the simple feature types configured for serialization, keyed by hash code
    *
    * @param conf conf
    * @return (unique string key for the type, unique hash code for the type, type)
    */
  def getSerialization(conf: Configuration): Seq[(String, Int, SimpleFeatureType)] = {
<span class="nc" id="L128">    Option(conf.get(Keys.SftNames)).map(StringSerialization.decodeSeq).getOrElse(Seq.empty).map { key =&gt;</span>
<span class="nc" id="L129">      val sep = key.indexOf(':')</span>
<span class="nc" id="L130">      val hash = key.substring(0, sep).toInt</span>
<span class="nc" id="L131">      val typeName = key.substring(sep + 1)</span>
<span class="nc" id="L132">      val spec = conf.get(s&quot;${Keys.SftNames}.$key&quot;)</span>
<span class="nc" id="L133">      (key, hash, SimpleFeatureTypes.createType(typeName, spec))</span>
    }
  }
<span class="nc" id="L136">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>