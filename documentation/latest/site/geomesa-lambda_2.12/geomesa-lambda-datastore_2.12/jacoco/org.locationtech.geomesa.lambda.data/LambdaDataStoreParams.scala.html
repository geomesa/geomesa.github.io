<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LambdaDataStoreParams.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Lambda DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.lambda.data</a> &gt; <span class="el_source">LambdaDataStoreParams.scala</span></div><h1>LambdaDataStoreParams.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.lambda.data

import org.locationtech.geomesa.index.geotools.GeoMesaDataStoreFactory.GeoMesaDataStoreParams
import org.locationtech.geomesa.lambda.data.LambdaDataStore.{LambdaConfig, PersistenceConfig}
import org.locationtech.geomesa.lambda.data.LambdaDataStoreFactory.Params
import org.locationtech.geomesa.lambda.stream.OffsetManager
import org.locationtech.geomesa.utils.geotools.GeoMesaParam

import java.time.Clock
import java.util.Properties
import java.util.concurrent.TimeUnit
import scala.concurrent.duration.{Duration, FiniteDuration}

<span class="nc" id="L22">object LambdaDataStoreParams extends GeoMesaDataStoreParams {</span>

  // note: this class is kept separate to avoid any runtime dependencies on Accumulo

  import scala.collection.JavaConverters._

<span class="nc" id="L28">  val BrokersParam =</span>
<span class="nc" id="L29">    new GeoMesaParam[String](</span>
<span class="nc" id="L30">      &quot;lambda.kafka.brokers&quot;,</span>
<span class="nc" id="L31">      &quot;Kafka brokers&quot;,</span>
<span class="nc" id="L32">      optional = false,</span>
<span class="nc" id="L33">      deprecatedKeys = Seq(&quot;kafka.brokers&quot;),</span>
<span class="nc" id="L34">      supportsNiFiExpressions = true)</span>

<span class="nc" id="L36">  val ZookeepersParam =</span>
<span class="nc" id="L37">    new GeoMesaParam[String](</span>
<span class="nc" id="L38">      &quot;lambda.kafka.zookeepers&quot;,</span>
<span class="nc" id="L39">      &quot;Kafka zookeepers&quot;,</span>
<span class="nc" id="L40">      deprecatedKeys = Seq(&quot;kafka.zookeepers&quot;),</span>
<span class="nc" id="L41">      supportsNiFiExpressions = true)</span>

<span class="nc" id="L43">  val PartitionsParam =</span>
<span class="nc" id="L44">    new GeoMesaParam[Integer](</span>
<span class="nc" id="L45">      &quot;lambda.kafka.partitions&quot;,</span>
<span class="nc" id="L46">      &quot;Number of partitions to use in kafka topics&quot;,</span>
<span class="nc" id="L47">      default = Int.box(1),</span>
<span class="nc" id="L48">      deprecatedKeys = Seq(&quot;kafka.partitions&quot;),</span>
<span class="nc" id="L49">      supportsNiFiExpressions = true)</span>

<span class="nc" id="L51">  val ConsumersParam =</span>
<span class="nc" id="L52">    new GeoMesaParam[Integer](</span>
<span class="nc" id="L53">      &quot;lambda.kafka.consumers&quot;,</span>
<span class="nc" id="L54">      &quot;Number of kafka consumers used per feature type&quot;,</span>
<span class="nc" id="L55">      default = Int.box(1),</span>
<span class="nc" id="L56">      deprecatedKeys = Seq(&quot;kafka.consumers&quot;),</span>
<span class="nc" id="L57">      supportsNiFiExpressions = true)</span>

<span class="nc" id="L59">  val ProducerOptsParam =</span>
<span class="nc" id="L60">    new GeoMesaParam[Properties](</span>
<span class="nc" id="L61">      &quot;lambda.kafka.producer.options&quot;,</span>
<span class="nc" id="L62">      &quot;Kafka producer configuration options, in Java properties format&quot;,</span>
<span class="nc" id="L63">      largeText = true,</span>
<span class="nc" id="L64">      deprecatedKeys = Seq(&quot;kafka.producer.options&quot;))</span>

<span class="nc" id="L66">  val ConsumerOptsParam =</span>
<span class="nc" id="L67">    new GeoMesaParam[Properties](</span>
<span class="nc" id="L68">      &quot;lambda.kafka.consumer.options&quot;,</span>
<span class="nc" id="L69">      &quot;Kafka consumer configuration options, in Java properties format'&quot;,</span>
<span class="nc" id="L70">      largeText = true,</span>
<span class="nc" id="L71">      deprecatedKeys = Seq(&quot;kafka.consumer.options&quot;))</span>

<span class="nc" id="L73">  val ExpiryParam =</span>
<span class="nc" id="L74">    new GeoMesaParam[Duration](</span>
<span class="nc" id="L75">      &quot;lambda.expiry&quot;,</span>
<span class="nc" id="L76">      &quot;Duration before features expire from transient store. Use 'Inf' &quot; +</span>
          &quot;to prevent this store from participating in feature expiration&quot;,
<span class="nc" id="L78">      default = Duration(&quot;1h&quot;),</span>
<span class="nc" id="L79">      deprecatedKeys = Seq(&quot;expiry&quot;),</span>
<span class="nc" id="L80">      supportsNiFiExpressions = true)</span>

<span class="nc" id="L82">  val PersistParam =</span>
<span class="nc" id="L83">    new GeoMesaParam[java.lang.Boolean](</span>
<span class="nc" id="L84">      &quot;lambda.persist&quot;,</span>
<span class="nc" id="L85">      &quot;Whether this instance will persist expired features to long-term storage&quot;,</span>
<span class="nc" id="L86">      default = java.lang.Boolean.TRUE,</span>
<span class="nc" id="L87">      deprecatedKeys = Seq(&quot;persist&quot;))</span>

<span class="nc" id="L89">  val BatchSizeParam =</span>
<span class="nc" id="L90">    new GeoMesaParam[Integer](</span>
<span class="nc" id="L91">      &quot;lambda.persist.batch.size&quot;,</span>
<span class="nc" id="L92">      &quot;Maximum number of features to persist in one run&quot;,</span>
<span class="nc" id="L93">      default = 100,</span>
    )

  // test params
<span class="nc" id="L97">  val ClockParam =</span>
<span class="nc" id="L98">    new GeoMesaParam[Clock](</span>
<span class="nc" id="L99">      &quot;lambda.clock&quot;,</span>
<span class="nc" id="L100">      &quot;Clock instance to use for timing&quot;,</span>
<span class="nc" id="L101">      deprecatedKeys = Seq(&quot;clock&quot;))</span>

<span class="nc" id="L103">  val OffsetManagerParam =</span>
<span class="nc" id="L104">    new GeoMesaParam[OffsetManager](</span>
<span class="nc" id="L105">      &quot;lambda.offset-manager&quot;,</span>
<span class="nc" id="L106">      &quot;Offset manager instance to use&quot;,</span>
<span class="nc" id="L107">      deprecatedKeys = Seq(&quot;lamdab.offset-manager&quot;, &quot;offsetManager&quot;))</span>

<span class="nc" id="L109">  val ConsumerOffsetCommitInterval =</span>
<span class="nc" id="L110">    new GeoMesaParam[FiniteDuration](</span>
<span class="nc" id="L111">      &quot;lambda.kafka.consumer.offset-commit-interval&quot;,</span>
<span class="nc" id="L112">      &quot;The frequency of committing offsets for the Kafka consumer&quot;,</span>
<span class="nc" id="L113">      default = Duration(10, TimeUnit.SECONDS)</span>
    )

<span class="nc" id="L116">  val ForceEmptyAuthsParam: GeoMesaParam[java.lang.Boolean] = org.locationtech.geomesa.security.ForceEmptyAuthsParam</span>

<span class="nc" id="L118">  def parse(params: java.util.Map[String, _], namespace: String): LambdaConfig = {</span>
<span class="nc" id="L119">    val brokers = BrokersParam.lookup(params)</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">    val persistence = if (!PersistParam.lookup(params).booleanValue) { None } else {</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">      ExpiryParam.lookupOpt(params).collect { case d: FiniteDuration =&gt;</span>
<span class="nc" id="L122">        PersistenceConfig(d, BatchSizeParam.lookup(params).intValue())</span>
      }
    }

<span class="nc" id="L126">    val partitions = PartitionsParam.lookup(params).intValue</span>
<span class="nc" id="L127">    val consumers = ConsumersParam.lookup(params).intValue</span>

<span class="nc" id="L129">    val bootstrap = Map(&quot;bootstrap.servers&quot; -&gt; brokers)</span>
<span class="nc" id="L130">    val consumerConfig = ConsumerOptsParam.lookupOpt(params).map(_.asScala.toMap).getOrElse(Map.empty) ++ bootstrap</span>
<span class="nc" id="L131">    val producerConfig = ProducerOptsParam.lookupOpt(params).map(_.asScala.toMap).getOrElse(Map.empty) ++ bootstrap</span>

<span class="nc" id="L133">    val zk = ZookeepersParam.lookupOpt(params).orElse(Params.Accumulo.ZookeepersParam.lookupOpt(params)).getOrElse {</span>
<span class="nc" id="L134">      throw new IllegalArgumentException(s&quot;Missing required key: ${ZookeepersParam.key}/${Params.Accumulo.ZookeepersParam.key}&quot;)</span>
    }
<span class="nc" id="L136">    val zkNamespace = s&quot;gm_lambda_$namespace&quot;</span>

<span class="nc" id="L138">    val offsetCommitInterval = ConsumerOffsetCommitInterval.lookup(params)</span>

<span class="nc" id="L140">    LambdaConfig(zk, zkNamespace, producerConfig, consumerConfig, partitions, consumers, persistence, offsetCommitInterval)</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>