<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LambdaDataStoreFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Lambda DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.lambda.data</a> &gt; <span class="el_source">LambdaDataStoreFactory.scala</span></div><h1>LambdaDataStoreFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.lambda.data

import org.geotools.api.data.DataAccessFactory.Param
import org.geotools.api.data.{DataStore, DataStoreFactorySpi}
import org.locationtech.geomesa.accumulo.data.{AccumuloDataStoreFactory, AccumuloDataStoreParams}
import org.locationtech.geomesa.index.geotools.GeoMesaDataStoreFactory.{GeoMesaDataStoreInfo, GeoMesaDataStoreParams}
import org.locationtech.geomesa.lambda.data.LambdaDataStoreParams.OffsetManagerParam
import org.locationtech.geomesa.lambda.stream.ZookeeperOffsetManager
import org.locationtech.geomesa.utils.geotools.GeoMesaParam

import java.awt.RenderingHints.Key
import java.time.Clock
import scala.reflect.ClassTag

<span class="nc" id="L23">class LambdaDataStoreFactory extends DataStoreFactorySpi {</span>

  import LambdaDataStoreParams.{ClockParam, NamespaceParam}

  override def createDataStore(params: java.util.Map[String, _]): DataStore = {
    // TODO GEOMESA-1891 attribute level vis
<span class="nc" id="L29">    val persistence = new AccumuloDataStoreFactory().createDataStore(LambdaDataStoreFactory.filter(params))</span>
<span class="nc" id="L30">    val config = LambdaDataStoreParams.parse(params, persistence.config.catalog)</span>
    val offsetManager =
<span class="nc" id="L32">      OffsetManagerParam.lookupOpt(params).getOrElse(new ZookeeperOffsetManager(config.zookeepers, config.zkNamespace))</span>
<span class="nc" id="L33">    val clock = ClockParam.lookupOpt(params).getOrElse(Clock.systemUTC())</span>
<span class="nc" id="L34">    new LambdaDataStore(persistence, offsetManager, config)(clock)</span>
  }

<span class="nc" id="L37">  override def createNewDataStore(params: java.util.Map[String, _]): DataStore = createDataStore(params)</span>

<span class="nc" id="L39">  override def isAvailable: Boolean = true</span>

<span class="nc" id="L41">  override def getDisplayName: String = LambdaDataStoreFactory.DisplayName</span>

<span class="nc" id="L43">  override def getDescription: String = LambdaDataStoreFactory.Description</span>

<span class="nc" id="L45">  override def getParametersInfo: Array[Param] = Array(LambdaDataStoreFactory.ParameterInfo :+ NamespaceParam: _*)</span>

  override def canProcess(params: java.util.Map[String, _]): Boolean =
<span class="nc" id="L48">    LambdaDataStoreFactory.canProcess(params)</span>

<span class="nc" id="L50">  override def getImplementationHints: java.util.Map[Key, _] = java.util.Collections.emptyMap()</span>
}

<span class="nc" id="L53">object LambdaDataStoreFactory extends GeoMesaDataStoreInfo {</span>

  import LambdaDataStoreParams._

<span class="nc" id="L57">  override val DisplayName = &quot;Kafka/Accumulo Lambda (GeoMesa)&quot;</span>

<span class="nc" id="L59">  override val Description = &quot;Hybrid store using Kafka for recent events and Accumulo for long-term storage&quot;</span>

<span class="nc" id="L61">  override val ParameterInfo: Array[GeoMesaParam[_ &lt;: AnyRef]] =</span>
<span class="nc" id="L62">    Array(</span>
<span class="nc" id="L63">      Params.Accumulo.InstanceParam,</span>
<span class="nc" id="L64">      Params.Accumulo.ZookeepersParam,</span>
<span class="nc" id="L65">      Params.Accumulo.CatalogParam,</span>
<span class="nc" id="L66">      Params.Accumulo.UserParam,</span>
<span class="nc" id="L67">      Params.Accumulo.PasswordParam,</span>
<span class="nc" id="L68">      Params.Accumulo.KeytabParam,</span>
<span class="nc" id="L69">      BrokersParam,</span>
<span class="nc" id="L70">      ZookeepersParam,</span>
<span class="nc" id="L71">      ExpiryParam,</span>
<span class="nc" id="L72">      PersistParam,</span>
<span class="nc" id="L73">      BatchSizeParam,</span>
<span class="nc" id="L74">      AuthsParam,</span>
<span class="nc" id="L75">      ForceEmptyAuthsParam,</span>
<span class="nc" id="L76">      QueryTimeoutParam,</span>
<span class="nc" id="L77">      QueryThreadsParam,</span>
<span class="nc" id="L78">      Params.Accumulo.RecordThreadsParam,</span>
<span class="nc" id="L79">      Params.Accumulo.WriteThreadsParam,</span>
<span class="nc" id="L80">      PartitionsParam,</span>
<span class="nc" id="L81">      ConsumersParam,</span>
<span class="nc" id="L82">      ProducerOptsParam,</span>
<span class="nc" id="L83">      ConsumerOptsParam,</span>
<span class="nc" id="L84">      LooseBBoxParam,</span>
<span class="nc" id="L85">      GenerateStatsParam,</span>
<span class="nc" id="L86">      AuditQueriesParam</span>
    )

  override def canProcess(params: java.util.Map[String, _]): Boolean =
<span class="nc bnc" id="L90" title="All 2 branches missed.">    AccumuloDataStoreFactory.canProcess(LambdaDataStoreFactory.filter(params)) &amp;&amp;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">      Seq(ExpiryParam, BrokersParam).forall(_.exists(params)) &amp;&amp;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">      Seq(Params.Accumulo.ZookeepersParam, ZookeepersParam).exists(_.exists(params))</span>

  // noinspection TypeAnnotation
<span class="nc" id="L95">  object Params extends GeoMesaDataStoreParams {</span>

<span class="nc" id="L97">    object Accumulo {</span>
<span class="nc" id="L98">      val InstanceParam      = copy(AccumuloDataStoreParams.InstanceNameParam)</span>
<span class="nc" id="L99">      val ZookeepersParam    = copy(AccumuloDataStoreParams.ZookeepersParam)</span>
<span class="nc" id="L100">      val UserParam          = copy(AccumuloDataStoreParams.UserParam)</span>
<span class="nc" id="L101">      val PasswordParam      = copy(AccumuloDataStoreParams.PasswordParam)</span>
<span class="nc" id="L102">      val KeytabParam        = copy(AccumuloDataStoreParams.KeytabPathParam)</span>
<span class="nc" id="L103">      val RecordThreadsParam = copy(AccumuloDataStoreParams.RecordThreadsParam)</span>
<span class="nc" id="L104">      val WriteThreadsParam  = copy(AccumuloDataStoreParams.WriteThreadsParam)</span>
<span class="nc" id="L105">      val CatalogParam       = copy(AccumuloDataStoreParams.CatalogParam)</span>
    }
<span class="nc" id="L107">  }</span>

  private def copy[T &lt;: AnyRef](p: GeoMesaParam[T])(implicit ct: ClassTag[T]): GeoMesaParam[T] = {
<span class="nc bnc" id="L110" title="All 2 branches missed.">    new GeoMesaParam[T](s&quot;lambda.${p.key}&quot;, p.description.toString, optional = !p.required, default = p.default,</span>
<span class="nc" id="L111">      password = p.password, largeText = p.largeText, extension = p.extension, deprecatedKeys = p.deprecatedKeys,</span>
<span class="nc" id="L112">      deprecatedParams = p.deprecatedParams, systemProperty = p.systemProperty)</span>
  }

  private def filter(params: java.util.Map[String, _]): java.util.Map[String, _] = {
    // note: includes a bit of redirection to allow us to pass non-serializable values in to tests
    import scala.collection.JavaConverters._
<span class="nc" id="L118">    Map[String, Any](params.asScala.toSeq: _ *)</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">        .map { case (k, v) =&gt; (if (k.startsWith(&quot;lambda.&quot;)) { k.substring(7) } else { k }, v) }</span>
        .asJava
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>