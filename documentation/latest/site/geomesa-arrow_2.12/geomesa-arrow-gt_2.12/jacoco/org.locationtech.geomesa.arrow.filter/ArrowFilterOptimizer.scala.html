<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrowFilterOptimizer.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Arrow GeoTools Abstractions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.arrow.filter</a> &gt; <span class="el_source">ArrowFilterOptimizer.scala</span></div><h1>ArrowFilterOptimizer.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.arrow.filter

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter._
import org.geotools.api.filter.expression.PropertyName
import org.geotools.api.filter.spatial.BBOX
import org.geotools.api.filter.temporal.During
import org.geotools.api.temporal.Period
import org.geotools.geometry.jts.ReferencedEnvelope
import org.locationtech.geomesa.arrow.features.ArrowSimpleFeature
import org.locationtech.geomesa.arrow.jts.GeometryVector
import org.locationtech.geomesa.arrow.vector.ArrowAttributeReader._
import org.locationtech.geomesa.arrow.vector.ArrowDictionary
import org.locationtech.geomesa.filter.checkOrderUnsafe
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.utils.geotools.CRS_EPSG_4326
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.jts.geom.{Coordinate, Polygon}

import java.util.Date
import scala.util.control.NonFatal

/**
  * Optimizes filters for running against arrow files
  */
<span class="nc bnc" id="L35" title="All 4 branches missed.">object ArrowFilterOptimizer extends LazyLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

<span class="nc" id="L42">  private val ff: FilterFactory = FastFilterFactory.factory</span>

  def rewrite(filter: Filter, sft: SimpleFeatureType, dictionaries: Map[String, ArrowDictionary]): Filter = {
<span class="nc" id="L45">    val bound = FastFilterFactory.optimize(sft, filter)</span>
<span class="nc" id="L46">    FastFilterFactory.sfts.set(sft)</span>
    try {
<span class="nc" id="L48">      rewriteFilter(bound, sft, dictionaries)</span>
    } finally {
<span class="nc" id="L50">      FastFilterFactory.sfts.remove()</span>
    }
  }

  private def rewriteFilter(filter: Filter, sft: SimpleFeatureType, dictionaries: Map[String, ArrowDictionary]): Filter = {
<span class="nc" id="L55">    try {</span>
<span class="nc" id="L56">      filter match {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">        case f: BBOX              =&gt; rewriteBBox(f, sft)</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        case f: During            =&gt; rewriteDuring(f, sft)</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        case f: PropertyIsBetween =&gt; rewriteBetween(f, sft)</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        case f: PropertyIsEqualTo =&gt; rewritePropertyIsEqualTo(f, sft, dictionaries)</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">        case a: And               =&gt; ff.and(a.getChildren.asScala.map(rewriteFilter(_, sft, dictionaries)).asJava)</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        case o: Or                =&gt; ff.or(o.getChildren.asScala.map(rewriteFilter(_, sft, dictionaries)).asJava)</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        case f: Not               =&gt; ff.not(rewriteFilter(f.getFilter, sft, dictionaries))</span>
<span class="nc" id="L64">        case _                    =&gt; filter</span>
      }
    } catch {
<span class="nc bnc" id="L67" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.warn(s&quot;Error re-writing filter $filter&quot;, e); filter</span>
    }
  }

  private def rewriteBBox(filter: BBOX, sft: SimpleFeatureType): Filter = {
<span class="nc bnc" id="L72" title="All 4 branches missed.">    if (sft.isPoints || sft.isLines) {</span>
<span class="nc" id="L73">      val props = checkOrderUnsafe(filter.getExpression1, filter.getExpression2)</span>
<span class="nc" id="L74">      val bbox = FastConverter.evaluate(props.literal, classOf[Polygon]).getEnvelopeInternal</span>
<span class="nc" id="L75">      val attrIndex = sft.indexOf(props.name)</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      if (sft.isPoints) {</span>
<span class="nc" id="L77">        ArrowPointBBox(attrIndex, bbox.getMinX, bbox.getMinY, bbox.getMaxX, bbox.getMaxY)</span>
      } else {
<span class="nc" id="L79">        ArrowLineStringBBox(attrIndex, bbox.getMinX, bbox.getMinY, bbox.getMaxX, bbox.getMaxY)</span>
      }
    } else {
<span class="nc" id="L82">      filter</span>
    }
  }

  private def rewriteDuring(filter: During, sft: SimpleFeatureType): Filter = {
<span class="nc" id="L87">    val props = checkOrderUnsafe(filter.getExpression1, filter.getExpression2)</span>
<span class="nc" id="L88">    val attrIndex = sft.indexOf(props.name)</span>
<span class="nc" id="L89">    val period = FastConverter.evaluate(props.literal, classOf[Period])</span>
<span class="nc" id="L90">    val lower = period.getBeginning.getPosition.getDate.getTime</span>
<span class="nc" id="L91">    val upper = period.getEnding.getPosition.getDate.getTime</span>
<span class="nc" id="L92">    ArrowDuring(attrIndex, lower, upper)</span>
  }

  private def rewriteBetween(filter: PropertyIsBetween, sft: SimpleFeatureType): Filter = {
<span class="nc" id="L96">    val attribute = filter.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L97">    val attrIndex = sft.indexOf(attribute)</span>
<span class="nc bnc" id="L98" title="All 6 branches missed.">    if (sft.getDescriptor(attrIndex).getType.getBinding != classOf[Date]) { filter } else {</span>
<span class="nc" id="L99">      val lower = FastConverter.evaluate(filter.getLowerBoundary, classOf[Date]).getTime</span>
<span class="nc" id="L100">      val upper = FastConverter.evaluate(filter.getUpperBoundary, classOf[Date]).getTime</span>
<span class="nc" id="L101">      ArrowBetweenDate(attrIndex, lower, upper)</span>
    }
  }

  private def rewritePropertyIsEqualTo(filter: PropertyIsEqualTo,
                                       sft: SimpleFeatureType,
                                       dictionaries: Map[String, ArrowDictionary]): Filter = {
<span class="nc" id="L108">    val props = checkOrderUnsafe(filter.getExpression1, filter.getExpression2)</span>
<span class="nc" id="L109">    dictionaries.get(props.name) match {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">      case None =&gt; filter</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">      case Some(dictionary) =&gt;</span>
<span class="nc" id="L112">        val attrIndex = sft.indexOf(props.name)</span>
<span class="nc" id="L113">        val numericValue = dictionary.index(props.literal.evaluate(null))</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (sft.getDescriptor(attrIndex).isList) {</span>
<span class="nc" id="L115">          ArrowListDictionaryEquals(attrIndex, numericValue)</span>
        } else {
<span class="nc" id="L117">          ArrowDictionaryEquals(attrIndex, numericValue)</span>
        }
    }
  }

<span class="nc bnc" id="L122" title="All 26 branches missed.">  case class ArrowPointBBox(i: Int, xmin: Double, ymin: Double, xmax: Double, ymax: Double) extends Filter {</span>
<span class="nc" id="L123">    override def accept(visitor: FilterVisitor, extraData: AnyRef): AnyRef = extraData</span>
    override def evaluate(o: AnyRef): Boolean = {
<span class="nc" id="L125">      val arrow = o.asInstanceOf[ArrowSimpleFeature]</span>
<span class="nc" id="L126">      val reader = arrow.getReader(i).asInstanceOf[ArrowPointReader]</span>
<span class="nc" id="L127">      val index = arrow.getIndex</span>
<span class="nc" id="L128">      val y = reader.readPointY(index)</span>
<span class="nc bnc" id="L129" title="All 4 branches missed.">      if (y &lt; ymin || y &gt; ymax) { false } else {</span>
<span class="nc" id="L130">        val x = reader.readPointX(index)</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">        x &gt;= xmin &amp;&amp; x &lt;= xmax</span>
      }
    }
  }

<span class="nc bnc" id="L136" title="All 26 branches missed.">  case class ArrowLineStringBBox(i: Int, xmin: Double, ymin: Double, xmax: Double, ymax: Double) extends Filter {</span>
<span class="nc" id="L137">    private val bboxEnvelope = new ReferencedEnvelope(xmin, xmax, ymin, ymax, CRS_EPSG_4326)</span>
<span class="nc" id="L138">    private val bbox = GeometryVector.factory.toGeometry(bboxEnvelope)</span>

<span class="nc" id="L140">    override def accept(visitor: FilterVisitor, extraData: AnyRef): AnyRef = extraData</span>
    override def evaluate(o: AnyRef): Boolean = {
<span class="nc" id="L142">      val arrow = o.asInstanceOf[ArrowSimpleFeature]</span>
<span class="nc" id="L143">      val reader = arrow.getReader(i).asInstanceOf[ArrowLineStringReader]</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">      val (start, end) = reader.readOffsets(arrow.getIndex)</span>
<span class="nc" id="L145">      var offset = start</span>
<span class="nc" id="L146">      val points = Array.ofDim[Coordinate](2)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">      while (offset &lt; end) {</span>
<span class="nc" id="L148">        val y = reader.readPointY(offset)</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">        if (y &gt;= ymin &amp;&amp; y &lt;= ymax) {</span>
<span class="nc" id="L150">          val x = reader.readPointX(offset)</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">          if (x &gt;= xmin &amp;&amp; x &lt;= xmax) {</span>
            // we have a point in the bbox, short-circuit and return
<span class="nc" id="L153">            return true</span>
          }
          // check for intersection even if the points aren't contained in the bbox
<span class="nc" id="L156">          points(1) = points(0)</span>
<span class="nc" id="L157">          points(0) = new Coordinate(x, y)</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">          if (offset &gt; start) {</span>
<span class="nc" id="L159">            val line = GeometryVector.factory.createLineString(points)</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">            if (line.getEnvelopeInternal.intersects(bboxEnvelope) &amp;&amp; line.intersects(bbox)) {</span>
              // found an intersection, short-circuit and return
<span class="nc" id="L162">              return true</span>
            }
          }
        }
<span class="nc" id="L166">        offset += 1</span>
      }
<span class="nc" id="L168">      false</span>
    }
  }

<span class="nc bnc" id="L172" title="All 20 branches missed.">  case class ArrowDuring(i: Int, lower: Long, upper: Long) extends Filter {</span>
<span class="nc" id="L173">    override def accept(visitor: FilterVisitor, extraData: AnyRef): AnyRef = extraData</span>
    override def evaluate(o: AnyRef): Boolean = {
<span class="nc" id="L175">      val arrow = o.asInstanceOf[ArrowSimpleFeature]</span>
<span class="nc" id="L176">      val time = arrow.getReader(i).asInstanceOf[ArrowDateReader].getTime(arrow.getIndex)</span>
      // note that during is exclusive
<span class="nc bnc" id="L178" title="All 4 branches missed.">      time &gt; lower &amp;&amp; time &lt; upper</span>
    }
  }

<span class="nc bnc" id="L182" title="All 20 branches missed.">  case class ArrowBetweenDate(i: Int, lower: Long, upper: Long) extends Filter {</span>
<span class="nc" id="L183">    override def accept(visitor: FilterVisitor, extraData: AnyRef): AnyRef = extraData</span>
    override def evaluate(o: AnyRef): Boolean = {
<span class="nc" id="L185">      val arrow = o.asInstanceOf[ArrowSimpleFeature]</span>
<span class="nc" id="L186">      val time = arrow.getReader(i).asInstanceOf[ArrowDateReader].getTime(arrow.getIndex)</span>
      // note that between is inclusive
<span class="nc bnc" id="L188" title="All 4 branches missed.">      time &gt;= lower &amp;&amp; time &lt;= upper</span>
    }
  }

<span class="nc bnc" id="L192" title="All 17 branches missed.">  case class ArrowDictionaryEquals(i: Int, value: Int) extends Filter {</span>
<span class="nc" id="L193">    override def accept(visitor: FilterVisitor, extraData: AnyRef): AnyRef = extraData</span>
    override def evaluate(o: AnyRef): Boolean = {
<span class="nc" id="L195">      val arrow = o.asInstanceOf[ArrowSimpleFeature]</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">      arrow.getReader(i).asInstanceOf[ArrowDictionaryReader].getEncoded(arrow.getIndex) == value</span>
    }
  }

<span class="nc bnc" id="L200" title="All 17 branches missed.">  case class ArrowListDictionaryEquals(i: Int, value: Int) extends Filter {</span>
<span class="nc" id="L201">    override def accept(visitor: FilterVisitor, extraData: AnyRef): AnyRef = extraData</span>
    override def evaluate(o: AnyRef): Boolean = {
<span class="nc" id="L203">      val arrow = o.asInstanceOf[ArrowSimpleFeature]</span>
<span class="nc" id="L204">      arrow.getReader(i).asInstanceOf[ArrowListDictionaryReader].getEncoded(arrow.getIndex).contains(value)</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>