<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrowDictionary.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Arrow GeoTools Abstractions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.arrow.vector</a> &gt; <span class="el_source">ArrowDictionary.scala</span></div><h1>ArrowDictionary.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.arrow.vector

import org.apache.arrow.vector.FieldVector
import org.apache.arrow.vector.dictionary.Dictionary
import org.apache.arrow.vector.types.pojo.{ArrowType, DictionaryEncoding}
import org.geotools.api.feature.`type`.AttributeDescriptor
import org.locationtech.geomesa.arrow.ArrowAllocator
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.io.CloseWithLogging

import java.io.Closeable
import java.util.concurrent.atomic.AtomicInteger
import scala.reflect.ClassTag

/**
  * Holder for dictionary values
  */
<span class="nc" id="L28">sealed trait ArrowDictionary extends Closeable {</span>

  lazy private val map = {
<span class="nc" id="L31">    val builder = scala.collection.mutable.Map.newBuilder[AnyRef, Int]</span>
<span class="nc" id="L32">    builder.sizeHint(length)</span>
<span class="nc" id="L33">    var i = 0</span>
<span class="nc" id="L34">    foreach { value =&gt;</span>
<span class="nc" id="L35">      builder += ((value, i))</span>
<span class="nc" id="L36">      i += 1</span>
    }
<span class="nc" id="L38">    builder.result()</span>
  }

  def encoding: DictionaryEncoding
<span class="nc" id="L42">  def id: Long = encoding.getId</span>
  def length: Int

  /**
    * Decode a dictionary int to a value. Note: may not be thread safe
    *
    * @param i dictionary encoded int
    * @return value
    */
  def lookup(i: Int): AnyRef

  /**
    * Dictionary encode a value to an int
    *
    * @param value value to encode
    * @return dictionary encoded int
    */
<span class="nc" id="L59">  def index(value: AnyRef): Int = map.getOrElse(value, length)</span>

  /**
    * Apply a function to each value in the dictionary
    *
    * @param f function
    * @tparam U function return type
    */
<span class="nc" id="L67">  def foreach[U](f: AnyRef =&gt; U): Unit = iterator.foreach(f)</span>

  /**
    * Create an iterator over the values in this dictionary
    *
    * @return
    */
<span class="nc bnc" id="L74" title="All 2 branches missed.">  def iterator: Iterator[AnyRef] = new Iterator[AnyRef] {</span>
<span class="nc" id="L75">    private var i = 0</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">    override def hasNext: Boolean = i &lt; ArrowDictionary.this.length</span>
<span class="nc" id="L77">    override def next(): AnyRef = try { lookup(i) } finally { i += 1 }</span>
  }

  /**
   * Create an arrow dictionary vector
   *
   * @param precision precision
   * @return
   */
  def toDictionary(precision: SimpleFeatureEncoding): Dictionary with Closeable
}

<span class="nc" id="L89">object ArrowDictionary {</span>

  /**
    * Create a dictionary based off a sequence of values. Encoding will be smallest that will fit all values.
    *
    * @param id dictionary id
    * @param values dictionary values
    * @return dictionary
    */
  def create[T &lt;: AnyRef](typename: String, id: Long, values: Array[T])(implicit ct: ClassTag[T]): ArrowDictionary =
<span class="nc" id="L99">    create(typename, id, values, values.length)</span>

  /**
    * Create a dictionary based on a subset of a value array
    *
    * @param id dictionary id
    * @param values array of dictionary values
    * @param length number of valid entries in the values array, starting at position 0
    * @return
    */
  def create[T &lt;: AnyRef](typename: String, id: Long, values: Array[T], length: Int)(implicit ct: ClassTag[T]): ArrowDictionary =
<span class="nc" id="L110">    new ArrowDictionaryArray[T](typename, createEncoding(id, length), values, length, ct.runtimeClass.asInstanceOf[Class[T]])</span>

  /**
    * Create a dictionary based on wrapping an arrow vector
    *
    * @param encoding dictionary id and metadata
    * @param values dictionary vector
    * @param descriptor attribute descriptor for the dictionary, used to read values from the underlying vector
    * @param precision simple feature encoding used on the dictionary values
    * @return
    */
  def create(
      encoding: DictionaryEncoding,
      values: FieldVector,
      descriptor: AttributeDescriptor,
      precision: SimpleFeatureEncoding): ArrowDictionary = {
<span class="nc" id="L126">    new ArrowDictionaryVector(encoding, values, ObjectType.selectType(descriptor), precision)</span>
  }

  /**
   * Create a dictionary based on wrapping an arrow vector
   *
   * @param encoding dictionary id and metadata
   * @param values dictionary vector
   * @param bindings attribute descriptor bindings, used for reading values from the arrow vector
   * @param precision simple feature encoding used on the dictionary values
   * @return
   */
  def create(
      encoding: DictionaryEncoding,
      values: FieldVector,
      bindings: Seq[ObjectType],
      precision: SimpleFeatureEncoding): ArrowDictionary = {
<span class="nc" id="L143">    new ArrowDictionaryVector(encoding, values, bindings, precision)</span>
  }

  /**
    * Holder for dictionary values
    *
    * @param values dictionary values. When encoded, values are replaced with their index in the seq
    * @param encoding dictionary id and int width, id must be unique per arrow file
    */
<span class="nc bnc" id="L152" title="All 4 branches missed.">  class ArrowDictionaryArray[T &lt;: AnyRef](</span>
<span class="nc" id="L153">      typename: String,</span>
<span class="nc" id="L154">      val encoding: DictionaryEncoding,</span>
<span class="nc" id="L155">      values: Array[T],</span>
<span class="nc" id="L156">      val length: Int,</span>
<span class="nc" id="L157">      binding: Class[T]</span>
<span class="nc" id="L158">    ) extends ArrowDictionary {</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">    override def lookup(i: Int): AnyRef = if (i &lt; length) { values(i) } else { &quot;[other]&quot; }</span>

    override def toDictionary(precision: SimpleFeatureEncoding): Dictionary with Closeable = {
<span class="nc" id="L163">      val allocator = ArrowAllocator(s&quot;dictionary-array:$typename&quot;)</span>
<span class="nc" id="L164">      val name = s&quot;dictionary-$id&quot;</span>
<span class="nc" id="L165">      val bindings = ObjectType.selectType(binding)</span>
<span class="nc" id="L166">      val writer = ArrowAttributeWriter(name, bindings, None, Map.empty, precision, VectorFactory(allocator))</span>
<span class="nc" id="L167">      var i = 0</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      while (i &lt; length) {</span>
<span class="nc" id="L169">        writer.apply(i, values(i))</span>
<span class="nc" id="L170">        i += 1</span>
      }
<span class="nc" id="L172">      writer.setValueCount(length)</span>

<span class="nc" id="L174">      new Dictionary(writer.vector, encoding) with Closeable {</span>
<span class="nc" id="L175">        override def close(): Unit = CloseWithLogging.raise(writer.vector, allocator)</span>
      }
    }

<span class="nc" id="L179">    override def close(): Unit = {}</span>
  }

  /**
    * Dictionary that wraps an arrow vector
    *
    * @param encoding dictionary id and metadata
    * @param vector arrow vector
    * @param bindings attribute descriptor bindings, used for reading values from the arrow vector
    * @param precision simple feature encoding used for the arrow vector
    */
<span class="nc bnc" id="L190" title="All 4 branches missed.">  class ArrowDictionaryVector(</span>
<span class="nc" id="L191">      val encoding: DictionaryEncoding,</span>
<span class="nc" id="L192">      vector: FieldVector,</span>
      bindings: Seq[ObjectType],
<span class="nc" id="L194">      precision: SimpleFeatureEncoding</span>
<span class="nc" id="L195">    ) extends ArrowDictionary {</span>

    // we use an attribute reader to get the right type conversion
<span class="nc" id="L198">    private val reader = ArrowAttributeReader(bindings, vector, None, precision)</span>
<span class="nc" id="L199">    private var references = 1</span>

<span class="nc" id="L201">    override val length: Int = vector.getValueCount</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">    override def lookup(i: Int): AnyRef = if (i &lt; length) { reader.apply(i) } else { &quot;[other]&quot; }</span>

    override def toDictionary(precision: SimpleFeatureEncoding): Dictionary with Closeable = synchronized {
<span class="nc bnc" id="L206" title="All 2 branches missed.">      if (references &lt; 1) {</span>
<span class="nc" id="L207">        throw new IllegalStateException(&quot;Trying to create a dictionary from a closed vector&quot;)</span>
<span class="nc bnc" id="L208" title="All 6 branches missed.">      } else if (precision != this.precision) {</span>
<span class="nc" id="L209">        throw new IllegalArgumentException(&quot;Wrapped dictionary vectors can't be re-encoded with a different precision&quot;)</span>
      }
<span class="nc" id="L211">      references += 1</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      new Dictionary(vector, encoding) with Closeable {</span>
<span class="nc" id="L213">        override def close(): Unit = ArrowDictionaryVector.this.close()</span>
      }
    }

    override def close(): Unit = synchronized {
<span class="nc" id="L218">      references -= 1</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">      if (references &lt; 1) {</span>
<span class="nc" id="L220">        vector.close()</span>
      }
    }
  }

  /**
   * Tracks values seen and writes dictionary encoded ints instead
   */
<span class="nc bnc" id="L228" title="All 4 branches missed.">  class ArrowDictionaryBuilder(val encoding: DictionaryEncoding) extends ArrowDictionary {</span>

    // next dictionary index to use
<span class="nc" id="L231">    private val counter = new AtomicInteger(0)</span>

    // values that we have seen, and their dictionary index
<span class="nc" id="L234">    private val values = scala.collection.mutable.LinkedHashMap.empty[AnyRef, Int]</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">    override def lookup(i: Int): AnyRef = values.find(_._2 == i).map(_._1).getOrElse(&quot;[other]&quot;)</span>

<span class="nc" id="L238">    override def index(value: AnyRef): Int = values.getOrElseUpdate(value, counter.getAndIncrement())</span>

<span class="nc" id="L240">    override def length: Int = values.size</span>

    // note: iterator will return in insert order
    // we need to keep it ordered so that dictionary values match up with their index
<span class="nc" id="L244">    override def iterator: Iterator[AnyRef] = values.keys.iterator</span>

    override def toDictionary(precision: SimpleFeatureEncoding): Dictionary with Closeable =
<span class="nc" id="L247">      throw new UnsupportedOperationException()</span>

<span class="nc" id="L249">    override def close(): Unit = {}</span>

    def clear(): Unit = {
<span class="nc" id="L252">      counter.set(0)</span>
<span class="nc" id="L253">      values.clear()</span>
    }
  }

  // use the smallest int type possible to minimize bytes used
  private def createEncoding(id: Long, count: Int): DictionaryEncoding = {
    // we check `MaxValue - 1` to allow for the fallback 'other'
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (count &lt; Byte.MaxValue - 1) {</span>
<span class="nc" id="L261">      new DictionaryEncoding(id, false, new ArrowType.Int(8, true))</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    } else if (count &lt; Short.MaxValue - 1) {</span>
<span class="nc" id="L263">      new DictionaryEncoding(id, false, new ArrowType.Int(16, true))</span>
    } else {
<span class="nc" id="L265">      new DictionaryEncoding(id, false, new ArrowType.Int(32, true))</span>
    }
  }
<span class="nc" id="L268">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>