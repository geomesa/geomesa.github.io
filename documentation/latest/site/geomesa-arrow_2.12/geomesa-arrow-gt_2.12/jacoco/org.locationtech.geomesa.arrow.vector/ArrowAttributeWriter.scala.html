<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrowAttributeWriter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Arrow GeoTools Abstractions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.arrow.vector</a> &gt; <span class="el_source">ArrowAttributeWriter.scala</span></div><h1>ArrowAttributeWriter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.arrow
package vector

import org.apache.arrow.memory.BufferAllocator
import org.apache.arrow.vector._
import org.apache.arrow.vector.complex.{FixedSizeListVector, ListVector, StructVector}
import org.apache.arrow.vector.types.Types.MinorType
import org.apache.arrow.vector.types.pojo.{ArrowType, FieldType}
import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.arrow.jts._
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding.Encoding
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding.Encoding.Encoding
import org.locationtech.geomesa.filter.function.ProxyIdFunction
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.geotools.{ObjectType, SimpleFeatureTypes}
import org.locationtech.jts.geom._

import java.nio.charset.StandardCharsets
import java.util.{Date, UUID}

/**
  * Writes a simple feature attribute to an arrow vector
  */
<span class="nc" id="L34">trait ArrowAttributeWriter {</span>

  def name: String

  /**
    * Writes an attribute for the ith feature
    * @param i index of the feature to write
    * @param value attribute value to write
    */
  def apply(i: Int, value: AnyRef): Unit

  /**
    * Sets the underlying value count, after writing is finished. @see FieldVector.Mutator.setValueCount
    *
    * @param count number of features written (or null)
    */
<span class="nc" id="L50">  def setValueCount(count: Int): Unit = vector.setValueCount(count)</span>

  /**
    * Handle to the underlying field vector being written to
    *
    * @return
    */
  def vector: FieldVector
}

<span class="nc" id="L60">object ArrowAttributeWriter {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

  /**
    * Writer for feature ID. The return FeatureWriter expects to be passed the entire SimpleFeature, not
    * just the feature ID string (this is to support cached UUIDs).
    *
    * @param vector simple feature vector
    * @param encoding actually write the feature ids, or omit them, in which case the writer is a no-op
    * @return feature ID writer
    */
  def id(sft: SimpleFeatureType, encoding: SimpleFeatureEncoding, vector: StructVector): ArrowAttributeWriter = {
<span class="nc" id="L75">    val name = SimpleFeatureVector.FeatureIdField</span>
<span class="nc" id="L76">    encoding.fids match {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      case None =&gt; ArrowNoFidWriter</span>
<span class="nc bnc" id="L78" title="All 10 branches missed.">      case Some(Encoding.Min) if sft.isUuid =&gt; new ArrowFeatureIdMinimalUuidWriter(name, VectorFactory(vector))</span>
<span class="nc bnc" id="L79" title="All 10 branches missed.">      case Some(Encoding.Max) if sft.isUuid =&gt; new ArrowFeatureIdUuidWriter(name, VectorFactory(vector))</span>
<span class="nc bnc" id="L80" title="All 8 branches missed.">      case Some(Encoding.Min) =&gt; new ArrowFeatureIdMinimalStringWriter(name, VectorFactory(vector))</span>
<span class="nc bnc" id="L81" title="All 8 branches missed.">      case Some(Encoding.Max) =&gt; new ArrowFeatureIdStringWriter(name, VectorFactory(vector))</span>
    }
  }

  /**
    * Creates a sequence of attribute writers for a simple feature type. Each attribute in the feature type
    * will map to a writer in the returned sequence.
    *
    * @param sft simple feature type
    * @param vector child vectors will be created in this container
    * @param dictionaries dictionaries, if any
    * @param encoding encoding options
    * @return attribute writers
    */
  def apply(
      sft: SimpleFeatureType,
      vector: StructVector,
<span class="nc" id="L98">      dictionaries: Map[String, ArrowDictionary] = Map.empty,</span>
<span class="nc" id="L99">      encoding: SimpleFeatureEncoding = SimpleFeatureEncoding.Min): Seq[ArrowAttributeWriter] = {</span>
<span class="nc" id="L100">    sft.getAttributeDescriptors.asScala.map { descriptor =&gt;</span>
<span class="nc" id="L101">      apply(sft, descriptor, dictionaries.get(descriptor.getLocalName), encoding, vector)</span>
    }.toSeq
  }

  /**
   * Creates a single attribute writer
   *
   * @param sft simple feature type
   * @param descriptor attribute descriptor
   * @param dictionary the dictionary for the attribute, if any
   * @param encoding encoding options
   * @param vector child vectors will be created in the container
   * @return
   */
  def apply(
      sft: SimpleFeatureType,
      descriptor: AttributeDescriptor,
      dictionary: Option[ArrowDictionary],
      encoding: SimpleFeatureEncoding,
      vector: StructVector): ArrowAttributeWriter = {
<span class="nc" id="L121">    apply(sft, descriptor, dictionary, encoding, VectorFactory(vector))</span>
  }

  /**
   * Creates a single attribute writer
   *
   * @param sft simple feature type
   * @param descriptor attribute descriptor
   * @param dictionary the dictionary for the attribute, if any
   * @param encoding encoding options
   * @param allocator buffer allocator used to create underlying vectors
   * @return
   */
  def apply(
      sft: SimpleFeatureType,
      descriptor: AttributeDescriptor,
      dictionary: Option[ArrowDictionary],
      encoding: SimpleFeatureEncoding,
      allocator: BufferAllocator): ArrowAttributeWriter = {
<span class="nc" id="L140">    apply(sft, descriptor, dictionary, encoding, VectorFactory(allocator))</span>
  }

  /**
   * Creates a single attribute writer
   *
   * @param sft simple feature type
   * @param descriptor attribute descriptor
   * @param dictionary the dictionary for the attribute, if any
   * @param encoding encoding options
   * @param factory factory used to create underlying vectors
   * @return
   */
  def apply(
      sft: SimpleFeatureType,
      descriptor: AttributeDescriptor,
      dictionary: Option[ArrowDictionary],
      encoding: SimpleFeatureEncoding,
      factory: VectorFactory): ArrowAttributeWriter = {
<span class="nc" id="L159">    val name = descriptor.getLocalName</span>
<span class="nc" id="L160">    val bindings = ObjectType.selectType(descriptor)</span>
<span class="nc" id="L161">    val metadata = Map(SimpleFeatureVector.DescriptorKey -&gt; SimpleFeatureTypes.encodeDescriptor(sft, descriptor))</span>
<span class="nc" id="L162">    apply(name, bindings, dictionary, metadata, encoding, factory)</span>
  }

  /**
   * Low-level method to create a single attribute writer
   *
   * @param name attribute name
   * @param bindings object bindings, the attribute type plus any subtypes (e.g. for lists or maps)
   * @param dictionary the dictionary for the attribute, if any
   * @param metadata vector metadata encoded in the field - generally the encoded attribute descriptor
   * @param encoding encoding options
   * @param factory parent vector or allocator
   * @return
   */
  def apply(
      name: String,
      bindings: Seq[ObjectType],
      dictionary: Option[ArrowDictionary],
      metadata: Map[String, String],
      encoding: SimpleFeatureEncoding,
      factory: VectorFactory): ArrowAttributeWriter = {
<span class="nc" id="L183">    dictionary match {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      case Some(dict) =&gt;</span>
<span class="nc bnc" id="L185" title="All 6 branches missed.">        ArrowAttributeWriter.dictionary(name, dict, bindings.head == ObjectType.LIST, metadata, factory)</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">      case None =&gt;</span>
<span class="nc" id="L188">        bindings.head match {</span>
<span class="nc bnc" id="L189" title="All 6 branches missed.">          case ObjectType.STRING   =&gt; new ArrowStringWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L190" title="All 6 branches missed.">          case ObjectType.DATE     =&gt; date(name, encoding.date, metadata, factory)</span>
<span class="nc bnc" id="L191" title="All 6 branches missed.">          case ObjectType.INT      =&gt; new ArrowIntWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L192" title="All 6 branches missed.">          case ObjectType.LONG     =&gt; new ArrowLongWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L193" title="All 6 branches missed.">          case ObjectType.FLOAT    =&gt; new ArrowFloatWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L194" title="All 6 branches missed.">          case ObjectType.DOUBLE   =&gt; new ArrowDoubleWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L195" title="All 6 branches missed.">          case ObjectType.GEOMETRY =&gt; geometry(name, bindings(1), encoding, metadata, factory)</span>
<span class="nc bnc" id="L196" title="All 6 branches missed.">          case ObjectType.BOOLEAN  =&gt; new ArrowBooleanWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L197" title="All 6 branches missed.">          case ObjectType.LIST     =&gt; new ArrowListWriter(name, bindings(1), encoding, metadata, factory)</span>
<span class="nc bnc" id="L198" title="All 6 branches missed.">          case ObjectType.MAP      =&gt; new ArrowMapWriter(name, bindings(1), bindings(2), encoding, metadata, factory)</span>
<span class="nc bnc" id="L199" title="All 6 branches missed.">          case ObjectType.BYTES    =&gt; new ArrowBytesWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L200" title="All 6 branches missed.">          case ObjectType.UUID     =&gt; new ArrowUuidWriter(name, metadata, factory)</span>
<span class="nc" id="L201">          case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type ${bindings.head}&quot;)</span>
        }
    }
  }

  private def dictionary(
      name: String,
      dictionary: ArrowDictionary,
      isList: Boolean,
      metadata: Map[String, String],
      factory: VectorFactory): ArrowAttributeWriter = {
<span class="nc bnc" id="L212" title="All 14 branches missed.">    (dictionary.encoding.getIndexType.getBitWidth, isList) match {</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">      case (8,  false) =&gt; new ArrowDictionaryByteWriter(name, dictionary, metadata, factory)</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">      case (16, false) =&gt; new ArrowDictionaryShortWriter(name, dictionary, metadata, factory)</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">      case (32, false) =&gt; new ArrowDictionaryIntWriter(name, dictionary, metadata, factory)</span>
<span class="nc bnc" id="L216" title="All 4 branches missed.">      case (8,  true)  =&gt; new ArrowListDictionaryByteWriter(name, dictionary, metadata, factory)</span>
<span class="nc bnc" id="L217" title="All 4 branches missed.">      case (16, true)  =&gt; new ArrowListDictionaryShortWriter(name, dictionary, metadata, factory)</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">      case (32, true)  =&gt; new ArrowListDictionaryIntWriter(name, dictionary, metadata, factory)</span>
<span class="nc" id="L219">      case (w, _)      =&gt; throw new IllegalArgumentException(s&quot;Unsupported dictionary encoding width: $w&quot;)</span>
    }
  }

  private def date(
      name: String,
      encoding: Encoding,
      metadata: Map[String, String],
      factory: VectorFactory): ArrowAttributeWriter = {
<span class="nc" id="L228">    encoding match {</span>
<span class="nc bnc" id="L229" title="All 6 branches missed.">      case Encoding.Min =&gt; new ArrowDateSecondsWriter(name, metadata, factory)</span>
<span class="nc bnc" id="L230" title="All 6 branches missed.">      case Encoding.Max =&gt; new ArrowDateMillisWriter(name, metadata, factory)</span>
    }
  }

  private def geometry(
      name: String,
      binding: ObjectType,
      encoding: SimpleFeatureEncoding,
      metadata: Map[String, String],
      factory: VectorFactory): ArrowGeometryWriter = {
<span class="nc" id="L240">    val m = metadata.asJava</span>
<span class="nc bnc" id="L241" title="All 58 branches missed.">    val vector = (binding, encoding.geometry, factory) match {</span>
<span class="nc bnc" id="L242" title="All 14 branches missed.">      case (ObjectType.POINT, Encoding.Min, FromStruct(c))              =&gt; new PointFloatVector(name, c, m)</span>
<span class="nc bnc" id="L243" title="All 14 branches missed.">      case (ObjectType.POINT, Encoding.Min, FromAllocator(c))           =&gt; new PointFloatVector(name, c, m)</span>
<span class="nc bnc" id="L244" title="All 14 branches missed.">      case (ObjectType.POINT, Encoding.Max, FromStruct(c))              =&gt; new PointVector(name, c, m)</span>
<span class="nc bnc" id="L245" title="All 14 branches missed.">      case (ObjectType.POINT, Encoding.Max, FromAllocator(c))           =&gt; new PointVector(name, c, m)</span>
<span class="nc bnc" id="L246" title="All 14 branches missed.">      case (ObjectType.LINESTRING, Encoding.Min, FromStruct(c))         =&gt; new LineStringFloatVector(name, c, m)</span>
<span class="nc bnc" id="L247" title="All 14 branches missed.">      case (ObjectType.LINESTRING, Encoding.Min, FromAllocator(c))      =&gt; new LineStringFloatVector(name, c, m)</span>
<span class="nc bnc" id="L248" title="All 14 branches missed.">      case (ObjectType.LINESTRING, Encoding.Max, FromStruct(c))         =&gt; new LineStringVector(name, c, m)</span>
<span class="nc bnc" id="L249" title="All 14 branches missed.">      case (ObjectType.LINESTRING, Encoding.Max, FromAllocator(c))      =&gt; new LineStringVector(name, c, m)</span>
<span class="nc bnc" id="L250" title="All 14 branches missed.">      case (ObjectType.POLYGON, Encoding.Min, FromStruct(c))            =&gt; new PolygonFloatVector(name, c, m)</span>
<span class="nc bnc" id="L251" title="All 14 branches missed.">      case (ObjectType.POLYGON, Encoding.Min, FromAllocator(c))         =&gt; new PolygonFloatVector(name, c, m)</span>
<span class="nc bnc" id="L252" title="All 14 branches missed.">      case (ObjectType.POLYGON, Encoding.Max, FromStruct(c))            =&gt; new PolygonVector(name, c, m)</span>
<span class="nc bnc" id="L253" title="All 14 branches missed.">      case (ObjectType.POLYGON, Encoding.Max, FromAllocator(c))         =&gt; new PolygonVector(name, c, m)</span>
<span class="nc bnc" id="L254" title="All 14 branches missed.">      case (ObjectType.MULTILINESTRING, Encoding.Min, FromStruct(c))    =&gt; new MultiLineStringFloatVector(name, c, m)</span>
<span class="nc bnc" id="L255" title="All 14 branches missed.">      case (ObjectType.MULTILINESTRING, Encoding.Min, FromAllocator(c)) =&gt; new MultiLineStringFloatVector(name, c, m)</span>
<span class="nc bnc" id="L256" title="All 14 branches missed.">      case (ObjectType.MULTILINESTRING, Encoding.Max, FromStruct(c))    =&gt; new MultiLineStringVector(name, c, m)</span>
<span class="nc bnc" id="L257" title="All 14 branches missed.">      case (ObjectType.MULTILINESTRING, Encoding.Max, FromAllocator(c)) =&gt; new MultiLineStringVector(name, c, m)</span>
<span class="nc bnc" id="L258" title="All 14 branches missed.">      case (ObjectType.MULTIPOLYGON, Encoding.Min, FromStruct(c))       =&gt; new MultiPolygonFloatVector(name, c, m)</span>
<span class="nc bnc" id="L259" title="All 14 branches missed.">      case (ObjectType.MULTIPOLYGON, Encoding.Min, FromAllocator(c))    =&gt; new MultiPolygonFloatVector(name, c, m)</span>
<span class="nc bnc" id="L260" title="All 14 branches missed.">      case (ObjectType.MULTIPOLYGON, Encoding.Max, FromStruct(c))       =&gt; new MultiPolygonVector(name, c, m)</span>
<span class="nc bnc" id="L261" title="All 14 branches missed.">      case (ObjectType.MULTIPOLYGON, Encoding.Max, FromAllocator(c))    =&gt; new MultiPolygonVector(name, c, m)</span>
<span class="nc bnc" id="L262" title="All 14 branches missed.">      case (ObjectType.MULTIPOINT, Encoding.Min, FromStruct(c))         =&gt; new MultiPointFloatVector(name, c, m)</span>
<span class="nc bnc" id="L263" title="All 14 branches missed.">      case (ObjectType.MULTIPOINT, Encoding.Min, FromAllocator(c))      =&gt; new MultiPointFloatVector(name, c, m)</span>
<span class="nc bnc" id="L264" title="All 14 branches missed.">      case (ObjectType.MULTIPOINT, Encoding.Max, FromStruct(c))         =&gt; new MultiPointVector(name, c, m)</span>
<span class="nc bnc" id="L265" title="All 14 branches missed.">      case (ObjectType.MULTIPOINT, Encoding.Max, FromAllocator(c))      =&gt; new MultiPointVector(name, c, m)</span>
<span class="nc bnc" id="L266" title="All 8 branches missed.">      case (ObjectType.GEOMETRY, _, FromStruct(c))                      =&gt; new WKBGeometryVector(name, c, m)</span>
<span class="nc bnc" id="L267" title="All 8 branches missed.">      case (ObjectType.GEOMETRY, _, FromAllocator(c))                   =&gt; new WKBGeometryVector(name, c, m)</span>
<span class="nc bnc" id="L268" title="All 8 branches missed.">      case (ObjectType.GEOMETRY_COLLECTION, _, FromStruct(c))           =&gt; new WKBGeometryVector(name, c, m)</span>
<span class="nc bnc" id="L269" title="All 8 branches missed.">      case (ObjectType.GEOMETRY_COLLECTION, _, FromAllocator(c))        =&gt; new WKBGeometryVector(name, c, m)</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">      case (_, _, FromList(_)) =&gt; throw new UnsupportedOperationException(&quot;Geometry lists are not supported&quot;)</span>
<span class="nc" id="L271">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected geometry type $binding&quot;)</span>
    }
<span class="nc" id="L273">    val geometryVector = vector.asInstanceOf[GeometryVector[Geometry, FieldVector]]</span>
<span class="nc" id="L274">    geometryVector.setFlipAxisOrder(encoding.flipAxisOrder)</span>

<span class="nc" id="L276">    new ArrowGeometryWriter(name, geometryVector)</span>
  }

  trait ArrowDictionaryWriter extends ArrowAttributeWriter {
    def dictionary: ArrowDictionary
  }

  /**
   * Converts a value into a dictionary encoded byte and writes it
   *
   * @param name attribute/field name
   * @param dictionary dictionary values
   * @param metadata field metadata
   * @param factory vector factory
   */
<span class="nc" id="L291">  class ArrowDictionaryByteWriter(</span>
<span class="nc" id="L292">      val name: String,</span>
<span class="nc" id="L293">      val dictionary: ArrowDictionary,</span>
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L296">    ) extends ArrowDictionaryWriter {</span>

<span class="nc" id="L298">    override val vector: TinyIntVector = factory.apply(name, MinorType.TINYINT, dictionary.encoding, metadata)</span>

    // note: nulls get encoded in the dictionary
<span class="nc" id="L301">    override def apply(i: Int, value: AnyRef): Unit = vector.setSafe(i, dictionary.index(value).toByte)</span>
  }

  /**
   * Converts a list value into a list of dictionary bytes and writes it
   *
   * @param name attribute/field name
   * @param dictionary dictionary values
   * @param metadata field metadata
   * @param factory vector factory
   */
<span class="nc" id="L312">  class ArrowListDictionaryByteWriter(</span>
<span class="nc" id="L313">      val name: String,</span>
<span class="nc" id="L314">      val dictionary: ArrowDictionary,</span>
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L317">    ) extends ArrowDictionaryWriter {</span>

<span class="nc" id="L319">    override val vector: ListVector = factory.apply(name, MinorType.LIST, metadata)</span>

<span class="nc" id="L321">    private val inner: TinyIntVector =</span>
<span class="nc" id="L322">      FromList(vector).apply(null, MinorType.TINYINT, dictionary.encoding, Map.empty)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L325" title="All 2 branches missed.">      if (vector.getLastSet &gt;= i) {</span>
<span class="nc" id="L326">        vector.setLastSet(i - 1)</span>
      }
<span class="nc" id="L328">      val start = vector.startNewValue(i)</span>
      // note: null gets converted to empty list
<span class="nc bnc" id="L330" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L331">        vector.endValue(i, 0)</span>
      } else {
<span class="nc" id="L333">        val list = value.asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc" id="L334">        var offset = 0</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        while (offset &lt; list.size()) {</span>
          // note: nulls get encoded in the dictionary
<span class="nc" id="L337">          inner.setSafe(start + offset, dictionary.index(list.get(offset)).toByte)</span>
<span class="nc" id="L338">          offset += 1</span>
        }
<span class="nc" id="L340">        vector.endValue(i, offset)</span>
      }
    }
  }

  /**
   * Converts a value into a dictionary encoded short and writes it
   *
   * @param name attribute/field name
   * @param dictionary dictionary values
   * @param metadata field metadata
   * @param factory vector factory
   */
<span class="nc" id="L353">  class ArrowDictionaryShortWriter(</span>
<span class="nc" id="L354">      val name: String,</span>
<span class="nc" id="L355">      val dictionary: ArrowDictionary,</span>
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L358">    ) extends ArrowDictionaryWriter {</span>

<span class="nc" id="L360">    override val vector: SmallIntVector = factory.apply(name, MinorType.SMALLINT, dictionary.encoding, metadata)</span>

    // note: nulls get encoded in the dictionary
<span class="nc" id="L363">    override def apply(i: Int, value: AnyRef): Unit = vector.setSafe(i, dictionary.index(value).toShort)</span>
  }

  /**
   * Converts a list value into a list of dictionary shorts and writes it
   *
   * @param name attribute/field name
   * @param dictionary dictionary values
   * @param metadata field metadata
   * @param factory vector factory
   */
<span class="nc" id="L374">  class ArrowListDictionaryShortWriter(</span>
<span class="nc" id="L375">      val name: String,</span>
<span class="nc" id="L376">      val dictionary: ArrowDictionary,</span>
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L379">    ) extends ArrowDictionaryWriter {</span>

<span class="nc" id="L381">    override val vector: ListVector = factory.apply(name, MinorType.LIST, metadata)</span>

<span class="nc" id="L383">    private val inner: SmallIntVector =</span>
<span class="nc" id="L384">      FromList(vector).apply(null, MinorType.SMALLINT, dictionary.encoding, Map.empty)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L387" title="All 2 branches missed.">      if (vector.getLastSet &gt;= i) {</span>
<span class="nc" id="L388">        vector.setLastSet(i - 1)</span>
      }
<span class="nc" id="L390">      val start = vector.startNewValue(i)</span>
      // note: null gets converted to empty list
<span class="nc bnc" id="L392" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L393">        vector.endValue(i, 0)</span>
      } else {
<span class="nc" id="L395">        val list = value.asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc" id="L396">        var offset = 0</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        while (offset &lt; list.size()) {</span>
          // note: nulls get encoded in the dictionary
<span class="nc" id="L399">          inner.setSafe(start + offset, dictionary.index(list.get(offset)).toShort)</span>
<span class="nc" id="L400">          offset += 1</span>
        }
<span class="nc" id="L402">        vector.endValue(i, offset)</span>
      }
    }
  }

  /**
   * Converts a value into a dictionary encoded int and writes it
   *
   * @param name attribute/field name
   * @param dictionary dictionary values
   * @param metadata field metadata
   * @param factory vector factory
   */
<span class="nc" id="L415">  class ArrowDictionaryIntWriter(</span>
<span class="nc" id="L416">      val name: String,</span>
<span class="nc" id="L417">      val dictionary: ArrowDictionary,</span>
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L420">    ) extends ArrowDictionaryWriter {</span>

<span class="nc" id="L422">    override val vector: IntVector = factory.apply(name, MinorType.INT, dictionary.encoding, metadata)</span>

    // note: nulls get encoded in the dictionary
<span class="nc" id="L425">    override def apply(i: Int, value: AnyRef): Unit = vector.setSafe(i, dictionary.index(value))</span>
  }

  /**
   * Converts a list value into a list of dictionary ints and writes it
   *
   * @param name attribute/field name
   * @param dictionary dictionary values
   * @param metadata field metadata
   * @param factory vector factory
   */
<span class="nc" id="L436">  class ArrowListDictionaryIntWriter(</span>
<span class="nc" id="L437">      val name: String,</span>
<span class="nc" id="L438">      val dictionary: ArrowDictionary,</span>
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L441">    ) extends ArrowDictionaryWriter {</span>

<span class="nc" id="L443">    override val vector: ListVector = factory.apply(name, MinorType.LIST, metadata)</span>

<span class="nc" id="L445">    private val inner: IntVector = FromList(vector).apply(null, MinorType.INT, dictionary.encoding, Map.empty)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L448" title="All 2 branches missed.">      if (vector.getLastSet &gt;= i) {</span>
<span class="nc" id="L449">        vector.setLastSet(i - 1)</span>
      }
<span class="nc" id="L451">      val start = vector.startNewValue(i)</span>
      // note: null gets converted to empty list
<span class="nc bnc" id="L453" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L454">        vector.endValue(i, 0)</span>
      } else {
<span class="nc" id="L456">        val list = value.asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc" id="L457">        var offset = 0</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        while (offset &lt; list.size()) {</span>
          // note: nulls get encoded in the dictionary
<span class="nc" id="L460">          inner.setSafe(start + offset, dictionary.index(list.get(offset)))</span>
<span class="nc" id="L461">          offset += 1</span>
        }
<span class="nc" id="L463">        vector.endValue(i, offset)</span>
      }
    }
  }

  /**
    * Writes geometries - delegates to our JTS geometry vectors
    */
<span class="nc" id="L471">  class ArrowGeometryWriter(val name: String, delegate: GeometryVector[Geometry, FieldVector])</span>
<span class="nc" id="L472">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L474">    override def vector: FieldVector = delegate.getVector</span>

    // note: delegate handles nulls
<span class="nc" id="L477">    override def apply(i: Int, value: AnyRef): Unit = delegate.set(i, value.asInstanceOf[Geometry])</span>

<span class="nc" id="L479">    override def setValueCount(count: Int): Unit = delegate.setValueCount(count)</span>
  }

  /**
    * Doesn't actually write anything
    */
<span class="nc" id="L485">  object ArrowNoFidWriter extends ArrowAttributeWriter {</span>
<span class="nc" id="L486">    override def name: String = SimpleFeatureVector.FeatureIdField</span>
<span class="nc" id="L487">    override def vector: FieldVector = null</span>
<span class="nc" id="L488">    override def apply(i: Int, value: AnyRef): Unit = {}</span>
<span class="nc" id="L489">    override def setValueCount(count: Int): Unit = {}</span>
  }

<span class="nc" id="L492">  class ArrowUuidWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L493">    extends ArrowAttributeWriter {</span>
<span class="nc" id="L494">    val fieldType: FieldType = new FieldType(true, new ArrowType.FixedSizeList(2), null, metadata.asJava)</span>
<span class="nc" id="L495">    override val vector: FixedSizeListVector = factory.apply(name, fieldType)</span>

<span class="nc" id="L497">    private val bits = {</span>
<span class="nc" id="L498">      val result = vector.addOrGetVector[BigIntVector](FieldType.nullable(MinorType.BIGINT.getType))</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">      if (result.isCreated) {</span>
<span class="nc" id="L500">        result.getVector.allocateNew()</span>
      }
<span class="nc" id="L502">      result.getVector</span>
    }

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L506" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L507">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L509">        val uuid = value.asInstanceOf[UUID]</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">        val (msb, lsb) = (uuid.getMostSignificantBits, uuid.getLeastSignificantBits)</span>
<span class="nc" id="L511">        vector.setNotNull(i)</span>
<span class="nc" id="L512">        bits.setSafe(i * 2, msb)</span>
<span class="nc" id="L513">        bits.setSafe(i * 2 + 1, lsb)</span>
      }
    }
  }

<span class="nc" id="L518">  class ArrowFeatureIdMinimalUuidWriter(val name: String, factory: VectorFactory)</span>
<span class="nc" id="L519">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L521">    override val vector: IntVector = factory.apply(name, MinorType.INT, Map.empty)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
      import org.locationtech.geomesa.utils.geotools.Conversions.RichSimpleFeature
<span class="nc bnc" id="L525" title="All 2 branches missed.">      val (msb, lsb) = value.asInstanceOf[SimpleFeature].getUuid</span>
<span class="nc" id="L526">      vector.setSafe(i, ProxyIdFunction.proxyId(msb, lsb))</span>
    }
  }

<span class="nc" id="L530">  class ArrowFeatureIdMinimalStringWriter(val name: String, factory: VectorFactory)</span>
<span class="nc" id="L531">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L533">    override val vector: IntVector = factory.apply(name, MinorType.INT, Map.empty)</span>

    override def apply(i: Int, value: AnyRef): Unit =
<span class="nc" id="L536">      vector.setSafe(i, ProxyIdFunction.proxyId(value.asInstanceOf[SimpleFeature].getID))</span>
  }

<span class="nc" id="L539">  class ArrowFeatureIdUuidWriter(val name: String, factory: VectorFactory)</span>
<span class="nc" id="L540">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L542">    override val vector: FixedSizeListVector = factory.apply(name, FieldType.nullable(new ArrowType.FixedSizeList(2)))</span>

<span class="nc" id="L544">    private val bits = {</span>
<span class="nc" id="L545">      val result = vector.addOrGetVector[BigIntVector](FieldType.nullable(MinorType.BIGINT.getType))</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">      if (result.isCreated) {</span>
<span class="nc" id="L547">        result.getVector.allocateNew()</span>
      }
<span class="nc" id="L549">      result.getVector</span>
    }

    override def apply(i: Int, value: AnyRef): Unit = {
      import org.locationtech.geomesa.utils.geotools.Conversions.RichSimpleFeature
<span class="nc bnc" id="L554" title="All 2 branches missed.">      val (msb, lsb) = value.asInstanceOf[SimpleFeature].getUuid</span>
<span class="nc" id="L555">      vector.setNotNull(i)</span>
<span class="nc" id="L556">      bits.setSafe(i * 2, msb)</span>
<span class="nc" id="L557">      bits.setSafe(i * 2 + 1, lsb)</span>
    }
  }

<span class="nc" id="L561">  class ArrowFeatureIdStringWriter(val name: String, factory: VectorFactory)</span>
<span class="nc" id="L562">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L564">    override val vector: VarCharVector = factory.apply(name, MinorType.VARCHAR, Map.empty)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc" id="L567">      val bytes = value.asInstanceOf[SimpleFeature].getID.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L568">      vector.setSafe(i, bytes, 0, bytes.length)</span>
    }
  }

<span class="nc" id="L572">  class ArrowStringWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L573">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L575">    override val vector: VarCharVector = factory.apply(name, MinorType.VARCHAR, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L578" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L579">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L581">        val bytes = value.toString.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L582">        vector.setSafe(i, bytes, 0, bytes.length)</span>
      }
    }
  }

<span class="nc" id="L587">  class ArrowIntWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L588">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L590">    override val vector: IntVector = factory.apply(name, MinorType.INT, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L593" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L594">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L596">        vector.setSafe(i, value.asInstanceOf[Int])</span>
      }
    }
  }

<span class="nc" id="L601">  class ArrowLongWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L602">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L604">    override val vector: BigIntVector = factory.apply(name, MinorType.BIGINT, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L608">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L610">        vector.setSafe(i, value.asInstanceOf[Long])</span>
      }
    }
  }

<span class="nc" id="L615">  class ArrowFloatWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L616">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L618">    override val vector: Float4Vector = factory.apply(name, MinorType.FLOAT4, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L621" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L622">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L624">        vector.setSafe(i, value.asInstanceOf[Float])</span>
      }
    }
  }

<span class="nc" id="L629">  class ArrowDoubleWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L630">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L632">    override val vector: Float8Vector = factory.apply(name, MinorType.FLOAT8, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L635" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L636">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L638">        vector.setSafe(i, value.asInstanceOf[Double])</span>
      }
    }
  }

<span class="nc" id="L643">  class ArrowBooleanWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L644">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L646">    override val vector: BitVector = factory.apply(name, MinorType.BIT, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L649" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L650">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        vector.setSafe(i, if (value.asInstanceOf[Boolean]) { 1 } else { 0 })</span>
      }
    }
  }

<span class="nc" id="L657">  class ArrowDateMillisWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L658">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L660">    override val vector: BigIntVector = factory.apply(name, MinorType.BIGINT, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L663" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L664">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L666">        vector.setSafe(i, value.asInstanceOf[Date].getTime)</span>
      }
    }
  }

<span class="nc" id="L671">  class ArrowDateSecondsWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L672">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L674">    override val vector: IntVector = factory.apply(name, MinorType.INT, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L677" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L678">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L680">        vector.setSafe(i, (value.asInstanceOf[Date].getTime / 1000L).toInt)</span>
      }
    }
  }

<span class="nc" id="L685">  class ArrowBytesWriter(val name: String, metadata: Map[String, String], factory: VectorFactory)</span>
<span class="nc" id="L686">      extends ArrowAttributeWriter {</span>

<span class="nc" id="L688">    override val vector: VarBinaryVector = factory.apply(name, MinorType.VARBINARY, metadata)</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L691" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L692">        vector.setNull(i) // note: calls .setSafe internally</span>
      } else {
<span class="nc" id="L694">        val bytes = value.asInstanceOf[Array[Byte]]</span>
<span class="nc" id="L695">        vector.setSafe(i, bytes, 0, bytes.length)</span>
      }
    }
  }

<span class="nc" id="L700">  class ArrowListWriter(</span>
<span class="nc" id="L701">      val name: String,</span>
      binding: ObjectType,
      encoding: SimpleFeatureEncoding,
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L706">    ) extends ArrowAttributeWriter {</span>

<span class="nc" id="L708">    override val vector: ListVector = factory.apply(name, MinorType.LIST, metadata)</span>

<span class="nc" id="L710">    private val subWriter =</span>
<span class="nc" id="L711">      ArrowAttributeWriter(null, Seq(binding), None, Map.empty[String, String], encoding, FromList(vector))</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L714" title="All 2 branches missed.">      if (vector.getLastSet &gt;= i) {</span>
<span class="nc" id="L715">        vector.setLastSet(i - 1)</span>
      }
<span class="nc" id="L717">      val start = vector.startNewValue(i)</span>
      // note: null gets converted to empty list
<span class="nc bnc" id="L719" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L720">        vector.endValue(i, 0)</span>
      } else {
<span class="nc" id="L722">        val list = value.asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc" id="L723">        var offset = 0</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        while (offset &lt; list.size()) {</span>
<span class="nc" id="L725">          subWriter.apply(start + offset, list.get(offset))</span>
<span class="nc" id="L726">          offset += 1</span>
        }
<span class="nc" id="L728">        vector.endValue(i, offset)</span>
      }
    }
  }

<span class="nc" id="L733">  class ArrowMapWriter(</span>
<span class="nc" id="L734">      val name: String,</span>
      keyBinding: ObjectType,
      valueBinding: ObjectType,
      encoding: SimpleFeatureEncoding,
      metadata: Map[String, String],
      factory: VectorFactory
<span class="nc" id="L740">    ) extends ArrowAttributeWriter {</span>

<span class="nc" id="L742">    override val vector: StructVector = factory.apply(name, MinorType.STRUCT, metadata)</span>

<span class="nc" id="L744">    private val keyWriter =</span>
<span class="nc" id="L745">      ArrowAttributeWriter(&quot;k&quot;, Seq(ObjectType.LIST, keyBinding), None, Map.empty, encoding, FromStruct(vector))</span>
<span class="nc" id="L746">    private val valueWriter =</span>
<span class="nc" id="L747">      ArrowAttributeWriter(&quot;v&quot;, Seq(ObjectType.LIST, valueBinding), None, Map.empty, encoding, FromStruct(vector))</span>

    override def apply(i: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L750" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L751">        vector.setNull(i)</span>
      } else {
<span class="nc" id="L753">        vector.setIndexDefined(i)</span>
<span class="nc" id="L754">        val map = value.asInstanceOf[java.util.Map[AnyRef, AnyRef]]</span>
<span class="nc" id="L755">        val keys = new java.util.ArrayList[AnyRef](map.size())</span>
<span class="nc" id="L756">        val values = new java.util.ArrayList[AnyRef](map.size())</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        map.asScala.foreach { case (k, v) =&gt;</span>
<span class="nc" id="L758">          keys.add(k)</span>
<span class="nc" id="L759">          values.add(v)</span>
        }
<span class="nc" id="L761">        keyWriter.apply(i, keys)</span>
<span class="nc" id="L762">        valueWriter.apply(i, values)</span>
      }
    }
  }
<span class="nc" id="L766">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>