<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleFeatureVector.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Arrow GeoTools Abstractions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.arrow.vector</a> &gt; <span class="el_source">SimpleFeatureVector.scala</span></div><h1>SimpleFeatureVector.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.arrow.vector

import org.apache.arrow.memory.BufferAllocator
import org.apache.arrow.vector.complex.{ListVector, StructVector}
import org.apache.arrow.vector.types.FloatingPointPrecision
import org.apache.arrow.vector.types.pojo.{ArrowType, FieldType}
import org.apache.arrow.vector.{BigIntVector, FieldVector}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.arrow.ArrowAllocator
import org.locationtech.geomesa.arrow.features.ArrowSimpleFeature
import org.locationtech.geomesa.arrow.jts.GeometryFields
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding.Encoding
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding.Encoding.Encoding
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.io.{CloseQuietly, CloseWithLogging}
import org.locationtech.jts.geom.Geometry

import java.io.Closeable
import java.util.{Collections, Date}
import scala.collection.mutable.ArrayBuffer
import scala.reflect.ClassTag
import scala.util.control.NonFatal

/**
  * Abstraction for using simple features in Arrow vectors
  *
  * @param sft simple feature type
  * @param underlying underlying arrow vector
  * @param dictionaries map of field names to dictionary values, used for dictionary encoding fields.
  *                     All values must be provided up front.
  * @param encoding options for encoding
  */
<span class="nc" id="L42">class SimpleFeatureVector private [arrow] (</span>
<span class="nc" id="L43">    val sft: SimpleFeatureType,</span>
<span class="nc" id="L44">    val underlying: StructVector,</span>
<span class="nc" id="L45">    val dictionaries: Map[String, ArrowDictionary],</span>
<span class="nc" id="L46">    val encoding: SimpleFeatureEncoding,</span>
<span class="nc" id="L47">    allocator: Option[BufferAllocator]</span>
<span class="nc" id="L48">  ) extends Closeable {</span>

  // note: writer creates the map child vectors based on the sft, and should be instantiated before the reader
<span class="nc" id="L51">  val writer = new Writer()</span>
<span class="nc" id="L52">  val reader = new Reader()</span>

  /**
    * Clear any simple features currently stored in the vector
    */
<span class="nc" id="L57">  def clear(): Unit = underlying.setValueCount(0)</span>

<span class="nc" id="L59">  override def close(): Unit = CloseWithLogging.raise(Seq(underlying) ++ allocator)</span>

<span class="nc bnc" id="L61" title="All 2 branches missed.">  class Writer {</span>

<span class="nc" id="L63">    private val idWriter = ArrowAttributeWriter.id(sft, encoding, underlying)</span>
<span class="nc" id="L64">    private val writers = ArrowAttributeWriter(sft, underlying, dictionaries, encoding).toArray</span>

    /**
     * Sets the feature at the given index
     *
     * @param index index to set
     * @param feature feature to set
     */
    def set(index: Int, feature: SimpleFeature): Unit = {
<span class="nc" id="L73">      underlying.getWriter.setPosition(index)</span>
<span class="nc" id="L74">      underlying.getWriter.start()</span>
<span class="nc" id="L75">      idWriter.apply(index, feature)</span>
<span class="nc" id="L76">      var i = 0</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      while (i &lt; writers.length) {</span>
<span class="nc" id="L78">        writers(i).apply(index, feature.getAttribute(i))</span>
<span class="nc" id="L79">        i += 1</span>
      }
<span class="nc" id="L81">      underlying.getWriter.end()</span>
    }

    /**
     * Sets the value count, e.g. the number of features contained in this vector.
     * Should only be called after all features have been written
     *
     * @param count count
     */
    def setValueCount(count: Int): Unit = {
<span class="nc" id="L91">      underlying.getWriter.setValueCount(count)</span>
<span class="nc" id="L92">      writers.foreach(_.setValueCount(count))</span>
    }
  }

<span class="nc bnc" id="L96" title="All 2 branches missed.">  class Reader {</span>

<span class="nc" id="L98">    private val idReader = ArrowAttributeReader.id(sft, underlying, encoding)</span>
<span class="nc" id="L99">    private val readers = ArrowAttributeReader(sft, underlying, dictionaries, encoding).toArray</span>

    // feature that can be re-populated with calls to 'load'
<span class="nc" id="L102">    val feature: ArrowSimpleFeature = new ArrowSimpleFeature(sft, idReader, readers, -1)</span>

    /**
     * Gets the feature at a given index
     *
     * @param index index to get
     * @return
     */
<span class="nc" id="L110">    def get(index: Int): ArrowSimpleFeature = new ArrowSimpleFeature(sft, idReader, readers, index)</span>

    /**
     * Loads the re-usable `feature` with the given index
     *
     * @param index index to load
     */
<span class="nc" id="L117">    def load(index: Int): Unit = feature.index = index</span>

    /**
     * Gets the value count, e.g. the number of features contained in this vector
     *
     * @return
     */
<span class="nc" id="L124">    def getValueCount: Int = underlying.getValueCount</span>
  }
<span class="nc" id="L126">}</span>

<span class="nc" id="L128">object SimpleFeatureVector {</span>

<span class="nc" id="L130">  val DefaultCapacity = 8096</span>
<span class="nc" id="L131">  val FeatureIdField  = &quot;id&quot;</span>
<span class="nc" id="L132">  val DescriptorKey   = &quot;descriptor&quot;</span>
<span class="nc" id="L133">  val OptionsKey      = &quot;options&quot;</span>

<span class="nc bnc" id="L135" title="All 37 branches missed.">  case class SimpleFeatureEncoding(fids: Option[Encoding], geometry: Encoding, date: Encoding, flipAxisOrder: Boolean)</span>

<span class="nc" id="L137">  object SimpleFeatureEncoding {</span>

<span class="nc" id="L139">    val Min: SimpleFeatureEncoding = SimpleFeatureEncoding(Some(Encoding.Min), Encoding.Min, Encoding.Min, flipAxisOrder = false)</span>
<span class="nc" id="L140">    val Max: SimpleFeatureEncoding = SimpleFeatureEncoding(Some(Encoding.Max), Encoding.Max, Encoding.Max, flipAxisOrder = false)</span>

<span class="nc" id="L142">    def min(includeFids: Boolean, proxyFids: Boolean = false, flipAxisOrder: Boolean = false): SimpleFeatureEncoding = {</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">      val fids = if (includeFids) { Some(if (proxyFids) { Encoding.Min } else { Encoding.Max }) } else { None }</span>
<span class="nc" id="L144">      SimpleFeatureEncoding(fids, Encoding.Min, Encoding.Min, flipAxisOrder)</span>
    }

<span class="nc" id="L147">    object Encoding extends Enumeration {</span>
      type Encoding = Value
<span class="nc" id="L149">      val Min, Max = Value</span>
    }
  }

  /**
    * Create a new simple feature vector
    *
    * @param sft simple feature type
    * @param dictionaries map of field names to dictionary values, used for dictionary encoding fields.
    *                     All values must be provided up front.
    * @param encoding options for encoding
    * @param capacity initial capacity for number of features able to be stored in vectors
    * @return
    */
<span class="nc" id="L163">  def create(</span>
      sft: SimpleFeatureType,
      dictionaries: Map[String, ArrowDictionary],
<span class="nc" id="L166">      encoding: SimpleFeatureEncoding = SimpleFeatureEncoding.Min,</span>
<span class="nc" id="L167">      capacity: Int = DefaultCapacity): SimpleFeatureVector = {</span>
<span class="nc" id="L168">    val allocator = ArrowAllocator(s&quot;simple-feature-vector:${sft.getTypeName}&quot;)</span>
<span class="nc" id="L169">    try {</span>
<span class="nc" id="L170">      val metadata = Collections.singletonMap(OptionsKey, SimpleFeatureTypes.encodeUserData(sft))</span>
<span class="nc" id="L171">      val fieldType = new FieldType(true, ArrowType.Struct.INSTANCE, null, metadata)</span>
<span class="nc" id="L172">      val underlying = new StructVector(sft.getTypeName, allocator, fieldType, null)</span>
<span class="nc" id="L173">      val vector = new SimpleFeatureVector(sft, underlying, dictionaries, encoding, Some(allocator))</span>
      // set capacity after all child vectors have been created by the writers, then allocate
<span class="nc" id="L175">      underlying.setInitialCapacity(capacity)</span>
<span class="nc" id="L176">      underlying.allocateNew()</span>
<span class="nc" id="L177">      vector</span>
    } catch {
<span class="nc bnc" id="L179" title="All 2 branches missed.">      case NonFatal(e) =&gt; CloseQuietly(allocator).foreach(e.addSuppressed); throw e</span>
    }
  }

  /**
    * Creates a simple feature vector based on an existing arrow vector
    *
    * @param vector arrow vector
    * @param dictionaries map of field names to dictionary values, used for dictionary encoding fields.
    *                     All values must be provided up front.
    * @return
    */
  def wrap(vector: StructVector, dictionaries: Map[String, ArrowDictionary]): SimpleFeatureVector = {
<span class="nc bnc" id="L192" title="All 2 branches missed.">    val (sft, encoding) = getFeatureType(vector)</span>
<span class="nc" id="L193">    new SimpleFeatureVector(sft, vector, dictionaries, encoding, None)</span>
  }

  /**
    * Create a simple feature vector using a new arrow vector
    *
    * @param vector simple feature vector to copy
    * @param underlying arrow vector
    * @return
    */
  def clone(vector: SimpleFeatureVector, underlying: StructVector): SimpleFeatureVector =
<span class="nc" id="L204">    new SimpleFeatureVector(vector.sft, underlying, vector.dictionaries, vector.encoding, None)</span>

  /**
    * Reads the feature type and feature encoding from an existing arrow vector
    *
    * @param vector vector
    * @return
    */
  def getFeatureType(vector: StructVector): (SimpleFeatureType, SimpleFeatureEncoding) = {
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

    import scala.collection.JavaConverters._

<span class="nc" id="L217">    val attributes = ArrayBuffer.empty[String]</span>
<span class="nc" id="L218">    var fidEncoding: Option[Encoding] = None</span>

<span class="nc" id="L220">    vector.getField.getChildren.asScala.foreach { field =&gt;</span>
<span class="nc bnc" id="L221" title="All 6 branches missed.">      if (field.getName == FeatureIdField) {</span>
<span class="nc" id="L222">        field.getType match {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">          case _: ArrowType.Int           =&gt; fidEncoding = Some(Encoding.Min) // proxy id encoded fids</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">          case _: ArrowType.FixedSizeList =&gt; fidEncoding = Some(Encoding.Max) // uuid encoded fids</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">          case _: ArrowType.Utf8          =&gt; fidEncoding = Some(Encoding.Max) // normal string fids</span>
<span class="nc" id="L226">          case _ =&gt; throw new IllegalArgumentException(s&quot;Found feature ID vector field of unexpected type: $field&quot;)</span>
        }
      } else {
<span class="nc" id="L229">        attributes.append(field.getMetadata.get(DescriptorKey))</span>
      }
    }
    // add sft-level metadata
<span class="nc" id="L233">    val options = Option(vector.getField.getMetadata.get(OptionsKey)).getOrElse(&quot;&quot;)</span>

<span class="nc" id="L235">    val sft = SimpleFeatureTypes.createImmutableType(vector.getField.getName, attributes.mkString(&quot;,&quot;) + options)</span>
    val geomPrecision = {
      val geomVector: Option[FieldVector] =
<span class="nc" id="L238">        Option(sft.getGeomField).flatMap(d =&gt; Option(vector.getChild(d))).orElse(getNestedVector[Geometry](sft, vector))</span>
<span class="nc bnc" id="L239" title="All 6 branches missed.">      val isDouble = geomVector.exists(v =&gt; GeometryFields.precisionFromField(v.getField) == FloatingPointPrecision.DOUBLE)</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">      if (isDouble) { Encoding.Max } else { Encoding.Min }</span>
    }
    val datePrecision = {
      val dateVector: Option[FieldVector] =
<span class="nc" id="L244">        sft.getDtgField.flatMap(d =&gt; Option(vector.getChild(d))).orElse(getNestedVector[Date](sft, vector))</span>
<span class="nc" id="L245">      val isLong = dateVector.exists(_.isInstanceOf[BigIntVector])</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">      if (isLong) { Encoding.Max } else { Encoding.Min }</span>
    }
<span class="nc" id="L248">    val encoding = SimpleFeatureEncoding(fidEncoding, geomPrecision, datePrecision, flipAxisOrder = false)</span>

<span class="nc" id="L250">    (sft, encoding)</span>
  }

  def isGeometryVector(vector: FieldVector): Boolean = {
<span class="nc" id="L254">    Option(vector.getField.getMetadata.get(DescriptorKey))</span>
<span class="nc" id="L255">        .map(SimpleFeatureTypes.createDescriptor)</span>
<span class="nc" id="L256">        .exists(d =&gt; classOf[Geometry].isAssignableFrom(d.getType.getBinding))</span>
  }

  /**
    * Checks nested vector types (lists and maps) for instances of the given type
    *
    * @param sft simple feature type
    * @param vector simple feature vector
    * @param ct class tag
    *
    * @return
    */
  private def getNestedVector[T](sft: SimpleFeatureType,
                                 vector: StructVector)
                                (implicit ct: ClassTag[T]): Option[FieldVector] = {
    import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

    import scala.collection.JavaConverters._

<span class="nc" id="L275">    sft.getAttributeDescriptors.asScala.flatMap {</span>
<span class="nc bnc" id="L276" title="All 4 branches missed.">      case d if d.isList &amp;&amp; ct.runtimeClass.isAssignableFrom(d.getListType()) =&gt;</span>
<span class="nc" id="L277">        Option(vector.getChild(d.getLocalName).asInstanceOf[ListVector]).map(_.getDataVector)</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">      case d if d.isMap &amp;&amp; ct.runtimeClass.isAssignableFrom(d.getMapTypes()._1) =&gt;</span>
<span class="nc" id="L279">        Option(vector.getChild(d.getLocalName).asInstanceOf[StructVector]).map(_.getChildrenFromFields.get(0))</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">      case d if d.isMap &amp;&amp; ct.runtimeClass.isAssignableFrom(d.getMapTypes()._2) =&gt;</span>
<span class="nc" id="L281">        Option(vector.getChild(d.getLocalName).asInstanceOf[StructVector]).map(_.getChildrenFromFields.get(1))</span>
<span class="nc" id="L282">      case _ =&gt; None</span>
    }.headOption
  }
<span class="nc" id="L285">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>