<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrowAttributeReader.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Arrow GeoTools Abstractions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.arrow.vector</a> &gt; <span class="el_source">ArrowAttributeReader.scala</span></div><h1>ArrowAttributeReader.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.arrow.vector

import org.apache.arrow.vector._
import org.apache.arrow.vector.complex.{BaseRepeatedValueVector, FixedSizeListVector, ListVector, StructVector}
import org.apache.arrow.vector.holders._
import org.apache.arrow.vector.types.Types.MinorType
import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.arrow.jts._
import org.locationtech.geomesa.arrow.jts.impl.{AbstractLineStringVector, AbstractPointVector}
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding.Encoding
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding.Encoding.Encoding
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.jts.geom._

import java.nio.charset.StandardCharsets
import java.util.concurrent.atomic.AtomicLong
import java.util.{Date, UUID}

/**
  * Reads a simple feature attribute from an arrow vector
  */
<span class="nc" id="L33">trait ArrowAttributeReader {</span>

  /**
    * Read an attribute from the ith feature in the simple feature vector
    *
    * @param i index of the feature to read
    * @return the attribute value
    */
  def apply(i: Int): AnyRef

  /**
    * Handle to the underlying field vector being read from
    *
    * @return
    */
  def vector: FieldVector

  /**
    *
    * @return
    */
<span class="nc" id="L54">  def getValueCount: Int = vector.getValueCount</span>
}

<span class="nc" id="L57">object ArrowAttributeReader {</span>

  import scala.collection.JavaConverters._

  /**
    * Reads an ID
    *
    * @param sft simple feature type
    * @param vector simple feature vector to read from
    * @param encoding encoding options
    * @return
    */
  def id(
      sft: SimpleFeatureType,
      vector: StructVector,
<span class="nc" id="L72">      encoding: SimpleFeatureEncoding = SimpleFeatureEncoding.Min): ArrowAttributeReader = {</span>
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L75">    def child: FieldVector = vector.getChild(SimpleFeatureVector.FeatureIdField)</span>

<span class="nc" id="L77">    encoding.fids match {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      case None                             =&gt; ArrowAttributeReader.ArrowFeatureIdIncrementingReader</span>
<span class="nc bnc" id="L79" title="All 8 branches missed.">      case Some(Encoding.Min)               =&gt; new ArrowFeatureIdMinimalReader(child.asInstanceOf[IntVector])</span>
<span class="nc bnc" id="L80" title="All 10 branches missed.">      case Some(Encoding.Max) if sft.isUuid =&gt; new ArrowFeatureIdUuidReader(child.asInstanceOf[FixedSizeListVector])</span>
<span class="nc bnc" id="L81" title="All 8 branches missed.">      case Some(Encoding.Max)               =&gt; new ArrowStringReader(child.asInstanceOf[VarCharVector])</span>
    }
  }

  /**
    * Creates a sequence of attribute readers based on the attributes of the simple feature type. There
    * will be one reader per attribute.
    *
    * @param sft simple feature type
    * @param vector simple feature vector to read from
    * @param dictionaries dictionaries, if any
    * @param encoding encoding options
    * @return sequence of readers
    */
  def apply(sft: SimpleFeatureType,
            vector: StructVector,
            dictionaries: Map[String, ArrowDictionary],
<span class="nc" id="L98">            encoding: SimpleFeatureEncoding = SimpleFeatureEncoding.Min): Seq[ArrowAttributeReader] = {</span>
<span class="nc" id="L99">    sft.getAttributeDescriptors.asScala.map { descriptor =&gt;</span>
<span class="nc" id="L100">      val name = descriptor.getLocalName</span>
<span class="nc" id="L101">      val dictionary = dictionaries.get(name).orElse(dictionaries.get(descriptor.getLocalName))</span>
<span class="nc" id="L102">      apply(descriptor, vector.getChild(name), dictionary, encoding)</span>
    }.toSeq
  }

  def apply(descriptor: AttributeDescriptor,
            vector: FieldVector,
            dictionary: Option[ArrowDictionary],
            encoding: SimpleFeatureEncoding): ArrowAttributeReader = {
<span class="nc" id="L110">    apply(ObjectType.selectType(descriptor), vector, dictionary, encoding)</span>
  }

  /**
    * Creates an attribute reader for a single attribute
    *
    * @param bindings object bindings, the attribute type plus any subtypes (e.g. for lists or maps)
    * @param vector the simple feature vector to read from
    * @param dictionary the dictionary for the attribute, if any
    * @param encoding encoding options
    * @return reader
    */
  def apply(bindings: Seq[ObjectType],
            vector: FieldVector,
            dictionary: Option[ArrowDictionary],
            encoding: SimpleFeatureEncoding): ArrowAttributeReader = {
<span class="nc" id="L126">    dictionary match {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      case None =&gt;</span>
<span class="nc" id="L128">        bindings.head match {</span>
<span class="nc bnc" id="L129" title="All 6 branches missed.">          case ObjectType.GEOMETRY =&gt; ArrowGeometryReader(vector, bindings(1), encoding.geometry)</span>
<span class="nc bnc" id="L130" title="All 6 branches missed.">          case ObjectType.DATE     =&gt; ArrowDateReader(vector, encoding.date)</span>
<span class="nc bnc" id="L131" title="All 6 branches missed.">          case ObjectType.STRING   =&gt; new ArrowStringReader(vector.asInstanceOf[VarCharVector])</span>
<span class="nc bnc" id="L132" title="All 6 branches missed.">          case ObjectType.INT      =&gt; new ArrowIntReader(vector.asInstanceOf[IntVector])</span>
<span class="nc bnc" id="L133" title="All 6 branches missed.">          case ObjectType.LONG     =&gt; new ArrowLongReader(vector.asInstanceOf[BigIntVector])</span>
<span class="nc bnc" id="L134" title="All 6 branches missed.">          case ObjectType.FLOAT    =&gt; new ArrowFloatReader(vector.asInstanceOf[Float4Vector])</span>
<span class="nc bnc" id="L135" title="All 6 branches missed.">          case ObjectType.DOUBLE   =&gt; new ArrowDoubleReader(vector.asInstanceOf[Float8Vector])</span>
<span class="nc bnc" id="L136" title="All 6 branches missed.">          case ObjectType.BOOLEAN  =&gt; new ArrowBooleanReader(vector.asInstanceOf[BitVector])</span>
<span class="nc bnc" id="L137" title="All 6 branches missed.">          case ObjectType.LIST     =&gt; new ArrowListReader(vector.asInstanceOf[ListVector], bindings(1), encoding)</span>
<span class="nc bnc" id="L138" title="All 6 branches missed.">          case ObjectType.MAP      =&gt; new ArrowMapReader(vector.asInstanceOf[StructVector], bindings(1), bindings(2), encoding)</span>
<span class="nc bnc" id="L139" title="All 6 branches missed.">          case ObjectType.BYTES    =&gt; new ArrowByteReader(vector.asInstanceOf[VarBinaryVector])</span>
<span class="nc bnc" id="L140" title="All 6 branches missed.">          case ObjectType.UUID     =&gt; new ArrowUuidReader(vector.asInstanceOf[FixedSizeListVector])</span>
<span class="nc" id="L141">          case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type ${bindings.head}&quot;)</span>
        }

<span class="nc bnc" id="L144" title="All 2 branches missed.">      case Some(dict) =&gt;</span>
<span class="nc" id="L145">        vector match {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">          case v: TinyIntVector  =&gt; new ArrowDictionaryByteReader(v, dict)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">          case v: SmallIntVector =&gt; new ArrowDictionaryShortReader(v, dict)</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">          case v: IntVector      =&gt; new ArrowDictionaryIntReader(v, dict)</span>

<span class="nc bnc" id="L150" title="All 2 branches missed.">          case v: ListVector =&gt;</span>
<span class="nc" id="L151">            val nested = v.getField.getChildren.get(0).getType</span>
<span class="nc bnc" id="L152" title="All 6 branches missed.">            if (nested == MinorType.TINYINT.getType) {</span>
<span class="nc" id="L153">              new ArrowListDictionaryByteReader(v, dict)</span>
<span class="nc bnc" id="L154" title="All 6 branches missed.">            } else if (nested == MinorType.SMALLINT.getType) {</span>
<span class="nc" id="L155">              new ArrowListDictionaryShortReader(v, dict)</span>
<span class="nc bnc" id="L156" title="All 6 branches missed.">            } else if (nested == MinorType.INT.getType) {</span>
<span class="nc" id="L157">              new ArrowListDictionaryIntReader(v, dict)</span>
            } else {
<span class="nc" id="L159">              throw new IllegalArgumentException(s&quot;Unexpected dictionary vector: $vector&quot;)</span>
            }

<span class="nc" id="L162">          case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected dictionary vector: $vector&quot;)</span>
        }
    }
  }

  /**
   * Transparently reads dictionary encoded values
   */
  trait ArrowDictionaryReader extends ArrowAttributeReader {

    /**
     * Gets the raw underlying value without dictionary decoding it
     *
     * @param i index of the feature to read
     * @return
     */
    def getEncoded(i: Int): Integer
  }

  /**
   * Transparently reads lists of dictionary encoded values
   */
  trait ArrowListDictionaryReader extends ArrowAttributeReader {

    /**
     * Gets the raw underlying value without dictionary decoding it
     *
     * @param i index of the feature to read
     * @return
     */
    def getEncoded(i: Int): java.util.List[Integer]
  }

  /**
   * Reads dictionary encoded bytes and converts them to the actual values
   *
   * @param vector encoded vector to read
   * @param dictionary dictionary values
   */
<span class="nc" id="L201">  class ArrowDictionaryByteReader(override val vector: TinyIntVector, dictionary: ArrowDictionary)</span>
<span class="nc" id="L202">      extends ArrowDictionaryReader {</span>

<span class="nc" id="L204">    private val holder = new NullableTinyIntHolder</span>

    override def apply(i: Int): AnyRef = {
<span class="nc" id="L207">      vector.get(i, holder)</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else {</span>
<span class="nc" id="L209">        dictionary.lookup(holder.value)</span>
      }
    }

    override def getEncoded(i: Int): Integer = {
<span class="nc" id="L214">      vector.get(i, holder)</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else { Int.box(holder.value) }</span>
    }
  }

  /**
   * Reads lists of dictionary encoded bytes and converts them to the actual values
   *
   * @param vector encoded vector to read
   * @param dictionary dictionary values
   */
<span class="nc" id="L225">  class ArrowListDictionaryByteReader(override val vector: ListVector, dictionary: ArrowDictionary)</span>
<span class="nc" id="L226">      extends ArrowListDictionaryReader {</span>

<span class="nc" id="L228">    private val inner = vector.getDataVector.asInstanceOf[TinyIntVector]</span>
<span class="nc" id="L229">    private val holder = new NullableTinyIntHolder</span>

    override def apply(i: Int): AnyRef = {
<span class="nc bnc" id="L232" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
        // note: the offset buffer can be swapped out, so don't hold on to any references to it
<span class="nc" id="L234">        var offset = vector.getOffsetBuffer.getInt(i * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L235">        val end = vector.getOffsetBuffer.getInt((i + 1) * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L236">        val list = new java.util.ArrayList[AnyRef](end - offset)</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        while (offset &lt; end) {</span>
<span class="nc" id="L238">          inner.get(offset, holder)</span>
<span class="nc" id="L239">          list.add(dictionary.lookup(holder.value))</span>
<span class="nc" id="L240">          offset += 1</span>
        }
<span class="nc" id="L242">        list</span>
      }
    }

    override def getEncoded(i: Int): java.util.List[Integer] = {
<span class="nc bnc" id="L247" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
        // note: the offset buffer can be swapped out, so don't hold on to any references to it
<span class="nc" id="L249">        var offset = vector.getOffsetBuffer.getInt(i * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L250">        val end = vector.getOffsetBuffer.getInt((i + 1) * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L251">        val list = new java.util.ArrayList[Integer](end - offset)</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        while (offset &lt; end) {</span>
<span class="nc" id="L253">          inner.get(offset, holder)</span>
<span class="nc" id="L254">          list.add(holder.value)</span>
<span class="nc" id="L255">          offset += 1</span>
        }
<span class="nc" id="L257">        list</span>
      }
    }
  }

  /**
   * Reads dictionary encoded shorts and converts them to the actual values
   *
   * @param vector encoded vector to read
   * @param dictionary dictionary values
   */
<span class="nc" id="L268">  class ArrowDictionaryShortReader(override val vector: SmallIntVector, dictionary: ArrowDictionary)</span>
<span class="nc" id="L269">      extends ArrowDictionaryReader {</span>

<span class="nc" id="L271">    private val holder = new NullableSmallIntHolder</span>

    override def apply(i: Int): AnyRef = {
<span class="nc" id="L274">      vector.get(i, holder)</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else {</span>
<span class="nc" id="L276">        dictionary.lookup(holder.value)</span>
      }
    }

    override def getEncoded(i: Int): Integer = {
<span class="nc" id="L281">      vector.get(i, holder)</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else { Int.box(holder.value) }</span>
    }
  }

  /**
   * Reads lists of dictionary encoded shorts and converts them to the actual values
   *
   * @param vector encoded vector to read
   * @param dictionary dictionary values
   */
<span class="nc" id="L292">  class ArrowListDictionaryShortReader(override val vector: ListVector, dictionary: ArrowDictionary)</span>
<span class="nc" id="L293">      extends ArrowListDictionaryReader {</span>

<span class="nc" id="L295">    private val inner = vector.getDataVector.asInstanceOf[SmallIntVector]</span>
<span class="nc" id="L296">    private val holder = new NullableSmallIntHolder</span>

    override def apply(i: Int): AnyRef = {
<span class="nc bnc" id="L299" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
        // note: the offset buffer can be swapped out, so don't hold on to any references to it
<span class="nc" id="L301">        var offset = vector.getOffsetBuffer.getInt(i * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L302">        val end = vector.getOffsetBuffer.getInt((i + 1) * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L303">        val list = new java.util.ArrayList[AnyRef](end - offset)</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        while (offset &lt; end) {</span>
<span class="nc" id="L305">          inner.get(offset, holder)</span>
<span class="nc" id="L306">          list.add(dictionary.lookup(holder.value))</span>
<span class="nc" id="L307">          offset += 1</span>
        }
<span class="nc" id="L309">        list</span>
      }
    }

    override def getEncoded(i: Int): java.util.List[Integer] = {
<span class="nc bnc" id="L314" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
        // note: the offset buffer can be swapped out, so don't hold on to any references to it
<span class="nc" id="L316">        var offset = vector.getOffsetBuffer.getInt(i * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L317">        val end = vector.getOffsetBuffer.getInt((i + 1) * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L318">        val list = new java.util.ArrayList[Integer](end - offset)</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        while (offset &lt; end) {</span>
<span class="nc" id="L320">          inner.get(offset, holder)</span>
<span class="nc" id="L321">          list.add(holder.value)</span>
<span class="nc" id="L322">          offset += 1</span>
        }
<span class="nc" id="L324">        list</span>
      }
    }
  }

  /**
   * Reads dictionary encoded ints and converts them to the actual values
   *
   * @param vector encoded vector to read
   * @param dictionary dictionary values
   */
<span class="nc" id="L335">  class ArrowDictionaryIntReader(override val vector: IntVector, dictionary: ArrowDictionary)</span>
<span class="nc" id="L336">      extends ArrowDictionaryReader {</span>

<span class="nc" id="L338">    private val holder = new NullableIntHolder</span>

    override def apply(i: Int): AnyRef = {
<span class="nc" id="L341">      vector.get(i, holder)</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else {</span>
<span class="nc" id="L343">        dictionary.lookup(holder.value)</span>
      }
    }

    override def getEncoded(i: Int): Integer = {
<span class="nc" id="L348">      vector.get(i, holder)</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else { Int.box(holder.value) }</span>
    }
  }

  /**
   * Reads lists of dictionary encoded ints and converts them to the actual values
   *
   * @param vector encoded vector to read
   * @param dictionary dictionary values
   */
<span class="nc" id="L359">  class ArrowListDictionaryIntReader(override val vector: ListVector, dictionary: ArrowDictionary)</span>
<span class="nc" id="L360">      extends ArrowListDictionaryReader {</span>

<span class="nc" id="L362">    private val inner = vector.getDataVector.asInstanceOf[IntVector]</span>
<span class="nc" id="L363">    private val holder = new NullableIntHolder</span>

    override def apply(i: Int): AnyRef = {
<span class="nc bnc" id="L366" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
        // note: the offset buffer can be swapped out, so don't hold on to any references to it
<span class="nc" id="L368">        var offset = vector.getOffsetBuffer.getInt(i * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L369">        val end = vector.getOffsetBuffer.getInt((i + 1) * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L370">        val list = new java.util.ArrayList[AnyRef](end - offset)</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        while (offset &lt; end) {</span>
<span class="nc" id="L372">          inner.get(offset, holder)</span>
<span class="nc" id="L373">          list.add(dictionary.lookup(holder.value))</span>
<span class="nc" id="L374">          offset += 1</span>
        }
<span class="nc" id="L376">        list</span>
      }
    }

    override def getEncoded(i: Int): java.util.List[Integer] = {
<span class="nc bnc" id="L381" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
        // note: the offset buffer can be swapped out, so don't hold on to any references to it
<span class="nc" id="L383">        var offset = vector.getOffsetBuffer.getInt(i * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L384">        val end = vector.getOffsetBuffer.getInt((i + 1) * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L385">        val list = new java.util.ArrayList[Integer](end - offset)</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        while (offset &lt; end) {</span>
<span class="nc" id="L387">          inner.get(offset, holder)</span>
<span class="nc" id="L388">          list.add(holder.value)</span>
<span class="nc" id="L389">          offset += 1</span>
        }
<span class="nc" id="L391">        list</span>
      }
    }
  }

<span class="nc" id="L396">  object ArrowGeometryReader {</span>
    def apply(vector: FieldVector, binding: ObjectType, encoding: Encoding): ArrowAttributeReader = {
<span class="nc bnc" id="L398" title="All 6 branches missed.">      if (binding == ObjectType.POINT) {</span>
<span class="nc" id="L399">        val delegate: AbstractPointVector[_] = encoding match {</span>
<span class="nc bnc" id="L400" title="All 6 branches missed.">          case Encoding.Min =&gt; new PointFloatVector(vector.asInstanceOf[FixedSizeListVector])</span>
<span class="nc bnc" id="L401" title="All 6 branches missed.">          case Encoding.Max =&gt; new PointVector(vector.asInstanceOf[FixedSizeListVector])</span>
        }
<span class="nc" id="L403">        new ArrowPointReader(vector, delegate)</span>
<span class="nc bnc" id="L404" title="All 6 branches missed.">      } else if (binding == ObjectType.LINESTRING) {</span>
<span class="nc" id="L405">        val delegate: AbstractLineStringVector[_] = encoding match {</span>
<span class="nc bnc" id="L406" title="All 6 branches missed.">          case Encoding.Min =&gt; new LineStringFloatVector(vector.asInstanceOf[ListVector])</span>
<span class="nc bnc" id="L407" title="All 6 branches missed.">          case Encoding.Max =&gt; new LineStringVector(vector.asInstanceOf[ListVector])</span>
        }
<span class="nc" id="L409">        new ArrowLineStringReader(vector, delegate)</span>
      } else {
<span class="nc bnc" id="L411" title="All 6 branches missed.">        val delegate: GeometryVector[_ &lt;: Geometry, _] = if (binding == ObjectType.POLYGON) {</span>
<span class="nc" id="L412">          encoding match {</span>
<span class="nc bnc" id="L413" title="All 6 branches missed.">            case Encoding.Min =&gt; new PolygonFloatVector(vector.asInstanceOf[ListVector])</span>
<span class="nc bnc" id="L414" title="All 6 branches missed.">            case Encoding.Max =&gt; new PolygonVector(vector.asInstanceOf[ListVector])</span>
          }
<span class="nc bnc" id="L416" title="All 6 branches missed.">        } else if (binding == ObjectType.MULTILINESTRING) {</span>
<span class="nc" id="L417">          encoding match {</span>
<span class="nc bnc" id="L418" title="All 6 branches missed.">            case Encoding.Min =&gt; new MultiLineStringFloatVector(vector.asInstanceOf[ListVector])</span>
<span class="nc bnc" id="L419" title="All 6 branches missed.">            case Encoding.Max =&gt; new MultiLineStringVector(vector.asInstanceOf[ListVector])</span>
          }
<span class="nc bnc" id="L421" title="All 6 branches missed.">        } else if (binding == ObjectType.MULTIPOLYGON) {</span>
<span class="nc" id="L422">          encoding match {</span>
<span class="nc bnc" id="L423" title="All 6 branches missed.">            case Encoding.Min =&gt; new MultiPolygonFloatVector(vector.asInstanceOf[ListVector])</span>
<span class="nc bnc" id="L424" title="All 6 branches missed.">            case Encoding.Max =&gt; new MultiPolygonVector(vector.asInstanceOf[ListVector])</span>
          }
<span class="nc bnc" id="L426" title="All 6 branches missed.">        } else if (binding == ObjectType.MULTIPOINT) {</span>
<span class="nc" id="L427">          encoding match {</span>
<span class="nc bnc" id="L428" title="All 6 branches missed.">            case Encoding.Min =&gt; new MultiPointFloatVector(vector.asInstanceOf[ListVector])</span>
<span class="nc bnc" id="L429" title="All 6 branches missed.">            case Encoding.Max =&gt; new MultiPointVector(vector.asInstanceOf[ListVector])</span>
          }
<span class="nc bnc" id="L431" title="All 6 branches missed.">        } else if (binding == ObjectType.GEOMETRY) {</span>
<span class="nc" id="L432">          new WKBGeometryVector(vector.asInstanceOf[VarBinaryVector])</span>
<span class="nc bnc" id="L433" title="All 6 branches missed.">        } else if (binding == ObjectType.GEOMETRY_COLLECTION) {</span>
<span class="nc" id="L434">          new WKBGeometryVector(vector.asInstanceOf[VarBinaryVector])</span>
        } else {
<span class="nc" id="L436">          throw new IllegalArgumentException(s&quot;Expected geometry type, got $binding&quot;)</span>
        }
<span class="nc" id="L438">        new ArrowGeometryReader(vector, delegate)</span>
      }
    }
  }

  /**
    * Reads geometries - delegates to our JTS geometry vectors
    */
<span class="nc" id="L446">  class ArrowGeometryReader(override val vector: FieldVector, delegate: GeometryVector[_ &lt;: Geometry, _])</span>
<span class="nc" id="L447">      extends ArrowAttributeReader {</span>
<span class="nc" id="L448">    override def apply(i: Int): AnyRef = delegate.get(i)</span>
  }

  /**
    * Subclass with special methods for reading coordinate directly
    */
<span class="nc" id="L454">  class ArrowPointReader(override val vector: FieldVector, delegate: AbstractPointVector[_])</span>
<span class="nc" id="L455">      extends ArrowAttributeReader {</span>

<span class="nc" id="L457">    override def apply(i: Int): AnyRef = delegate.get(i)</span>

    /**
      * Reads the first (y) ordinal for the given point
      *
      * @param i index of the point to read
      * @return y ordinal
      */
<span class="nc" id="L465">    def readPointY(i: Int): Double = delegate.getCoordinateY(i)</span>

    /**
      * Reads the second (x) ordinal for the given point
      *
      * @param i index of the point to read
      * @return x ordinal
      */
<span class="nc" id="L473">    def readPointX(i: Int): Double = delegate.getCoordinateX(i)</span>
  }

  /**
    * Subclass with special methods for reading coordinate directly
    */
<span class="nc" id="L479">  class ArrowLineStringReader(override val vector: FieldVector, delegate: AbstractLineStringVector[_])</span>
<span class="nc" id="L480">      extends ArrowAttributeReader {</span>

<span class="nc" id="L482">    override def apply(i: Int): AnyRef = delegate.get(i)</span>

    /**
      * Gets the offsets for points in the ith line
      *
      * @param i index of the line to read offsets for
      * @return (offset start, offset end)
      */
<span class="nc" id="L490">    def readOffsets(i: Int): (Int, Int) = (delegate.getStartOffset(i), delegate.getEndOffset(i))</span>

    /**
      * Reads the first (y) ordinal for the given point
      *
      * @param offset offset, from readOffsetStart/End, of the point to read
      * @return y ordinal
      */
<span class="nc" id="L498">    def readPointY(offset: Int): Double = delegate.getCoordinateY(offset)</span>

    /**
      * Reads the second (x) ordinal for the given point
      *
      * @param offset offset, from readOffsetStart/End, of the point to read
      * @return x ordinal
      */
<span class="nc" id="L506">    def readPointX(offset: Int): Double = delegate.getCoordinateX(offset)</span>
  }

  /**
    * Returns an incrementing Long to use as a feature id
    */
<span class="nc" id="L512">  object ArrowFeatureIdIncrementingReader extends ArrowAttributeReader {</span>
<span class="nc" id="L513">    private val ids = new AtomicLong(0)</span>
<span class="nc" id="L514">    override val vector: FieldVector = null</span>
<span class="nc" id="L515">    override def apply(i: Int): AnyRef = ids.getAndIncrement.toString</span>
<span class="nc" id="L516">    override def getValueCount: Int = 0</span>
  }

<span class="nc" id="L519">  class ArrowFeatureIdUuidReader(vector: FixedSizeListVector) extends ArrowUuidReader(vector) {</span>
<span class="nc" id="L520">    override def apply(i: Int): AnyRef = String.valueOf(super.apply(i))</span>
  }

<span class="nc" id="L523">  class ArrowFeatureIdMinimalReader(vector: IntVector) extends ArrowIntReader(vector) {</span>
<span class="nc" id="L524">    override def apply(i: Int): AnyRef = String.valueOf(super.apply(i))</span>
  }

<span class="nc" id="L527">  class ArrowStringReader(override val vector: VarCharVector) extends ArrowAttributeReader {</span>
<span class="nc" id="L528">    private val holder = new NullableVarCharHolder</span>
<span class="nc" id="L529">    private var bytes = Array.empty[Byte]</span>
    override def apply(i: Int): AnyRef = {
<span class="nc" id="L531">      vector.get(i, holder)</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else {</span>
<span class="nc" id="L533">        val length = holder.end - holder.start</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (bytes.length &lt; length) {</span>
<span class="nc" id="L535">          bytes = Array.ofDim(math.ceil(length * 1.3).toInt)</span>
        }
<span class="nc" id="L537">        holder.buffer.getBytes(holder.start, bytes, 0, length)</span>
<span class="nc" id="L538">        new String(bytes, 0, length, StandardCharsets.UTF_8)</span>
      }
    }
  }

<span class="nc" id="L543">  class ArrowIntReader(override val vector: IntVector) extends ArrowAttributeReader {</span>
<span class="nc" id="L544">    override def apply(i: Int): AnyRef = vector.getObject(i)</span>
  }

<span class="nc" id="L547">  class ArrowLongReader(override val vector: BigIntVector) extends ArrowAttributeReader {</span>
<span class="nc" id="L548">    override def apply(i: Int): AnyRef = vector.getObject(i)</span>
  }

<span class="nc" id="L551">  class ArrowFloatReader(override val vector: Float4Vector) extends ArrowAttributeReader {</span>
<span class="nc" id="L552">    override def apply(i: Int): AnyRef = vector.getObject(i)</span>
  }

<span class="nc" id="L555">  class ArrowDoubleReader(override val vector: Float8Vector) extends ArrowAttributeReader {</span>
<span class="nc" id="L556">    override def apply(i: Int): AnyRef = vector.getObject(i)</span>
  }

<span class="nc" id="L559">  class ArrowBooleanReader(override val vector: BitVector) extends ArrowAttributeReader {</span>
<span class="nc" id="L560">    override def apply(i: Int): AnyRef = vector.getObject(i)</span>
  }

  trait ArrowDateReader extends ArrowAttributeReader {
    def getTime(i: Int): Long
  }

<span class="nc" id="L567">  object ArrowDateReader {</span>
    def apply(vector: FieldVector, encoding: Encoding): ArrowDateReader = {
<span class="nc" id="L569">      encoding match {</span>
<span class="nc bnc" id="L570" title="All 6 branches missed.">        case Encoding.Min =&gt; new ArrowDateSecondsReader(vector.asInstanceOf[IntVector])</span>
<span class="nc bnc" id="L571" title="All 6 branches missed.">        case Encoding.Max =&gt; new ArrowDateMillisReader(vector.asInstanceOf[BigIntVector])</span>
      }
    }
  }

<span class="nc" id="L576">  class ArrowDateMillisReader(override val vector: BigIntVector) extends ArrowDateReader {</span>
<span class="nc" id="L577">    private val holder = new NullableBigIntHolder</span>
    override def apply(i: Int): AnyRef = {
<span class="nc" id="L579">      vector.get(i, holder)</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else {</span>
<span class="nc" id="L581">        new Date(holder.value)</span>
      }
    }
    override def getTime(i: Int): Long = {
<span class="nc" id="L585">      vector.get(i, holder)</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">      if (holder.isSet == 0) { 0L } else {</span>
<span class="nc" id="L587">        holder.value</span>
      }
    }
  }

<span class="nc" id="L592">  class ArrowDateSecondsReader(override val vector: IntVector) extends ArrowDateReader {</span>
<span class="nc" id="L593">    private val holder = new NullableIntHolder</span>
    override def apply(i: Int): AnyRef = {
<span class="nc" id="L595">      vector.get(i, holder)</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">      if (holder.isSet == 0) { null } else {</span>
<span class="nc" id="L597">        new Date(holder.value * 1000L)</span>
      }
    }
    override def getTime(i: Int): Long = {
<span class="nc" id="L601">      vector.get(i, holder)</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">      if (holder.isSet == 0) { 0L } else {</span>
<span class="nc" id="L603">        holder.value * 1000L</span>
      }
    }
  }

<span class="nc" id="L608">  class ArrowByteReader(override val vector: VarBinaryVector) extends ArrowAttributeReader {</span>
<span class="nc" id="L609">    override def apply(i: Int): AnyRef = vector.getObject(i)</span>
  }

<span class="nc" id="L612">  class ArrowUuidReader(override val vector: FixedSizeListVector) extends ArrowAttributeReader {</span>
<span class="nc" id="L613">    private val bits = vector.getChildrenFromFields.get(0).asInstanceOf[BigIntVector]</span>
    override def apply(i: Int): AnyRef = {
<span class="nc bnc" id="L615" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
<span class="nc" id="L616">        val msb = bits.get(i * 2)</span>
<span class="nc" id="L617">        val lsb = bits.get(i * 2 + 1)</span>
<span class="nc" id="L618">        new UUID(msb, lsb)</span>
      }
    }
  }

<span class="nc" id="L623">  class ArrowListReader(override val vector: ListVector, binding: ObjectType, encoding: SimpleFeatureEncoding)</span>
<span class="nc" id="L624">      extends ArrowAttributeReader {</span>
<span class="nc" id="L625">    private val reader = ArrowAttributeReader(Seq(binding), vector.getDataVector, None, encoding)</span>
    override def apply(i: Int): AnyRef = {
<span class="nc bnc" id="L627" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
        // note: the offset buffer can be swapped out, so don't hold on to any references to it
<span class="nc" id="L629">        var offset = vector.getOffsetBuffer.getInt(i * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L630">        val end = vector.getOffsetBuffer.getInt((i + 1) * BaseRepeatedValueVector.OFFSET_WIDTH)</span>
<span class="nc" id="L631">        val list = new java.util.ArrayList[AnyRef](end - offset)</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        while (offset &lt; end) {</span>
<span class="nc" id="L633">          list.add(reader.apply(offset))</span>
<span class="nc" id="L634">          offset += 1</span>
        }
<span class="nc" id="L636">        list</span>
      }
    }
  }

<span class="nc" id="L641">  class ArrowMapReader(override val vector: StructVector,</span>
                       keyBinding: ObjectType,
                       valueBinding: ObjectType,
<span class="nc" id="L644">                       encoding: SimpleFeatureEncoding) extends ArrowAttributeReader {</span>
<span class="nc" id="L645">    private val keyReader = ArrowAttributeReader(Seq(ObjectType.LIST, keyBinding), vector.getChild(&quot;k&quot;), None, encoding)</span>
<span class="nc" id="L646">    private val valueReader = ArrowAttributeReader(Seq(ObjectType.LIST, valueBinding), vector.getChild(&quot;v&quot;), None, encoding)</span>
    override def apply(i: Int): AnyRef = {
<span class="nc bnc" id="L648" title="All 2 branches missed.">      if (vector.isNull(i)) { null } else {</span>
<span class="nc" id="L649">        val keys = keyReader.apply(i).asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc" id="L650">        val values = valueReader.apply(i).asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc" id="L651">        val map = new java.util.HashMap[AnyRef, AnyRef](keys.size)</span>
<span class="nc" id="L652">        var count = 0</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        while (count &lt; keys.size()) {</span>
<span class="nc" id="L654">          map.put(keys.get(count), values.get(count))</span>
<span class="nc" id="L655">          count += 1</span>
        }
<span class="nc" id="L657">        map</span>
      }
    }
  }
<span class="nc" id="L661">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>