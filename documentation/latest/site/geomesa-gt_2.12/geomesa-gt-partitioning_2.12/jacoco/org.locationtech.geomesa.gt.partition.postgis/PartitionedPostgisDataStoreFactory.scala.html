<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartitionedPostgisDataStoreFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa GeoTools Postgis Partitioning</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.gt.partition.postgis</a> &gt; <span class="el_source">PartitionedPostgisDataStoreFactory.scala</span></div><h1>PartitionedPostgisDataStoreFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.gt.partition.postgis

import com.typesafe.config.ConfigFactory
import com.typesafe.scalalogging.LazyLogging
import io.micrometer.core.instrument.binder.db.PostgreSQLDatabaseMetrics
import io.micrometer.core.instrument.{Metrics, Tag, Tags}
import org.apache.commons.dbcp.BasicDataSource
import org.geotools.data.jdbc.datasource.AbstractManageableDataSource
import org.geotools.data.postgis.{PostGISDialect, PostGISPSDialect, PostgisNGDataStoreFactory}
import org.geotools.jdbc.{JDBCDataStore, JDBCDataStoreFactory, SQLDialect}
import org.locationtech.geomesa.gt.partition.postgis.PartitionedPostgisDataStoreFactory.Dbcp2ManagedDataSource
import org.locationtech.geomesa.gt.partition.postgis.dialect.{PartitionedPostgisDialect, PartitionedPostgisPsDialect, RoleName}
import org.locationtech.geomesa.metrics.micrometer.dbcp2.MetricsDataSource
import org.locationtech.geomesa.utils.io.CloseWithLogging

import java.io.Closeable
import java.time.Duration
import java.util.Collections
import java.util.concurrent.ConcurrentHashMap
import javax.sql.DataSource
import scala.util.control.NonFatal

<span class="nc bnc" id="L31" title="All 4 branches missed.">class PartitionedPostgisDataStoreFactory extends PostgisNGDataStoreFactory with LazyLogging {</span>

  import JDBCDataStoreFactory.{DATABASE, USER}
  import PartitionedPostgisDataStoreParams.{DbType, IdleInTransactionTimeout, PreparedStatements, ReadAccessRoles}
  import org.locationtech.geomesa.index.geotools.GeoMesaDataStoreFactory.{MetricsRegistryConfigParam, MetricsRegistryParam}

  import scala.collection.JavaConverters._

<span class="nc" id="L39">  override def getDisplayName: String = &quot;PostGIS (partitioned)&quot;</span>

<span class="nc" id="L41">  override def getDescription: String = &quot;PostGIS Database with time-partitioned tables&quot;</span>

<span class="nc" id="L43">  override protected def getDatabaseID: String = DbType.sample.asInstanceOf[String]</span>

  override protected def setupParameters(parameters: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L46">    super.setupParameters(parameters)</span>
<span class="nc" id="L47">    Seq(DbType, IdleInTransactionTimeout, PreparedStatements, ReadAccessRoles, MetricsRegistryParam, MetricsRegistryConfigParam)</span>
<span class="nc" id="L48">        .foreach(p =&gt; parameters.put(p.key, p))</span>
  }

  override protected def createDataSource(params: java.util.Map[String, _], dialect: SQLDialect): DataSource = {
<span class="nc" id="L52">    val dataSource = super.createDataSource(params, dialect)</span>

<span class="nc" id="L54">    val metrics = MetricsRegistryParam.lookupRegistry(params).flatMap { registry =&gt;</span>
<span class="nc" id="L55">      var metrics: MetricsDataSource = null</span>
<span class="nc" id="L56">      try {</span>
        // try to re-create the datasource as a commons-dbcp2 instance so we can instrument it
<span class="nc" id="L58">        val basic = dataSource match {</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">          case ds: AbstractManageableDataSource =&gt; ds.unwrap(classOf[BasicDataSource])</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">          case ds: BasicDataSource =&gt; ds</span>
<span class="nc" id="L61">          case ds =&gt; throw new UnsupportedOperationException(s&quot;Unexpected data source class: ${ds.getClass.getName} $ds&quot;)</span>
        }
<span class="nc" id="L63">        metrics = new MetricsDataSource(&quot;postgis&quot;)</span>

        // these are the options that are configured in our parent factories
<span class="nc" id="L66">        metrics.setDriverClassName(basic.getDriverClassName)</span>
<span class="nc" id="L67">        metrics.setUrl(basic.getUrl)</span>
<span class="nc" id="L68">        metrics.setUsername(basic.getUsername)</span>
<span class="nc" id="L69">        metrics.setPassword(basic.getPassword)</span>
<span class="nc" id="L70">        metrics.setMaxWait(Duration.ofMillis(basic.getMaxWait))</span>
<span class="nc" id="L71">        metrics.setMinIdle(basic.getMinIdle)</span>
<span class="nc" id="L72">        metrics.setMaxTotal(basic.getMaxActive)</span>
<span class="nc" id="L73">        metrics.setTestOnBorrow(basic.getTestOnBorrow)</span>
<span class="nc" id="L74">        metrics.setValidationQuery(basic.getValidationQuery)</span>
<span class="nc" id="L75">        metrics.setTestWhileIdle(basic.getTestWhileIdle)</span>
<span class="nc" id="L76">        metrics.setDurationBetweenEvictionRuns(Duration.ofMillis(basic.getTimeBetweenEvictionRunsMillis))</span>
<span class="nc" id="L77">        metrics.setMinEvictableIdle(Duration.ofMillis(basic.getMinEvictableIdleTimeMillis))</span>
<span class="nc" id="L78">        metrics.setNumTestsPerEvictionRun(basic.getNumTestsPerEvictionRun)</span>
<span class="nc" id="L79">        metrics.setAccessToUnderlyingConnectionAllowed(basic.isAccessToUnderlyingConnectionAllowed)</span>
<span class="nc" id="L80">        metrics.setMaxOpenPreparedStatements(basic.getMaxOpenPreparedStatements)</span>
<span class="nc" id="L81">        metrics.setPoolPreparedStatements(basic.isPoolPreparedStatements)</span>

        // re-add connection properties, as we can't access those from the BasicDataSource
<span class="nc bnc" id="L84" title="All 2 branches missed.">        createConnectionOptions(params).foreach { case (k, v) =&gt; metrics.addConnectionProperty(k, v) }</span>

<span class="nc" id="L86">        val registration = registry.register()</span>

<span class="nc" id="L88">        tryBindPostgresMetrics(metrics, params)</span>

        // we attach the registry to the ManagedDataSource b/c that's the only hook we have into datastore.dispose()
<span class="nc" id="L91">        Some(new Dbcp2ManagedDataSource(metrics, registration))</span>
      } catch {
<span class="nc bnc" id="L93" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">          logger.warn(&quot;Unable to instrument data source, metrics will not be available:&quot;, e)</span>
<span class="nc" id="L95">          CloseWithLogging(Option(metrics))</span>
<span class="nc" id="L96">          None</span>
      }
    }

<span class="nc" id="L100">    metrics.getOrElse(dataSource)</span>
  }

  private def tryBindPostgresMetrics(dataSource: MetricsDataSource, params: java.util.Map[String, _]): Unit = {
<span class="nc" id="L104">    try {</span>
      val conf =
<span class="nc" id="L106">        MetricsRegistryConfigParam.lookupOpt(params)</span>
<span class="nc" id="L107">          .getOrElse(ConfigFactory.empty)</span>
<span class="nc" id="L108">          .withFallback(ConfigFactory.load(&quot;postgres-metrics&quot;))</span>
<span class="nc" id="L109">          .getConfig(&quot;postgres&quot;)</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">      if (conf.getBoolean(&quot;enabled&quot;)) {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        val tags = Tags.of(conf.getConfig(&quot;tags&quot;).root().unwrapped().asScala.map { case (k, v) =&gt; Tag.of(k, v.toString) }.asJava)</span>
        val db =
<span class="nc" id="L113">          Option(DATABASE.lookUp(params).asInstanceOf[String])</span>
<span class="nc" id="L114">            .orElse(Option(USER.lookUp(params).asInstanceOf[String]))</span>
<span class="nc" id="L115">            .getOrElse(throw new IllegalArgumentException(s&quot;${DATABASE.key} was not found in the parameter map&quot;))</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (PartitionedPostgisDataStoreFactory.bindings.add(db -&gt; tags)) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">          logger.info(&quot;Adding postgres metrics&quot;)</span>
<span class="nc" id="L118">          new PostgreSQLDatabaseMetrics(dataSource, db, tags).bindTo(Metrics.globalRegistry)</span>
        }
      }
    } catch {
<span class="nc bnc" id="L122" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.warn(&quot;Error binding postgres metrics:&quot;, e)</span>
    }
  }

  override def createDataSource(params: java.util.Map[String, _]): BasicDataSource = {
<span class="nc" id="L127">    val source = super.createDataSource(params)</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    createConnectionOptions(params).foreach { case (k, v) =&gt; source.addConnectionProperty(k, v) }</span>
<span class="nc" id="L129">    source</span>
  }

  override protected def createDataStoreInternal(store: JDBCDataStore, baseParams: java.util.Map[String, _]): JDBCDataStore = {
<span class="nc" id="L133">    val params = new java.util.HashMap[String, Any](baseParams)</span>
    // default to using prepared statements, if not specified
<span class="nc bnc" id="L135" title="All 2 branches missed.">    if (!params.containsKey(PreparedStatements.key)) {</span>
<span class="nc" id="L136">      params.put(PreparedStatements.key, java.lang.Boolean.TRUE)</span>
    }
    // set default schema, if not specified - postgis store doesn't actually use its own default
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (!params.containsKey(PostgisNGDataStoreFactory.SCHEMA.key)) {</span>
      // need to set it in the store, as the key has already been processed
<span class="nc" id="L141">      store.setDatabaseSchema(&quot;public&quot;)</span>
      // also set in the params for consistency, although it's not used anywhere
<span class="nc" id="L143">      params.put(PostgisNGDataStoreFactory.SCHEMA.key, &quot;public&quot;)</span>
    }
<span class="nc" id="L145">    val roles = Option(ReadAccessRoles.lookUp(params).asInstanceOf[String]).toSeq.flatMap(_.split(&quot;,&quot;)).map(r =&gt; RoleName(r.trim))</span>

<span class="nc" id="L147">    val ds = super.createDataStoreInternal(store, params)</span>
<span class="nc" id="L148">    val dialect = new PartitionedPostgisDialect(ds, roles)</span>

<span class="nc" id="L150">    ds.getSQLDialect match {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">      case d: PostGISDialect =&gt;</span>
<span class="nc" id="L152">        dialect.setEncodeBBOXFilterAsEnvelope(d.isEncodeBBOXFilterAsEnvelope)</span>
<span class="nc" id="L153">        dialect.setEstimatedExtentsEnabled(d.isEstimatedExtentsEnabled)</span>
<span class="nc" id="L154">        dialect.setFunctionEncodingEnabled(d.isFunctionEncodingEnabled)</span>
<span class="nc" id="L155">        dialect.setLooseBBOXEnabled(d.isLooseBBOXEnabled)</span>
<span class="nc" id="L156">        dialect.setSimplifyEnabled(d.isSimplifyEnabled)</span>
<span class="nc" id="L157">        ds.setSQLDialect(dialect)</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">      case d: PostGISPSDialect =&gt;</span>
<span class="nc" id="L160">        dialect.setEncodeBBOXFilterAsEnvelope(d.isEncodeBBOXFilterAsEnvelope)</span>
<span class="nc" id="L161">        dialect.setFunctionEncodingEnabled(d.isFunctionEncodingEnabled)</span>
<span class="nc" id="L162">        dialect.setLooseBBOXEnabled(d.isLooseBBOXEnabled)</span>

        // these configs aren't exposed through the PS dialect so re-calculate them from the params
<span class="nc" id="L165">        val est = PostgisNGDataStoreFactory.ESTIMATED_EXTENTS.lookUp(params)</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">        dialect.setEstimatedExtentsEnabled(est == null || est == java.lang.Boolean.TRUE)</span>
<span class="nc" id="L167">        val simplify = PostgisNGDataStoreFactory.SIMPLIFY.lookUp(params)</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">        dialect.setSimplifyEnabled(simplify == null || simplify == java.lang.Boolean.TRUE)</span>

<span class="nc" id="L170">        ds.setSQLDialect(new PartitionedPostgisPsDialect(ds, dialect))</span>

<span class="nc" id="L172">      case d =&gt; throw new IllegalArgumentException(s&quot;Expected PostGISDialect but got: ${d.getClass.getName}&quot;)</span>
    }

<span class="nc" id="L175">    ds</span>
  }

  // these will get replaced in createDataStoreInternal, above
<span class="nc" id="L179">  override protected def createSQLDialect(dataStore: JDBCDataStore): SQLDialect = new PostGISDialect(dataStore)</span>
  override protected def createSQLDialect(dataStore: JDBCDataStore, params: java.util.Map[String, _]): SQLDialect =
<span class="nc" id="L181">    new PostGISDialect(dataStore)</span>

  private def createConnectionOptions(params: java.util.Map[String, _]): Map[String, String] = {
    val options =
<span class="nc" id="L185">      Seq(IdleInTransactionTimeout)</span>
<span class="nc" id="L186">        .flatMap(p =&gt; p.opt(params).map(t =&gt; s&quot;-c ${p.key}=${t.millis}&quot;))</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">    logger.debug(s&quot;Connection options: ${options.mkString(&quot; &quot;)}&quot;)</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">    if (options.isEmpty) {</span>
<span class="nc" id="L191">      Map.empty</span>
    } else {
<span class="nc" id="L193">      Map(&quot;options&quot; -&gt; options.mkString(&quot; &quot;))</span>
    }
  }
}

<span class="nc" id="L198">object PartitionedPostgisDataStoreFactory {</span>

  // instrumentations that we've already bound, to prevent duplicates
<span class="nc" id="L201">  private val bindings = Collections.newSetFromMap(new ConcurrentHashMap[(String, Tags), java.lang.Boolean]())</span>

  /**
   * Managed data source for apache dbcp2. Managed data sources expose a `close` method on data sources.
   *
   * @param wrapped wrapped data source
   * @param registry metrics registry
   */
<span class="nc" id="L209">  class Dbcp2ManagedDataSource(wrapped: org.apache.commons.dbcp2.BasicDataSource, registry: Closeable)</span>
<span class="nc" id="L210">      extends AbstractManageableDataSource(wrapped) {</span>

    override def close(): Unit = {
<span class="nc" id="L213">      CloseWithLogging(registry)</span>
<span class="nc" id="L214">      wrapped.close()</span>
    }

<span class="nc" id="L217">    override def isWrapperFor(c: Class[_]): Boolean = classOf[DataSource].isAssignableFrom(c)</span>

    override def unwrap[T](c: Class[T]): T = {
<span class="nc bnc" id="L220" title="All 2 branches missed.">      if (isWrapperFor(c)) {</span>
<span class="nc" id="L221">        wrapped.asInstanceOf[T]</span>
      } else {
<span class="nc" id="L223">        null.asInstanceOf[T]</span>
      }
    }
  }
<span class="nc" id="L227">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>