<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartitionedPostgisPsDialect.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa GeoTools Postgis Partitioning</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.gt.partition.postgis.dialect</a> &gt; <span class="el_source">PartitionedPostgisPsDialect.scala</span></div><h1>PartitionedPostgisPsDialect.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.gt.partition.postgis.dialect

import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.expression.{Expression, PropertyName}
import org.geotools.api.filter.{BinaryLogicOperator, Filter, Or}
import org.geotools.data.postgis.{PostGISPSDialect, PostgisPSFilterToSql}
import org.geotools.feature.AttributeTypeBuilder
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.geotools.jdbc.{JDBCDataStore, PreparedFilterToSQL}
import org.geotools.util.Version
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.gt.partition.postgis.dialect.PartitionedPostgisPsDialect.PartitionedPostgisPsFilterToSql
import org.locationtech.geomesa.utils.geotools.converters.FastConverter

import java.sql.{Connection, DatabaseMetaData, PreparedStatement, Types}

<span class="nc" id="L26">class PartitionedPostgisPsDialect(store: JDBCDataStore, delegate: PartitionedPostgisDialect)</span>
<span class="nc" id="L27">    extends PostGISPSDialect(store, delegate){</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  override def createPreparedFilterToSQL: PreparedFilterToSQL = {
<span class="nc" id="L32">    val fts = new PartitionedPostgisPsFilterToSql(this, delegate.getPostgreSQLVersion(null))</span>
<span class="nc" id="L33">    fts.setFunctionEncodingEnabled(delegate.isFunctionEncodingEnabled)</span>
<span class="nc" id="L34">    fts.setLooseBBOXEnabled(delegate.isLooseBBOXEnabled)</span>
<span class="nc" id="L35">    fts.setEncodeBBOXFilterAsEnvelope(delegate.isEncodeBBOXFilterAsEnvelope)</span>
<span class="nc" id="L36">    fts.setEscapeBackslash(delegate.isEscapeBackslash)</span>
<span class="nc" id="L37">    fts</span>
  }

  override def setValue(
      value: AnyRef,
      binding: Class[_],
      att: AttributeDescriptor,
      ps: PreparedStatement,
      column: Int,
      cx: Connection): Unit = {
    // json columns are string type in geotools, but we have to use setObject or else we get a binding error
<span class="nc bnc" id="L48" title="All 10 branches missed.">    if (binding == classOf[String] &amp;&amp; att != null &amp;&amp; att.isJson) {</span>
<span class="nc" id="L49">      ps.setObject(column, value, Types.OTHER)</span>
<span class="nc bnc" id="L50" title="All 8 branches missed.">    } else if (binding.isArray || binding == classOf[java.util.List[_]]) {</span>
      // handle bug in jdbc store not calling setArrayValue in update statements
<span class="nc" id="L52">      value match {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">        case null =&gt;</span>
<span class="nc" id="L54">          ps.setNull(column, Types.ARRAY)</span>

<span class="nc bnc" id="L56" title="All 2 branches missed.">        case list: java.util.Collection[_] =&gt;</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">          if (list.isEmpty) {</span>
<span class="nc" id="L58">            ps.setNull(column, Types.ARRAY)</span>
          } else {
<span class="nc" id="L60">            setArrayValue(list.toArray(), att, ps, column, cx)</span>
          }

<span class="nc bnc" id="L63" title="All 2 branches missed.">        case array: Array[_] =&gt;</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">          if (array.isEmpty) {</span>
<span class="nc" id="L65">            ps.setNull(column, Types.ARRAY)</span>
          } else {
<span class="nc" id="L67">            setArrayValue(array, att, ps, column, cx)</span>
          }

        case singleton =&gt;
<span class="nc" id="L71">          setArrayValue(Array(singleton), att, ps, column, cx)</span>
      }
    } else {
<span class="nc" id="L74">      super.setValue(value, binding, att, ps, column, cx)</span>
    }
  }

  override protected def convertToArray(
      value: Any, componentTypeName: String, componentType: Class[_], connection: Connection): java.sql.Array = {
<span class="nc" id="L80">    val array = value match {</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      case list: java.util.List[_] =&gt; list.toArray()</span>
<span class="nc" id="L82">      case _ =&gt; value</span>
    }
<span class="nc" id="L84">    super.convertToArray(array, componentTypeName, componentType, connection)</span>
  }

<span class="nc" id="L87">  override protected def convert[T](value: AnyRef, binding: Class[T]): T = FastConverter.convert(value, binding)</span>

  // fix bug with PostGISPSDialect dialect not delegating these methods
<span class="nc" id="L90">  override def encodeCreateTable(sql: StringBuffer): Unit = delegate.encodeCreateTable(sql)</span>
<span class="nc" id="L91">  override def getDefaultVarcharSize: Int = delegate.getDefaultVarcharSize</span>
<span class="nc" id="L92">  override def encodeTableName(raw: String, sql: StringBuffer): Unit = delegate.encodeTableName(raw, sql)</span>
  override def encodePostCreateTable(tableName: String, sql: StringBuffer): Unit =
<span class="nc" id="L94">    delegate.encodePostCreateTable(tableName, sql)</span>
  override def postCreateAttribute(att: AttributeDescriptor, tableName: String, schemaName: String, cx: Connection): Unit =
<span class="nc" id="L96">    delegate.postCreateAttribute(att, tableName, schemaName, cx)</span>
  override def postCreateFeatureType(
      featureType: SimpleFeatureType,
      metadata: DatabaseMetaData,
      schemaName: String,
      cx: Connection): Unit = {
<span class="nc" id="L102">    delegate.postCreateFeatureType(featureType, metadata, schemaName, cx)</span>
  }
  override def splitFilter(filter: Filter, schema: SimpleFeatureType): Array[Filter] =
<span class="nc" id="L105">    delegate.splitFilter(filter, schema)</span>
<span class="nc" id="L106">  override def getDesiredTablesType: Array[String] = delegate.getDesiredTablesType</span>
  override def encodePostColumnCreateTable(att: AttributeDescriptor, sql: StringBuffer): Unit =
<span class="nc" id="L108">    delegate.encodePostColumnCreateTable(att, sql)</span>
}

<span class="nc" id="L111">object PartitionedPostgisPsDialect {</span>

<span class="nc" id="L113">  class PartitionedPostgisPsFilterToSql(dialect: PartitionedPostgisPsDialect, pgVersion: Version)</span>
<span class="nc" id="L114">      extends PostgisPSFilterToSql(dialect, pgVersion) {</span>

    import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

    import scala.collection.JavaConverters._

    override def setFeatureType(featureType: SimpleFeatureType): Unit = {
      // convert List-type attributes to Array-types so that prepared statement bindings work correctly
<span class="nc bnc" id="L122" title="All 8 branches missed.">      if (featureType.getAttributeDescriptors.asScala.exists(_.getType.getBinding == classOf[java.util.List[_]])) {</span>
<span class="nc" id="L123">        val builder = new SimpleFeatureTypeBuilder() {</span>
          override def init(`type`: SimpleFeatureType): Unit = {
<span class="nc" id="L125">            super.init(`type`)</span>
<span class="nc" id="L126">            attributes().clear()</span>
          }
        }
<span class="nc" id="L129">        builder.init(featureType)</span>
<span class="nc" id="L130">        featureType.getAttributeDescriptors.asScala.foreach { descriptor =&gt;</span>
<span class="nc" id="L131">          val ab = new AttributeTypeBuilder(builder.getFeatureTypeFactory)</span>
<span class="nc" id="L132">          ab.init(descriptor)</span>
<span class="nc bnc" id="L133" title="All 6 branches missed.">          if (descriptor.getType.getBinding == classOf[java.util.List[_]]) {</span>
<span class="nc" id="L134">            ab.setBinding(java.lang.reflect.Array.newInstance(Option(descriptor.getListType()).getOrElse(classOf[String]), 0).getClass)</span>
          }
<span class="nc" id="L136">          builder.add(ab.buildDescriptor(descriptor.getLocalName))</span>
        }
<span class="nc" id="L138">        this.featureType = builder.buildFeatureType()</span>
<span class="nc" id="L139">        this.featureType.getUserData.putAll(featureType.getUserData)</span>
      } else {
<span class="nc" id="L141">        this.featureType = featureType</span>
      }
    }

    // note: this would be a cleaner solution, but it doesn't get invoked due to explicit calls to
    // super.getExpressionType in PostgisPSFilterToSql :/
    override def getExpressionType(expression: Expression): Class[_] = {
<span class="nc bnc" id="L148" title="All 4 branches missed.">      val result = Option(expression).collect { case p: PropertyName =&gt; p }.flatMap { p =&gt;</span>
<span class="nc" id="L149">        Option(p.evaluate(featureType).asInstanceOf[AttributeDescriptor]).map { descriptor =&gt;</span>
<span class="nc" id="L150">          val binding = descriptor.getType.getBinding</span>
<span class="nc bnc" id="L151" title="All 6 branches missed.">          if (binding == classOf[java.util.List[_]]) {</span>
<span class="nc" id="L152">            val listType = descriptor.getListType()</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (listType == null) {</span>
<span class="nc" id="L154">              classOf[Array[String]]</span>
            } else {
<span class="nc" id="L156">              java.lang.reflect.Array.newInstance(listType, 0).getClass</span>
            }
          } else {
<span class="nc" id="L159">            binding</span>
          }
        }
      }

<span class="nc" id="L164">      result.getOrElse(super.getExpressionType(expression))</span>
    }

    override def visit(filter: Or, extraData: AnyRef): AnyRef = {
      // for array-types, skip the super-class implementation, which merges ORs into INs, as it breaks array OR queries
      // for other types, keep the super handling as INs may be more efficient that ORs
<span class="nc bnc" id="L170" title="All 2 branches missed.">      if (FilterHelper.propertyNames(filter).flatMap(name =&gt; Option(featureType.getDescriptor(name))).exists(_.getType.getBinding.isArray)) {</span>
<span class="nc" id="L171">        visit(filter.asInstanceOf[BinaryLogicOperator], &quot;OR&quot;)</span>
      } else {
<span class="nc" id="L173">        super.visit(filter, extraData)</span>
      }
    }
  }
<span class="nc" id="L177">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>