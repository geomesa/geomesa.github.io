<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartitionedPostgisDialect.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa GeoTools Postgis Partitioning</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.gt.partition.postgis.dialect</a> &gt; <span class="el_source">PartitionedPostgisDialect.scala</span></div><h1>PartitionedPostgisDialect.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.gt.partition.postgis.dialect

import com.typesafe.scalalogging.StrictLogging
import org.geotools.api.data.Query
import org.geotools.api.feature.`type`.{AttributeDescriptor, GeometryDescriptor}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.geotools.data.postgis.PostGISDialect
import org.geotools.geometry.jts._
import org.geotools.jdbc.JDBCDataStore
import org.geotools.referencing.CRS
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.gt.partition.postgis.dialect.PartitionedPostgisDialect.{SftUserData, getIndexedColumns}
import org.locationtech.geomesa.gt.partition.postgis.dialect.filter.SplitFilterVisitor
import org.locationtech.geomesa.gt.partition.postgis.dialect.functions.{LogCleaner, TruncateToPartition, TruncateToTenMinutes}
import org.locationtech.geomesa.gt.partition.postgis.dialect.procedures._
import org.locationtech.geomesa.gt.partition.postgis.dialect.tables._
import org.locationtech.geomesa.gt.partition.postgis.dialect.triggers.{DeleteTrigger, InsertTrigger, UpdateTrigger, WriteAheadTrigger}
import org.locationtech.geomesa.index.planning.QueryInterceptor.QueryInterceptorFactory
import org.locationtech.geomesa.utils.geotools.PrimitiveConversions.{Conversion, ConvertToInt}
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeOptions
import org.locationtech.geomesa.utils.io.{CloseWithLogging, WithClose}
import org.locationtech.jts.geom._

import java.sql.{Connection, DatabaseMetaData, ResultSet, Types}
import scala.util.{Failure, Success, Try}

/**
 * Dialect
 *
 * @param store data store
 * @param grants roles that should be granted access to feature types created by this dialect
 */
<span class="nc" id="L43">class PartitionedPostgisDialect(store: JDBCDataStore, grants: Seq[RoleName] = Seq.empty)</span>
<span class="nc" id="L44">    extends PostGISDialect(store) with StrictLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  import scala.collection.JavaConverters._

  // order of calls from JDBCDataStore during create schema:
  //  encodeCreateTable
  //  encodeTableName
  //  encodePrimaryKey
  //  encodeColumnName
  //  encodeColumnType
  //  encodePostColumnCreateTable
  //  encodePostCreateTable
  //  postCreateTable

  // order of calls during remove schema:
  //  preDropTable
  //  &quot;DROP TABLE &quot; + encodeTableName
  //  postDropTable

  // state for checking when we want to use the write_ahead table in place of the main view
<span class="nc" id="L66">  private val dropping = new ThreadLocal[Boolean]() {</span>
<span class="nc" id="L67">    override def initialValue(): Boolean = false</span>
  }

<span class="nc" id="L70">  private val interceptors = {</span>
<span class="nc" id="L71">    val factory = QueryInterceptorFactory(store)</span>
<span class="nc" id="L72">    sys.addShutdownHook(CloseWithLogging(factory)) // we don't have any API hooks to dispose of things...</span>
<span class="nc" id="L73">    factory</span>
  }

  /**
   * Re-create the PLPG/SQL procedures associated with a feature type. This can be used
   * to 'upgrade in place' if the code is changed.
   *
   * @param schemaName database schema, e.g. &quot;public&quot;
   * @param sft feature type
   * @param cx connection
   */
  def upgrade(schemaName: String, sft: SimpleFeatureType, cx: Connection): Unit =
<span class="nc" id="L85">    postCreateTable(schemaName, sft, cx)</span>

<span class="nc" id="L87">  override def getDesiredTablesType: Array[String] = Array(&quot;VIEW&quot;, &quot;TABLE&quot;)</span>

  // filter out the partition tables from exposed feature types
  override def includeTable(schemaName: String, tableName: String, cx: Connection): Boolean = {
<span class="nc bnc" id="L91" title="All 4 branches missed.">    super.includeTable(schemaName, tableName, cx) &amp;&amp; !PartitionedPostgisDialect.IgnoredTables.contains(tableName) &amp;&amp; {</span>
<span class="nc" id="L92">      val metadata = cx.getMetaData</span>
<span class="nc" id="L93">      val schemaPattern = store.escapeNamePattern(metadata, schemaName)</span>
<span class="nc" id="L94">      val tablePattern = store.escapeNamePattern(metadata, tableName)</span>
<span class="nc" id="L95">      val rs = metadata.getTables(null, schemaPattern, tablePattern, Array(&quot;VIEW&quot;))</span>
<span class="nc" id="L96">      try { rs.next() } finally {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">        rs.close()</span>
      }
    }
  }

  override def encodeCreateTable(sql: StringBuffer): Unit =
<span class="nc" id="L103">    sql.append(&quot;CREATE TABLE IF NOT EXISTS &quot;)</span>

  override def encodeTableName(raw: String, sql: StringBuffer): Unit = {
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if (dropping.get) {</span>
      // redirect from the view as DROP TABLE is hard-coded by the JDBC data store,
      // and cascade the drop to delete any write ahead partitions
<span class="nc" id="L109">      sql.append(escape(raw + WriteAheadTableSuffix.raw)).append(&quot; CASCADE&quot;)</span>
<span class="nc" id="L110">      dropping.remove()</span>
    } else {
<span class="nc" id="L112">      sql.append(escape(raw))</span>
    }
  }

  override def encodePrimaryKey(column: String, sql: StringBuffer): Unit = {
<span class="nc" id="L117">    encodeColumnName(null, column, sql)</span>
    // make our primary key a string instead of the default integer
<span class="nc" id="L119">    sql.append(&quot; character varying NOT NULL&quot;)</span>
  }

  override def encodePostCreateTable(tableName: String, sql: StringBuffer): Unit = {
<span class="nc" id="L123">    val i = sql.indexOf(tableName)</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    if (i == -1) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      logger.warn(s&quot;Did not find table name '$tableName' in CREATE TABLE statement: $sql&quot;)</span>
    } else {
      // rename to the write ahead table
<span class="nc" id="L128">      sql.insert(i + tableName.length, WriteAheadTableSuffix.raw)</span>
    }
  }

  override def postCreateTable(schemaName: String, sft: SimpleFeatureType, cx: Connection): Unit = {
    // Throw an error if the sft name is longer than 31 characters
<span class="nc bnc" id="L134" title="All 2 branches missed.">    if (sft.getTypeName.length() &gt; 31) {</span>
<span class="nc" id="L135">      val errorMsg = &quot;Can't create schema: type name exceeds max supported length of 31 characters&quot;</span>
<span class="nc" id="L136">      throw new IllegalArgumentException(errorMsg)</span>
    }

    // note: we skip the call to `super`, which creates a spatial index (that we don't want), and which
    // alters the geometry column types (which we handle in the create statement)
<span class="nc" id="L141">    val info = TypeInfo(schemaName, sft)</span>
<span class="nc" id="L142">    implicit val ex: ExecutionContext = new ExecutionContext(cx)</span>
    try {
<span class="nc" id="L144">      PartitionedPostgisDialect.Commands.foreach(_.create(info))</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">      if (grants.nonEmpty) {</span>
<span class="nc" id="L146">        val roles = grants.map(_.quoted).mkString(&quot;, &quot;)</span>
        val tables =
<span class="nc" id="L148">          Seq(</span>
<span class="nc" id="L149">            info.tables.view.name,</span>
<span class="nc" id="L150">            info.tables.writeAhead.name,</span>
<span class="nc" id="L151">            info.tables.writeAheadPartitions.name,</span>
<span class="nc" id="L152">            info.tables.mainPartitions.name,</span>
<span class="nc" id="L153">            info.tables.spillPartitions.name,</span>
<span class="nc" id="L154">            TableIdentifier(schemaName, PrimaryKeyTable.Name.raw),</span>
<span class="nc" id="L155">            TableIdentifier(schemaName, UserDataTable.Name.raw)</span>
          )
<span class="nc" id="L157">        tables.foreach { table =&gt;</span>
<span class="nc" id="L158">          ex.execute(s&quot;GRANT SELECT ON ${table.qualified} TO $roles;&quot;)</span>
        }
      }
    } finally {
<span class="nc" id="L162">      ex.close()</span>
    }
  }

  override def postCreateAttribute(
      att: AttributeDescriptor,
      tableName: String,
      schemaName: String,
      cx: Connection): Unit = {

    def withCol(fn: ResultSet =&gt; Unit): Unit = {
<span class="nc" id="L173">      val meta = cx.getMetaData</span>
<span class="nc" id="L174">      def escape(name: String): String = store.escapeNamePattern(meta, name)</span>
<span class="nc" id="L175">      WithClose(meta.getColumns(cx.getCatalog, escape(schemaName), escape(tableName), escape(att.getLocalName))) { cols =&gt;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (cols.next()) {</span>
<span class="nc" id="L177">          fn(cols)</span>
        } else {
<span class="nc bnc" id="L179" title="All 2 branches missed.">          logger.warn(s&quot;Could not retrieve column metadata for attribute ${att.getLocalName}&quot;)</span>
        }
      }
    }

<span class="nc bnc" id="L184" title="All 2 branches missed.">    if (classOf[String].isAssignableFrom(att.getType.getBinding)) {</span>
<span class="nc" id="L185">      withCol { cols =&gt;</span>
<span class="nc" id="L186">        val typeName = cols.getString(&quot;TYPE_NAME&quot;)</span>
<span class="nc bnc" id="L187" title="All 4 branches missed.">        if (&quot;json&quot;.equalsIgnoreCase(typeName) || &quot;jsonb&quot;.equalsIgnoreCase(typeName)) {</span>
<span class="nc" id="L188">          att.getUserData.put(SimpleFeatureTypes.AttributeOptions.OptJson, &quot;true&quot;)</span>
        }
      }
<span class="nc bnc" id="L191" title="All 2 branches missed.">    } else if (classOf[java.util.List[_]].isAssignableFrom(att.getType.getBinding)) {</span>
<span class="nc" id="L192">      withCol { cols =&gt;</span>
<span class="nc" id="L193">        val arrayType = super.getMapping(cols, cx)</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (arrayType.isArray) {</span>
<span class="nc" id="L195">          att.getUserData.put(SimpleFeatureTypes.AttributeConfigs.UserDataListType, arrayType.getComponentType.getName)</span>
        } else {
<span class="nc bnc" id="L197" title="All 2 branches missed.">          logger.warn(s&quot;Found a list-type attribute but database type was not an array for ${att.getLocalName}&quot;)</span>
        }
      }
    }
  }

  override def postCreateFeatureType(
      sft: SimpleFeatureType,
      metadata: DatabaseMetaData,
      schemaName: String,
      cx: Connection): Unit = {

    // normally views get set to read-only, override that here since we use triggers to delegate writes
<span class="nc" id="L210">    sft.getUserData.remove(JDBCDataStore.JDBC_READ_ONLY)</span>

    // populate tablespaces (deprecated)
<span class="nc bnc" id="L213" title="All 2 branches missed.">    PartitionTablespacesTable.read(cx, metadata, schemaName, sft.getTypeName).foreach { case (k, v) =&gt; sft.getUserData.put(k, v) }</span>

    // populate user data
<span class="nc bnc" id="L216" title="All 2 branches missed.">    UserDataTable.read(cx, schemaName, sft.getTypeName).foreach { case (k, v) =&gt; sft.getUserData.put(k, v) }</span>

    // populate flags on indexed attributes
<span class="nc" id="L219">    getIndexedColumns(cx, sft.getTypeName) match {</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">      case Success(cols) =&gt;</span>
<span class="nc" id="L221">        cols.foreach { col =&gt;</span>
<span class="nc bnc" id="L222" title="All 6 branches missed.">          if (col != &quot;fid&quot;) {</span>
<span class="nc" id="L223">            val i = sft.indexOf(col)</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (i == -1) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">              logger.debug(</span>
<span class="nc" id="L226">                s&quot;Found unexpected indexed column not in feature type: $col for ${sft.getTypeName}=${SimpleFeatureTypes.encodeType(sft)}&quot;)</span>
            } else {
<span class="nc" id="L228">              sft.getDescriptor(i).getUserData.put(AttributeOptions.OptIndex, &quot;true&quot;)</span>
            }
          }
        }

<span class="nc bnc" id="L233" title="All 4 branches missed.">      case Failure(e) =&gt; logger.warn(s&quot;Error loading indexed columns for feature type ${sft.getTypeName}:&quot;, e)</span>
    }
  }

  override def preDropTable(schemaName: String, sft: SimpleFeatureType, cx: Connection): Unit = {
    // due to the JDBCDataStore hard-coding &quot;DROP TABLE&quot; we have to redirect it away from the main view,
    // and we can't drop the write ahead table so that it has something to drop
<span class="nc" id="L240">    dropping.set(true)</span>
<span class="nc" id="L241">    val info = TypeInfo(schemaName, sft)</span>

<span class="nc" id="L243">    implicit val ex: ExecutionContext = new ExecutionContext(cx)</span>
    try {
<span class="nc bnc" id="L245" title="All 6 branches missed.">      PartitionedPostgisDialect.Commands.reverse.filter(_ != WriteAheadTable).foreach(_.drop(info))</span>
<span class="nc" id="L246">      PartitionTablespacesTable.drop(info)</span>
    } finally {
<span class="nc" id="L248">      ex.close()</span>
    }
  }

  override def postDropTable(schemaName: String, sft: SimpleFeatureType, cx: Connection): Unit = {
<span class="nc" id="L253">    val info = TypeInfo(schemaName, sft)</span>

<span class="nc" id="L255">    implicit val ex: ExecutionContext = new ExecutionContext(cx)</span>
    try {
<span class="nc" id="L257">      WriteAheadTable.drop(info) // drop the write ahead name sequence</span>
    } finally {
<span class="nc" id="L259">      ex.close()</span>
    }

    // rename the sft so that configuration is applied to the write ahead table
<span class="nc" id="L263">    super.postDropTable(schemaName, SimpleFeatureTypes.renameSft(sft, info.tables.writeAhead.name.raw), cx)</span>
  }

  override def splitFilter(filter: Filter, schema: SimpleFeatureType): Array[Filter] = {
<span class="nc" id="L267">    val simplified = SplitFilterVisitor(filter, SftUserData.FilterWholeWorld.get(schema))</span>
<span class="nc" id="L268">    val query = new Query(schema.getTypeName, simplified)</span>
<span class="nc" id="L269">    interceptors(schema).foreach(_.rewrite(query))</span>
<span class="nc" id="L270">    super.splitFilter(query.getFilter, schema)</span>
  }

  override def registerClassToSqlMappings(mappings: java.util.Map[Class[_], Integer]): Unit = {
<span class="nc" id="L274">    super.registerClassToSqlMappings(mappings)</span>
<span class="nc" id="L275">    mappings.put(classOf[java.util.List[_]], Types.ARRAY)</span>
  }

  override def registerSqlTypeNameToClassMappings(mappings: java.util.Map[String, Class[_]]): Unit = {
<span class="nc" id="L279">    super.registerSqlTypeNameToClassMappings(mappings)</span>
<span class="nc" id="L280">    mappings.put(&quot;array&quot;, classOf[java.util.List[_]])</span>
  }

  override def registerSqlTypeToSqlTypeNameOverrides(overrides: java.util.Map[Integer, String]): Unit = {
<span class="nc" id="L284">    super.registerSqlTypeToSqlTypeNameOverrides(overrides)</span>
<span class="nc" id="L285">    overrides.put(Types.ARRAY, &quot;ARRAY&quot;)</span>
  }

  override def encodePostColumnCreateTable(att: AttributeDescriptor, sql: StringBuffer): Unit = {
    import PartitionedPostgisDialect.GeometryAttributeConversions
<span class="nc" id="L290">    att match {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      case gd: GeometryDescriptor =&gt;</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">        val nullable = gd.getMinOccurs &lt;= 0 || gd.isNillable</span>
<span class="nc" id="L293">        val i = sql.lastIndexOf(&quot;geometry&quot;)</span>
        // expect `geometry NOT NULL` or `geometry` depending on nullable flag
<span class="nc bnc" id="L295" title="All 10 branches missed.">        if (i == -1 || (nullable &amp;&amp; i != sql.length() - 8) || (!nullable &amp;&amp; i != sql.length() - 17)) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">          logger.warn(s&quot;Found geometry-type attribute but no geometry column binding: $sql&quot;)</span>
        } else {
<span class="nc" id="L298">          val srid = gd.getSrid.getOrElse(-1)</span>
<span class="nc" id="L299">          val geomType = PartitionedPostgisDialect.GeometryMappings.getOrElse(gd.getType.getBinding, &quot;GEOMETRY&quot;)</span>
<span class="nc" id="L300">          val geomTypeWithDims = gd.getCoordinateDimensions match {</span>
<span class="nc bnc" id="L301" title="All 8 branches missed.">            case None | Some(2) =&gt; geomType</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">            case Some(3) =&gt; s&quot;${geomType}Z&quot;</span>
<span class="nc bnc" id="L303" title="All 4 branches missed.">            case Some(4) =&gt; s&quot;${geomType}ZM&quot;</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            case Some(d) =&gt;</span>
<span class="nc" id="L305">              throw new IllegalArgumentException(</span>
<span class="nc" id="L306">                s&quot;PostGIS only supports geometries with 2, 3 and 4 dimensions, but found: $d&quot;)</span>
          }
<span class="nc" id="L308">          sql.insert(i + 8, s&quot; ($geomTypeWithDims, $srid)&quot;)</span>
        }

<span class="nc bnc" id="L311" title="All 2 branches missed.">      case _ if att.isJson() =&gt;</span>
        // replace 'VARCHAR' with jsonb
<span class="nc" id="L313">        val i = sql.lastIndexOf(&quot; VARCHAR&quot;)</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (i == sql.length() - 8) {</span>
<span class="nc" id="L315">          sql.replace(i + 1, i + 8, &quot;JSONB&quot;)</span>
        } else {
<span class="nc bnc" id="L317" title="All 2 branches missed.">          logger.warn(s&quot;Found JSON-type attribute but no CHARACTER VARYING column binding: $sql&quot;)</span>
        }

<span class="nc bnc" id="L320" title="All 2 branches missed.">      case _ if att.isList =&gt;</span>
        // go back and encode the array type in the CQL create statement
<span class="nc" id="L322">        val i = sql.lastIndexOf(&quot; ARRAY&quot;)</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (i == sql.length() - 6) {</span>
<span class="nc" id="L324">          sql.insert(i, &quot; &quot; + getListTypeMapping(att.getListType()))</span>
        } else {
<span class="nc bnc" id="L326" title="All 2 branches missed.">          logger.warn(s&quot;Found list-type attribute but no ARRAY column binding: $sql&quot;)</span>
        }

<span class="nc" id="L329">      case _ =&gt; // no-op</span>
    }
  }

  override def getMapping(columnMetaData: ResultSet, cx: Connection): Class[_] = {
<span class="nc" id="L334">    val mapping = super.getMapping(columnMetaData, cx)</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">    if (mapping != null &amp;&amp; mapping.isArray) {</span>
<span class="nc" id="L336">      classOf[java.util.List[_]]</span>
    } else {
<span class="nc" id="L338">      mapping</span>
    }
  }

  /**
   * Gets the array type for a list/array column
   *
   * @param binding list-type binding
   * @return
   */
  private def getListTypeMapping(binding: Class[_]): String = {
<span class="nc" id="L349">    val mappings = new java.util.HashMap[String, Class[_]]()</span>
<span class="nc" id="L350">    registerSqlTypeNameToClassMappings(mappings)</span>
<span class="nc" id="L351">    var mapping: String = null</span>
<span class="nc" id="L352">    var partial: String = null</span>
<span class="nc" id="L353">    val iter = mappings.asScala.iterator</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">    while (iter.hasNext &amp;&amp; mapping == null) {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">      val (name, clas) = iter.next</span>
<span class="nc bnc" id="L356" title="All 6 branches missed.">      if (clas == binding) {</span>
<span class="nc" id="L357">        mapping = name</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">      } else if (partial == null &amp;&amp; clas.isAssignableFrom(binding)) {</span>
<span class="nc" id="L359">        partial = name</span>
      }
    }
<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (mapping != null) {</span>
<span class="nc" id="L363">      mapping</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">    } else if (partial != null) {</span>
<span class="nc" id="L365">      partial</span>
    } else {
<span class="nc bnc" id="L367" title="All 2 branches missed.">      logger.warn(s&quot;Could not find list-type column for type ${binding.getName}&quot;)</span>
<span class="nc" id="L368">      &quot;text&quot;</span>
    }
  }
}

<span class="nc" id="L373">object PartitionedPostgisDialect extends StrictLogging {</span>

<span class="nc" id="L375">  private val IgnoredTables = Seq(&quot;pg_stat_statements&quot;, &quot;pg_stat_statements_info&quot;)</span>

<span class="nc" id="L377">  private val GeometryMappings = Map[Class[_], String](</span>
<span class="nc" id="L378">    classOf[Geometry]           -&gt; &quot;GEOMETRY&quot;,</span>
<span class="nc" id="L379">    classOf[Point]              -&gt; &quot;POINT&quot;,</span>
<span class="nc" id="L380">    classOf[LineString]         -&gt; &quot;LINESTRING&quot;,</span>
<span class="nc" id="L381">    classOf[Polygon]            -&gt; &quot;POLYGON&quot;,</span>
<span class="nc" id="L382">    classOf[MultiPoint]         -&gt; &quot;MULTIPOINT&quot;,</span>
<span class="nc" id="L383">    classOf[MultiLineString]    -&gt; &quot;MULTILINESTRING&quot;,</span>
<span class="nc" id="L384">    classOf[MultiPolygon]       -&gt; &quot;MULTIPOLYGON&quot;,</span>
<span class="nc" id="L385">    classOf[GeometryCollection] -&gt; &quot;GEOMETRYCOLLECTION&quot;,</span>
<span class="nc" id="L386">    classOf[CircularString]     -&gt; &quot;CIRCULARSTRING&quot;,</span>
<span class="nc" id="L387">    classOf[CircularRing]       -&gt; &quot;CIRCULARSTRING&quot;,</span>
<span class="nc" id="L388">    classOf[MultiCurve]         -&gt; &quot;MULTICURVE&quot;,</span>
<span class="nc" id="L389">    classOf[CompoundCurve]      -&gt; &quot;COMPOUNDCURVE&quot;,</span>
<span class="nc" id="L390">    classOf[CompoundRing]       -&gt; &quot;COMPOUNDCURVE&quot;</span>
  )

<span class="nc" id="L393">  private val Commands: Seq[Sql] = Seq(</span>
<span class="nc" id="L394">    SequenceTable,</span>
<span class="nc" id="L395">    WriteAheadTable,</span>
<span class="nc" id="L396">    WriteAheadTrigger,</span>
<span class="nc" id="L397">    PartitionTables,</span>
<span class="nc" id="L398">    MainView,</span>
<span class="nc" id="L399">    InsertTrigger,</span>
<span class="nc" id="L400">    UpdateTrigger,</span>
<span class="nc" id="L401">    DeleteTrigger,</span>
<span class="nc" id="L402">    PrimaryKeyTable,</span>
<span class="nc" id="L403">    AnalyzeQueueTable,</span>
<span class="nc" id="L404">    SortQueueTable,</span>
<span class="nc" id="L405">    UserDataTable,</span>
<span class="nc" id="L406">    TruncateToTenMinutes,</span>
<span class="nc" id="L407">    TruncateToPartition,</span>
<span class="nc" id="L408">    RollWriteAheadLog,</span>
<span class="nc" id="L409">    PartitionWriteAheadLog,</span>
<span class="nc" id="L410">    MergeWriteAheadPartitions,</span>
<span class="nc" id="L411">    DropAgedOffPartitions,</span>
<span class="nc" id="L412">    PartitionMaintenance,</span>
<span class="nc" id="L413">    AnalyzePartitions,</span>
<span class="nc" id="L414">    CompactPartitions,</span>
<span class="nc" id="L415">    LogCleaner</span>
  )

  /**
   * Feature type user data fields
   *
   * @param key key used to store the data
   * @param mutable whether the value can be changed after the schema has been created
   * @param default default value, if any
   * @param conversion conversion from user data (string) to typed value
   * @tparam T typed value
   */
<span class="nc bnc" id="L427" title="All 26 branches missed.">  case class SftUserData[T](key: String, mutable: Boolean, default: T)(implicit conversion: Conversion[T]) {</span>
<span class="nc" id="L428">    def get(sft: SimpleFeatureType): T = Option(sft.getUserData.get(key)).map(conversion.convert).getOrElse(default)</span>
<span class="nc" id="L429">    def get(userData: Map[String, String]): T = userData.get(key).map(conversion.convert).getOrElse(default)</span>
  }

<span class="nc" id="L432">  object SftUserData {</span>
    // default date field
<span class="nc" id="L434">    val DtgField: SftUserData[Option[String]] = SftUserData(SimpleFeatureTypes.Configs.DefaultDtgField, mutable = false, None)</span>
    // size of each partition - can be updated after schema is created, but requires
    // running PartitionedPostgisDialect.upgrade in order to be applied
<span class="nc" id="L437">    val IntervalHours: SftUserData[Int] = SftUserData(&quot;pg.partitions.interval.hours&quot;, mutable = true, 6)</span>
    // pages_per_range on the BRIN index - can't be updated after schema is created
<span class="nc" id="L439">    val PagesPerRange: SftUserData[Int] = SftUserData(&quot;pg.partitions.pages-per-range&quot;, mutable = false, 128)</span>
    // max partitions to keep, i.e. age-off - can be updated freely after schema is created
<span class="nc" id="L441">    val MaxPartitions: SftUserData[Option[Int]] = SftUserData(&quot;pg.partitions.max&quot;, mutable = true, None)</span>
    // minute of each 10 minute block to execute the partition jobs - TODO can be updated after schema is created,
    // but requires running PartitionedPostgisDialect.upgrade in order to be applied
<span class="nc" id="L444">    val CronMinute: SftUserData[Option[Int]] = SftUserData(&quot;pg.partitions.cron.minute&quot;, mutable = false, None)</span>
    // remove 'whole world' filters - can be updated freely after schema is created
<span class="nc" id="L446">    val FilterWholeWorld: SftUserData[Boolean] = SftUserData(&quot;pg.partitions.filter.world&quot;, mutable = true, default = true)</span>
    // query interceptors
<span class="nc" id="L448">    val QueryInterceptors: SftUserData[Option[String]] = SftUserData(SimpleFeatureTypes.Configs.QueryInterceptors, mutable = true, None)</span>
    // set postgres table wal logging
<span class="nc" id="L450">    val WalLogEnabled: SftUserData[Boolean] = SftUserData(&quot;pg.wal.enabled&quot;, mutable = false, default = true)</span>

    // tablespace configurations - can be updated freely after the schema is created
<span class="nc" id="L453">    val WriteAheadTableSpace: SftUserData[Option[String]] = SftUserData(&quot;pg.partitions.tablespace.wa&quot;, mutable = true, None)</span>
<span class="nc" id="L454">    val WriteAheadPartitionsTableSpace: SftUserData[Option[String]] = SftUserData(&quot;pg.partitions.tablespace.wa-partitions&quot;, mutable = true, None)</span>
<span class="nc" id="L455">    val MainTableSpace: SftUserData[Option[String]] = SftUserData(&quot;pg.partitions.tablespace.main&quot;, mutable = true, None)</span>
  }

<span class="nc" id="L458">  implicit private def optionConversion[T](implicit conversion: Conversion[T]): Conversion[Option[T]] =</span>
<span class="nc" id="L459">    new OptionConversion[T](conversion)</span>

<span class="nc" id="L461">  private class OptionConversion[T](delegate: Conversion[T]) extends Conversion[Option[T]] {</span>
<span class="nc" id="L462">    override def convert(value: AnyRef): Option[T] = Option(value).map(delegate.convert)</span>
  }

<span class="nc bnc" id="L465" title="All 12 branches missed.">  implicit class GeometryAttributeConversions(val d: GeometryDescriptor) extends AnyVal {</span>
    def getSrid: Option[Int] =
<span class="nc" id="L467">      Option(d.getUserData.get(JDBCDataStore.JDBC_NATIVE_SRID)).map(ConvertToInt.convert)</span>
<span class="nc" id="L468">        .orElse(</span>
<span class="nc" id="L469">          Option(d.getCoordinateReferenceSystem)</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            .flatMap(crs =&gt; Try(CRS.lookupEpsgCode(crs, true)).filter(_ != null).toOption.map(_.intValue())))</span>
    def getCoordinateDimensions: Option[Int] =
<span class="nc" id="L472">      Option(d.getUserData.get(Hints.COORDINATE_DIMENSION)).map(ConvertToInt.convert)</span>
  }

  /**
   * Get a list of indexed columns for the given SimpleFeatureType
   *
   * @param cx connection
   * @param typeName feature type name
   * @return a sequence of SimpleFeatureType attribute names which have an index
   */
  def getIndexedColumns(cx: Connection, typeName: String): Try[List[String]] = {
    val attributesWithIndicesSql =
<span class="nc" id="L484">      s&quot;&quot;&quot;select distinct(att.attname) as indexed_attribute_name</span>
         |from pg_class obj
         |join pg_index idx on idx.indrelid = obj.oid
         |join pg_attribute att on att.attrelid = obj.oid and att.attnum = any(idx.indkey)
<span class="nc" id="L488">         |where obj.relname = concat(?, ${PartitionedTableSuffix.quoted})</span>
         |order by att.attname;&quot;&quot;&quot;.stripMargin
<span class="nc" id="L490">    Try {</span>
<span class="nc" id="L491">      WithClose(cx.prepareStatement(attributesWithIndicesSql)) { statement =&gt;</span>
<span class="nc" id="L492">        statement.setString(1, typeName)</span>
<span class="nc" id="L493">        WithClose(statement.executeQuery()) { rs =&gt;</span>
<span class="nc" id="L494">          Iterator.continually(rs).takeWhile(_.next()).map(_.getString(1)).toList</span>
        }
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>