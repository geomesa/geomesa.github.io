<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>package.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa GeoTools Postgis Partitioning</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.gt.partition.postgis.dialect</a> &gt; <span class="el_source">package.scala</span></div><h1>package.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.gt.partition.postgis

import com.typesafe.scalalogging.StrictLogging
import org.geotools.api.feature.`type`.{AttributeDescriptor, GeometryDescriptor}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.gt.partition.postgis.dialect.PartitionedPostgisDialect.SftUserData
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeOptions
import org.locationtech.geomesa.utils.index.{IndexCoverage, TemporalIndexCheck}

import java.io.Closeable
import java.sql.{Connection, PreparedStatement}
import java.util.regex.Pattern
import scala.util.Try
import scala.util.control.NonFatal

<span class="nc" id="L25">package object dialect {</span>

<span class="nc" id="L27">  private val DoubleQuote = &quot;\&quot;&quot;</span>
<span class="nc" id="L28">  private val NamePattern = Pattern.compile(DoubleQuote, Pattern.LITERAL)</span>

<span class="nc" id="L30">  private val SingleQuote = &quot;'&quot;</span>
<span class="nc" id="L31">  private val LiteralPattern = Pattern.compile(SingleQuote, Pattern.LITERAL)</span>

<span class="nc" id="L33">  private[dialect] val WriteAheadTableSuffix            = SqlLiteral(&quot;_wa&quot;)</span>
<span class="nc" id="L34">  private[dialect] val PartitionedWriteAheadTableSuffix = SqlLiteral(&quot;_wa_partition&quot;)</span>
<span class="nc" id="L35">  private[dialect] val PartitionedTableSuffix           = SqlLiteral(&quot;_partition&quot;)</span>
<span class="nc" id="L36">  private[dialect] val SpillTableSuffix                 = SqlLiteral(&quot;_spill&quot;)</span>
<span class="nc" id="L37">  private[dialect] val AnalyzeTableSuffix               = SqlLiteral(&quot;_analyze_queue&quot;)</span>
<span class="nc" id="L38">  private[dialect] val SortTableSuffix                  = SqlLiteral(&quot;_sort_queue&quot;)</span>

  /**
   * Escape a sql identifier
   *
   * @param name name
   * @return
   */
<span class="nc" id="L46">  def escape(name: String): String = quoteAndReplace(name, NamePattern, DoubleQuote)</span>

  /**
   * Escape a sql identifier, creating the identifier based on different parts, concatenated
   * together with `_`
   *
   * @param name0 first part
   * @param name1 second part
   * @param nameN additional parts
   * @return
   */
  def escape(name0: String, name1: String, nameN: String*): String =
<span class="nc" id="L58">    escape((Seq(name0, name1) ++ nameN).mkString(&quot;_&quot;))</span>

  /**
   * Quote a literal string
   *
   * @param string string literal
   * @return
   */
<span class="nc" id="L66">  def literal(string: String): String = quoteAndReplace(string, LiteralPattern, SingleQuote)</span>

  /**
   * Quote a literal string, creating the string based on different parts, concatenated
   * together with `_`
   *
   * @param string0 first value
   * @param string1 seconds value
   * @param stringN additional values
   * @return
   */
  def literal(string0: String, string1: String, stringN: String*): String =
<span class="nc" id="L78">    literal((Seq(string0, string1) ++ stringN).mkString(&quot;_&quot;))</span>

  private def quoteAndReplace(string: String, pattern: Pattern, quote: String): String =
<span class="nc" id="L81">    s&quot;$quote${pattern.matcher(string).replaceAll(quote + quote)}$quote&quot;</span>

  /**
   * Wrapper to facilitate jdbc calls.
   *
   * Note: does not do any validation, sql must be sanitized by the caller.
   *
   * @param cx connection
   */
<span class="nc" id="L90">  class ExecutionContext(val cx: Connection) extends Closeable with StrictLogging {</span>

<span class="nc" id="L92">    private val statement = cx.createStatement()</span>
<span class="nc" id="L93">    private var rollback = false</span>

    /**
     * Execute a sql command
     *
     * @param sql sql string
     */
    def execute(sql: String): Unit = {
<span class="nc" id="L101">      try {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        logger.debug(sql)</span>
<span class="nc" id="L103">        statement.execute(sql)</span>
      } catch {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        case NonFatal(e) =&gt; rollback = true; throw e</span>
      }
    }

    /**
     * Execute an update statements
     *
     * @param sql sql string, with arguments denoted by '?'
     * @param args arguments to the update statement, must match the argument placeholders in the sql string
     */
    def executeUpdate(sql: String, args: Seq[Any]): Unit = {
<span class="nc" id="L116">      val ps: PreparedStatement = cx.prepareStatement(sql)</span>
<span class="nc" id="L117">      try {</span>
<span class="nc" id="L118">        var i = 1</span>
<span class="nc" id="L119">        args.foreach { arg =&gt;</span>
<span class="nc" id="L120">          ps.setObject(i, arg)</span>
<span class="nc" id="L121">          i += 1</span>
        }
<span class="nc bnc" id="L123" title="All 2 branches missed.">        logger.debug(s&quot;$sql, ${args.mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L124">        ps.executeUpdate()</span>
      } catch {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        case NonFatal(e) =&gt; rollback = true; throw e</span>
      } finally {
<span class="nc" id="L128">        ps.close()</span>
      }
    }

    override def close(): Unit = {
<span class="nc bnc" id="L133" title="All 2 branches missed.">      if (!cx.getAutoCommit) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (rollback) {</span>
<span class="nc" id="L135">          Try(cx.rollback())</span>
        } else {
<span class="nc" id="L137">          cx.commit()</span>
        }
      }
<span class="nc" id="L140">      statement.close()</span>
    }
  }

  /**
   * All the info for a feature type used by the partitioning scheme
   *
   * @param schema database schema (e.g. &quot;public&quot;)
   * @param typeName feature type name
   * @param tables table names
   * @param cols columns
   * @param partitions partition config
   * @param userData feature type user data
   */
<span class="nc bnc" id="L154" title="All 53 branches missed.">  case class TypeInfo(</span>
<span class="nc" id="L155">      schema: SchemaName,</span>
<span class="nc" id="L156">      typeName: String,</span>
<span class="nc" id="L157">      tables: Tables,</span>
<span class="nc" id="L158">      cols: Columns,</span>
<span class="nc" id="L159">      partitions: PartitionInfo,</span>
<span class="nc" id="L160">      userData: Map[String, String] = Map.empty,</span>
    )

<span class="nc" id="L163">  object TypeInfo {</span>

    import scala.collection.JavaConverters._

    def apply(schema: String, sft: SimpleFeatureType): TypeInfo = {
<span class="nc" id="L168">      val tables = Tables(sft, schema)</span>
<span class="nc" id="L169">      val columns = Columns(sft)</span>
<span class="nc" id="L170">      val partitions = PartitionInfo(sft)</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      val userData = sft.getUserData.asScala.map { case (k, v) =&gt; String.valueOf(k) -&gt; String.valueOf(v) }</span>
<span class="nc" id="L172">      TypeInfo(SchemaName(schema), sft.getTypeName, tables, columns, partitions, userData.toMap)</span>
    }
  }

<span class="nc bnc" id="L176" title="All 25 branches missed.">  case class SchemaName(quoted: String, raw: String) extends SqlIdentifier</span>

<span class="nc" id="L178">  object SchemaName {</span>
<span class="nc" id="L179">    def apply(schema: String): SchemaName = SchemaName(escape(schema), schema)</span>
  }

  /**
   * A user/role name
   *
   * @param quoted escaped name
   * @param raw name without escaping
   */
<span class="nc bnc" id="L188" title="All 25 branches missed.">  case class RoleName(quoted: String, raw: String) extends SqlIdentifier</span>

<span class="nc" id="L190">  object RoleName {</span>
<span class="nc" id="L191">    def apply(name: String): RoleName = RoleName(escape(name), name)</span>
  }

  /**
   * Tables used by the partitioning system
   *
   * @param view primary view of all partitions
   * @param writeAhead write ahead table
   * @param writeAheadPartitions recent partitions table
   * @param mainPartitions main partitions table
   * @param analyzeQueue analyze queue table
   * @param sortQueue sort queue table
   */
<span class="nc bnc" id="L204" title="All 60 branches missed.">  case class Tables(</span>
<span class="nc" id="L205">      view: TableConfig,</span>
<span class="nc" id="L206">      writeAhead: TableConfig,</span>
<span class="nc" id="L207">      writeAheadPartitions: TableConfig,</span>
<span class="nc" id="L208">      mainPartitions: TableConfig,</span>
<span class="nc" id="L209">      spillPartitions: TableConfig,</span>
<span class="nc" id="L210">      analyzeQueue: TableConfig,</span>
<span class="nc" id="L211">      sortQueue: TableConfig)</span>

<span class="nc" id="L213">  object Tables {</span>
    def apply(sft: SimpleFeatureType, schema: String): Tables = {
<span class="nc" id="L215">      val logged = SftUserData.WalLogEnabled.get(sft)</span>
<span class="nc" id="L216">      val view = TableConfig(schema, sft.getTypeName, None)</span>
      // we disable autovacuum for write ahead tables, as they are transient and get dropped fairly quickly
<span class="nc" id="L218">      val writeAhead = TableConfig(schema, view.name.raw + WriteAheadTableSuffix.raw, SftUserData.WriteAheadTableSpace.get(sft), vacuum = false, logged)</span>
<span class="nc" id="L219">      val writeAheadPartitions = TableConfig(schema, view.name.raw + PartitionedWriteAheadTableSuffix.raw, SftUserData.WriteAheadPartitionsTableSpace.get(sft), vacuum = false, logged)</span>
<span class="nc" id="L220">      val mainPartitions = TableConfig(schema, view.name.raw + PartitionedTableSuffix.raw, SftUserData.MainTableSpace.get(sft), logged = logged)</span>
<span class="nc" id="L221">      val spillPartitions = TableConfig(schema, view.name.raw + SpillTableSuffix.raw, SftUserData.MainTableSpace.get(sft), logged = logged)</span>
<span class="nc" id="L222">      val analyzeQueue = TableConfig(schema, view.name.raw + AnalyzeTableSuffix.raw, None, logged = logged)</span>
<span class="nc" id="L223">      val sortQueue = TableConfig(schema, view.name.raw + SortTableSuffix.raw, None, logged = logged)</span>
<span class="nc" id="L224">      Tables(view, writeAhead, writeAheadPartitions, mainPartitions, spillPartitions, analyzeQueue, sortQueue)</span>
    }
  }

  /**
   * Table configuration
   *
   * @param name table name
   * @param tablespace table space
   * @param storage storage opts (auto vacuum)
   * @param logged logged or unlogged table
   */
<span class="nc bnc" id="L236" title="All 37 branches missed.">  case class TableConfig(name: TableIdentifier, tablespace: Option[TableSpace], storage: Storage, logged: Boolean)</span>

<span class="nc" id="L238">  object TableConfig {</span>
<span class="nc" id="L239">    def apply(schema: String, name: String, tablespace: Option[String], vacuum: Boolean = true, logged: Boolean = true): TableConfig = {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">      val storage = if (vacuum) { Storage.Nothing } else { Storage.AutoVacuumDisabled }</span>
<span class="nc bnc" id="L241" title="All 4 branches missed.">      val ts = tablespace.collect { case t if t.nonEmpty =&gt; TableSpace(t) }</span>
<span class="nc" id="L242">      TableConfig(TableIdentifier(schema, name), ts, storage, logged)</span>
    }
  }

<span class="nc" id="L246">  sealed trait Storage {</span>
    def opts: String
  }

<span class="nc" id="L250">  object Storage {</span>
<span class="nc" id="L251">    case object Nothing extends Storage {</span>
<span class="nc" id="L252">      override val opts: String = &quot;&quot;</span>
    }
<span class="nc" id="L254">    case object AutoVacuumDisabled extends Storage {</span>
<span class="nc" id="L255">      override val opts: String = &quot; WITH (autovacuum_enabled = false)&quot;</span>
    }
  }

  /**
   * Tablespace
   *
   * @param quoted escaped name
   * @param raw raw name
   */
<span class="nc bnc" id="L265" title="All 25 branches missed.">  case class TableSpace(quoted: String, raw: String) extends SqlIdentifier</span>

<span class="nc" id="L267">  object TableSpace {</span>
<span class="nc" id="L268">    def apply(tablespace: String): TableSpace = TableSpace(escape(tablespace), tablespace)</span>
  }

  /**
   * Table name
   *
   * @param qualified fully qualified and escaped name
   * @param quoted escaped name without the schema
   * @param raw unqualified name without escaping
   */
<span class="nc bnc" id="L278" title="All 32 branches missed.">  case class TableIdentifier(qualified: String, quoted: String, raw: String) extends QualifiedSqlIdentifier {</span>
<span class="nc" id="L279">    def asRegclass: String = s&quot;${literal(qualified)}::regclass&quot;</span>
  }

<span class="nc" id="L282">  object TableIdentifier {</span>
    def apply(schema: String, raw: String): TableIdentifier =
<span class="nc" id="L284">      TableIdentifier(s&quot;${escape(schema)}.${escape(raw)}&quot;, escape(raw), raw)</span>
  }

  /**
   * A table name, but without any schema information
   *
   * @param quoted escaped name
   * @param raw name without escaping
   */
<span class="nc bnc" id="L293" title="All 25 branches missed.">  case class TableName(quoted: String, raw: String) extends SqlIdentifier</span>

<span class="nc" id="L295">  object TableName {</span>
<span class="nc" id="L296">    def apply(name: String): TableName = TableName(escape(name), name)</span>
  }

  /**
   * Columns names for the feature type
   *
   * @param dtg primary dtg column
   * @param geom primary geometry column
   * @param geoms all geometry cols (including primary)
   * @param indexed any indexed columns
   * @param all all columns
   */
<span class="nc bnc" id="L308" title="All 46 branches missed.">  case class Columns(</span>
<span class="nc" id="L309">      dtg: ColumnName,</span>
<span class="nc" id="L310">      geom: ColumnName,</span>
<span class="nc" id="L311">      geoms: Seq[ColumnName],</span>
<span class="nc" id="L312">      indexed: Seq[ColumnName],</span>
<span class="nc" id="L313">      all: Seq[ColumnName]</span>
    )

<span class="nc" id="L316">  object Columns {</span>

    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

    import scala.collection.JavaConverters._

    def apply(original: SimpleFeatureType): Columns = {
<span class="nc" id="L323">      val sft = SimpleFeatureTypes.copy(original)</span>
<span class="nc" id="L324">      TemporalIndexCheck.validateDtgField(sft)</span>
<span class="nc" id="L325">      val dtg = sft.getDtgField.map(ColumnName.apply).getOrElse {</span>
<span class="nc" id="L326">        throw new IllegalArgumentException(&quot;Must include a date-type attribute when using a partitioned store&quot;)</span>
      }
<span class="nc" id="L328">      val geom = Option(sft.getGeomField).map(ColumnName.apply).getOrElse {</span>
<span class="nc" id="L329">        throw new IllegalArgumentException(&quot;Must include a geometry-type attribute when using a partitioned store&quot;)</span>
      }
<span class="nc bnc" id="L331" title="All 4 branches missed.">      val geoms = sft.getAttributeDescriptors.asScala.collect { case d: GeometryDescriptor =&gt; ColumnName(d) }</span>
      // TODO we could use covering indices, but BRIN indices don't support them
      //  val includes =
      //    Seq(dtg) ++ sft.getAttributeDescriptors.asScala.collect { case d if d.isIndexValue() =&gt; ColumnName(d) }
      //    .distinct
<span class="nc bnc" id="L336" title="All 12 branches missed.">      def indexed(d: AttributeDescriptor): Boolean = d.getLocalName != geom.raw &amp;&amp; d.getLocalName != dtg.raw &amp;&amp;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">          Option(d.getUserData.get(AttributeOptions.OptIndex).asInstanceOf[String]).exists { i =&gt;</span>
<span class="nc" id="L338">            Seq(&quot;true&quot;, IndexCoverage.FULL, IndexCoverage.JOIN).map(_.toString).exists(_.equalsIgnoreCase(i))</span>
          }

<span class="nc bnc" id="L341" title="All 4 branches missed.">      val indices = sft.getAttributeDescriptors.asScala.collect { case d if indexed(d) =&gt; ColumnName(d) }</span>
<span class="nc" id="L342">      val all = sft.getAttributeDescriptors.asScala.map(ColumnName.apply)</span>
<span class="nc" id="L343">      Columns(dtg, geom, geoms.toSeq, indices.toSeq, all.toSeq)</span>
    }
  }

  /**
   * Column name
   *
   * @param quoted escaped name
   * @param raw unescaped name
   */
<span class="nc bnc" id="L353" title="All 25 branches missed.">  case class ColumnName(quoted: String, raw: String) extends SqlIdentifier</span>

<span class="nc" id="L355">  object ColumnName {</span>
<span class="nc" id="L356">    def apply(d: AttributeDescriptor): ColumnName = apply(d.getLocalName)</span>
<span class="nc" id="L357">    def apply(raw: String): ColumnName = ColumnName(escape(raw), raw)</span>
  }

  /**
   * Partition config
   *
   * @param hoursPerPartition number of hours to keep in each partition, must be a divisor of 24
   * @param pagesPerRange number of pages to add to each range in the BRIN index
   * @param maxPartitions max number of partitions to keep
   * @param cronMinute minute of each 10 minute chunk that partition maintenance will run
   */
<span class="nc bnc" id="L368" title="All 31 branches missed.">  case class PartitionInfo(</span>
<span class="nc" id="L369">      hoursPerPartition: Int,</span>
<span class="nc" id="L370">      pagesPerRange: Int,</span>
<span class="nc" id="L371">      maxPartitions: Option[Int],</span>
<span class="nc" id="L372">      cronMinute: Option[Int]</span>
    )

<span class="nc" id="L375">  object PartitionInfo {</span>
    def apply(sft: SimpleFeatureType): PartitionInfo = {
<span class="nc" id="L377">      val hours = SftUserData.IntervalHours.get(sft)</span>
<span class="nc bnc" id="L378" title="All 4 branches missed.">      require(hours &gt; 0 &amp;&amp; hours &lt;= 24, s&quot;Partition interval must be between 1 and 24 hours: $hours hours&quot;)</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">      require(24 % hours == 0, s&quot;Partition interval must be a divisor of 24 hours: $hours hours&quot;)</span>
<span class="nc" id="L380">      val cronMinute = SftUserData.CronMinute.get(sft)</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">      require(cronMinute.forall(m =&gt; m &gt;= 0 &amp;&amp; m &lt; 9), s&quot;Cron minute must be between 0 and 8: ${cronMinute.orNull}&quot;)</span>
<span class="nc" id="L382">      val pagesPerRange = SftUserData.PagesPerRange.get(sft)</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">      require(pagesPerRange &gt;= 0, s&quot;Pages per range but be a positive number: $pagesPerRange&quot;)</span>
<span class="nc" id="L384">      val maxPartitions = SftUserData.MaxPartitions.get(sft)</span>
<span class="nc" id="L385">      PartitionInfo(hours, pagesPerRange, maxPartitions, cronMinute)</span>
    }
  }

  /**
   * Trigger name
   *
   * @param quoted escaped name
   * @param raw raw name
   */
<span class="nc bnc" id="L395" title="All 25 branches missed.">  case class TriggerName(quoted: String, raw: String) extends SqlIdentifier</span>

<span class="nc" id="L397">  object TriggerName {</span>
<span class="nc" id="L398">    def apply(name: String): TriggerName = TriggerName(escape(name), name)</span>
  }

  /**
   * Function name
   *
   * @param quoted escaped name
   * @param raw raw name
   */
<span class="nc bnc" id="L407" title="All 25 branches missed.">  case class FunctionName(quoted: String, raw: String) extends SqlIdentifier</span>

<span class="nc" id="L409">  object FunctionName {</span>
<span class="nc" id="L410">    def apply(name: String): FunctionName = FunctionName(escape(name), name)</span>
  }

  /**
   * Identifier for sql objects
   */
<span class="nc" id="L416">  trait SqlIdentifier {</span>

    /**
     * Escaped and quoted name
     *
     * @return
     */
    def quoted: String

    /**
     * Raw, unqualified name, without escaping
     *
     * @return
     */
    def raw: String

    /**
     * Get as a quoted literal instead of an identifier
     *
     * @return
     */
<span class="nc" id="L437">    def asLiteral: String = literal(raw)</span>
  }

  /**
   * Identifier for qualified sql objects (i.e. with schemas)
   */
  trait QualifiedSqlIdentifier extends SqlIdentifier {

    /**
     * Fully qualified and escaped name
     *
     * @return
     */
    def qualified: String
  }

  /**
   * A sql literal
   *
   * @param quoted escaped and quoted value
   * @param raw raw value
   */
<span class="nc bnc" id="L459" title="All 25 branches missed.">  case class SqlLiteral(quoted: String, raw: String)</span>

<span class="nc" id="L461">  object SqlLiteral {</span>
<span class="nc" id="L462">    def apply(value: String): SqlLiteral = SqlLiteral(literal(value), value)</span>
  }

  /**
   * Trait for modelling sql objects
   */
<span class="nc" id="L468">  trait Sql {</span>

    /**
     * Execute sql defined by this class
     *
     * @param info type info
     */
    def create(info: TypeInfo)(implicit ex: ExecutionContext): Unit

    /**
     * Drop things created by this class
     *
     * @param info type info
     */
    def drop(info: TypeInfo)(implicit ex: ExecutionContext): Unit
  }

  /**
   * Trait for modeling a list of sql statements
   */
<span class="nc" id="L488">  trait SqlStatements extends Sql {</span>

    override def create(info: TypeInfo)(implicit ex: ExecutionContext): Unit =
<span class="nc" id="L491">      createStatements(info).foreach(ex.execute)</span>

    override def drop(info: TypeInfo)(implicit ex: ExecutionContext): Unit =
<span class="nc" id="L494">      dropStatements(info).foreach(ex.execute)</span>

    /**
     * The sql defined by this class
     *
     * @param info type info
     * @return
     */
    protected def createStatements(info: TypeInfo): Seq[String]

    /**
     * The sql to drop things created by this class
     *
     * @param info type info
     * @return
     */
    protected def dropStatements(info: TypeInfo): Seq[String]
  }

  /**
   * A procedure definition
   */
<span class="nc" id="L516">  trait SqlProcedure extends SqlStatements {</span>

    /**
     * The name of the procedure
     *
     * @param info type info
     * @return
     */
    def name(info: TypeInfo): FunctionName

    override protected def dropStatements(info: TypeInfo): Seq[String] =
<span class="nc" id="L527">      Seq(s&quot;DROP PROCEDURE IF EXISTS ${name(info).quoted};&quot;)</span>
  }

  /**
   * A function definition
   */
<span class="nc" id="L533">  trait SqlFunction extends SqlStatements {</span>

    /**
     * The name of the function
     *
     * @param info type info
     * @return
     */
    def name(info: TypeInfo): FunctionName

    override protected def dropStatements(info: TypeInfo): Seq[String] =
<span class="nc" id="L544">      Seq(s&quot;DROP FUNCTION IF EXISTS ${info.schema.quoted}.${name(info).quoted};&quot;)</span>
  }

  /**
   * A table trigger with an associated function definition
   */
<span class="nc" id="L550">  trait SqlTriggerFunction extends SqlFunction {</span>

    /**
     * Name of the trigger
     *
     * @param info type info
     * @return
     */
<span class="nc" id="L558">    def triggerName(info: TypeInfo): TriggerName = TriggerName(s&quot;${name(info).raw}_trigger&quot;)</span>

    /**
     * Table that the trigger is applied to
     *
     * @param info type info
     * @return
     */
    protected def table(info: TypeInfo): TableIdentifier

    /**
     * Triggered action (e.g. &quot;INSTEAD OF INSERT&quot;, &quot;BEFORE INSERT&quot;, &quot;INSTEAD OF DELETE&quot;, etc)
     *
     * @return
     */
    protected def action: String

    override protected def createStatements(info: TypeInfo): Seq[String] = {
      // there is no &quot;create or replace&quot; for triggers so we have to wrap it in a check
<span class="nc" id="L577">      val tgName = triggerName(info)</span>
<span class="nc" id="L578">      val tgTable = table(info)</span>
      val create =
<span class="nc" id="L580">        s&quot;&quot;&quot;DO $$$$</span>
           |BEGIN
<span class="nc" id="L582">           |  IF NOT EXISTS (SELECT FROM pg_trigger WHERE tgname = ${tgName.asLiteral} AND tgrelid = ${tgTable.asRegclass}) THEN</span>
<span class="nc" id="L583">           |    CREATE TRIGGER ${tgName.quoted}</span>
<span class="nc" id="L584">           |      $action ON ${tgTable.qualified}</span>
<span class="nc" id="L585">           |      FOR EACH ROW EXECUTE PROCEDURE ${info.schema.quoted}.${name(info).quoted}();</span>
           |  END IF;
           |END$$$$;&quot;&quot;&quot;.stripMargin
<span class="nc" id="L588">      Seq(create)</span>
    }

    override protected def dropStatements(info: TypeInfo): Seq[String] =
<span class="nc" id="L592">      Seq(dropTrigger(info)) ++ super.dropStatements(info)</span>

    private def dropTrigger(info: TypeInfo): String =
<span class="nc" id="L595">      s&quot;DROP TRIGGER IF EXISTS ${triggerName(info).quoted} ON ${table(info).qualified};&quot;</span>
  }

  /**
   * A cron'd function or procedure
   */
<span class="nc" id="L601">  trait CronSchedule extends SqlStatements {</span>

    /**
     * The name of the cron job in the cron.job tables
     *
     * @param info type info
     * @return
     */
    def jobName(info: TypeInfo): SqlLiteral

    /**
     * The cron schedule, e.g. &quot;* * * * *&quot;
     *
     * @param info type info
     * @return
     */
    protected def schedule(info: TypeInfo): SqlLiteral

    /**
     * The statement to execute for each cron run
     *
     * @param info type info
     * @return
     */
    protected def invocation(info: TypeInfo): SqlLiteral

    override protected def createStatements(info: TypeInfo): Seq[String] = {
<span class="nc" id="L628">      val jName = jobName(info).quoted</span>
      val create =
<span class="nc" id="L630">        s&quot;&quot;&quot;DO $$$$</span>
           |BEGIN
<span class="nc" id="L632">           |${unscheduleSql(jName)}</span>
<span class="nc" id="L633">           |  PERFORM cron.schedule($jName, ${schedule(info).quoted}, ${invocation(info).quoted});</span>
           |END$$$$;&quot;&quot;&quot;.stripMargin
<span class="nc" id="L635">      Seq(create)</span>
    }

    abstract override protected def dropStatements(info: TypeInfo): Seq[String] = {
<span class="nc" id="L639">      val jName = jobName(info).quoted</span>
      val drop =
<span class="nc" id="L641">        s&quot;&quot;&quot;DO $$$$</span>
           |BEGIN
<span class="nc" id="L643">           |${unscheduleSql(jName)}</span>
           |END$$$$;&quot;&quot;&quot;.stripMargin
<span class="nc" id="L645">      Seq(drop) ++ super.dropStatements(info)</span>
    }

    protected def unscheduleSql(quotedName: String): String =
<span class="nc" id="L649">      s&quot;&quot;&quot;  IF EXISTS (SELECT FROM cron.job WHERE jobname = $quotedName) THEN</span>
<span class="nc" id="L650">         |    PERFORM cron.unschedule($quotedName);</span>
         |  END IF;&quot;&quot;&quot;.stripMargin
  }

  /**
   * Uses a postgres advisory lock to synchronize create and drop statements
   */
<span class="nc" id="L657">  trait AdvisoryLock extends Sql {</span>

    /**
     * The lock id associated with this object
     *
     * @return
     */
    protected def lockId: Long

<span class="nc" id="L666">    private def lock: String = s&quot;SELECT pg_advisory_lock($lockId);&quot;</span>
<span class="nc" id="L667">    private def unlock: String = s&quot;SELECT pg_advisory_unlock($lockId);&quot;</span>

    abstract override def create(info: TypeInfo)(implicit ex: ExecutionContext): Unit = {
<span class="nc" id="L670">      ex.execute(lock)</span>
<span class="nc" id="L671">      try { super.create(info) } finally {</span>
<span class="nc" id="L672">        ex.execute(unlock)</span>
      }
    }

    abstract override def drop(info: TypeInfo)(implicit ex: ExecutionContext): Unit = {
<span class="nc" id="L677">      ex.execute(lock)</span>
<span class="nc" id="L678">      try { super.drop(info) } finally {</span>
<span class="nc" id="L679">        ex.execute(unlock)</span>
      }
    }

  }
<span class="nc" id="L684">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>