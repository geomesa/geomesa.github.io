<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttributeIndexV7.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.index.attribute.legacy</a> &gt; <span class="el_source">AttributeIndexV7.scala</span></div><h1>AttributeIndexV7.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.index.attribute.legacy

import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.index.api.ShardStrategy.AttributeShardStrategy
import org.locationtech.geomesa.index.api._
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.index.attribute.legacy.AttributeIndexV7.AttributeIndexKeySpaceV7
import org.locationtech.geomesa.index.index.attribute.{AttributeIndex, AttributeIndexKey, AttributeIndexKeySpace}
import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.index.ByteArrays.{OneByteArray, ZeroByteArray}
import org.locationtech.geomesa.utils.index.IndexMode.IndexMode

import java.nio.charset.StandardCharsets
import scala.util.Try

/**
  * Attribute index with tiering based on the default date and geom. All attributes share a single table
  *
  * @param ds data store
  * @param sft simple feature type stored in this index
  * @param version version of the index
  * @param attribute attribute field being indexed
  * @param secondaries secondary fields used for the index tiering
  * @param mode mode of the index (read/write/both)
  */
<span class="nc" id="L35">class AttributeIndexV7 protected (ds: GeoMesaDataStore[_],</span>
                                  sft: SimpleFeatureType,
                                  version: Int,
                                  attribute: String,
                                  secondaries: Seq[String],
                                  mode: IndexMode)
<span class="nc" id="L41">    extends AttributeIndex(ds, sft, version, attribute, secondaries, mode) {</span>

  def this(ds: GeoMesaDataStore[_], sft: SimpleFeatureType, attribute: String, secondaries: Seq[String], mode: IndexMode) =
<span class="nc" id="L44">    this(ds, sft, 7, attribute, secondaries, mode)</span>

<span class="nc" id="L46">  override protected val tableNameKey: String = s&quot;table.attr.v$version&quot;</span>

<span class="nc" id="L48">  override val keySpace: AttributeIndexKeySpace =</span>
<span class="nc" id="L49">    new AttributeIndexKeySpaceV7(sft, sft.getTableSharingBytes, AttributeShardStrategy(sft), attribute)</span>
}

<span class="nc" id="L52">object AttributeIndexV7 {</span>

<span class="nc" id="L54">  class AttributeIndexKeySpaceV7(sft: SimpleFeatureType,</span>
<span class="nc" id="L55">                                 override val sharing: Array[Byte],</span>
                                 sharding: ShardStrategy,
                                 attributeField: String)
<span class="nc" id="L58">      extends AttributeIndexKeySpace(sft, sharding, attributeField) {</span>

<span class="nc" id="L60">    private val idxBytes = AttributeIndexKey.indexToBytes(fieldIndex)</span>

<span class="nc" id="L62">    private val rangePrefixes = {</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">      if (sharing.isEmpty) {</span>
<span class="nc" id="L64">        sharding.shards</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">      } else if (sharding.length == 0) {</span>
<span class="nc" id="L66">        Seq(sharing)</span>
      } else {
<span class="nc" id="L68">        sharding.shards.map(ByteArrays.concat(sharing, _))</span>
      }
    }

<span class="nc" id="L72">    override val indexKeyByteLength: Left[(Array[Byte], Int, Int) =&gt; Int, Int] =</span>
<span class="nc" id="L73">      Left((row, offset, _) =&gt;</span>
<span class="nc" id="L74">        row.indexOf(ByteArrays.ZeroByte, offset + sharding.length + sharing.length + 2) + 1 - offset)</span>

    override def toIndexKey(writable: WritableFeature,
                            tier: Array[Byte],
                            id: Array[Byte],
                            lenient: Boolean): RowKeyValue[AttributeIndexKey] = {
<span class="nc" id="L80">      val shard = sharding(writable)</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">      if (isList) {</span>
<span class="nc" id="L83">        val attribute = writable.getAttribute[java.util.List[Any]](fieldIndex)</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (attribute == null) {</span>
<span class="nc" id="L85">          MultiRowKeyValue(Seq.empty, sharing, shard, Seq.empty, tier, id, writable.values)</span>
        } else {
<span class="nc" id="L87">          val rows = Seq.newBuilder[Array[Byte]]</span>
<span class="nc" id="L88">          val keys = Seq.newBuilder[AttributeIndexKey]</span>

<span class="nc" id="L90">          var j = 0</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">          while (j &lt; attribute.size()) {</span>
<span class="nc" id="L92">            val encoded = AttributeIndexKey.typeEncode(attribute.get(j))</span>
<span class="nc" id="L93">            val value = encoded.getBytes(StandardCharsets.UTF_8)</span>

            // create the byte array - allocate a single array up front to contain everything
            // +2 for idx bytes, +1 for null byte
<span class="nc" id="L97">            val bytes = Array.ofDim[Byte](sharing.length + shard.length + tier.length + id.length + 3 + value.length)</span>
<span class="nc" id="L98">            var i = 0</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">            if (!sharing.isEmpty) {</span>
<span class="nc" id="L100">              bytes(0) = sharing.head // sharing is only a single byte</span>
<span class="nc" id="L101">              i += 1</span>
            }
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (!shard.isEmpty) {</span>
<span class="nc" id="L104">              bytes(i) = shard.head // shard is only a single byte</span>
<span class="nc" id="L105">              i += 1</span>
            }
<span class="nc" id="L107">            bytes(i) = idxBytes(0)</span>
<span class="nc" id="L108">            bytes(i + 1) = idxBytes(1)</span>
<span class="nc" id="L109">            i += 2</span>
<span class="nc" id="L110">            System.arraycopy(value, 0, bytes, i, value.length)</span>
<span class="nc" id="L111">            i += value.length</span>
<span class="nc" id="L112">            bytes(i) = ByteArrays.ZeroByte</span>
<span class="nc" id="L113">            System.arraycopy(tier, 0, bytes, i + 1, tier.length)</span>
<span class="nc" id="L114">            System.arraycopy(id, 0, bytes, i + 1 + tier.length, id.length)</span>

<span class="nc" id="L116">            rows += bytes</span>
<span class="nc" id="L117">            keys += AttributeIndexKey(fieldIndexShort, encoded)</span>

<span class="nc" id="L119">            j += 1</span>
          }
<span class="nc" id="L121">          MultiRowKeyValue(rows.result, sharing, shard, keys.result, tier, id, writable.values)</span>
        }
      } else {
<span class="nc" id="L124">        val attribute = writable.getAttribute[Any](fieldIndex)</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (attribute == null) {</span>
<span class="nc" id="L126">          MultiRowKeyValue(Seq.empty, sharing, shard, Seq.empty, tier, id, writable.values)</span>
        } else {
<span class="nc" id="L128">          val encoded = AttributeIndexKey.typeEncode(attribute)</span>
<span class="nc" id="L129">          val value = encoded.getBytes(StandardCharsets.UTF_8)</span>

          // create the byte array - allocate a single array up front to contain everything
          // +2 for idx bytes, +1 for null byte
<span class="nc" id="L133">          val bytes = Array.ofDim[Byte](sharing.length + shard.length + tier.length + id.length + 3 + value.length)</span>
<span class="nc" id="L134">          var i = 0</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">          if (!sharing.isEmpty) {</span>
<span class="nc" id="L136">            bytes(0) = sharing.head // sharing is only a single byte</span>
<span class="nc" id="L137">            i += 1</span>
          }
<span class="nc bnc" id="L139" title="All 2 branches missed.">          if (!shard.isEmpty) {</span>
<span class="nc" id="L140">            bytes(i) = shard.head // shard is only a single byte</span>
<span class="nc" id="L141">            i += 1</span>
          }
<span class="nc" id="L143">          bytes(i) = idxBytes(0)</span>
<span class="nc" id="L144">          bytes(i + 1) = idxBytes(1)</span>
<span class="nc" id="L145">          i += 2</span>
<span class="nc" id="L146">          System.arraycopy(value, 0, bytes, i, value.length)</span>
<span class="nc" id="L147">          i += value.length</span>
<span class="nc" id="L148">          bytes(i) = ByteArrays.ZeroByte</span>
<span class="nc" id="L149">          System.arraycopy(tier, 0, bytes, i + 1, tier.length)</span>
<span class="nc" id="L150">          System.arraycopy(id, 0, bytes, i + 1 + tier.length, id.length)</span>

<span class="nc" id="L152">          SingleRowKeyValue(bytes, sharing, shard, AttributeIndexKey(fieldIndexShort, encoded), tier, id, writable.values)</span>
        }
      }
    }

    override def getRangeBytes(ranges: Iterator[ScanRange[AttributeIndexKey]], tier: Boolean): Iterator[ByteRange] = {
<span class="nc bnc" id="L158" title="All 2 branches missed.">      if (tier) {</span>
<span class="nc" id="L159">        getTieredRangeBytes(ranges, rangePrefixes)</span>
      } else {
<span class="nc" id="L161">        getStandardRangeBytes(ranges, rangePrefixes)</span>
      }
    }

<span class="nc" id="L165">    override def decodeRowValue(row: Array[Byte], offset: Int, length: Int): Try[AnyRef] = Try {</span>
      // start of the encoded value
      // exclude feature byte and 2 index bytes and shard bytes
<span class="nc" id="L168">      val valueStart = offset + sharding.length + sharing.length + 2</span>
      // null byte indicates end of value
<span class="nc" id="L170">      val valueEnd = math.min(row.indexOf(ByteArrays.ZeroByte, valueStart), offset + length)</span>
<span class="nc" id="L171">      decodeValue(new String(row, valueStart, valueEnd - valueStart, StandardCharsets.UTF_8))</span>
    }

<span class="nc" id="L174">    override protected def lower(key: AttributeIndexKey, prefix: Boolean = false): Array[Byte] = {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">      if (key.value == null) {</span>
<span class="nc" id="L176">        idxBytes</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">      } else if (prefix) {</span>
        // note: inclusive doesn't make sense for prefix ranges
<span class="nc" id="L179">        ByteArrays.concat(idxBytes, key.value.getBytes(StandardCharsets.UTF_8))</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">      } else if (key.inclusive) {</span>
<span class="nc" id="L181">        ByteArrays.concat(idxBytes, key.value.getBytes(StandardCharsets.UTF_8), ZeroByteArray)</span>
      } else {
<span class="nc" id="L183">        ByteArrays.concat(idxBytes, key.value.getBytes(StandardCharsets.UTF_8), OneByteArray)</span>
      }
    }

<span class="nc" id="L187">    override protected def upper(key: AttributeIndexKey, prefix: Boolean = false): Array[Byte] = {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">      if (key.value == null) {</span>
<span class="nc" id="L189">        ByteArrays.rowFollowingPrefix(idxBytes)</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">      } else if (prefix) {</span>
        // get the row following the prefix, then get the next row
        // note: inclusiveness doesn't really make sense for prefix ranges
<span class="nc" id="L193">        ByteArrays.rowFollowingPrefix(ByteArrays.concat(idxBytes, key.value.getBytes(StandardCharsets.UTF_8)))</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      } else if (key.inclusive) {</span>
        // row following prefix, after the delimiter
<span class="nc" id="L196">        ByteArrays.concat(idxBytes, key.value.getBytes(StandardCharsets.UTF_8), OneByteArray)</span>
      } else {
        // exclude the row
<span class="nc" id="L199">        ByteArrays.concat(idxBytes, key.value.getBytes(StandardCharsets.UTF_8), ZeroByteArray)</span>
      }
    }

    override protected def tieredUpper(key: AttributeIndexKey): Option[Array[Byte]] = {
      // note: we can't tier exclusive end points, as we can't calculate previous rows
<span class="nc bnc" id="L205" title="All 4 branches missed.">      if (key.value == null || !key.inclusive) { None } else {</span>
        // match the final row, and count on remaining range to exclude the rest
<span class="nc" id="L207">        Some(ByteArrays.concat(idxBytes, key.value.getBytes(StandardCharsets.UTF_8), ZeroByteArray))</span>
      }
    }
  }
<span class="nc" id="L211">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>