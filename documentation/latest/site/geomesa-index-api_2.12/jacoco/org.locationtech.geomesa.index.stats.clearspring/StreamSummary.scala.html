<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamSummary.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.clearspring</a> &gt; <span class="el_source">StreamSummary.scala</span></div><h1>StreamSummary.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

/**
  * Adapted from:
  *
  * stream-lib
  * Copyright (C) 2011 Clearspring Technologies, Inc.
  * Copyright 2016 AddThis
  *
  * This product includes software developed by AddThis.
  *
  * This product also includes code adapted from:
  *
  * Apache Solr (http://lucene.apache.org/solr/)
  * Copyright 2014 The Apache Software Foundation
  *
  * Apache Mahout (http://mahout.apache.org/)
  * Copyright 2014 The Apache Software Foundation
  *
  */

package org.locationtech.geomesa.index.stats.clearspring

import com.clearspring.analytics.stream.ITopK
import com.clearspring.analytics.util.{DoublyLinkedList, ListNode2}
import StreamSummary.{Bucket, Counter}

import java.util.Collections

/**
  * Based on the `Space-Saving` algorithm and the `Stream-Summary`
  * data structure as described in:
  * `Efficient Computation of Frequent and Top-k Elements in Data Streams`
  * by Metwally, Agrawal, and Abbadi
  *
  * @param capacity maximum size (larger capacities improve accuracy)
  * @tparam T type of data in the stream to be summarized
  */
<span class="nc" id="L45">class StreamSummary[T] private (val capacity: Int,</span>
<span class="nc" id="L46">                                private val counterMap: java.util.HashMap[T, ListNode2[Counter[T]]],</span>
<span class="nc" id="L47">                                private val bucketList: DoublyLinkedList[Bucket[T]]) extends ITopK[T] {</span>

  /**
    * Algorithm: `Space-Saving`
    *
    * @param item stream element (`e`)
    * @return false if item was already in the stream summary, true otherwise
    */
<span class="nc" id="L55">  override def offer(item: T): Boolean = offer(item, 1)</span>

  /**
    * Algorithm: `Space-Saving`
    *
    * @param item stream element (`e`)
    * @return false if item was already in the stream summary, true otherwise
    */
<span class="nc" id="L63">  override def offer(item: T, increment: Int): Boolean = offerReturnAll(item, increment)._1</span>

<span class="nc" id="L65">  def offer(item: T, increment: Long): Boolean = offerReturnAll(item, increment)._1</span>

  /**
    * @param item stream element (`e`)
    * @return item dropped from summary if an item was dropped, null otherwise
    */
<span class="nc" id="L71">  def offerReturnDropped(item: T, increment: Long): T = offerReturnAll(item, increment)._2</span>

  /**
    * @param item stream element (`e`)
    * @return (isNewItem, itemDropped) where isNewItem is the return value of offer() and itemDropped is
    *         null if no item was dropped
    */
  def offerReturnAll(item: T, increment: Long): (Boolean, T) = {
<span class="nc" id="L79">    var counterNode = counterMap.get(item)</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">    val isNewItem = counterNode == null</span>
<span class="nc" id="L81">    var droppedItem: T = null.asInstanceOf[T]</span>

<span class="nc bnc" id="L83" title="All 2 branches missed.">    if (isNewItem) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      if (size &lt; capacity) {</span>
<span class="nc" id="L85">        counterNode = bucketList.enqueue(new Bucket(0)).getValue.counterList.add(new Counter[T](bucketList.tail(), item))</span>
      } else {
<span class="nc" id="L87">        val min = bucketList.first()</span>
<span class="nc" id="L88">        counterNode = min.counterList.tail()</span>
<span class="nc" id="L89">        val counter = counterNode.getValue</span>
<span class="nc" id="L90">        droppedItem = counter.item</span>
<span class="nc" id="L91">        counterMap.remove(droppedItem)</span>
<span class="nc" id="L92">        counter.item = item</span>
<span class="nc" id="L93">        counter.error = min.count</span>
      }
<span class="nc" id="L95">      counterMap.put(item, counterNode)</span>
    }

<span class="nc" id="L98">    incrementCounter(counterNode, increment)</span>

<span class="nc" id="L100">    (isNewItem, droppedItem)</span>
  }

  private def incrementCounter(counterNode: ListNode2[Counter[T]], increment: Long): Unit = {
<span class="nc" id="L104">    val counter = counterNode.getValue     // count_i</span>
<span class="nc" id="L105">    val oldNode = counter.bucketNode</span>
<span class="nc" id="L106">    val bucket = oldNode.getValue          // Let Bucket_i be the bucket of count_i</span>
<span class="nc" id="L107">    bucket.counterList.remove(counterNode) // Detach count_i from Bucket_i's child-list</span>
<span class="nc" id="L108">    counter.count += increment</span>

    // Finding the right bucket for count_i
    // Because we allow a single call to increment count more than once, this may not be the adjacent bucket.
<span class="nc" id="L112">    var bucketNodePrev = oldNode</span>
<span class="nc" id="L113">    var bucketNodeNext = bucketNodePrev.getNext</span>
<span class="nc" id="L114">    var break = false</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">    while (!break &amp;&amp; bucketNodeNext != null) {</span>
<span class="nc" id="L116">      val bucketNext = bucketNodeNext.getValue // Let Bucket_i^+ be Bucket_i's neighbor of larger value</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">      if (counter.count == bucketNext.count) {</span>
<span class="nc" id="L118">        bucketNext.counterList.add(counterNode)    // Attach count_i to Bucket_i^+'s child-list</span>
<span class="nc" id="L119">        break = true</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">      } else if (counter.count &gt; bucketNext.count) {</span>
<span class="nc" id="L121">        bucketNodePrev = bucketNodeNext</span>
<span class="nc" id="L122">        bucketNodeNext = bucketNodePrev.getNext  // Continue hunting for an appropriate bucket</span>
      } else {
        // A new bucket has to be created
<span class="nc" id="L125">        bucketNodeNext = null</span>
      }
    }

<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (bucketNodeNext == null) {</span>
<span class="nc" id="L130">        val bucketNext = new Bucket[T](counter.count)</span>
<span class="nc" id="L131">        bucketNext.counterList.add(counterNode)</span>
<span class="nc" id="L132">        bucketNodeNext = bucketList.addAfter(bucketNodePrev, bucketNext)</span>
    }
<span class="nc" id="L134">    counter.bucketNode = bucketNodeNext</span>

    // Cleaning up
<span class="nc bnc" id="L137" title="All 2 branches missed.">    if (bucket.counterList.isEmpty) {     // If Bucket_i's child-list is empty</span>
<span class="nc" id="L138">      bucketList.remove(oldNode);         // Detach Bucket_i from the Stream-Summary</span>
    }
  }

  override def peek(k: Int): java.util.List[T] = {
<span class="nc" id="L143">    val topK = new java.util.ArrayList[T](k)</span>

<span class="nc bnc" id="L145" title="All 2 branches missed.">    if (k &gt; 0) {</span>
<span class="nc" id="L146">      var bNode = bucketList.head()</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">      while (bNode != null) {</span>
<span class="nc" id="L148">        val b = bNode.getValue</span>
<span class="nc" id="L149">        val iter = b.counterList.iterator()</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        while (iter.hasNext) {</span>
<span class="nc" id="L151">          topK.add(iter.next.item)</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">          if (topK.size() == k) {</span>
<span class="nc" id="L153">            return topK</span>
          }
        }
<span class="nc" id="L156">        bNode = bNode.getPrev</span>
      }
    }

<span class="nc" id="L160">    topK</span>
  }

<span class="nc" id="L163">  def topK(k : Int): Iterator[(T, Long)] = new Iterator[(T, Long)] {</span>
<span class="nc" id="L164">    private var i = 0</span>
<span class="nc" id="L165">    private var bNode = bucketList.head()</span>
<span class="nc" id="L166">    private var counters = nextCounters()</span>

<span class="nc bnc" id="L168" title="All 6 branches missed.">    override def hasNext: Boolean = i &lt; k &amp;&amp; (counters.hasNext || { counters = nextCounters(); counters.hasNext })</span>

    override def next(): (T, Long) = {
<span class="nc" id="L171">      i += 1</span>
<span class="nc" id="L172">      val c = counters.next</span>
<span class="nc" id="L173">      (c.item, c.count)</span>
    }

    private def nextCounters(): java.util.Iterator[Counter[T]] = {
<span class="nc bnc" id="L177" title="All 2 branches missed.">      if (bNode == null) { Collections.emptyIterator() } else {</span>
<span class="nc" id="L178">        val iter = bNode.getValue.counterList.iterator()</span>
<span class="nc" id="L179">        bNode = bNode.getPrev</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (iter.hasNext) {</span>
<span class="nc" id="L181">          iter</span>
        } else {
<span class="nc" id="L183">          nextCounters()</span>
        }
      }
    }
  }

<span class="nc" id="L189">  def size: Int = counterMap.size</span>

  def clear(): Unit = {
<span class="nc" id="L192">    counterMap.clear()</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">    while (!bucketList.isEmpty) {</span>
<span class="nc" id="L194">      bucketList.remove(bucketList.head)</span>
    }
  }

  override def toString: String = {
<span class="nc" id="L199">    val sb = new StringBuilder()</span>
<span class="nc" id="L200">    sb.append('[')</span>
<span class="nc" id="L201">    var bNode = bucketList.head()</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">    while (bNode != null) {</span>
<span class="nc" id="L203">      val b = bNode.getValue</span>
<span class="nc" id="L204">      sb.append('{')</span>
<span class="nc" id="L205">      sb.append(b.count)</span>
<span class="nc" id="L206">      sb.append(&quot;:[&quot;)</span>
<span class="nc" id="L207">      val iter = b.counterList.iterator()</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">      while (iter.hasNext) {</span>
<span class="nc" id="L209">        val c = iter.next</span>
<span class="nc" id="L210">        sb.append('{')</span>
<span class="nc" id="L211">        sb.append(c.item)</span>
<span class="nc" id="L212">        sb.append(':')</span>
<span class="nc" id="L213">        sb.append(c.error)</span>
<span class="nc" id="L214">        sb.append(&quot;},&quot;)</span>
      }
<span class="nc bnc" id="L216" title="All 2 branches missed.">      if (b.counterList.size() &gt; 0) {</span>
<span class="nc" id="L217">        sb.deleteCharAt(sb.length - 1)</span>
      }
<span class="nc" id="L219">      sb.append(&quot;]},&quot;)</span>
<span class="nc" id="L220">      bNode = bNode.getPrev</span>
    }
<span class="nc bnc" id="L222" title="All 2 branches missed.">    if (bucketList.size() &gt; 0) {</span>
<span class="nc" id="L223">      sb.deleteCharAt(sb.length - 1)</span>
    }
<span class="nc" id="L225">    sb.append(']')</span>
<span class="nc" id="L226">    sb.toString()</span>
  }
}

<span class="nc" id="L230">object StreamSummary {</span>

  /**
    * Create an empty stream summary
    *
    * @param capacity capacity
    * @tparam T type param
    * @return stream summary
    */
  def apply[T](capacity: Int): StreamSummary[T] = {
<span class="nc" id="L240">    val counterMap = new java.util.HashMap[T, ListNode2[Counter[T]]]()</span>
<span class="nc" id="L241">    val bucketList = new DoublyLinkedList[Bucket[T]]()</span>
<span class="nc" id="L242">    new StreamSummary(capacity, counterMap, bucketList)</span>
  }

  /**
    * Create a stream summary containing counts
    *
    * @param capacity capacity
    * @param counters counters - must be sorted high-&gt;low
    * @tparam T type param
    * @return stream summary
    */
  def apply[T](capacity: Int, counters: Seq[(T, Long)]): StreamSummary[T] = {
<span class="nc" id="L254">    val bucketList = new DoublyLinkedList[Bucket[T]]()</span>
<span class="nc" id="L255">    val counterMap = new java.util.HashMap[T, ListNode2[Counter[T]]](counters.length)</span>

<span class="nc" id="L257">    var currentBucket: Bucket[T] = null</span>
<span class="nc" id="L258">    var currentBucketNode: ListNode2[Bucket[T]] = null</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">    counters.foreach { case (item, count) =&gt;</span>
<span class="nc" id="L261">      val c = new Counter[T](null, item, count)</span>
<span class="nc bnc" id="L262" title="All 4 branches missed.">      if (currentBucket == null || c.count != currentBucket.count) {</span>
<span class="nc" id="L263">        currentBucket = new Bucket(c.count)</span>
<span class="nc" id="L264">        currentBucketNode = bucketList.enqueue(currentBucket)</span>
      }
<span class="nc" id="L266">      c.bucketNode = currentBucketNode</span>
<span class="nc" id="L267">      counterMap.put(c.item, currentBucket.counterList.add(c))</span>
    }

<span class="nc" id="L270">    new StreamSummary(capacity, counterMap, bucketList)</span>
  }

<span class="nc" id="L273">  private class Bucket[T](var count: Long) {</span>
<span class="nc" id="L274">    val counterList = new DoublyLinkedList[Counter[T]]</span>
  }

<span class="nc" id="L277">  private class Counter[T](var bucketNode: ListNode2[Bucket[T]], var item: T, var count: Long = 0L, var error: Long = 0L) {</span>
<span class="nc" id="L278">    override def toString: String = s&quot;$item:$count:$error&quot;</span>
  }
<span class="nc" id="L280">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>