<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HyperLogLog.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.clearspring</a> &gt; <span class="el_source">HyperLogLog.scala</span></div><h1>HyperLogLog.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

/**
  * Adapted from:
  *
  * stream-lib
  * Copyright (C) 2011 Clearspring Technologies, Inc.
  * Copyright 2016 AddThis
  *
  * This product includes software developed by AddThis.
  *
  * This product also includes code adapted from:
  *
  * Apache Solr (http://lucene.apache.org/solr/)
  * Copyright 2014 The Apache Software Foundation
  *
  * Apache Mahout (http://mahout.apache.org/)
  * Copyright 2014 The Apache Software Foundation
  *
  */

package org.locationtech.geomesa.index.stats.clearspring

import com.clearspring.analytics.hash.MurmurHash
import com.clearspring.analytics.stream.cardinality.ICardinality

/**
  * Scala implementation of HyperLogLog (HLL) algorithm from this paper:
  * &lt;p/&gt;
  * http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf
  * &lt;p/&gt;
  * HLL is an improved version of LogLog that is capable of estimating
  * the cardinality of a set with accuracy = 1.04/sqrt(m) where
  * m = math.pow(2, b).  So we can control accuracy vs space usage by increasing
  * or decreasing b.
  * &lt;p/&gt;
  * The main benefit of using HLL over LL is that it only requires 64%
  * of the space that LL does to get the same accuracy.
  * &lt;p/&gt;
  * This implementation implements a single counter.  If a large (millions)
  * number of counters are required you may want to refer to:
  * &lt;p/&gt;
  * http://dsiutils.dsi.unimi.it/
  * &lt;p/&gt;
  * It has a more complex implementation of HLL that supports multiple counters
  * in a single object, drastically reducing the java overhead from creating
  * a large number of objects.
  * &lt;p/&gt;
  * This implementation leveraged a javascript implementation that Yammer has
  * been working on:
  * &lt;p/&gt;
  * https://github.com/yammer/probablyjs
  * &lt;p&gt;
  * Note that this implementation does not include the long range correction function
  * defined in the original paper.  Empirical evidence shows that the correction
  * function causes more harm than good.
  * &lt;/p&gt;
  * &lt;p/&gt;
  * &lt;p&gt;
  * Users have different motivations to use different types of hashing functions.
  * Rather than try to keep up with all available hash functions and to remove
  * the concern of causing future binary incompatibilities this class allows clients
  * to offer the value in hashed int or long form.  This way clients are free
  * to change their hash function on their own time line.  We recommend using Google's
  * Guava Murmur3_128 implementation as it provides good performance and speed when
  * high precision is required.  In our tests the 32bit MurmurHash function included
  * in this project is faster and produces better results than the 32 bit murmur3
  * implementation google provides.
  * &lt;/p&gt;
  */
/**
  * Create a new HyperLogLog instance.  The log2m parameter defines the accuracy of
  * the counter.  The larger the log2m the better the accuracy.
  * &lt;p/&gt;
  * accuracy = 1.04/sqrt(math.pow(2, log2m))
  *
  * @param log2m - the number of bits to use as the basis for the HLL instance
  */
<span class="nc" id="L85">class HyperLogLog private (val log2m: Int, val registerSet: RegisterSet) extends ICardinality {</span>

<span class="nc bnc" id="L87" title="All 4 branches missed.">  require(log2m &gt;= 0 &amp;&amp; log2m &lt;= 30, s&quot;log2m argument $log2m is outside the acceptable range [0, 30]&quot;)</span>

<span class="nc" id="L89">  private val alphaMM: Double = HyperLogLog.getAlphaMM(log2m, 1 &lt;&lt; log2m)</span>

  override def offerHashed(hashedValue: Long): Boolean = {
    // j becomes the binary address determined by the first b log2m of x
    // j will be between 0 and 2^log2m
<span class="nc" id="L94">    val j = (hashedValue &gt;&gt;&gt; (java.lang.Long.SIZE - log2m)).asInstanceOf[Int]</span>
<span class="nc" id="L95">    val r = java.lang.Long.numberOfLeadingZeros((hashedValue &lt;&lt; log2m) | (1 &lt;&lt; (log2m - 1)) + 1) + 1</span>
<span class="nc" id="L96">    registerSet.updateIfGreater(j, r)</span>
  }

  override def offerHashed(hashedValue: Int): Boolean = {
    // j becomes the binary address determined by the first b log2m of x
    // j will be between 0 and 2^log2m
<span class="nc" id="L102">    val j = hashedValue &gt;&gt;&gt; (Integer.SIZE - log2m)</span>
<span class="nc" id="L103">    val r = Integer.numberOfLeadingZeros((hashedValue &lt;&lt; log2m) | (1 &lt;&lt; (log2m - 1)) + 1) + 1</span>
<span class="nc" id="L104">    registerSet.updateIfGreater(j, r)</span>
  }

<span class="nc" id="L107">  override def offer(o: Any): Boolean = offerHashed(MurmurHash.hash(o))</span>

  override def cardinality: Long = {
<span class="nc" id="L110">    var registerSum = 0d</span>
<span class="nc" id="L111">    var zeros = 0.0</span>

<span class="nc" id="L113">    var j = 0</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    while (j &lt; registerSet.count) {</span>
<span class="nc" id="L115">      val value = registerSet.get(j)</span>
<span class="nc" id="L116">      registerSum += 1.0 / (1 &lt;&lt; value)</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">      if (value == 0) {</span>
<span class="nc" id="L118">        zeros += 1</span>
      }
<span class="nc" id="L120">      j += 1</span>
    }

<span class="nc" id="L123">    val estimate = alphaMM * (1 / registerSum)</span>

<span class="nc bnc" id="L125" title="All 2 branches missed.">    if (estimate &lt;= (5.0 / 2.0) * registerSet.count) {</span>
      // Small Range Estimate
<span class="nc" id="L127">      math.round(HyperLogLog.linearCounting(registerSet.count, zeros))</span>
    } else {
<span class="nc" id="L129">      math.round(estimate)</span>
    }
  }

<span class="nc" id="L133">  override def sizeof(): Int = registerSet.size * 4</span>

  /**
    * Add all the elements of the other set to this set.
    * &lt;p/&gt;
    * This operation does not imply a loss of precision.
    *
    * @param other A compatible Hyperloglog instance (same log2m)
    * @throws IllegalArgumentException if other is not compatible
    */
  def +=(other: HyperLogLog): Unit = {
<span class="nc bnc" id="L144" title="All 2 branches missed.">    require(registerSet.size == other.registerSet.size, &quot;Cannot merge estimators of different sizes&quot;)</span>
<span class="nc" id="L145">    registerSet.merge(other.registerSet)</span>
  }

  override def merge(estimators: ICardinality*): HyperLogLog = {
<span class="nc" id="L149">    val merged = new HyperLogLog(log2m, new RegisterSet(this.registerSet.count)())</span>
<span class="nc" id="L150">    merged += this</span>
<span class="nc" id="L151">    estimators.foreach {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">      case h: HyperLogLog =&gt; merged += h</span>
<span class="nc" id="L153">      case e =&gt; throw new IllegalArgumentException(s&quot;Cannot merge estimators of different class: $e&quot;)</span>
    }
<span class="nc" id="L155">    merged</span>
  }

<span class="nc" id="L158">  override def getBytes: Array[Byte] = throw new UnsupportedOperationException()</span>
}

<span class="nc" id="L161">object HyperLogLog {</span>

<span class="nc" id="L163">  def apply(log2m: Int): HyperLogLog = new HyperLogLog(log2m, new RegisterSet(1 &lt;&lt; log2m)())</span>

  def apply(log2m: Int, register: Array[Int]): HyperLogLog =
<span class="nc" id="L166">    new HyperLogLog(log2m, new RegisterSet(1 &lt;&lt; log2m)(register))</span>

  private def getAlphaMM(p: Int, m: Int): Double = {
    // See the paper.
<span class="nc bnc" id="L170" title="All 4 branches missed.">    p match {</span>
<span class="nc" id="L171">      case 4 =&gt; 0.673 * m * m</span>
<span class="nc" id="L172">      case 5 =&gt; 0.697 * m * m</span>
<span class="nc" id="L173">      case 6 =&gt; 0.709 * m * m</span>
<span class="nc" id="L174">      case _ =&gt; (0.7213 / (1 + 1.079 / m)) * m * m</span>
    }
  }

<span class="nc" id="L178">  private def linearCounting(m: Int, V: Double): Double = m * math.log(m / V)</span>
<span class="nc" id="L179">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>