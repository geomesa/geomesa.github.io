<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CountMinSketch.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.clearspring</a> &gt; <span class="el_source">CountMinSketch.scala</span></div><h1>CountMinSketch.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

/**
  * Adapted from:
  *
  * stream-lib
  * Copyright 2016 AddThis
  *
  * This product includes software developed by AddThis.
  *
  * This product also includes code adapted from:
  *
  * Apache Solr (http://lucene.apache.org/solr/)
  * Copyright 2014 The Apache Software Foundation
  *
  * Apache Mahout (http://mahout.apache.org/)
  * Copyright 2014 The Apache Software Foundation
  *
  */

package org.locationtech.geomesa.index.stats.clearspring

import com.clearspring.analytics.stream.frequency.IFrequency
import com.clearspring.analytics.stream.membership.Filter

/**
 * Count-Min Sketch datastructure.
 * An Improved Data Stream Summary: The Count-Min Sketch and its Applications
 * https://web.archive.org/web/20060907232042/http://www.eecs.harvard.edu/~michaelm/CS222/countmin.pdf
 */
<span class="nc" id="L37">class CountMinSketch private (val eps: Double,</span>
<span class="nc" id="L38">                              val confidence: Double,</span>
<span class="nc" id="L39">                              private[stats] val table: Array[Array[Long]],</span>
<span class="nc" id="L40">                              private[stats] var _size: Long,</span>
<span class="nc" id="L41">                              private val depth: Int,</span>
<span class="nc" id="L42">                              private val width: Int,</span>
<span class="nc" id="L43">                              private val hashA: Array[Long]) extends IFrequency {</span>

<span class="nc" id="L45">  def getRelativeError: Double = eps</span>
<span class="nc" id="L46">  def getConfidence: Double = confidence</span>

  private def hash(item: Long, i: Int): Int = {
<span class="nc" id="L49">    var hash = hashA(i) * item</span>
    // A super fast way of computing x mod 2^p-1
    // See http://www.cs.princeton.edu/courses/archive/fall09/cos521/Handouts/universalclasses.pdf
    // page 149, right after Proposition 7.
<span class="nc" id="L53">    hash += hash &gt;&gt; 32</span>
<span class="nc" id="L54">    hash &amp;= CountMinSketch.PrimeModulus</span>
    // Doing &quot;%&quot; after (int) conversion is ~2x faster than %'ing longs.
<span class="nc" id="L56">    hash.toInt % width</span>
  }

  override def add(item: Long, count: Long): Unit = {
<span class="nc bnc" id="L60" title="All 2 branches missed.">    if (count &lt; 0) {</span>
      // Actually for negative increments we'll need to use the median
      // instead of minimum, and accuracy will suffer somewhat.
      // Probably makes sense to add an &quot;allow negative increments&quot;
      // parameter to constructor.
<span class="nc" id="L65">      throw new IllegalArgumentException(&quot;Negative increments not implemented&quot;)</span>
    }
<span class="nc" id="L67">    var i = 0</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">    while (i &lt; depth) {</span>
<span class="nc" id="L69">      table(i)(hash(item, i)) += count</span>
<span class="nc" id="L70">      i += 1</span>
    }
<span class="nc" id="L72">    _size += count</span>
  }

  override def add(item: String, count: Long): Unit = {
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (count &lt; 0) {</span>
      // Actually for negative increments we'll need to use the median
      // instead of minimum, and accuracy will suffer somewhat.
      // Probably makes sense to add an &quot;allow negative increments&quot;
      // parameter to constructor.
<span class="nc" id="L81">      throw new IllegalArgumentException(&quot;Negative increments not implemented&quot;)</span>
    }
<span class="nc" id="L83">    val buckets = Filter.getHashBuckets(item, depth, width)</span>
<span class="nc" id="L84">    var i = 0</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">    while (i &lt; depth) {</span>
<span class="nc" id="L86">      table(i)(buckets(i)) += count</span>
<span class="nc" id="L87">      i += 1</span>
    }
<span class="nc" id="L89">    _size += count</span>
  }

  /**
    * The estimate is correct within 'epsilon' * (total item count),
    * with probability 'confidence'.
    */
  override def estimateCount(item: Long): Long = {
<span class="nc" id="L97">    var res = Long.MaxValue</span>
<span class="nc" id="L98">    var i = 0</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">    while (i &lt; depth) {</span>
<span class="nc" id="L100">      val row = table(i)</span>
<span class="nc" id="L101">      res = math.min(res, row(hash(item, i)))</span>
<span class="nc" id="L102">      i += 1</span>
    }
<span class="nc" id="L104">    res</span>
  }

  override def estimateCount(item: String): Long = {
<span class="nc" id="L108">    var res = Long.MaxValue</span>
<span class="nc" id="L109">    val buckets = Filter.getHashBuckets(item, depth, width)</span>
<span class="nc" id="L110">    var i = 0</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">    while (i &lt; depth) {</span>
<span class="nc" id="L112">      res = Math.min(res, table(i)(buckets(i)))</span>
<span class="nc" id="L113">      i += 1</span>
    }
<span class="nc" id="L115">    res</span>
  }

  def +=(other: CountMinSketch): Unit = {
    // note: we assume that seed is equal
<span class="nc bnc" id="L120" title="All 4 branches missed.">    if (depth != other.depth || width != other.width) {</span>
<span class="nc" id="L121">      throw new IllegalArgumentException(&quot;Can't merge CountMinSketch of different sizes&quot;)</span>
    }
<span class="nc" id="L123">    var i, j = 0</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    while (i &lt; table.length) {</span>
<span class="nc" id="L125">      val row = table(i)</span>
<span class="nc" id="L126">      val otherRow = other.table(i)</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      while (j &lt; row.length) {</span>
<span class="nc" id="L128">        row(j) += otherRow(j)</span>
<span class="nc" id="L129">        j += 1</span>
      }
<span class="nc" id="L131">      i += 1</span>
<span class="nc" id="L132">      j = 0</span>
    }
<span class="nc" id="L134">    _size += other.size</span>
  }

  def clear(): Unit = {
<span class="nc" id="L138">    var i, j = 0</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">    while (i &lt; depth) {</span>
<span class="nc" id="L140">      val row = table(i)</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">      while (j &lt; width) {</span>
<span class="nc" id="L142">        row(j) = 0L</span>
<span class="nc" id="L143">        j += 1</span>
      }
<span class="nc" id="L145">      i += 1</span>
<span class="nc" id="L146">      j = 0</span>
    }
<span class="nc" id="L148">    _size = 0L</span>
  }

  def isEquivalent(other: CountMinSketch): Boolean = {
<span class="nc bnc" id="L152" title="All 6 branches missed.">    if (size != other.size || depth != other.depth || width != other.width) {</span>
<span class="nc" id="L153">      return false</span>
    }
<span class="nc" id="L155">    var i, j = 0</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    while (i &lt; depth) {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      if (hashA(i) != other.hashA(i)) {</span>
<span class="nc" id="L158">        return false</span>
      }
<span class="nc" id="L160">      val row = table(i)</span>
<span class="nc" id="L161">      val otherRow = other.table(i)</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      while (j &lt; width) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (row(j) != otherRow(j)) {</span>
<span class="nc" id="L164">          return false</span>
        }
<span class="nc" id="L166">        j += 1</span>
      }
<span class="nc" id="L168">      i += 1</span>
<span class="nc" id="L169">      j = 0</span>
    }
<span class="nc" id="L171">    true</span>
  }

<span class="nc" id="L174">  override def size: Long = _size</span>
}

<span class="nc" id="L177">object CountMinSketch {</span>

<span class="nc" id="L179">  private val PrimeModulus: Long = (1L &lt;&lt; 31) - 1</span>

  def apply(eps: Double, confidence: Double, seed: Int): CountMinSketch = {

    // 2/w = eps ; w = 2/eps
    // 1/2^depth &lt;= 1-confidence ; depth &gt;= -log2 (1-confidence)

<span class="nc" id="L186">    val width = math.ceil(2 / eps).toInt</span>
<span class="nc" id="L187">    val depth = math.ceil(-1 * math.log(1 - confidence) / math.log(2)).toInt</span>

<span class="nc" id="L189">    val table: Array[Array[Long]] = Array.fill(depth)(Array.fill(width)(0L))</span>

    // We're using a linear hash functions
    // of the form (a*x+b) mod p.
    // a,b are chosen independently for each hash function.
    // However we can set b = 0 as all it does is shift the results
    // without compromising their uniformity or independence with
    // the other hashes.
    val hashA: Array[Long] = {
<span class="nc" id="L198">      val r = new java.util.Random(seed)</span>
<span class="nc" id="L199">      Array.fill(depth)(r.nextInt(Int.MaxValue))</span>
    }

<span class="nc" id="L202">    new CountMinSketch(eps, confidence, table, 0L, depth, width, hashA)</span>
  }
<span class="nc" id="L204">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>