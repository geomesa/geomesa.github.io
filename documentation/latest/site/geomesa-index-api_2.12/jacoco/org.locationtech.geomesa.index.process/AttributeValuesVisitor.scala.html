<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttributeValuesVisitor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.process</a> &gt; <span class="el_source">AttributeValuesVisitor.scala</span></div><h1>AttributeValuesVisitor.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.process

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.{Query, SimpleFeatureSource}
import org.geotools.api.feature.Feature
import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.SimpleFeature
import org.geotools.api.filter.Filter
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.feature.visitor.{AbstractCalcResult, CalcResult}
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.index.conf.QueryHints
import org.locationtech.geomesa.index.index.attribute.AttributeIndex
import org.locationtech.geomesa.index.iterators.StatsScan
import org.locationtech.geomesa.index.process.AttributeValuesVisitor.AttributeResult
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.impl.EnumerationStat
import org.locationtech.geomesa.utils.collection.CloseableIterator

import scala.collection.mutable

/**
 * Visitor that tracks unique attribute values and counts
 *
 * @param features features to evaluate
 * @param attributeDescriptor attribute to evaluate
 * @param filter optional filter to apply to features before evaluating
 * @param histogram return counts or not
 */
<span class="nc bnc" id="L38" title="All 4 branches missed.">class AttributeValuesVisitor(</span>
<span class="nc" id="L39">    val features: SimpleFeatureCollection,</span>
<span class="nc" id="L40">    val attributeDescriptor: AttributeDescriptor,</span>
<span class="nc" id="L41">    val filter: Option[Filter],</span>
    histogram: Boolean
<span class="nc" id="L43">  ) extends GeoMesaProcessVisitor with LazyLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  import scala.collection.JavaConverters._

<span class="nc" id="L49">  private val attribute    = attributeDescriptor.getLocalName</span>
<span class="nc" id="L50">  private val uniqueValues = mutable.Map.empty[AnyRef, Long].withDefaultValue(0)</span>

<span class="nc" id="L52">  private var attributeIdx: Int = -1</span>

  // normally handled in our query planner, but we are going to use the filter directly here
<span class="nc bnc" id="L55" title="All 4 branches missed.">  private lazy val manualFilter = filter.map(FastFilterFactory.optimize(features.getSchema, _))</span>

  private def getAttribute[T](f: SimpleFeature): T = {
<span class="nc bnc" id="L58" title="All 2 branches missed.">    if (attributeIdx == -1) {</span>
<span class="nc" id="L59">      attributeIdx = f.getType.indexOf(attribute)</span>
    }
<span class="nc" id="L61">    f.getAttribute(attributeIdx).asInstanceOf[T]</span>
  }

  private def addSingularValue(f: SimpleFeature): Unit = {
<span class="nc" id="L65">    val value = getAttribute[AnyRef](f)</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">    if (value != null) {</span>
<span class="nc" id="L67">      uniqueValues(value) += 1</span>
    }
  }

  private def addMultiValue(f: SimpleFeature): Unit = {
<span class="nc" id="L72">    val values = getAttribute[java.util.Collection[AnyRef]](f)</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">    if (values != null) {</span>
<span class="nc" id="L74">      values.asScala.foreach(uniqueValues(_) += 1)</span>
    }
  }

<span class="nc" id="L78">  private val addValue: SimpleFeature =&gt; Unit =</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">    if (attributeDescriptor.isList) { addMultiValue } else { addSingularValue }</span>

  // non-optimized visit
  override def visit(feature: Feature): Unit = {
<span class="nc" id="L83">    val f = feature.asInstanceOf[SimpleFeature]</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">    if (manualFilter.forall(_.evaluate(f))) {</span>
<span class="nc" id="L85">      addValue(f)</span>
    }
  }

<span class="nc" id="L89">  override def getResult: AttributeResult = new AttributeResult(uniqueValues.toMap)</span>

  override def execute(source: SimpleFeatureSource, query: Query): Unit = {

    import org.locationtech.geomesa.filter.mergeFilters

<span class="nc bnc" id="L95" title="All 2 branches missed.">    logger.debug(s&quot;Running Geomesa histogram process on source type ${source.getClass.getName}&quot;)</span>

    // combine filters from this process and any input collection
<span class="nc" id="L98">    filter.foreach(f =&gt; query.setFilter(mergeFilters(query.getFilter, f)))</span>

<span class="nc" id="L100">    val sft = source.getSchema</span>

<span class="nc bnc" id="L102" title="All 2 branches missed.">    val enumerated = if (attributeDescriptor.isMultiValued) {</span>
      // stats don't support list types
<span class="nc" id="L104">      uniqueV5(source, query)</span>
    } else {
      // TODO if !histogram, we could write a new unique skipping iterator
<span class="nc" id="L107">      query.getHints.put(QueryHints.STATS_STRING, Stat.Enumeration(attribute))</span>
<span class="nc" id="L108">      query.getHints.put(QueryHints.ENCODE_STATS, java.lang.Boolean.TRUE)</span>

      // execute the query
<span class="nc" id="L111">      val reader = source.getFeatures(query).features()</span>

      val enumeration = try {
        // stats should always return exactly one result, even if there are no features in the table
<span class="nc" id="L115">        val encoded = reader.next.getAttribute(0).asInstanceOf[String]</span>
<span class="nc" id="L116">        StatsScan.decodeStat(sft)(encoded).asInstanceOf[EnumerationStat[AnyRef]]</span>
      } finally {
<span class="nc" id="L118">        reader.close()</span>
      }

<span class="nc" id="L121">      enumeration.frequencies</span>
    }

<span class="nc" id="L124">    uniqueValues.clear()</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">    enumerated.foreach { case (k, v) =&gt; uniqueValues.put(k, v) }</span>
  }

  private def uniqueV5(source: SimpleFeatureSource, query: Query): Iterable[(AnyRef, Long)] = {
    import org.locationtech.geomesa.filter.ff

    // only return the attribute we are interested in to reduce bandwidth
<span class="nc" id="L132">    query.setPropertyNames(Seq(attribute).asJava)</span>

    // if there is no filter, try to force an attribute scan - should be the fastest query
<span class="nc bnc" id="L135" title="All 8 branches missed.">    if (query.getFilter == Filter.INCLUDE &amp;&amp; AttributeIndex.indexed(features.getSchema, attribute)) {</span>
      // a filter that is equivalent to Filter.INCLUDE, but against the attribute index
<span class="nc" id="L137">      query.setFilter(ff.greaterOrEqual(ff.property(attribute), ff.literal(&quot;&quot;)))</span>
    }

    // execute the query
<span class="nc" id="L141">    CloseableIterator(source.getFeatures(query).features()).foreach(addValue)</span>
<span class="nc" id="L142">    uniqueValues.toMap</span>
  }
}

<span class="nc" id="L146">object AttributeValuesVisitor {</span>

  import scala.collection.JavaConverters._

  /**
   * Result class to hold the attribute histogram
   *
   * @param attributes result
   */
<span class="nc" id="L155">  class AttributeResult(val attributes: Map[AnyRef, Long]) extends AbstractCalcResult {</span>

<span class="nc" id="L157">    override def getValue: java.util.Map[AnyRef, Long] = attributes.asJava</span>

    override def isCompatible(targetResults: CalcResult): Boolean =
<span class="nc bnc" id="L160" title="All 8 branches missed.">      targetResults.isInstanceOf[AttributeResult] || targetResults == CalcResult.NULL_RESULT</span>

    override def merge(resultsToAdd: CalcResult): CalcResult = {
<span class="nc bnc" id="L163" title="All 2 branches missed.">      if (!isCompatible(resultsToAdd)) {</span>
<span class="nc" id="L164">        throw new IllegalArgumentException(&quot;Parameter is not a compatible type&quot;)</span>
<span class="nc bnc" id="L165" title="All 6 branches missed.">      } else if (resultsToAdd == CalcResult.NULL_RESULT) {</span>
<span class="nc" id="L166">        this</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">      } else if (resultsToAdd.isInstanceOf[AttributeResult]) {</span>
<span class="nc" id="L168">        val toAdd = resultsToAdd.getValue.asInstanceOf[Map[AnyRef, Long]]</span>
        // note ++ on maps will get all keys with second maps values if exists, if not first map values
<span class="nc bnc" id="L170" title="All 2 branches missed.">        val merged = attributes ++ toAdd.map {</span>
<span class="nc" id="L171">          case (attr, count) =&gt; attr -&gt; (count + attributes.getOrElse(attr, 0L))</span>
        }
<span class="nc" id="L173">        new AttributeResult(merged)</span>
      } else {
<span class="nc" id="L175">        throw new IllegalArgumentException(</span>
<span class="nc" id="L176">          &quot;The CalcResults claim to be compatible, but the appropriate merge method has not been implemented.&quot;)</span>
      }
    }
  }
<span class="nc" id="L180">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>