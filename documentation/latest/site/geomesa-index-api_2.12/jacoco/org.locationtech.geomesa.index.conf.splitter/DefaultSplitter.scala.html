<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultSplitter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.conf.splitter</a> &gt; <span class="el_source">DefaultSplitter.scala</span></div><h1>DefaultSplitter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.conf.splitter

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.curve.BinnedTime
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.index.conf.TableSplitter
import org.locationtech.geomesa.index.conf.splitter.SplitPatternParser.SplitPattern
import org.locationtech.geomesa.index.index.attribute.{AttributeIndex, AttributeIndexKey}
import org.locationtech.geomesa.index.index.id.IdIndex
import org.locationtech.geomesa.index.index.z2.{XZ2Index, Z2Index}
import org.locationtech.geomesa.index.index.z3.{XZ3Index, Z3Index}
import org.locationtech.geomesa.utils.conf.IndexId
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.text.{DateParsing, KVPairParser}

import java.nio.charset.StandardCharsets
import java.time.format.DateTimeFormatter
import java.util.Date
import scala.util.Try

/**
  * Default splitter implementation that creates splits based on configured user data
  */
<span class="nc bnc" id="L34" title="All 4 branches missed.">class DefaultSplitter extends TableSplitter with LazyLogging {</span>

  import AttributeIndex.JoinIndexName
  import DefaultSplitter._

  override def getSplits(sft: SimpleFeatureType, index: String, options: String): Array[Array[Byte]] =
<span class="nc" id="L40">    getSplits(sft, index, null, options)</span>

  override def getSplits(sft: SimpleFeatureType,
                         index: String,
                         partition: String,
                         options: String): Array[Array[Byte]] = {
<span class="nc" id="L46">    val splits = Try(IndexId.id(index)).toOption.flatMap { id =&gt;</span>
<span class="nc" id="L47">      val opts = Option(options).map(KVPairParser.parse).getOrElse(Map.empty)</span>
<span class="nc" id="L48">      id.name match {</span>
<span class="nc bnc" id="L49" title="All 6 branches missed.">        case IdIndex.name                        =&gt; Some(idBytes(opts))</span>
<span class="nc bnc" id="L50" title="All 14 branches missed.">        case Z3Index.name | XZ3Index.name        =&gt; Some(z3Bytes(sft, Option(partition), opts))</span>
<span class="nc bnc" id="L51" title="All 14 branches missed.">        case Z2Index.name | XZ2Index.name        =&gt; Some(z2Bytes(opts))</span>
<span class="nc bnc" id="L52" title="All 14 branches missed.">        case AttributeIndex.name | JoinIndexName =&gt; Some(attributeBytes(sft, id.attributes.head, Option(partition), opts))</span>
<span class="nc" id="L53">        case _ =&gt; None</span>
      }
    }
<span class="nc bnc" id="L56" title="All 2 branches missed.">    splits.getOrElse { logger.warn(s&quot;Unhandled index type $index&quot;); Array(Array.empty[Byte]) }</span>
  }
}

<span class="nc" id="L60">object DefaultSplitter {</span>

<span class="nc" id="L62">  val Instance = new DefaultSplitter</span>

<span class="nc" id="L64">  object Parser {</span>

<span class="nc" id="L66">    val Z3MinDateOption = s&quot;${Z3Index.name}.min&quot;</span>
<span class="nc" id="L67">    val Z3MaxDateOption = s&quot;${Z3Index.name}.max&quot;</span>

<span class="nc" id="L69">    private val ZeroByteString = new String(ByteArrays.ZeroByteArray, StandardCharsets.UTF_8)</span>

    /**
      * Creates splits suitable for a feature ID index. If nothing is specified, will assume a hex distribution.
      *
      * *  Options are:
      *
      * * 'id.pattern' - pattern used
      *
      * Additional patterns can be specified with 'id.pattern2', etc
      *
      * @param options user data containing split configuration
      * @return
      */
    def idSplits(options: Map[String, String]): Seq[String] = {
      val patterns = {
<span class="nc" id="L85">        val configured = DefaultSplitter.patterns(s&quot;${IdIndex.name}.pattern&quot;, options)</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (configured.nonEmpty) { configured } else {</span>
<span class="nc" id="L87">          Iterator(&quot;[0]&quot;, &quot;[4]&quot;, &quot;[8]&quot;, &quot;[c]&quot;) // 4 splits assuming hex layout</span>
        }
      }
<span class="nc" id="L90">      patterns.toSeq.flatMap(p =&gt; SplitPatternParser.parse(p).range)</span>
    }

    /**
      * Creates splits suitable for an attribute index. Each indexed attribute can be split individually.
      *
      *  Options are:
      *
      * * 'attr.&amp;lt;attribute&amp;gt;.pattern' - pattern used for a given attribute
      *
      * Additional patterns can be specified with 'attr.&amp;lt;attribute&amp;gt;.pattern2', etc
      *
      * @param name attribute name
      * @param binding attribute type
      * @param options user data containing split configuration
      * @return
      */
    def attributeSplits(name: String, binding: Class[_], options: Map[String, String]): Seq[String] = {
<span class="nc" id="L108">      val patterns = DefaultSplitter.patternPairs(s&quot;${AttributeIndex.name}.$name.&quot;, &quot;pattern&quot;, &quot;date-range&quot;, options)</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      val ranges = patterns.map { case (pattern, datePattern) =&gt;</span>
<span class="nc" id="L110">        (SplitPatternParser.parse(pattern), datePattern.map(SplitPatternParser.parse))</span>
      }
      val getSplits: SplitPattern =&gt; Seq[String] =
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (classOf[Number].isAssignableFrom(binding)) {</span>
<span class="nc" id="L114">          pattern =&gt;</span>
<span class="nc" id="L115">            try { numberPatternSplits(pattern, binding) } catch {</span>
              case e: NumberFormatException =&gt;
<span class="nc" id="L117">                throw new IllegalArgumentException(s&quot;Trying to create splits for attribute '$name' &quot; +</span>
<span class="nc" id="L118">                    s&quot;of type ${binding.getName}, but splits could not be parsed as a number: &quot; +</span>
<span class="nc" id="L119">                    patterns.mkString(&quot; &quot;), e)</span>
            }
        } else {
<span class="nc" id="L122">          pattern =&gt; pattern.range</span>
        }
<span class="nc bnc" id="L124" title="All 2 branches missed.">      ranges.flatMap { case (primary, secondary) =&gt;</span>
<span class="nc" id="L125">        val splits = getSplits(primary)</span>
<span class="nc" id="L126">        secondary match {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">          case None =&gt; splits</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">          case Some(s) =&gt; for { a &lt;- splits; b &lt;- s.range } yield { a + ZeroByteString + b }</span>
        }
      }
    }

    /**
      * Creates splits suitable for a z3 index. Generally, a split will be created per time interval (e.g. week).
      * Further splits can be created by specifying the number of bits that will be used for splits, per week.
      * The total number of splits is: (number of time intervals) * 2^^(number of bits)
      *
      *  Options are:
      *
      * * 'z3.min' - min date for data
      * * 'z3.max' - max date for data (must also include min date) - will default to current date if not specified
      * * 'z3.bits' - number of bits used to create splits. e.g. 2 bits will create 4 splits.
      *
      * @param interval interval of the z3 index
      * @param options user data containing split configuration
      * @return
      */
    def z3Splits(interval: TimePeriod, options: Map[String, String]): Seq[(Short, Option[Long])] = {

      def date(key: String): Option[Date] = {
<span class="nc" id="L151">        options.get(key).map { d =&gt;</span>
<span class="nc" id="L152">          val converted = FastConverter.convert(d, classOf[Date])</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">          if (converted == null) {</span>
<span class="nc" id="L154">            throw new IllegalArgumentException(s&quot;Could not convert date '$d' for splits&quot;)</span>
          }
<span class="nc" id="L156">          converted</span>
        }
      }

<span class="nc" id="L160">      date(Z3MinDateOption).map(_.getTime) match {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        case None =&gt; Seq.empty</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        case Some(min) =&gt;</span>
<span class="nc" id="L163">          val max = date(Z3MaxDateOption).map(_.getTime).getOrElse(System.currentTimeMillis())</span>

<span class="nc" id="L165">          val toBin = BinnedTime.timeToBinnedTime(interval)</span>
<span class="nc" id="L166">          val minBin = toBin(min).bin</span>
<span class="nc" id="L167">          val maxBin = toBin(max).bin</span>
<span class="nc" id="L168">          val times = Seq.range(minBin, maxBin + 1).map(_.toShort)</span>

<span class="nc" id="L170">          val zs = z3BitSplits(options)</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">          if (zs.isEmpty) {</span>
<span class="nc" id="L172">            times.map(t =&gt; (t, None))</span>
          } else {
<span class="nc" id="L174">            times.flatMap(t =&gt; zs.map(z =&gt; (t, Some(z))))</span>
          }
      }
    }

    /**
      * Creates just the bit-splits for a z3 index. Generally this would be applied per time interval. Use `z3Splits`
      * to get bits per time interval.
      *
      * The total number of splits is: 2^^(number of bits)
      *
      *  Options are:
      *
      * * 'z3.bits' - number of bits used to create splits. e.g. 2 bits will create 4 splits.
      *
      * @param options user data containing split configuration
      * @return
      */
    def z3BitSplits(options: Map[String, String]): Seq[Long] = {
      // note: first bit in z value is not used, and is always 0
<span class="nc" id="L194">      bitSplits(s&quot;${Z3Index.name}.bits&quot;, options, 1)</span>
    }

    /**
      * Creates splits suitable for a z2 index. Splits can be created by specifying the number of bits that will be
      * used. The total number of splits is: 2^^(number of bits)
      *
      *  Options are:
      *
      * * 'z2.bits' - number of bits used to create splits. e.g. 2 bits will create 4 splits.
      *
      * @param options user data containing split configuration
      * @return
      */
    def z2Splits(options: Map[String, String]): Seq[Long] =
      // note: first 2 bits in z value are not used, and are always 0
<span class="nc" id="L210">      bitSplits(s&quot;${Z2Index.name}.bits&quot;, options, 2)</span>
  }

<span class="nc" id="L213">  private def idBytes(options: Map[String, String]): Array[Array[Byte]] =</span>
<span class="nc" id="L214">    Parser.idSplits(options).map(_.getBytes(StandardCharsets.UTF_8)).toArray</span>

  private def attributeBytes(
      sft: SimpleFeatureType,
      attribute: String,
      partition: Option[String],
      options: Map[String, String]): Array[Array[Byte]] = {
    import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L224">    val descriptor = sft.getDescriptor(attribute)</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">    val binding = if (descriptor.isList) { descriptor.getListType() } else { descriptor.getType.getBinding }</span>
    // if this is a time partition, update the options to include the min/max dates
<span class="nc" id="L227">    val opts = partition.flatMap(p =&gt; Try(p.toShort).toOption).fold(options) { p =&gt;</span>
<span class="nc" id="L228">      val patterns = DefaultSplitter.patterns(s&quot;${AttributeIndex.name}.$attribute.partition-date-splits&quot;, options)</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      if (patterns.isEmpty) { options } else {</span>
<span class="nc" id="L230">        val period = sft.getZ3Interval</span>
<span class="nc" id="L231">        val toDate = BinnedTime.binnedTimeToDate(period)</span>
<span class="nc" id="L232">        val min = DateParsing.format(toDate(BinnedTime(p, 1L)), DateTimeFormatter.ISO_LOCAL_DATE)</span>
<span class="nc" id="L233">        val max = DateParsing.format(toDate(BinnedTime(p, BinnedTime.maxOffset(period))), DateTimeFormatter.ISO_LOCAL_DATE)</span>
        val dates =
<span class="nc" id="L235">          optionsIterator(s&quot;${AttributeIndex.name}.$attribute.date-range&quot;).zip(patterns.iterator.map(s =&gt; s&quot;$min/$max/$s&quot;)).toMap</span>
<span class="nc" id="L236">        options ++ dates</span>
      }
    }
<span class="nc" id="L239">    Parser.attributeSplits(attribute, binding, opts).map(_.getBytes(StandardCharsets.UTF_8)).toArray</span>
  }

  private def z3Bytes(sft: SimpleFeatureType,
                      partition: Option[String],
                      options: Map[String, String]): Array[Array[Byte]] = {
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

    // if this is a time partition, update the options to include the min/max dates
<span class="nc" id="L248">    val period = sft.getZ3Interval</span>
<span class="nc" id="L249">    val opts = partition.flatMap(p =&gt; Try(p.toShort).toOption) match {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">      case None =&gt; options</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">      case Some(p) =&gt;</span>
<span class="nc" id="L252">        val date = DateParsing.format(BinnedTime.binnedTimeToDate(period).apply(BinnedTime(p, 1L)))</span>
<span class="nc" id="L253">        options ++ Map(Parser.Z3MinDateOption -&gt; date, Parser.Z3MaxDateOption -&gt; date)</span>
    }
<span class="nc bnc" id="L255" title="All 4 branches missed.">    Parser.z3Splits(period, opts).map {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      case (bin, None) =&gt; ByteArrays.toBytes(bin)</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      case (bin, Some(z)) =&gt; ByteArrays.toBytes(bin, z)</span>
<span class="nc" id="L258">    }.toArray</span>
  }

  private def z2Bytes(options: Map[String, String]): Array[Array[Byte]] =
<span class="nc" id="L262">    Parser.z2Splits(options).map(ByteArrays.toBytes).toArray</span>

  private def patterns(base: String, options: Map[String, String]): Seq[String] =
<span class="nc bnc" id="L265" title="All 2 branches missed.">    optionsIterator(base).map(options.get(_).orNull).takeWhile(_ != null).toSeq</span>

  private def patternPairs(
      prefix: String,
      primary: String,
      secondary: String,
      options: Map[String, String]): Seq[(String, Option[String])] = {
<span class="nc bnc" id="L272" title="All 2 branches missed.">    val patterns = optionsIterator(s&quot;$prefix$primary&quot;).zip(optionsIterator(s&quot;$prefix$secondary&quot;)).map {</span>
<span class="nc" id="L273">      case (p, s) =&gt; (options.get(p).orNull, options.get(s))</span>
    }
<span class="nc bnc" id="L275" title="All 2 branches missed.">    patterns.takeWhile(_._1 != null).toSeq</span>
  }

  @throws(classOf[NumberFormatException])
  private def numberPatternSplits(pattern: SplitPattern, binding: Class[_]): Seq[String] = {
<span class="nc" id="L280">    pattern.range.map { r =&gt;</span>
      // validate numeric value
<span class="nc" id="L282">      Integer.parseInt(r)</span>
<span class="nc" id="L283">      AttributeIndexKey.encodeForQuery(r, binding)</span>
    }
  }

  /**
    * Create splits based on individual bits. Will create 2^^(bits) splits.
    *
    * @param key key for number of bits to consider
    * @param options config options
    * @param maskedBits number of unused bits at the start of the first byte
    * @return
    */
  private def bitSplits(key: String, options: Map[String, String], maskedBits: Int): Seq[Long] = {
<span class="nc" id="L296">    options.get(key).map(_.toInt) match {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">      case None =&gt; Seq.empty</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">      case Some(bits) =&gt;</span>
<span class="nc bnc" id="L299" title="All 4 branches missed.">        require(bits &gt; 0 &amp;&amp; bits &lt; 64, &quot;Bit split must be between 1 and 63&quot;)</span>

        // recursive function to create all bit permutations
        def add(result: Seq[Seq[Int]], bits: Seq[Int], remaining: Int): Seq[Seq[Int]] = {
<span class="nc bnc" id="L303" title="All 2 branches missed.">          if (remaining == 0) { Seq(bits) } else {</span>
<span class="nc" id="L304">            val zero = add(result, bits :+ 0, remaining - 1)</span>
<span class="nc" id="L305">            val one = add(result, bits :+ 1, remaining - 1)</span>
<span class="nc" id="L306">            result ++ zero ++ one</span>
          }
        }
        // note: first bit(s) in z value are not used, and are always 0
        def toLong(bits: Seq[Int]): Long = {
<span class="nc" id="L311">          val binaryString = (Seq.fill(maskedBits)(0) ++ bits).padTo(64, 0).mkString(&quot;&quot;)</span>
<span class="nc" id="L312">          java.lang.Long.parseLong(binaryString, 2)</span>
        }

<span class="nc" id="L315">        add(Seq.empty, Seq.empty, bits).map(toLong)</span>
    }
  }

  /**
   * Gets an iterator that returns numbered option keys, i.e. `base`, `base2`, `base3` etc
   *
   * @param base base option key
   * @return
   */
  private def optionsIterator(base: String): Iterator[String] =
<span class="nc" id="L326">    Iterator.single(base) ++ Iterator.range(2, Int.MaxValue).map(i =&gt; s&quot;$base$i&quot;)</span>
<span class="nc" id="L327">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>