<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttributeIndexKeySpace.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.index.attribute</a> &gt; <span class="el_source">AttributeIndexKeySpace.scala</span></div><h1>AttributeIndexKeySpace.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.index.attribute

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.index.api.IndexKeySpace.IndexKeySpaceFactory
import org.locationtech.geomesa.index.api.ShardStrategy.AttributeShardStrategy
import org.locationtech.geomesa.index.api._
import org.locationtech.geomesa.index.geotools.GeoMesaDataStoreFactory.GeoMesaDataStoreConfig
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.utils.index.ByteArrays.{OneByteArray, ZeroByteArray}
import org.locationtech.geomesa.utils.index.{ByteArrays, VisibilityLevel}

import java.nio.charset.StandardCharsets
import java.util.Collections
import scala.util.Try

/**
  * Attribute index key
  *
  * @param sft simple feature type
  * @param attributeField attribute being indexed
  */
<span class="nc bnc" id="L34" title="All 4 branches missed.">class AttributeIndexKeySpace(val sft: SimpleFeatureType, val sharding: ShardStrategy, attributeField: String)</span>
<span class="nc" id="L35">    extends IndexKeySpace[AttributeIndexValues[Any], AttributeIndexKey] with LazyLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L40">  protected val fieldIndex: Int = sft.indexOf(attributeField)</span>
<span class="nc" id="L41">  protected val fieldIndexShort: Short = fieldIndex.toShort</span>
<span class="nc" id="L42">  protected val isList: Boolean = sft.getDescriptor(fieldIndex).isList</span>

<span class="nc" id="L44">  private val descriptor = sft.getDescriptor(fieldIndex)</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">  private val binding = if (isList) { descriptor.getListType() } else { descriptor.getType.getBinding }</span>

<span class="nc" id="L47">  protected val decodeValue: String =&gt; AnyRef = {</span>
<span class="nc" id="L48">    val alias = AttributeIndexKey.alias(binding)</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">    if (isList) {</span>
      // Note that for collection types, only a single entry of the collection will be decoded - this is
      // because the collection entries have been broken up into multiple rows
<span class="nc" id="L52">      encoded =&gt; Collections.singletonList(AttributeIndexKey.decode(alias, encoded))</span>
    } else {
<span class="nc" id="L54">      AttributeIndexKey.decode(alias, _)</span>
    }
  }

<span class="nc" id="L58">  require(AttributeIndexKey.encodable(binding),</span>
<span class="nc" id="L59">    s&quot;Indexing is not supported for field $attributeField of type ${binding.getName} - supported types are: &quot; +</span>
<span class="nc" id="L60">        AttributeIndexKey.lexicoders.map(_.getName).mkString(&quot;, &quot;))</span>

<span class="nc" id="L62">  override val attributes: Seq[String] = Seq(attributeField)</span>

<span class="nc" id="L64">  override val sharing: Array[Byte] = Array.empty</span>

<span class="nc" id="L66">  override val indexKeyByteLength: Left[(Array[Byte], Int, Int) =&gt; Int, Int] = Left(idOffset)</span>

  override def toIndexKey(writable: WritableFeature,
                          tier: Array[Byte],
                          id: Array[Byte],
                          lenient: Boolean): RowKeyValue[AttributeIndexKey] = {
<span class="nc" id="L72">    val shard = sharding(writable)</span>

<span class="nc bnc" id="L74" title="All 2 branches missed.">    if (isList) {</span>
<span class="nc" id="L75">      val attribute = writable.getAttribute[java.util.List[Any]](fieldIndex)</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      if (attribute == null) {</span>
<span class="nc" id="L77">        MultiRowKeyValue(Seq.empty, sharing, shard, Seq.empty, tier, id, writable.values)</span>
      } else {
<span class="nc" id="L79">        val rows = Seq.newBuilder[Array[Byte]]</span>
<span class="nc" id="L80">        rows.sizeHint(attribute.size())</span>
<span class="nc" id="L81">        val keys = Seq.newBuilder[AttributeIndexKey]</span>
<span class="nc" id="L82">        keys.sizeHint(attribute.size())</span>

<span class="nc" id="L84">        var i = 0</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        while (i &lt; attribute.size()) {</span>
<span class="nc" id="L86">          val encoded = AttributeIndexKey.typeEncode(attribute.get(i))</span>
<span class="nc" id="L87">          val value = encoded.getBytes(StandardCharsets.UTF_8)</span>

          // create the byte array - allocate a single array up front to contain everything
<span class="nc" id="L90">          val bytes = Array.ofDim[Byte](shard.length + tier.length + id.length + 1 + value.length) // +1 for null byte</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">          if (shard.isEmpty) {</span>
<span class="nc" id="L92">            System.arraycopy(value, 0, bytes, 0, value.length)</span>
<span class="nc" id="L93">            bytes(value.length) = ByteArrays.ZeroByte</span>
<span class="nc" id="L94">            System.arraycopy(tier, 0, bytes, value.length + 1, tier.length)</span>
<span class="nc" id="L95">            System.arraycopy(id, 0, bytes, value.length + 1 + tier.length, id.length)</span>
          } else {
<span class="nc" id="L97">            bytes(0) = shard.head // shard is only a single byte</span>
<span class="nc" id="L98">            System.arraycopy(value, 0, bytes, 1, value.length)</span>
<span class="nc" id="L99">            bytes(value.length + 1) = ByteArrays.ZeroByte</span>
<span class="nc" id="L100">            System.arraycopy(tier, 0, bytes, value.length + 2, tier.length)</span>
<span class="nc" id="L101">            System.arraycopy(id, 0, bytes, value.length + 2 + tier.length, id.length)</span>
          }

<span class="nc" id="L104">          rows += bytes</span>
<span class="nc" id="L105">          keys += AttributeIndexKey(fieldIndexShort, encoded)</span>

<span class="nc" id="L107">          i += 1</span>
        }
<span class="nc" id="L109">        MultiRowKeyValue(rows.result, sharing, shard, keys.result, tier, id, writable.values)</span>
      }
    } else {
<span class="nc" id="L112">      val attribute = writable.getAttribute[Any](fieldIndex)</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      if (attribute == null) {</span>
<span class="nc" id="L114">        MultiRowKeyValue(Seq.empty, sharing, shard, Seq.empty, tier, id, writable.values)</span>
      } else {
<span class="nc" id="L116">        val encoded = AttributeIndexKey.typeEncode(attribute)</span>
<span class="nc" id="L117">        val value = encoded.getBytes(StandardCharsets.UTF_8)</span>

        // create the byte array - allocate a single array up front to contain everything
<span class="nc" id="L120">        val bytes = Array.ofDim[Byte](shard.length + tier.length + id.length + 1 + value.length) // +1 for null byte</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (shard.isEmpty) {</span>
<span class="nc" id="L122">          System.arraycopy(value, 0, bytes, 0, value.length)</span>
<span class="nc" id="L123">          bytes(value.length) = ByteArrays.ZeroByte</span>
<span class="nc" id="L124">          System.arraycopy(tier, 0, bytes, value.length + 1, tier.length)</span>
<span class="nc" id="L125">          System.arraycopy(id, 0, bytes, value.length + 1 + tier.length, id.length)</span>
        } else {
<span class="nc" id="L127">          bytes(0) = shard.head // shard is only a single byte</span>
<span class="nc" id="L128">          System.arraycopy(value, 0, bytes, 1, value.length)</span>
<span class="nc" id="L129">          bytes(value.length + 1) = ByteArrays.ZeroByte</span>
<span class="nc" id="L130">          System.arraycopy(tier, 0, bytes, value.length + 2, tier.length)</span>
<span class="nc" id="L131">          System.arraycopy(id, 0, bytes, value.length + 2 + tier.length, id.length)</span>
        }

<span class="nc" id="L134">        SingleRowKeyValue(bytes, sharing, shard, AttributeIndexKey(fieldIndexShort, encoded), tier, id, writable.values)</span>
      }
    }
  }

  override def getIndexValues(filter: Filter, explain: Explainer): AttributeIndexValues[Any] = {
<span class="nc" id="L140">    val bounds = FilterHelper.extractAttributeBounds(filter, attributeField, binding.asInstanceOf[Class[Any]])</span>

<span class="nc bnc" id="L142" title="All 2 branches missed.">    if (bounds.isEmpty) {</span>
      // we have an attribute, but weren't able to extract any bounds
<span class="nc bnc" id="L144" title="All 2 branches missed.">      logger.warn(s&quot;Unable to extract any attribute bounds from: ${FilterHelper.toString(filter)}&quot;)</span>
    }

<span class="nc" id="L147">    AttributeIndexValues[Any](attributeField, fieldIndex, bounds, binding.asInstanceOf[Class[Any]])</span>
  }

  override def getRanges(values: AttributeIndexValues[Any],
                         multiplier: Int): Iterator[ScanRange[AttributeIndexKey]] = {

    import AttributeIndexKey.encodeForQuery
    import org.locationtech.geomesa.filter.WildcardSuffix

<span class="nc bnc" id="L156" title="All 2 branches missed.">    if (values.values.isEmpty) {</span>
      // we have an attribute, but weren't able to extract any bounds... scan all values
<span class="nc" id="L158">      Iterator.single(UnboundedRange(AttributeIndexKey(fieldIndexShort, null, inclusive = false)))</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">    } else if (values.values.disjoint &amp;&amp; !isList) {</span>
<span class="nc" id="L160">      Iterator.empty</span>
    } else {
<span class="nc" id="L162">      values.values.values.iterator.flatMap { bounds =&gt;</span>
<span class="nc bnc" id="L163" title="All 8 branches missed.">        bounds.bounds match {</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">          case (None, None) =&gt; // not null</span>
<span class="nc" id="L165">            Iterator.single(UnboundedRange(AttributeIndexKey(fieldIndexShort, null, inclusive = false)))</span>

<span class="nc bnc" id="L167" title="All 4 branches missed.">          case (Some(lower), None) =&gt;</span>
<span class="nc" id="L168">            val start = AttributeIndexKey(fieldIndexShort, encodeForQuery(lower, binding), bounds.lower.inclusive)</span>
<span class="nc" id="L169">            Iterator.single(LowerBoundedRange(start))</span>

<span class="nc bnc" id="L171" title="All 4 branches missed.">          case (None, Some(upper)) =&gt;</span>
<span class="nc" id="L172">            val end = AttributeIndexKey(fieldIndexShort, encodeForQuery(upper, binding), bounds.upper.inclusive)</span>
<span class="nc" id="L173">            Iterator.single(UpperBoundedRange(end))</span>

<span class="nc bnc" id="L175" title="All 4 branches missed.">          case (Some(lower), Some(upper)) =&gt;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (lower == upper) {</span>
<span class="nc" id="L177">              val row = AttributeIndexKey(fieldIndexShort, encodeForQuery(lower, binding), inclusive = true)</span>
<span class="nc" id="L178">              Iterator.single(SingleRowRange(row))</span>
<span class="nc bnc" id="L179" title="All 6 branches missed.">            } else if (lower + WildcardSuffix == upper) {</span>
<span class="nc" id="L180">              val row = AttributeIndexKey(fieldIndexShort, encodeForQuery(lower, binding), inclusive = true)</span>
<span class="nc" id="L181">              Iterator.single(PrefixRange(row))</span>
            } else {
<span class="nc" id="L183">              val start = AttributeIndexKey(fieldIndexShort, encodeForQuery(lower, binding), bounds.lower.inclusive)</span>
<span class="nc" id="L184">              val end = AttributeIndexKey(fieldIndexShort, encodeForQuery(upper, binding), bounds.upper.inclusive)</span>
<span class="nc" id="L185">              Iterator.single(BoundedRange(start, end))</span>
            }
        }
      }
    }
  }

  override def getRangeBytes(ranges: Iterator[ScanRange[AttributeIndexKey]], tier: Boolean): Iterator[ByteRange] = {
<span class="nc bnc" id="L193" title="All 2 branches missed.">    if (tier) {</span>
<span class="nc" id="L194">      getTieredRangeBytes(ranges, sharding.shards)</span>
    } else {
<span class="nc" id="L196">      getStandardRangeBytes(ranges, sharding.shards)</span>
    }
  }

  override def useFullFilter(values: Option[AttributeIndexValues[Any]],
                             config: Option[GeoMesaDataStoreConfig],
                             hints: Hints): Boolean = {
    // if we have an attribute, but weren't able to extract any bounds, values.values will be empty
<span class="nc bnc" id="L204" title="All 6 branches missed.">    values.forall(v =&gt; v.values.isEmpty || !v.values.precise) ||</span>
      // for attribute-level vis, we need to re-evaluate the filter to account for visibility of the row key
<span class="nc bnc" id="L206" title="All 8 branches missed.">      (sft.getVisibilityLevel == VisibilityLevel.Attribute &amp;&amp; values.exists(_.values.nonEmpty))</span>
  }

  /**
    * Decodes an attribute value out of row string
    *
    * @param row row bytes
    * @param offset offset into the row bytes
    * @param length length of the row bytes, from the offset
    * @return
    */
<span class="nc" id="L217">  def decodeRowValue(row: Array[Byte], offset: Int, length: Int): Try[AnyRef] = Try {</span>
<span class="nc" id="L218">    val valueStart = offset + sharding.length // start of the encoded value</span>
    // null byte indicates end of value
<span class="nc" id="L220">    val valueEnd = math.min(row.indexOf(ByteArrays.ZeroByte, valueStart), offset + length)</span>
<span class="nc" id="L221">    decodeValue(new String(row, valueStart, valueEnd - valueStart, StandardCharsets.UTF_8))</span>
  }

  protected def getTieredRangeBytes(ranges: Iterator[ScanRange[AttributeIndexKey]],
                                    prefixes: Seq[Array[Byte]]): Iterator[ByteRange] = {
    import org.locationtech.geomesa.utils.index.ByteArrays.concat

<span class="nc" id="L228">    val bytes = ranges.map {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      case SingleRowRange(row) =&gt;</span>
<span class="nc" id="L230">        SingleRowByteRange(lower(row))</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">      case BoundedRange(lo, hi) =&gt;</span>
<span class="nc" id="L233">        tieredUpper(hi) match {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">          case None     =&gt; LowerBoundedByteRange(lower(lo), upper(hi))</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">          case Some(up) =&gt; BoundedByteRange(lower(lo), up)</span>
        }

<span class="nc bnc" id="L238" title="All 2 branches missed.">      case PrefixRange(prefix) =&gt;</span>
<span class="nc" id="L239">        UnboundedByteRange(lower(prefix, prefix = true), upper(prefix, prefix = true))</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">      case LowerBoundedRange(lo) =&gt;</span>
<span class="nc" id="L242">        LowerBoundedByteRange(lower(lo), upper(AttributeIndexKey(lo.i, null)))</span>

<span class="nc bnc" id="L244" title="All 2 branches missed.">      case UpperBoundedRange(hi) =&gt;</span>
<span class="nc" id="L245">        tieredUpper(hi) match {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">          case None     =&gt; UnboundedByteRange(lower(AttributeIndexKey(hi.i, null)), upper(hi))</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">          case Some(up) =&gt; UpperBoundedByteRange(lower(AttributeIndexKey(hi.i, null)), up)</span>
        }

<span class="nc bnc" id="L250" title="All 2 branches missed.">      case UnboundedRange(empty) =&gt;</span>
<span class="nc" id="L251">        UnboundedByteRange(lower(empty), upper(empty))</span>
    }

<span class="nc bnc" id="L254" title="All 2 branches missed.">    if (prefixes.isEmpty) { bytes } else {</span>
<span class="nc" id="L255">      bytes.flatMap {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        case SingleRowByteRange(row)       =&gt; prefixes.map(p =&gt; SingleRowByteRange(concat(p, row)))</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        case BoundedByteRange(lo, hi)      =&gt; prefixes.map(p =&gt; BoundedByteRange(concat(p, lo), concat(p, hi)))</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        case LowerBoundedByteRange(lo, hi) =&gt; prefixes.map(p =&gt; LowerBoundedByteRange(concat(p, lo), concat(p, hi)))</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        case UpperBoundedByteRange(lo, hi) =&gt; prefixes.map(p =&gt; UpperBoundedByteRange(concat(p, lo), concat(p, hi)))</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        case UnboundedByteRange(lo, hi)    =&gt; prefixes.map(p =&gt; UnboundedByteRange(concat(p, lo), concat(p, hi)))</span>
      }
    }
  }

  protected def getStandardRangeBytes(ranges: Iterator[ScanRange[AttributeIndexKey]],
                                      prefixes: Seq[Array[Byte]]): Iterator[ByteRange] = {

    import org.locationtech.geomesa.utils.index.ByteArrays.concat

<span class="nc" id="L270">    val bytes = ranges.map {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">      case SingleRowRange(row)   =&gt; BoundedByteRange(lower(row), upper(row))</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      case BoundedRange(lo, hi)  =&gt; BoundedByteRange(lower(lo), upper(hi))</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      case PrefixRange(prefix)   =&gt; BoundedByteRange(lower(prefix, prefix = true), upper(prefix, prefix = true))</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">      case LowerBoundedRange(lo) =&gt; BoundedByteRange(lower(lo), upper(AttributeIndexKey(lo.i, null)))</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">      case UpperBoundedRange(hi) =&gt; BoundedByteRange(lower(AttributeIndexKey(hi.i, null)), upper(hi))</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">      case UnboundedRange(empty) =&gt; BoundedByteRange(lower(empty), upper(empty))</span>
<span class="nc" id="L277">      case r =&gt; throw new IllegalArgumentException(s&quot;Unexpected range type $r&quot;)</span>
    }

<span class="nc bnc" id="L280" title="All 2 branches missed.">    if (prefixes.isEmpty) { bytes } else {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">      bytes.flatMap {</span>
<span class="nc" id="L282">        case BoundedByteRange(lo, hi) =&gt; prefixes.map(p =&gt; BoundedByteRange(concat(p, lo), concat(p, hi)))</span>
      }
    }
  }

  /**
    * Gets a lower range bound for an attribute value. The bound can be used with additional tiering or not
    *
    * @param key attribute value
    * @param prefix if this is a prefix scan or not
    * @return
    */
<span class="nc" id="L294">  protected def lower(key: AttributeIndexKey, prefix: Boolean = false): Array[Byte] = {</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">    if (key.value == null || key.value.isEmpty) {</span>
<span class="nc" id="L296">      Array.empty</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">    } else if (prefix) {</span>
      // note: inclusive doesn't make sense for prefix ranges
<span class="nc" id="L299">      key.value.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">    } else if (key.inclusive) {</span>
<span class="nc" id="L301">      ByteArrays.concat(key.value.getBytes(StandardCharsets.UTF_8), ZeroByteArray)</span>
    } else {
<span class="nc" id="L303">      ByteArrays.concat(key.value.getBytes(StandardCharsets.UTF_8), OneByteArray)</span>
    }
  }

  /**
    * Gets an upper range bound for an attribute value. The bound is only suitable when there is no additional tiering
    *
    * @param key attribute value
    * @param prefix if this is a prefix scan or not
    * @return
    */
<span class="nc" id="L314">  protected def upper(key: AttributeIndexKey, prefix: Boolean = false): Array[Byte] = {</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">    if (key.value == null || key.value.isEmpty) {</span>
<span class="nc" id="L316">      ByteRange.UnboundedUpperRange</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    } else if (prefix) {</span>
      // get the row following the prefix, then get the next row
      // note: inclusiveness doesn't really make sense for prefix ranges
<span class="nc" id="L320">      ByteArrays.rowFollowingPrefix(key.value.getBytes(StandardCharsets.UTF_8))</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">    } else if (key.inclusive) {</span>
      // row following prefix, after the delimiter
<span class="nc" id="L323">      ByteArrays.concat(key.value.getBytes(StandardCharsets.UTF_8), OneByteArray)</span>
    } else {
      // exclude the row
<span class="nc" id="L326">      ByteArrays.concat(key.value.getBytes(StandardCharsets.UTF_8), ZeroByteArray)</span>
    }
  }

  /**
    * Gets an upper bound for a range that will be tiered. A bound will only be returned if it
    * supports additional tiering.
    *
    * @param key attribute value
    * @return
    */
  protected def tieredUpper(key: AttributeIndexKey): Option[Array[Byte]] = {
    // note: we can't tier exclusive end points, as we can't calculate previous rows
<span class="nc bnc" id="L339" title="All 4 branches missed.">    if (key.value == null || !key.inclusive) { None } else {</span>
      // match the final row, and count on remaining range to exclude the rest
<span class="nc" id="L341">      Some(ByteArrays.concat(key.value.getBytes(StandardCharsets.UTF_8), ZeroByteArray))</span>
    }
  }

  // null byte indicates end of value
  private def idOffset(row: Array[Byte], offset: Int, length: Int): Int =
<span class="nc" id="L347">    row.indexOf(ByteArrays.ZeroByte, offset + sharding.length) + 1 - offset</span>
}

<span class="nc" id="L350">object AttributeIndexKeySpace extends IndexKeySpaceFactory[AttributeIndexValues[Any], AttributeIndexKey] {</span>

  override def supports(sft: SimpleFeatureType, attributes: Seq[String]): Boolean = {
<span class="nc bnc" id="L353" title="All 2 branches missed.">    if (attributes.lengthCompare(1) != 0) { false } else {</span>
<span class="nc" id="L354">      val descriptor = sft.getDescriptor(attributes.head)</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">      descriptor != null &amp;&amp; AttributeIndexKey.encodable(descriptor)</span>
    }
  }

  override def apply(sft: SimpleFeatureType, attributes: Seq[String], tier: Boolean): AttributeIndexKeySpace =
<span class="nc" id="L360">    new AttributeIndexKeySpace(sft, AttributeShardStrategy(sft), attributes.head)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>