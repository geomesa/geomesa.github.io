<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TableBasedMetadata.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.metadata</a> &gt; <span class="el_source">TableBasedMetadata.scala</span></div><h1>TableBasedMetadata.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.metadata

import com.github.benmanes.caffeine.cache.{Cache, CacheLoader, Caffeine, LoadingCache}
import com.typesafe.scalalogging.LazyLogging
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.concurrent.ExitingExecutor
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.io.{CloseWithLogging, WithClose}
import org.locationtech.geomesa.utils.text.DateParsing

import java.io.Closeable
import java.time.format.DateTimeFormatterBuilder
import java.time.temporal.ChronoField
import java.time.{Instant, ZoneOffset}
import java.util.Locale
import java.util.concurrent.{ScheduledExecutorService, ScheduledFuture, ScheduledThreadPoolExecutor, TimeUnit}
import scala.util.Try

/**
  * Metadata persisted in a database table. The underlying table will be lazily created when required.
  * Metadata values are cached with a configurable timeout to save repeated database reads.
  *
  * @tparam T type param
  */
<span class="nc" id="L33">trait TableBasedMetadata[T] extends GeoMesaMetadata[T] with LazyLogging {</span>

  import scala.collection.JavaConverters._

  /**
    * Serializer
    *
    * @return
    */
  def serializer: MetadataSerializer[T]

  /**
    * Checks if the underlying table exists
    *
    * @return
    */
  protected def checkIfTableExists: Boolean

  /**
    * Creates the underlying table. Must be idempotent.
    */
  protected def createTable(): Unit

  /**
    * Create an instance to use for backup
    *
    * @param timestamp formatted timestamp for the current time
    * @return
    */
  protected def createEmptyBackup(timestamp: String): TableBasedMetadata[T]

  /**
    * Writes key/value pairs
    *
    * @param rows keys/values
    */
  protected def write(typeName: String, rows: Seq[(String, Array[Byte])]): Unit

  /**
    * Deletes multiple rows
    *
    * @param typeName simple feature type name
    * @param keys keys
    */
  protected def delete(typeName: String, keys: Seq[String]): Unit

  /**
    * Reads a value from the underlying table
    *
    * @param typeName simple feature type name
    * @param key key
    * @return value, if it exists
    */
  protected def scanValue(typeName: String, key: String): Option[Array[Byte]]

  /**
    * Reads row keys from the underlying table
    *
    * @param typeName simple feature type name
    * @param prefix scan prefix, or empty string for all values
    * @return matching tuples of (key, value)
    */
<span class="nc" id="L95">  protected def scanValues(typeName: String, prefix: String = &quot;&quot;): CloseableIterator[(String, Array[Byte])]</span>

  /**
    * Reads all row keys from the underlying table
    *
    * @return matching tuples of (typeName, key)
    */
  protected def scanKeys(): CloseableIterator[(String, String)]

<span class="nc" id="L104">  private val expiry = TableBasedMetadata.Expiry.toDuration.get.toMillis</span>

<span class="nc" id="L106">  private val tableExists = new TableExists().init()</span>

  // cache for our metadata - invalidate every 10 minutes so we keep things current
<span class="nc" id="L109">  private val metaDataCache: LoadingCache[(String, String), Option[T]] =</span>
<span class="nc" id="L110">    Caffeine.newBuilder().expireAfterWrite(expiry, TimeUnit.MILLISECONDS).build(</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">      new CacheLoader[(String, String), Option[T]] {</span>
        override def load(typeNameAndKey: (String, String)): Option[T] = {
<span class="nc bnc" id="L113" title="All 2 branches missed.">          if (!tableExists.get) { None } else {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            val (typeName, key) = typeNameAndKey</span>
<span class="nc" id="L115">            scanValue(typeName, key).map(serializer.deserialize(typeName, _))</span>
          }
        }
      }
    )

  // keep a separate cache for scan queries vs point lookups, so that the point lookups don't cache
  // partial values for a scan result
<span class="nc" id="L123">  private val metaDataScanCache: LoadingCache[(String, String), Seq[(String, T)]] =</span>
<span class="nc" id="L124">    Caffeine.newBuilder().expireAfterWrite(expiry, TimeUnit.MILLISECONDS).build(</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      new CacheLoader[(String, String), Seq[(String, T)]] {</span>
        override def load(typeNameAndPrefix: (String, String)): Seq[(String, T)] = {
<span class="nc bnc" id="L127" title="All 2 branches missed.">          if (!tableExists.get) { Seq.empty } else {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            val (typeName, prefix) = typeNameAndPrefix</span>
<span class="nc" id="L129">            WithClose(scanValues(typeName, prefix)) { iter =&gt;</span>
<span class="nc" id="L130">              val builder = Seq.newBuilder[(String, T)]</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">              iter.foreach { case (k, v) =&gt; builder += k -&gt; serializer.deserialize(typeName, v) }</span>
<span class="nc" id="L132">              builder.result()</span>
            }
          }
        }
      }
    )

  private lazy val formatter =
<span class="nc" id="L140">    new DateTimeFormatterBuilder()</span>
      .parseCaseInsensitive()
<span class="nc" id="L142">      .appendValue(ChronoField.YEAR, 4)</span>
<span class="nc" id="L143">      .appendValue(ChronoField.MONTH_OF_YEAR, 2)</span>
<span class="nc" id="L144">      .appendValue(ChronoField.DAY_OF_MONTH, 2)</span>
<span class="nc" id="L145">      .appendLiteral('T')</span>
<span class="nc" id="L146">      .appendValue(ChronoField.HOUR_OF_DAY, 2)</span>
<span class="nc" id="L147">      .appendValue(ChronoField.MINUTE_OF_HOUR, 2)</span>
<span class="nc" id="L148">      .appendValue(ChronoField.SECOND_OF_MINUTE, 2)</span>
<span class="nc" id="L149">      .toFormatter(Locale.US)</span>
<span class="nc" id="L150">      .withZone(ZoneOffset.UTC)</span>

  override def getFeatureTypes: Array[String] = {
<span class="nc bnc" id="L153" title="All 2 branches missed.">    if (!tableExists.get) { Array.empty } else {</span>
<span class="nc" id="L154">      WithClose(scanKeys()) { keys =&gt;</span>
<span class="nc bnc" id="L155" title="All 16 branches missed.">        keys.collect { case (typeName, key) if key == GeoMesaMetadata.AttributesKey =&gt; typeName }.toArray</span>
      }
    }
  }

  override def read(typeName: String, key: String, cache: Boolean): Option[T] = {
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (!cache) {</span>
<span class="nc" id="L162">      metaDataCache.invalidate((typeName, key))</span>
    }
<span class="nc" id="L164">    metaDataCache.get((typeName, key))</span>
  }

  override def scan(typeName: String, prefix: String, cache: Boolean): Seq[(String, T)] = {
<span class="nc bnc" id="L168" title="All 2 branches missed.">    if (!cache) {</span>
<span class="nc" id="L169">      metaDataScanCache.invalidate((typeName, prefix))</span>
    }
<span class="nc" id="L171">    metaDataScanCache.get((typeName, prefix))</span>
  }

<span class="nc" id="L174">  override def insert(typeName: String, key: String, value: T): Unit = insert(typeName, Map(key -&gt; value))</span>

  override def insert(typeName: String, kvPairs: Map[String, T]): Unit = {
<span class="nc" id="L177">    ensureTableExists()</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">    val strings = kvPairs.map { case (k, v) =&gt;</span>
<span class="nc" id="L179">      metaDataCache.put((typeName, k), Option(v)) // note: side effect in map</span>
<span class="nc" id="L180">      (k, serializer.serialize(typeName, v))</span>
    }
<span class="nc" id="L182">    write(typeName, strings.toSeq)</span>
<span class="nc" id="L183">    invalidate(metaDataScanCache, typeName)</span>
  }

  override def invalidateCache(typeName: String, key: String): Unit = {
<span class="nc" id="L187">    metaDataCache.invalidate((typeName, key))</span>
<span class="nc" id="L188">    invalidate(metaDataScanCache, typeName)</span>
  }

<span class="nc" id="L191">  override def remove(typeName: String, key: String): Unit = remove(typeName, Seq(key))</span>

  override def remove(typeName: String, keys: Seq[String]): Unit = {
<span class="nc bnc" id="L194" title="All 2 branches missed.">    if (tableExists.get()) {</span>
<span class="nc" id="L195">      delete(typeName, keys)</span>
      // also remove from the cache
<span class="nc" id="L197">      keys.foreach(k =&gt; metaDataCache.invalidate((typeName, k)))</span>
<span class="nc" id="L198">      invalidate(metaDataScanCache, typeName)</span>
    } else {
<span class="nc bnc" id="L200" title="All 2 branches missed.">      logger.debug(s&quot;Trying to delete '$typeName: ${keys.mkString(&quot;, &quot;)}' but table does not exist&quot;)</span>
    }
  }

  override def delete(typeName: String): Unit = {
<span class="nc bnc" id="L205" title="All 2 branches missed.">    if (tableExists.get()) {</span>
<span class="nc" id="L206">      WithClose(scanValues(typeName)) { rows =&gt;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (rows.nonEmpty) {</span>
<span class="nc" id="L208">          delete(typeName, rows.map(_._1).toSeq)</span>
        }
      }
    } else {
<span class="nc bnc" id="L212" title="All 2 branches missed.">      logger.debug(s&quot;Trying to delete type '$typeName' but table does not exist&quot;)</span>
    }
<span class="nc" id="L214">    Seq(metaDataCache, metaDataScanCache).foreach(invalidate(_, typeName))</span>
  }

  override def backup(typeName: String): Unit = {
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (tableExists.get()) {</span>
<span class="nc" id="L219">      WithClose(scanValues(typeName)) { rows =&gt;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (rows.nonEmpty) {</span>
<span class="nc" id="L221">          WithClose(createEmptyBackup(DateParsing.formatInstant(Instant.now, formatter))) { metadata =&gt;</span>
<span class="nc" id="L222">            metadata.ensureTableExists()</span>
<span class="nc" id="L223">            metadata.write(typeName, rows.toSeq)</span>
          }
        }
      }
    } else {
<span class="nc bnc" id="L228" title="All 2 branches missed.">      logger.debug(s&quot;Trying to back up type '$typeName' but table does not exist&quot;)</span>
    }
  }

  /**
   * Checks that the table is already created, and creates it if not
   */
<span class="nc" id="L235">  def ensureTableExists(): Unit = tableExists.createIfNeeded()</span>

  override def resetCache(): Unit = {
<span class="nc" id="L238">    tableExists.run()</span>
<span class="nc" id="L239">    metaDataCache.invalidateAll()</span>
<span class="nc" id="L240">    metaDataScanCache.invalidateAll()</span>
  }

<span class="nc" id="L243">  override def close(): Unit = tableExists.close()</span>

  /**
    * Invalidate all keys for the given feature type
    *
    * @param cache cache to invalidate
    * @param typeName feature type name
    */
  private def invalidate(cache: Cache[(String, String), _], typeName: String): Unit = {
<span class="nc" id="L252">    cache.asMap.asScala.keys.foreach { k =&gt;</span>
<span class="nc bnc" id="L253" title="All 6 branches missed.">      if (k._1 == typeName) {</span>
<span class="nc" id="L254">        cache.invalidate(k)</span>
      }
    }
  }

  /**
   * Tracks existence of the metadata table
   */
<span class="nc bnc" id="L262" title="All 2 branches missed.">  private class TableExists extends Runnable with Closeable {</span>

    @volatile
<span class="nc" id="L265">    private var exists = false</span>
<span class="nc" id="L266">    private var es: ScheduledExecutorService = _</span>
<span class="nc" id="L267">    private var future: ScheduledFuture[_] = _</span>

    /**
     * Initialization
     *
     * @return
     */
<span class="nc" id="L274">    def init(): TableExists = { run(); this }</span>

    /**
     * Does the table exist
     *
     * @return
     */
<span class="nc" id="L281">    def get(): Boolean = exists</span>

    /**
     * Create the table if it doesn't exist.
     *
     * Note that we don't synchronize this method, but creating the table should be idempotent
     */
    def createIfNeeded(): Unit = {
<span class="nc bnc" id="L289" title="All 2 branches missed.">      if (!exists) {</span>
<span class="nc" id="L290">        createTable()</span>
<span class="nc" id="L291">        run()</span>
      }
    }

    /**
     * Check for table existence
     */
    override def run(): Unit = {
<span class="nc" id="L299">      exists = checkIfTableExists</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">      if (exists) {</span>
<span class="nc" id="L301">        cancel()</span>
      } else {
<span class="nc" id="L303">        schedule()</span>
      }
    }

<span class="nc" id="L307">    override def close(): Unit = cancel()</span>

    private def schedule(): Unit = synchronized {
<span class="nc bnc" id="L310" title="All 2 branches missed.">      if (es == null) {</span>
<span class="nc" id="L311">        es = ExitingExecutor(new ScheduledThreadPoolExecutor(1))</span>
      }
<span class="nc bnc" id="L313" title="All 2 branches missed.">      if (future == null) {</span>
<span class="nc" id="L314">        future = es.scheduleAtFixedRate(this, expiry, expiry, TimeUnit.MILLISECONDS)</span>
      }
    }

    /**
     * Cancel any scheduled tasks
     */
    private def cancel(): Unit = synchronized {
<span class="nc bnc" id="L322" title="All 2 branches missed.">      if (future != null) {</span>
<span class="nc" id="L323">        Try(future.cancel(true))</span>
<span class="nc" id="L324">        future = null</span>
      }
<span class="nc bnc" id="L326" title="All 2 branches missed.">      if (es != null) {</span>
<span class="nc" id="L327">        CloseWithLogging(es)</span>
<span class="nc" id="L328">        es = null</span>
      }
    }
  }
}

<span class="nc" id="L334">object TableBasedMetadata {</span>
<span class="nc" id="L335">  val Expiry: SystemProperty = SystemProperty(&quot;geomesa.metadata.expiry&quot;, &quot;10 minutes&quot;)</span>
<span class="nc" id="L336">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>