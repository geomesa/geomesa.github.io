<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DensityScan.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.iterators</a> &gt; <span class="el_source">DensityScan.scala</span></div><h1>DensityScan.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.iterators
import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.filter.expression.Expression
import org.geotools.filter.text.ecql.ECQL
import org.geotools.util.factory.Hints
import org.geotools.util.factory.Hints.ClassKey
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.features.kryo.impl.{KryoFeatureDeserialization, KryoFeatureSerialization}
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.api.QueryPlan.ResultsToFeatures
import org.locationtech.geomesa.index.iterators.DensityScan.{DensityScanResult, GeometryRenderer}
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.geotools.{GeometryUtils, GridSnap, RenderingGrid}
import org.locationtech.geomesa.utils.interop.SimpleFeatureTypes
import org.locationtech.jts.geom._

<span class="nc" id="L29">trait DensityScan extends AggregatingScan[DensityScanResult] {</span>

  // we snap each point into a pixel and aggregate based on that
  protected var renderer: GeometryRenderer = _

  override protected def createResult(
      sft: SimpleFeatureType,
      transform: Option[SimpleFeatureType],
      batchSize: Int,
      options: Map[String, String]): DensityScanResult = {
<span class="nc" id="L39">    val geom = options.getOrElse(DensityScan.Configuration.GeometryOpt, sft.getGeometryDescriptor.getLocalName)</span>
<span class="nc" id="L40">    val renderer = DensityScan.getRenderer(sft, geom, options.get(DensityScan.Configuration.WeightOpt))</span>
<span class="nc" id="L41">    val bounds = options(DensityScan.Configuration.EnvelopeOpt).split(&quot;,&quot;).map(_.toDouble)</span>
<span class="nc" id="L42">    val envelope = new Envelope(bounds(0), bounds(1), bounds(2), bounds(3))</span>
<span class="nc bnc" id="L43" title="All 6 branches missed.">    val Array(width, height) = options(DensityScan.Configuration.GridOpt).split(&quot;,&quot;).map(_.toInt)</span>
<span class="nc" id="L44">    new DensityScanResult(renderer, new RenderingGrid(envelope, width, height))</span>
  }

  override protected def defaultBatchSize: Int =
<span class="nc" id="L48">    DensityScan.BatchSize.toInt.get // has a valid default so should be safe to .get</span>
}

<span class="nc bnc" id="L51" title="All 4 branches missed.">object DensityScan extends LazyLogging {</span>

  import org.locationtech.geomesa.index.conf.QueryHints.RichHints
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  private type GridIterator = SimpleFeature =&gt; Iterator[(Double, Double, Double)]

<span class="nc" id="L58">  val BatchSize: SystemProperty = SystemProperty(&quot;geomesa.density.batch.size&quot;, &quot;100000&quot;)</span>

<span class="nc" id="L60">  val DensitySft: SimpleFeatureType = SimpleFeatureTypes.createType(&quot;density&quot;, &quot;*geom:Point:srid=4326&quot;)</span>
<span class="nc" id="L61">  val DensityValueKey = new ClassKey(classOf[Array[Byte]])</span>

  // configuration keys
<span class="nc" id="L64">  object Configuration {</span>
<span class="nc" id="L65">    val GeometryOpt = &quot;geom&quot;</span>
<span class="nc" id="L66">    val EnvelopeOpt = &quot;envelope&quot;</span>
<span class="nc" id="L67">    val GridOpt     = &quot;grid&quot;</span>
<span class="nc" id="L68">    val WeightOpt   = &quot;weight&quot;</span>
  }

<span class="nc" id="L71">  def configure(</span>
      sft: SimpleFeatureType,
      index: GeoMesaFeatureIndex[_, _],
      filter: Option[Filter],
      hints: Hints): Map[String, String] = {
    import AggregatingScan.{OptionToConfig, StringToConfig}

<span class="nc" id="L78">    val geom = getDensityGeometry(sft, hints)</span>
<span class="nc" id="L79">    val envelope = hints.getDensityEnvelope.get</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">    val (width, height) = hints.getDensityBounds.get</span>
<span class="nc" id="L81">    val batchSize = DensityScan.BatchSize.toInt.get // has a valid default so should be safe to .get</span>
    // note: don't pass transforms
<span class="nc" id="L83">    val base = AggregatingScan.configure(sft, index, filter, None, hints.getSampling, batchSize)</span>
<span class="nc" id="L84">    base ++ AggregatingScan.optionalMap(</span>
<span class="nc" id="L85">      Configuration.GeometryOpt -&gt; geom,</span>
<span class="nc" id="L86">      Configuration.EnvelopeOpt -&gt; s&quot;${envelope.getMinX},${envelope.getMaxX},${envelope.getMinY},${envelope.getMaxY}&quot;,</span>
<span class="nc" id="L87">      Configuration.GridOpt     -&gt; s&quot;$width,$height&quot;,</span>
<span class="nc" id="L88">      Configuration.WeightOpt   -&gt; hints.getDensityWeight</span>
    )
  }

  /**
    * Encodes a sparse matrix into a byte array
    */
  def encodeResult(result: RenderingGrid): Array[Byte] = {
<span class="nc" id="L96">    val output = KryoFeatureSerialization.getOutput(null)</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">    result.iterator.toList.groupBy(_._1._1).foreach { case (row, cols) =&gt;</span>
<span class="nc" id="L98">      output.writeInt(row, true)</span>
<span class="nc" id="L99">      output.writeInt(cols.size, true)</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      cols.foreach { case (xy, weight) =&gt;</span>
<span class="nc" id="L101">        output.writeInt(xy._2, true)</span>
<span class="nc" id="L102">        output.writeDouble(weight)</span>
      }
    }
<span class="nc" id="L105">    output.toBytes</span>
  }

  /**
    * Returns a mapping of simple features (returned from a density query) to weighted points in the
    * form of (x, y, weight)
    */
  def decodeResult(envelope: Envelope, gridWidth: Int, gridHeight: Int): GridIterator =
<span class="nc" id="L113">    decodeResult(new GridSnap(envelope, gridWidth, gridHeight))</span>

  /**
    * Decodes a result feature into an iterator of (x, y, weight)
    */
<span class="nc" id="L118">  def decodeResult(gridSnap: GridSnap)(sf: SimpleFeature): Iterator[(Double, Double, Double)] = {</span>
<span class="nc" id="L119">    val result = sf.getUserData.get(DensityValueKey).asInstanceOf[Array[Byte]]</span>
<span class="nc" id="L120">    val input = KryoFeatureDeserialization.getInput(result, 0, result.length)</span>
<span class="nc" id="L121">    new Iterator[(Double, Double, Double)]() {</span>
<span class="nc" id="L122">      private var x = 0.0</span>
<span class="nc" id="L123">      private var colCount = 0</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">      override def hasNext: Boolean = input.position &lt; input.limit</span>
      override def next(): (Double, Double, Double) = {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (colCount == 0) {</span>
<span class="nc" id="L127">          x = gridSnap.x(input.readInt(true))</span>
<span class="nc" id="L128">          colCount = input.readInt(true)</span>
        }
<span class="nc" id="L130">        val y = gridSnap.y(input.readInt(true))</span>
<span class="nc" id="L131">        val weight = input.readDouble()</span>
<span class="nc" id="L132">        colCount -= 1</span>
<span class="nc" id="L133">        (x, y, weight)</span>
      }
    }
  }

  /**
    * Get the attributes used by a density query
    *
    * @param hints query hints
    * @param sft simple feature type
    * @return
    */
  def propertyNames(hints: Hints, sft: SimpleFeatureType): Seq[String] = {
<span class="nc" id="L146">    val geom = hints.getDensityGeometry.getOrElse(sft.getGeomField)</span>
<span class="nc" id="L147">    val weight = hints.getDensityWeight.map(ECQL.toExpression)</span>
<span class="nc" id="L148">    (Seq(geom) ++ weight.toSeq.flatMap(FilterHelper.propertyNames(_, sft))).distinct</span>
  }

  /**
   * Gets a renderer for the associated geometry binding
   *
   * @param sft simple feature type
   * @param geom geometry field to render
   * @param weight field to use for weighting features
   * @return
   */
  def getRenderer(sft: SimpleFeatureType, geom: String, weight: Option[String]): GeometryRenderer = {
    // function to get the weight from the feature - defaults to 1.0 unless an attribute/exp is specified
<span class="nc" id="L161">    val weigher = weight match {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      case None =&gt; EqualWeight</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">      case Some(w) =&gt;</span>
<span class="nc" id="L164">        val i = sft.indexOf(w)</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (i == -1) {</span>
<span class="nc" id="L166">          new WeightByExpression(ECQL.toExpression(w))</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        } else if (classOf[Number].isAssignableFrom(sft.getDescriptor(i).getType.getBinding)) {</span>
<span class="nc" id="L168">          new WeightByNumber(i)</span>
        } else {
<span class="nc" id="L170">          new WeightByNonNumber(i)</span>
        }
    }

<span class="nc" id="L174">    val i = sft.indexOf(geom)</span>
<span class="nc" id="L175">    sft.getDescriptor(i).getType.getBinding match {</span>
<span class="nc bnc" id="L176" title="All 6 branches missed.">      case b if b == classOf[Point]           =&gt; new PointRenderer(i, weigher)</span>
<span class="nc bnc" id="L177" title="All 6 branches missed.">      case b if b == classOf[MultiPoint]      =&gt; new MultiPointRenderer(i, weigher)</span>
<span class="nc bnc" id="L178" title="All 6 branches missed.">      case b if b == classOf[LineString]      =&gt; new LineStringRenderer(i, weigher)</span>
<span class="nc bnc" id="L179" title="All 6 branches missed.">      case b if b == classOf[MultiLineString] =&gt; new MultiLineStringRenderer(i, weigher)</span>
<span class="nc bnc" id="L180" title="All 6 branches missed.">      case b if b == classOf[Polygon]         =&gt; new PolygonRenderer(i, weigher)</span>
<span class="nc bnc" id="L181" title="All 6 branches missed.">      case b if b == classOf[MultiPolygon]    =&gt; new MultiPolygonRenderer(i, weigher)</span>
<span class="nc" id="L182">      case _                                  =&gt; new MultiRenderer(i, weigher)</span>
    }
  }

  /**
   * Get the geometry to render and validate it against the feature type
   *
   * @param sft simple feature type
   * @param hints query hints
   * @return
   */
  def getDensityGeometry(sft: SimpleFeatureType, hints: Hints): String = {
<span class="nc" id="L194">    val geom = hints.getDensityGeometry.getOrElse(sft.getGeomField)</span>
<span class="nc" id="L195">    require(</span>
<span class="nc bnc" id="L196" title="All 4 branches missed.">      sft.indexOf(geom) != -1 &amp;&amp; classOf[Geometry].isAssignableFrom(sft.getDescriptor(geom).getType.getBinding),</span>
<span class="nc" id="L197">      s&quot;Invalid geometry field: $geom&quot;)</span>
<span class="nc" id="L198">    geom</span>
  }

<span class="nc" id="L201">  class DensityScanResult(renderer: GeometryRenderer, grid: RenderingGrid) extends AggregatingScan.Result {</span>

<span class="nc" id="L203">    override def init(): Unit = {}</span>

    override def aggregate(sf: SimpleFeature): Int = {
<span class="nc" id="L206">      renderer.render(grid, sf); 1</span>
    }

<span class="nc" id="L209">    override def encode(): Array[Byte] = try { DensityScan.encodeResult(grid) } finally { grid.clear() }</span>

<span class="nc" id="L211">    override def cleanup(): Unit = {}</span>
  }

<span class="nc" id="L214">  abstract class DensityResultsToFeatures[T] extends ResultsToFeatures[T] {</span>

<span class="nc" id="L216">    override def init(state: Map[String, String]): Unit = {}</span>

<span class="nc" id="L218">    override def state: Map[String, String] = Map.empty</span>

<span class="nc" id="L220">    override def schema: SimpleFeatureType = DensityScan.DensitySft</span>

    override def apply(result: T): SimpleFeature = {
<span class="nc" id="L223">      val sf = new ScalaSimpleFeature(DensityScan.DensitySft, &quot;&quot;, Array(GeometryUtils.zeroPoint))</span>
<span class="nc" id="L224">      sf.getUserData.put(DensityScan.DensityValueKey, bytes(result))</span>
<span class="nc" id="L225">      sf</span>
    }

    protected def bytes(result: T): Array[Byte]

<span class="nc" id="L230">    def canEqual(other: Any): Boolean = other.isInstanceOf[DensityResultsToFeatures[T]]</span>

<span class="nc" id="L232">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">      case that: DensityResultsToFeatures[T] if that.canEqual(this) =&gt; true</span>
<span class="nc" id="L234">      case _ =&gt; false</span>
    }

<span class="nc" id="L237">    override def hashCode(): Int = schema.hashCode()</span>
  }

  /**
    * Gets the weight for a simple feature
    */
  private sealed trait Weigher {
    def weight(sf: SimpleFeature): Double
  }

<span class="nc" id="L247">  private case object EqualWeight extends Weigher {</span>
<span class="nc" id="L248">    override def weight(sf: SimpleFeature): Double = 1d</span>
  }

  /**
    * Gets the weight for a feature from a numeric attribute
    */
<span class="nc" id="L254">  private class WeightByNumber(i: Int) extends Weigher {</span>
    override def weight(sf: SimpleFeature): Double = {
<span class="nc" id="L256">      val d = sf.getAttribute(i).asInstanceOf[Number]</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if (d == null) { 0.0 } else { d.doubleValue }</span>
    }
  }

  /**
    * Tries to convert a non-double attribute into a double
    */
<span class="nc" id="L264">  private class WeightByNonNumber(i: Int) extends Weigher {</span>
    override def weight(sf: SimpleFeature): Double = {
<span class="nc" id="L266">      val d = sf.getAttribute(i)</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      if (d == null) { 0.0 } else {</span>
<span class="nc" id="L268">        val converted = FastConverter.convert(d, classOf[java.lang.Double])</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (converted == null) { 1.0 } else { converted.doubleValue() }</span>
      }
    }
  }

  /**
    * Evaluates an arbitrary expression against the simple feature to return a weight
    */
<span class="nc" id="L277">  private class WeightByExpression(e: Expression) extends Weigher {</span>
    override def weight(sf: SimpleFeature): Double = {
<span class="nc" id="L279">      val d = e.evaluate(sf, classOf[java.lang.Double])</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">      if (d == null) { 0.0 } else { d }</span>
    }
  }

  /**
    * Renderer for geometries
    */
  sealed trait GeometryRenderer {
    def render(grid: RenderingGrid, sf: SimpleFeature): Unit
  }

  /**
    * Writes a density record from a feature that has a point geometry
    */
<span class="nc" id="L294">  private class PointRenderer(i: Int, weigher: Weigher) extends GeometryRenderer {</span>
    override def render(grid: RenderingGrid, sf: SimpleFeature): Unit =
<span class="nc" id="L296">      grid.render(sf.getAttribute(i).asInstanceOf[Point], weigher.weight(sf))</span>
  }

  /**
    * Writes a density record from a feature that has a multi-point geometry
    */
<span class="nc" id="L302">  private class MultiPointRenderer(i: Int, weigher: Weigher) extends GeometryRenderer {</span>
    override def render(grid: RenderingGrid, sf: SimpleFeature): Unit =
<span class="nc" id="L304">      grid.render(sf.getAttribute(i).asInstanceOf[MultiPoint], weigher.weight(sf))</span>
  }

  /**
    * Writes a density record from a feature that has a line geometry
    */
<span class="nc" id="L310">  private class LineStringRenderer(i: Int, weigher: Weigher) extends GeometryRenderer {</span>
    override def render(grid: RenderingGrid, sf: SimpleFeature): Unit =
<span class="nc" id="L312">      grid.render(sf.getAttribute(i).asInstanceOf[LineString], weigher.weight(sf))</span>
  }

  /**
    * Writes a density record from a feature that has a multi-line geometry
    */
<span class="nc" id="L318">  private class MultiLineStringRenderer(i: Int, weigher: Weigher) extends GeometryRenderer {</span>
    override def render(grid: RenderingGrid, sf: SimpleFeature): Unit =
<span class="nc" id="L320">      grid.render(sf.getAttribute(i).asInstanceOf[MultiLineString], weigher.weight(sf))</span>
  }

  /**
    * Writes a density record from a feature that has a polygon geometry
    */
<span class="nc" id="L326">  private class PolygonRenderer(i: Int, weigher: Weigher) extends GeometryRenderer {</span>
    override def render(grid: RenderingGrid, sf: SimpleFeature): Unit =
<span class="nc" id="L328">      grid.render(sf.getAttribute(i).asInstanceOf[Polygon], weigher.weight(sf))</span>
  }

  /**
    * Writes a density record from a feature that has a polygon geometry
    */
<span class="nc" id="L334">  private class MultiPolygonRenderer(i: Int, weigher: Weigher) extends GeometryRenderer {</span>
    override def render(grid: RenderingGrid, sf: SimpleFeature): Unit =
<span class="nc" id="L336">      grid.render(sf.getAttribute(i).asInstanceOf[MultiPolygon], weigher.weight(sf))</span>
  }

  /**
    * Writes a density record from a feature that has an arbitrary geometry
    */
<span class="nc" id="L342">  private class MultiRenderer(i: Int, weigher: Weigher) extends GeometryRenderer {</span>
    override def render(grid: RenderingGrid, sf: SimpleFeature): Unit =
<span class="nc" id="L344">      grid.render(sf.getAttribute(i).asInstanceOf[Geometry], weigher.weight(sf))</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>