<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatsScan.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.iterators</a> &gt; <span class="el_source">StatsScan.scala</span></div><h1>StatsScan.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.iterators

import com.typesafe.scalalogging.LazyLogging
import org.apache.commons.codec.binary.Base64
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.api.QueryPlan.{FeatureReducer, ResultsToFeatures}
import org.locationtech.geomesa.index.iterators.StatsScan.StatResult
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.impl.StatSerializer
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.geotools.{GeometryUtils, SimpleFeatureTypes}
import org.locationtech.geomesa.utils.io.CloseWithLogging

import java.util.Objects

<span class="nc" id="L29">trait StatsScan extends AggregatingScan[StatResult] with LazyLogging {</span>

  import org.locationtech.geomesa.index.iterators.StatsScan.Configuration._

  override protected def createResult(
      sft: SimpleFeatureType,
      transform: Option[SimpleFeatureType],
      batchSize: Int,
      options: Map[String, String]): StatResult = {
<span class="nc" id="L38">    new StatResult(transform.getOrElse(sft), options(STATS_STRING_KEY))</span>
  }

  override protected def defaultBatchSize: Int =
<span class="nc" id="L42">    StatsScan.BatchSize.toInt.get // has a valid default so should be safe to .get</span>
}

<span class="nc" id="L45">object StatsScan {</span>

<span class="nc" id="L47">  val BatchSize: SystemProperty = SystemProperty(&quot;geomesa.stats.batch.size&quot;, &quot;10000&quot;)</span>

<span class="nc" id="L49">  val StatsSft: SimpleFeatureType = SimpleFeatureTypes.createType(&quot;stats:stats&quot;, &quot;stats:String,geom:Geometry&quot;)</span>

<span class="nc" id="L51">  object Configuration {</span>
<span class="nc" id="L52">    val STATS_STRING_KEY = &quot;geomesa.stats.string&quot;</span>
  }

<span class="nc" id="L55">  def configure(sft: SimpleFeatureType,</span>
                index: GeoMesaFeatureIndex[_, _],
                filter: Option[Filter],
                hints: Hints): Map[String, String] = {
    import Configuration.STATS_STRING_KEY
    import org.locationtech.geomesa.index.conf.QueryHints.{RichHints, STATS_STRING}
<span class="nc" id="L61">    val batchSize = StatsScan.BatchSize.toInt.get // has a valid default so should be safe to .get</span>
<span class="nc" id="L62">    AggregatingScan.configure(sft, index, filter, hints.getTransform, hints.getSampling, batchSize) ++</span>
<span class="nc" id="L63">      Map(STATS_STRING_KEY -&gt; hints.get(STATS_STRING).asInstanceOf[String])</span>
  }

  /**
    * Encodes a stat as a base64 string.
    *
    * @param sft simple feature type of underlying schema
    * @return function to encode a stat as a base64 string
    */
  def encodeStat(sft: SimpleFeatureType): Stat =&gt; String = {
<span class="nc" id="L73">    val serializer = StatSerializer(sft)</span>
<span class="nc" id="L74">    stat =&gt; Base64.encodeBase64URLSafeString(serializer.serialize(stat))</span>
  }

  /**
    * Decodes a stat string from a result simple feature.
    *
    * @param sft simple feature type of the underlying schema
    * @return function to convert an encoded encoded string to a stat
    */
  def decodeStat(sft: SimpleFeatureType): String =&gt; Stat = {
<span class="nc" id="L84">    val serializer = StatSerializer(sft)</span>
<span class="nc" id="L85">    encoded =&gt; serializer.deserialize(Base64.decodeBase64(encoded))</span>
  }

  /**
   * Result wrapper for stats
   *
   * @param sft simple feature type
   * @param definition stat string
   */
<span class="nc" id="L94">  class StatResult(sft: SimpleFeatureType, definition: String) extends AggregatingScan.Result {</span>

<span class="nc" id="L96">    private val stat = Stat(sft, definition)</span>
<span class="nc" id="L97">    private val serializer = StatSerializer(sft)</span>

<span class="nc" id="L99">    override def init(): Unit = {}</span>

    override def aggregate(sf: SimpleFeature): Int = {
<span class="nc" id="L102">      stat.observe(sf)</span>
<span class="nc" id="L103">      1</span>
    }

<span class="nc" id="L106">    override def encode(): Array[Byte] = try { serializer.serialize(stat) } finally { stat.clear() }</span>

<span class="nc" id="L108">    override def cleanup(): Unit = {}</span>
  }

  /**
    * Stats results to features
    *
    * @tparam T result type
    */
<span class="nc" id="L116">  abstract class StatsResultsToFeatures[T] extends ResultsToFeatures[T] {</span>

<span class="nc" id="L118">    override def state: Map[String, String] = Map.empty</span>

<span class="nc" id="L120">    override def init(state: Map[String, String]): Unit = {}</span>

<span class="nc" id="L122">    override def schema: SimpleFeatureType = StatsScan.StatsSft</span>

    override def apply(result: T): SimpleFeature = {
<span class="nc" id="L125">      val values = Array[AnyRef](Base64.encodeBase64URLSafeString(bytes(result)), GeometryUtils.zeroPoint)</span>
<span class="nc" id="L126">      new ScalaSimpleFeature(StatsScan.StatsSft, &quot;&quot;, values)</span>
    }

    protected def bytes(result: T): Array[Byte]

<span class="nc" id="L131">    def canEqual(other: Any): Boolean = other.isInstanceOf[StatsResultsToFeatures[T]]</span>

<span class="nc" id="L133">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">      case that: StatsResultsToFeatures[T] if that.canEqual(this) =&gt; true</span>
<span class="nc" id="L135">      case _ =&gt; false</span>
    }

<span class="nc" id="L138">    override def hashCode(): Int = schema.hashCode()</span>
  }

  /**
    * Reduces computed simple features which contain stat information into one on the client
    *
    * @param sft sft used for the stat query
    * @param query stat query
    * @param encode encode results or return as json
    */
<span class="nc" id="L148">  class StatsReducer(</span>
<span class="nc" id="L149">      private var sft: SimpleFeatureType,</span>
<span class="nc" id="L150">      private var query: String,</span>
<span class="nc" id="L151">      private var encode: Boolean</span>
<span class="nc" id="L152">    ) extends FeatureReducer {</span>

<span class="nc" id="L154">    def this() = this(null, null, false) // no-arg constructor required for serialization</span>

    override def init(state: Map[String, String]): Unit = {
<span class="nc" id="L157">      sft = SimpleFeatureTypes.createType(state(&quot;sft&quot;), state(&quot;spec&quot;))</span>
<span class="nc" id="L158">      query = state(&quot;q&quot;)</span>
<span class="nc" id="L159">      encode = state(&quot;e&quot;).toBoolean</span>
    }

<span class="nc" id="L162">    override def state: Map[String, String] = Map(</span>
<span class="nc" id="L163">      &quot;sft&quot;  -&gt; sft.getTypeName,</span>
<span class="nc" id="L164">      &quot;spec&quot; -&gt; SimpleFeatureTypes.encodeType(sft, includeUserData = true),</span>
<span class="nc" id="L165">      &quot;q&quot;    -&gt; query,</span>
<span class="nc" id="L166">      &quot;e&quot;    -&gt; encode.toString</span>
    )

    override def apply(features: CloseableIterator[SimpleFeature]): CloseableIterator[SimpleFeature] = {
      try {
        // if no results, create empty stat based on the original input so that we always return something
<span class="nc bnc" id="L172" title="All 2 branches missed.">        val sum = if (features.isEmpty) { Stat(sft, query) } else {</span>
<span class="nc" id="L173">          val decode = decodeStat(sft)</span>
<span class="nc" id="L174">          features.map(f =&gt; decode(f.getAttribute(0).asInstanceOf[String])).reduceLeft(reducer)</span>
        }
<span class="nc bnc" id="L176" title="All 2 branches missed.">        val result = if (encode) { encodeStat(sft)(sum) } else { sum.toJson }</span>
<span class="nc" id="L177">        CloseableIterator.single(new ScalaSimpleFeature(StatsSft, &quot;stat&quot;, Array(result, GeometryUtils.zeroPoint)))</span>
      } finally {
<span class="nc" id="L179">        CloseWithLogging(features)</span>
      }
    }

<span class="nc" id="L183">    private def reducer(sum: Stat, next: Stat): Stat = { sum += next; sum }</span>

<span class="nc" id="L185">    def canEqual(other: Any): Boolean = other.isInstanceOf[StatsReducer]</span>

<span class="nc" id="L187">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L188" title="All 18 branches missed.">      case that: StatsReducer if that.canEqual(this) =&gt; sft == that.sft &amp;&amp; query == that.query &amp;&amp; encode == that.encode</span>
<span class="nc" id="L189">      case _ =&gt; false</span>
    }

    override def hashCode(): Int = {
<span class="nc" id="L193">      val state = Seq(sft, query, encode)</span>
<span class="nc" id="L194">      state.map(Objects.hashCode).foldLeft(0)((a, b) =&gt; 31 * a + b)</span>
    }
  }

<span class="nc" id="L198">  object StatsReducer {</span>
    import org.locationtech.geomesa.index.conf.QueryHints.RichHints

    def apply(sft: SimpleFeatureType, hints: Hints): StatsReducer =
<span class="nc" id="L202">      new StatsReducer(hints.getTransformSchema.getOrElse(sft), hints.getStatsQuery, hints.isStatsEncode)</span>
  }
<span class="nc" id="L204">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>