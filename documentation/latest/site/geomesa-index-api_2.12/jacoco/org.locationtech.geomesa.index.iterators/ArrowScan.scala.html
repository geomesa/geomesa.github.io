<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrowScan.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.iterators</a> &gt; <span class="el_source">ArrowScan.scala</span></div><h1>ArrowScan.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.iterators

import com.typesafe.scalalogging.LazyLogging
import org.apache.arrow.vector.ipc.message.IpcOption
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.arrow.io._
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding
import org.locationtech.geomesa.arrow.vector.SimpleFeatureVector.SimpleFeatureEncoding.Encoding
import org.locationtech.geomesa.arrow.{ArrowEncodedSft, ArrowProperties}
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.api.QueryPlan.{FeatureReducer, ResultsToFeatures}
import org.locationtech.geomesa.index.stats.GeoMesaStats
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools._
import org.locationtech.geomesa.utils.io.CloseWithLogging
import org.locationtech.geomesa.utils.text.StringSerialization

import java.util.Objects

<span class="nc" id="L31">trait ArrowScan extends AggregatingScan[ArrowScan.ArrowAggregate] {</span>

  import org.locationtech.geomesa.index.iterators.ArrowScan._

  override def createResult(
      sft: SimpleFeatureType,
      transform: Option[SimpleFeatureType],
      batchSize: Int,
      options: Map[String, String]): ArrowAggregate = {

    import ArrowScan.Configuration._

<span class="nc" id="L43">    val arrowSft = transform.getOrElse(sft)</span>
<span class="nc" id="L44">    val includeFids = options(IncludeFidsKey).toBoolean</span>
<span class="nc" id="L45">    val proxyFids = options.get(ProxyFidsKey).exists(_.toBoolean)</span>
<span class="nc" id="L46">    val flipAxisOrder = options.get(FlipAxisOrderKey).exists(_.toBoolean)</span>
<span class="nc" id="L47">    val encoding = SimpleFeatureEncoding.min(includeFids, proxyFids, flipAxisOrder)</span>
<span class="nc" id="L48">    val dictionary = options(DictionaryKey)</span>
<span class="nc" id="L49">    val sort = options.get(SortKey).map(name =&gt; (name, options.get(SortReverseKey).exists(_.toBoolean)))</span>
<span class="nc" id="L50">    val ipcOpts = FormatVersion.options(options(IpcVersionKey))</span>
<span class="nc" id="L51">    val dictionaries = dictionary.split(&quot;,&quot;).filterNot(_.isEmpty)</span>
<span class="nc" id="L52">    new DeltaAggregate(arrowSft, dictionaries, encoding, ipcOpts, sort, batchSize)</span>
  }

<span class="nc" id="L55">  override protected def defaultBatchSize: Int = throw new IllegalArgumentException(&quot;Batch scan is specified per scan&quot;)</span>
}

<span class="nc bnc" id="L58" title="All 4 branches missed.">object ArrowScan extends LazyLogging {</span>

  import org.locationtech.geomesa.index.conf.QueryHints.RichHints

<span class="nc" id="L62">  object Configuration {</span>

<span class="nc" id="L64">    val IncludeFidsKey   = &quot;fids&quot;</span>
<span class="nc" id="L65">    val ProxyFidsKey     = &quot;proxy&quot;</span>
<span class="nc" id="L66">    val FlipAxisOrderKey = &quot;flip-axis-order&quot;</span>
<span class="nc" id="L67">    val DictionaryKey    = &quot;dict&quot;</span>
<span class="nc" id="L68">    val IpcVersionKey    = &quot;ipc&quot;</span>
<span class="nc" id="L69">    val SortKey          = &quot;sort&quot;</span>
<span class="nc" id="L70">    val SortReverseKey   = &quot;sort-rev&quot;</span>
  }

  /**
    * Configure the iterator
    *
    * @param sft simple feature type
    * @param index feature index
    * @param stats stats, used for querying dictionaries
    * @param filter full filter from the query, if any
    * @param ecql secondary push down filter, if any
    * @param hints query hints
    * @return
    */
<span class="nc" id="L84">  def configure(sft: SimpleFeatureType,</span>
                index: GeoMesaFeatureIndex[_, _],
                stats: GeoMesaStats,
                filter: Option[Filter],
                ecql: Option[Filter],
                hints: Hints): ArrowScanConfig = {
    import AggregatingScan.{OptionToConfig, StringToConfig}
    import Configuration._

<span class="nc" id="L93">    val arrowSft = hints.getTransformSchema.getOrElse(sft)</span>
<span class="nc" id="L94">    val includeFids = hints.isArrowIncludeFid</span>
<span class="nc" id="L95">    val proxyFids = hints.isArrowProxyFid</span>
<span class="nc" id="L96">    val flipAxisOrder = hints.isFlipAxisOrder</span>
<span class="nc" id="L97">    val encoding = SimpleFeatureEncoding.min(includeFids, proxyFids, flipAxisOrder)</span>
<span class="nc" id="L98">    val sort = hints.getArrowSort</span>
<span class="nc" id="L99">    val batchSize = getBatchSize(hints)</span>
<span class="nc" id="L100">    val ipc = hints.getArrowFormatVersion.getOrElse(FormatVersion.ArrowFormatVersion.get)</span>
<span class="nc" id="L101">    val ipcOpts = FormatVersion.options(ipc)</span>
<span class="nc" id="L102">    val dictionaryFields = hints.getArrowDictionaryFields</span>

    val config = {
<span class="nc" id="L105">      val base = AggregatingScan.configure(sft, index, ecql, hints.getTransform, hints.getSampling, batchSize)</span>
<span class="nc" id="L106">      base ++ AggregatingScan.optionalMap(</span>
<span class="nc" id="L107">        IncludeFidsKey   -&gt; includeFids.toString,</span>
<span class="nc" id="L108">        ProxyFidsKey     -&gt; proxyFids.toString,</span>
<span class="nc" id="L109">        FlipAxisOrderKey -&gt; flipAxisOrder.toString,</span>
<span class="nc" id="L110">        IpcVersionKey    -&gt; ipc,</span>
<span class="nc" id="L111">        SortKey          -&gt; sort.map(_._1),</span>
<span class="nc" id="L112">        SortReverseKey   -&gt; sort.map(_._2.toString),</span>
<span class="nc" id="L113">        DictionaryKey    -&gt; dictionaryFields.mkString(&quot;,&quot;)</span>
      )
    }

<span class="nc" id="L117">    val process = hints.isArrowProcessDeltas</span>
<span class="nc" id="L118">    val reducer = new DeltaReducer(arrowSft, dictionaryFields, encoding, ipcOpts, batchSize, sort, sorted = false, process)</span>
<span class="nc" id="L119">    ArrowScanConfig(config, reducer)</span>
  }

  /**
    * Gets the batch size from query hints, or falls back to the system property
    *
    * @param hints query hints
    * @return
    */
<span class="nc" id="L128">  def getBatchSize(hints: Hints): Int = hints.getArrowBatchSize.getOrElse(ArrowProperties.BatchSize.get.toInt)</span>

  def getIpcOpts(hints: Hints): IpcOption =
<span class="nc" id="L131">    FormatVersion.options(hints.getArrowFormatVersion.getOrElse(FormatVersion.ArrowFormatVersion.get))</span>

  def getEncoding(hints: Hints): SimpleFeatureEncoding =
<span class="nc" id="L134">    SimpleFeatureEncoding.min(hints.isArrowIncludeFid, hints.isArrowProxyFid, hints.isFlipAxisOrder)</span>

  /**
    * Simple feature used for returning from scans
    *
    * @return
    */
  def resultFeature(): SimpleFeature =
<span class="nc" id="L142">    new ScalaSimpleFeature(ArrowEncodedSft, &quot;&quot;, Array(null, GeometryUtils.zeroPoint))</span>

  /**
    * Trait for aggregating arrow files
    */
  trait ArrowAggregate extends AggregatingScan.Result

  /**
    * Returns batches of [threading key][dictionary deltas][record batch]. Will sort each batch,
    * but not between batches.
    *
    * @param sft simple feature type
    * @param dictionaryFields dictionary fields
    * @param encoding arrow encoding
    * @param sort sort field, sort reverse
    * @param batchSize batch size
    */
<span class="nc" id="L159">  class DeltaAggregate(</span>
<span class="nc" id="L160">      sft: SimpleFeatureType,</span>
<span class="nc" id="L161">      dictionaryFields: Seq[String],</span>
<span class="nc" id="L162">      encoding: SimpleFeatureEncoding,</span>
<span class="nc" id="L163">      ipcOpts: IpcOption,</span>
<span class="nc" id="L164">      sort: Option[(String, Boolean)],</span>
<span class="nc" id="L165">      batchSize: Int</span>
<span class="nc" id="L166">    ) extends ArrowAggregate {</span>

<span class="nc" id="L168">    private val features = Array.ofDim[SimpleFeature](batchSize)</span>

<span class="nc" id="L170">    private var writer: DeltaWriter = _</span>

<span class="nc" id="L172">    private var index = 0</span>

    override def init(): Unit = {
<span class="nc" id="L175">      writer = new DeltaWriter(sft, dictionaryFields, encoding, ipcOpts, sort, batchSize)</span>
    }

    override def aggregate(sf: SimpleFeature): Int = {
      // we have to copy since the feature might be re-used
      // TODO we could probably optimize this...
<span class="nc" id="L181">      features(index) = ScalaSimpleFeature.copy(sf)</span>
<span class="nc" id="L182">      index += 1</span>
<span class="nc" id="L183">      1</span>
    }

<span class="nc" id="L186">    override def encode(): Array[Byte] = try { writer.encode(features, index) } finally { index = 0 }</span>

    override def cleanup(): Unit = {
<span class="nc" id="L189">      CloseWithLogging(writer)</span>
<span class="nc" id="L190">      writer = null</span>
    }
  }

  /**
    * Reduce function for delta batches.
    *
    * First feature contains metadata for arrow file and dictionary batch, subsequent features
    * contain record batches, final feature contains EOF indicator
    *
    * @param sft simple feature type
    * @param dictionaryFields dictionaries
    * @param encoding encoding
    * @param batchSize batch size
    * @param sort sort
    * @return
    */
<span class="nc" id="L207">  class DeltaReducer(</span>
<span class="nc" id="L208">      private var sft: SimpleFeatureType,</span>
<span class="nc" id="L209">      private var dictionaryFields: Seq[String],</span>
<span class="nc" id="L210">      private var encoding: SimpleFeatureEncoding,</span>
<span class="nc" id="L211">      private var ipcOpts: IpcOption,</span>
<span class="nc" id="L212">      private var batchSize: Int,</span>
<span class="nc" id="L213">      private var sort: Option[(String, Boolean)],</span>
<span class="nc" id="L214">      private var sorted: Boolean,</span>
<span class="nc" id="L215">      private var process: Boolean</span>
<span class="nc" id="L216">    ) extends FeatureReducer {</span>

<span class="nc" id="L218">    def this() = this(null, null, null, null, -1, null, false, true) // no-arg constructor required for serialization</span>

<span class="nc" id="L220">    def this(sft: SimpleFeatureType, hints: Hints, sorted: Boolean) =</span>
<span class="nc" id="L221">      this(sft, hints.getArrowDictionaryFields, getEncoding(hints), getIpcOpts(hints), getBatchSize(hints),</span>
<span class="nc" id="L222">        hints.getSortFields.map(_.head).orElse(hints.getArrowSort), sorted, hints.isArrowProcessDeltas)</span>

    override def init(state: Map[String, String]): Unit = {
<span class="nc" id="L225">      sft = ReducerConfig.sft(state)</span>
<span class="nc" id="L226">      dictionaryFields = StringSerialization.decodeSeq(state(ReducerConfig.DictionariesKey))</span>
<span class="nc" id="L227">      encoding = ReducerConfig.encoding(state)</span>
<span class="nc" id="L228">      ipcOpts = ReducerConfig.ipcOption(state)</span>
<span class="nc" id="L229">      batchSize = ReducerConfig.batch(state)</span>
<span class="nc" id="L230">      sort = ReducerConfig.sort(state)</span>
<span class="nc" id="L231">      sorted = ReducerConfig.sorted(state)</span>
<span class="nc" id="L232">      process = ReducerConfig.process(state)</span>
    }

<span class="nc" id="L235">    override def state: Map[String, String] = Map(</span>
<span class="nc" id="L236">      ReducerConfig.sftName(sft),</span>
<span class="nc" id="L237">      ReducerConfig.sftSpec(sft),</span>
<span class="nc" id="L238">      ReducerConfig.DictionariesKey -&gt; StringSerialization.encodeSeq(dictionaryFields),</span>
<span class="nc" id="L239">      ReducerConfig.encoding(encoding),</span>
<span class="nc" id="L240">      ReducerConfig.flipAxisOrder(encoding),</span>
<span class="nc" id="L241">      ReducerConfig.ipcOption(ipcOpts),</span>
<span class="nc" id="L242">      ReducerConfig.batch(batchSize),</span>
<span class="nc" id="L243">      ReducerConfig.sort(sort),</span>
<span class="nc" id="L244">      ReducerConfig.sorted(sorted),</span>
<span class="nc" id="L245">      ReducerConfig.process(process)</span>
    )

    override def apply(features: CloseableIterator[SimpleFeature]): CloseableIterator[SimpleFeature] = {
<span class="nc" id="L249">      val files = features.map(_.getAttribute(0).asInstanceOf[Array[Byte]])</span>
<span class="nc" id="L250">      val result = DeltaWriter.reduce(sft, dictionaryFields, encoding, ipcOpts, sort, sorted, batchSize, process, files)</span>
<span class="nc" id="L251">      val sf = resultFeature()</span>
<span class="nc" id="L252">      result.map { bytes =&gt; sf.setAttribute(0, bytes); sf }</span>
    }

<span class="nc" id="L255">    def canEqual(other: Any): Boolean = other.isInstanceOf[DeltaReducer]</span>

<span class="nc" id="L257">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">      case that: DeltaReducer if that.canEqual(this) =&gt;</span>
<span class="nc bnc" id="L259" title="All 18 branches missed.">        sft == that.sft &amp;&amp; dictionaryFields == that.dictionaryFields &amp;&amp; encoding == that.encoding &amp;&amp;</span>
<span class="nc bnc" id="L260" title="All 12 branches missed.">            batchSize == that.batchSize &amp;&amp; sort == that.sort &amp;&amp; sorted == that.sorted &amp;&amp; that.process == process</span>
<span class="nc" id="L261">      case _ =&gt; false</span>
    }

    override def hashCode(): Int = {
<span class="nc" id="L265">      val state = Seq(sft, dictionaryFields, encoding, batchSize, sort, process)</span>
<span class="nc" id="L266">      state.map(Objects.hashCode).foldLeft(0)((a, b) =&gt; 31 * a + b)</span>
    }
  }

<span class="nc" id="L270">  object ReducerConfig {</span>

<span class="nc" id="L272">    val SftKey           = &quot;sft&quot;</span>
<span class="nc" id="L273">    val SpecKey          = &quot;spec&quot;</span>
<span class="nc" id="L274">    val DictionariesKey  = &quot;dicts&quot;</span>
<span class="nc" id="L275">    val EncodingKey      = &quot;enc&quot;</span>
<span class="nc" id="L276">    val FlipAxisOrderKey = &quot;flip-axis-order&quot;</span>
<span class="nc" id="L277">    val IpcKey           = &quot;ipc&quot;</span>
<span class="nc" id="L278">    val BatchKey         = &quot;batch&quot;</span>
<span class="nc" id="L279">    val SortKey          = &quot;sort&quot;</span>
<span class="nc" id="L280">    val SortedKey        = &quot;sorted&quot;</span>
<span class="nc" id="L281">    val ProcessKey       = &quot;process&quot;</span>

<span class="nc" id="L283">    def sftName(sft: SimpleFeatureType): (String, String) = SftKey -&gt; sft.getTypeName</span>
    def sftSpec(sft: SimpleFeatureType): (String, String) =
<span class="nc" id="L285">      SpecKey -&gt; SimpleFeatureTypes.encodeType(sft, includeUserData = true)</span>

    def sft(options: Map[String, String]): SimpleFeatureType =
<span class="nc" id="L288">      SimpleFeatureTypes.createType(options(SftKey), options(SpecKey))</span>

    def encoding(e: SimpleFeatureEncoding): (String, String) =
<span class="nc" id="L291">      EncodingKey -&gt; s&quot;${e.fids.getOrElse(&quot;&quot;)}:${e.geometry}:${e.date}&quot;</span>

    def flipAxisOrder(e: SimpleFeatureEncoding): (String, String) =
<span class="nc" id="L294">      FlipAxisOrderKey -&gt; s&quot;${e.flipAxisOrder}&quot;</span>

    def encoding(options: Map[String, String]): SimpleFeatureEncoding = {
<span class="nc bnc" id="L297" title="All 6 branches missed.">      val Array(fids, geom, dtg) = options(EncodingKey).split(&quot;:&quot;)</span>
<span class="nc" id="L298">      val fidOpt = Option(fids).filterNot(_.isEmpty).map(Encoding.withName)</span>
<span class="nc" id="L299">      val flipAxisOrder = options.get(FlipAxisOrderKey).exists(_.toBoolean)</span>
<span class="nc" id="L300">      SimpleFeatureEncoding(fidOpt, Encoding.withName(geom), Encoding.withName(dtg), flipAxisOrder)</span>
    }

<span class="nc" id="L303">    def ipcOption(options: Map[String, String]): IpcOption = FormatVersion.options(options(IpcKey))</span>
<span class="nc" id="L304">    def ipcOption(ipcOpts: IpcOption): (String, String) = IpcKey -&gt; FormatVersion.version(ipcOpts)</span>

<span class="nc" id="L306">    def batch(b: Int): (String, String) = BatchKey -&gt; b.toString</span>
<span class="nc" id="L307">    def batch(options: Map[String, String]): Int = options(BatchKey).toInt</span>

    def sort(s: Option[(String, Boolean)]): (String, String) =
<span class="nc bnc" id="L310" title="All 2 branches missed.">      SortKey -&gt; s.map { case (f, reverse) =&gt; s&quot;$reverse:$f&quot; }.getOrElse(&quot;&quot;)</span>

    def sort(options: Map[String, String]): Option[(String, Boolean)] = {
<span class="nc" id="L313">      options.get(SortKey).filterNot(_.isEmpty).map { s =&gt;</span>
<span class="nc bnc" id="L314" title="All 6 branches missed.">        val Array(rev, f) = s.split(&quot;:&quot;)</span>
<span class="nc" id="L315">        (f, rev.toBoolean)</span>
      }
    }

<span class="nc" id="L319">    def sorted(s: Boolean): (String, String) = SortedKey -&gt; s.toString</span>
<span class="nc" id="L320">    def sorted(options: Map[String, String]): Boolean = options.get(SortedKey).exists(_.toBoolean)</span>

<span class="nc" id="L322">    def process(s: Boolean): (String, String) = ProcessKey -&gt; s.toString</span>
<span class="nc" id="L323">    def process(options: Map[String, String]): Boolean = options.get(ProcessKey).forall(_.toBoolean)</span>
  }

  /**
    * Converts arrow-encoded results to features
    *
    * @tparam T result type
    */
<span class="nc" id="L331">  abstract class ArrowResultsToFeatures[T] extends ResultsToFeatures[T] {</span>

<span class="nc" id="L333">    override def init(state: Map[String, String]): Unit = {}</span>

<span class="nc" id="L335">    override def state: Map[String, String] = Map.empty</span>

<span class="nc" id="L337">    override def schema: SimpleFeatureType = ArrowEncodedSft</span>

    override def apply(result: T): SimpleFeature =
<span class="nc" id="L340">      new ScalaSimpleFeature(ArrowEncodedSft, &quot;&quot;, Array(bytes(result), GeometryUtils.zeroPoint))</span>

    protected def bytes(result: T): Array[Byte]

<span class="nc" id="L344">    def canEqual(other: Any): Boolean = other.isInstanceOf[ArrowResultsToFeatures[T]]</span>

<span class="nc" id="L346">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L347" title="All 4 branches missed.">      case that: ArrowResultsToFeatures[T] if that.canEqual(this) =&gt; true</span>
<span class="nc" id="L348">      case _ =&gt; false</span>
    }

<span class="nc" id="L351">    override def hashCode(): Int = schema.hashCode()</span>
  }

<span class="nc bnc" id="L354" title="All 25 branches missed.">  case class ArrowScanConfig(config: Map[String, String], reduce: FeatureReducer)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>