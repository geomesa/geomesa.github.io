<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IteratorCache.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.iterators</a> &gt; <span class="el_source">IteratorCache.scala</span></div><h1>IteratorCache.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.iterators

import com.github.benmanes.caffeine.cache.{Cache, Caffeine}
import com.typesafe.scalalogging.StrictLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.features.SerializationOption
import org.locationtech.geomesa.features.SerializationOption.SerializationOption
import org.locationtech.geomesa.features.kryo.KryoFeatureSerializer
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.index.api.{GeoMesaFeatureIndex, GeoMesaFeatureIndexFactory}
import org.locationtech.geomesa.utils.cache.ThreadLocalCache
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.conf.IndexId
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.index.IndexMode

import java.util.concurrent.TimeUnit

/**
  * Cache for expensive objects used in iterators
  */
<span class="nc" id="L31">object IteratorCache extends StrictLogging {</span>

  // force evaluation of accessor cache while setting the context classloader to pick up our custm accessors
<span class="nc" id="L34">  org.locationtech.geomesa.utils.geotools.SimpleFeaturePropertyAccessor.initialize()</span>

<span class="nc" id="L36">  private val expiry = SystemProperty(&quot;geomesa.filter.remote.cache.expiry&quot;, &quot;10 minutes&quot;).toDuration.get</span>

  // thread safe object caches
<span class="nc" id="L39">  private val serializerCache: Cache[(String, String), KryoFeatureSerializer] =</span>
<span class="nc" id="L40">    Caffeine.newBuilder().expireAfterAccess(expiry.toMillis, TimeUnit.MILLISECONDS).build()</span>
<span class="nc" id="L41">  private val indexCache: Cache[(String, String), GeoMesaFeatureIndex[_, _]] =</span>
<span class="nc" id="L42">    Caffeine.newBuilder().expireAfterAccess(expiry.toMillis, TimeUnit.MILLISECONDS).build()</span>

  // non-thread safe object caches
<span class="nc" id="L45">  private val filterCache = new ThreadLocalCache[(String, String), Filter](expiry)</span>

  /**
    * Returns a cached simple feature type, creating one if necessary. Note: do not modify returned value.
    *
    * @param spec simple feature type spec
    * @return
    */
<span class="nc" id="L53">  def sft(spec: String): SimpleFeatureType = SimpleFeatureTypes.createImmutableType(&quot;&quot;, spec)</span>

  /**
    * Returns a cached serializer, creating one if necessary
    *
    * @param spec simple feature type spec
    * @param options serialization options
    * @return
    */
  def serializer(spec: String, options: Set[SerializationOption]): KryoFeatureSerializer = {
    // note: before the cache is populated, we might end up creating multiple objects, but it is still thread-safe
<span class="nc" id="L64">    val cached = serializerCache.getIfPresent((spec, options.mkString))</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (cached != null) { cached } else {</span>
<span class="nc" id="L66">      val serializer = KryoFeatureSerializer(sft(spec), options)</span>
<span class="nc" id="L67">      serializerCache.put((spec, options.mkString), serializer)</span>
<span class="nc" id="L68">      serializer</span>
    }
  }

  /**
   * Returns a cached serializer, creating one if necessary
   *
   * @param spec simple feature type spec
   * @param withId serialization option
   * @return
   */
  def serializer(spec: String, withId: Boolean): KryoFeatureSerializer =
<span class="nc bnc" id="L80" title="All 2 branches missed.">    serializer(spec, if (withId) { SerializationOption.defaults } else { Set(SerializationOption.WithoutId) })</span>

  /**
    * Returns a cached filter, creating one if necessary.
    *
    * Note: need to include simple feature type in cache key,
    * as attribute name -&gt; attribute index gets cached in the filter
    *
    * @param sft simple feature type being filtered
    * @param spec spec string for the simple feature type
    * @param ecql ecql
    * @return
    */
  def filter(sft: SimpleFeatureType, spec: String, ecql: String): Filter = {
<span class="nc bnc" id="L94" title="All 2 branches missed.">    logger.debug(s&quot;Filter cache estimated size: ${filterCache.estimatedGlobalSize}&quot;)</span>
<span class="nc bnc" id="L95" title="All 6 branches missed.">    logger.trace(s&quot;Filter cache entries: ${filterCache.globalIterator.map { case (t, (k, v), _) =&gt; s&quot;thread $t $k=&gt;$v&quot; }.mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L96">    filterCache.getOrElseUpdate((spec, ecql), FastFilterFactory.toFilter(sft, ecql))</span>
  }

  /**
    * Gets a cached feature index instance. Note that the index is not backed by a data store as
    * normal, so operations which require a live connection will fail
    *
    * @param sft simple feature type
    * @param spec spec string for the simple feature type
    * @param identifier index id
    * @return
    */
  def index(sft: SimpleFeatureType, spec: String, identifier: String): GeoMesaFeatureIndex[_, _] = {
<span class="nc" id="L109">    val cached = indexCache.getIfPresent((spec, identifier))</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">    if (cached != null) { cached } else {</span>
<span class="nc" id="L111">      val index = GeoMesaFeatureIndexFactory.create(null, sft, Seq(IndexId.id(identifier))).headOption.getOrElse {</span>
<span class="nc" id="L112">        throw new RuntimeException(s&quot;Index option not configured correctly: $identifier&quot;)</span>
      }
<span class="nc bnc" id="L114" title="All 2 branches missed.">      if (!index.mode.supports(IndexMode.Read)) {</span>
<span class="nc" id="L115">        throw new RuntimeException(s&quot;Index option configured for a non-readable index: $identifier&quot;)</span>
      }
<span class="nc" id="L117">      indexCache.put((spec, identifier), index)</span>
<span class="nc" id="L118">      index</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>