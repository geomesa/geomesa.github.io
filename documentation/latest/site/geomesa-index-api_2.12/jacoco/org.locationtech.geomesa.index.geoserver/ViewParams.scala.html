<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ViewParams.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.geoserver</a> &gt; <span class="el_source">ViewParams.scala</span></div><h1>ViewParams.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.geoserver

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.Query
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.index.conf.QueryHints
import org.locationtech.geomesa.index.planning.StrategyDecider.CostEvaluation
import org.locationtech.geomesa.index.planning.StrategyDecider.CostEvaluation.CostEvaluation
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.text.{StringSerialization, WKTUtils}

import java.util.{Locale, Map =&gt; jMap}
import scala.util.Try
import scala.util.control.NonFatal

<span class="nc bnc" id="L26" title="All 4 branches missed.">object ViewParams extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L30">  private val QueryHintMap: Map[String, Hints.Key] = buildHintsMap(QueryHints)</span>
<span class="nc" id="L31">  private val AllHintsMap: Map[String, Hints.Key] = QueryHintMap ++ buildHintsMap(QueryHints.Internal)</span>
<span class="nc" id="L32">  private val AllHintsInverse: Map[Hints.Key, String] = AllHintsMap.map(_.swap)</span>

<span class="nc" id="L34">  private val envelope = &quot;&quot;&quot;\[\s*(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)\s*]&quot;&quot;&quot;.r</span>

  /**
    * Serialize hints into a string
    *
    * @param hints hints
    * @return
    */
  def serialize(hints: Hints): String = {
<span class="nc bnc" id="L43" title="All 2 branches missed.">    val map = AllHintsMap.flatMap { case (name, hint) =&gt;</span>
<span class="nc" id="L44">      Option(hints.get(hint)).flatMap {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">        case v: String             =&gt; Some(name -&gt; v)</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        case v: java.lang.Boolean  =&gt; Some(name -&gt; v.toString)</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">        case v: java.lang.Integer  =&gt; Some(name -&gt; v.toString)</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">        case v: java.lang.Float    =&gt; Some(name -&gt; v.toString)</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        case v: ReferencedEnvelope =&gt; Some(name -&gt; toString(v))</span>
<span class="nc bnc" id="L50" title="All 4 branches missed.">        case v: CostEvaluation     =&gt; Some(name -&gt; v.toString)</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">        case v: SimpleFeatureType  =&gt; Some(name -&gt; SimpleFeatureTypes.serialize(v))</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">        case _ =&gt; logger.warn(s&quot;Unhandled hint type for '$name'&quot;); None</span>
      }
    }
<span class="nc" id="L55">    StringSerialization.encodeMap(map)</span>
  }

  /**
    * Deserialize hints from a string serialized with `serialize`
    *
    * @param serialized serialized hints string
    * @return
    */
  def deserialize(serialized: String): Hints = {
<span class="nc" id="L65">    val hints = new Hints()</span>
<span class="nc" id="L66">    setHints(hints, StringSerialization.decodeMap(serialized), AllHintsMap)</span>
<span class="nc" id="L67">    hints</span>
  }

  /**
    * Examines the view parameters passed in through geoserver and sets the corresponding query hints
    * This kind of a hack, but it's the only way geoserver exposes custom data to the underlying data store.
    *
    * @param query query to examine/update
    */
  def setHints(query: Query): Unit = {
<span class="nc" id="L77">    val viewParams = query.getHints.get(Hints.VIRTUAL_TABLE_PARAMETERS).asInstanceOf[jMap[String, String]]</span>
<span class="nc" id="L78">    val params = Option(viewParams).map(_.asScala.toMap).getOrElse(Map.empty)</span>
<span class="nc" id="L79">    setHints(query.getHints, params, QueryHintMap)</span>
  }

  /**
    * Maps query hints to readable strings
    *
    * @param query query
    * @return
    */
<span class="nc" id="L88">  def getReadableHints(query: Query): java.util.Map[String, String] = getReadableHints(query.getHints)</span>

  /**
   * Maps query hints to readable strings
   *
   * @param hints hints
   * @return
   */
  def getReadableHints(hints: Hints): java.util.Map[String, String] = {
<span class="nc" id="L97">    val readable = new java.util.TreeMap[String, String]() // use tree map for consistent ordering by key</span>
<span class="nc bnc" id="L98" title="All 4 branches missed.">    hints.asScala.map { case (k: Hints.Key, v) =&gt;</span>
<span class="nc" id="L99">      val key = hintToString(k)</span>
<span class="nc" id="L100">      val value = v match {</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        case null =&gt; &quot;null&quot;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        case sft: SimpleFeatureType =&gt; SimpleFeatureTypes.encodeType(sft)</span>
<span class="nc" id="L103">        case s =&gt; s.toString</span>
      }
<span class="nc" id="L105">      readable.put(key, value)</span>
    }
<span class="nc" id="L107">    readable</span>
  }

<span class="nc" id="L110">  def hintToString(hint: Hints.Key): String = AllHintsInverse.getOrElse(hint, &quot;unknown_hint&quot;)</span>

  private def setHints(hints: Hints, params: Map[String, String], lookup: Map[String, Hints.Key]): Unit = {
<span class="nc bnc" id="L113" title="All 2 branches missed.">    params.foreach { case (original, value) =&gt;</span>
<span class="nc bnc" id="L114" title="All 6 branches missed.">      val key = if (original == &quot;STRATEGY&quot;) { &quot;QUERY_INDEX&quot; } else { original }</span>
<span class="nc" id="L115">      lookup.get(key) match {</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">        case None =&gt; logger.debug(s&quot;Ignoring view param $key=$value&quot;)</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        case Some(hint) =&gt;</span>
<span class="nc" id="L118">          try {</span>
<span class="nc" id="L119">            hint.getValueClass match {</span>
<span class="nc bnc" id="L120" title="All 6 branches missed.">              case c if c == classOf[String]             =&gt; setHint(hints, key, hint, value)</span>
<span class="nc bnc" id="L121" title="All 6 branches missed.">              case c if c == classOf[java.lang.Boolean]  =&gt; toBoolean(key, value).foreach(setHint(hints, key, hint, _))</span>
<span class="nc bnc" id="L122" title="All 6 branches missed.">              case c if c == classOf[java.lang.Integer]  =&gt; toInt(key, value).foreach(setHint(hints, key, hint, _))</span>
<span class="nc bnc" id="L123" title="All 6 branches missed.">              case c if c == classOf[java.lang.Float]    =&gt; toFloat(key, value).foreach(setHint(hints, key, hint, _))</span>
<span class="nc bnc" id="L124" title="All 6 branches missed.">              case c if c == classOf[ReferencedEnvelope] =&gt; toEnvelope(key, value).foreach(setHint(hints, key, hint, _))</span>
<span class="nc bnc" id="L125" title="All 6 branches missed.">              case c if c == classOf[CostEvaluation]     =&gt; toCost(value).foreach(setHint(hints, key, hint, _))</span>
<span class="nc bnc" id="L126" title="All 6 branches missed.">              case c if c == classOf[SimpleFeatureType]  =&gt; toFeatureType(key, value).foreach(setHint(hints, key, hint, _))</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">              case _ =&gt; logger.warn(s&quot;Unhandled hint type for '$key'&quot;)</span>
            }
          } catch {
<span class="nc bnc" id="L130" title="All 4 branches missed.">            case NonFatal(e) =&gt; logger.warn(s&quot;Error invoking query hint for $key=$value&quot;, e)</span>
          }
      }
    }
  }

  private def setHint(hints: Hints, name: String, hint: Hints.Key, value: Any): Unit = {
<span class="nc" id="L137">    val old = hints.get(hint)</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    if (old == null) {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">      logger.debug(s&quot;Using query hint from geoserver view params: $name=$value&quot;)</span>
<span class="nc" id="L140">      hints.put(hint, value)</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">    } else if (old != value) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">      logger.warn(&quot;Ignoring query hint from geoserver in favor of hint directly set in query. &quot; +</span>
<span class="nc" id="L143">          s&quot;Using $name=$old and disregarding $value&quot;)</span>
    }
  }

  private def toCost(name: String): Option[CostEvaluation] = {
<span class="nc" id="L148">    val check = name.toLowerCase(Locale.US)</span>
<span class="nc bnc" id="L149" title="All 6 branches missed.">    val value = CostEvaluation.values.find(_.toString.toLowerCase(Locale.US) == check)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">    if (value.isEmpty) {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">      logger.error(s&quot;Ignoring invalid cost type from view params: $name. Valid values &quot; +</span>
<span class="nc" id="L152">          s&quot;are ${CostEvaluation.values.mkString(&quot;, &quot;)}&quot;)</span>
    }
<span class="nc" id="L154">    value</span>
  }

  private def toString(env: ReferencedEnvelope): String =
<span class="nc" id="L158">    s&quot;[${env.getMinX},${env.getMinY},${env.getMaxX},${env.getMaxY}]&quot;</span>

  private def toEnvelope(name: String, geom: String): Option[ReferencedEnvelope] = {
    import org.locationtech.geomesa.utils.geotools.CRS_EPSG_4326

<span class="nc" id="L163">    def fromBbox: Try[ReferencedEnvelope] = Try {</span>
      // note: underlines are internal capture groups enclosed in the values we're already pulling out
<span class="nc bnc" id="L165" title="All 6 branches missed.">      val envelope(xmin, _, ymin, _, xmax, _, ymax, _) = geom</span>
<span class="nc" id="L166">      new ReferencedEnvelope(xmin.toDouble, xmax.toDouble, ymin.toDouble, ymax.toDouble, CRS_EPSG_4326)</span>
    }

    def fromWkt: Try[ReferencedEnvelope] =
<span class="nc" id="L170">      Try(new ReferencedEnvelope(WKTUtils.read(geom).getEnvelopeInternal, CRS_EPSG_4326))</span>

<span class="nc" id="L172">    val value = fromBbox.orElse(fromWkt).toOption</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">    if (value.isEmpty) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">      logger.error(s&quot;Ignoring invalid envelope from view params: $name=$geom. Envelope should be &quot; +</span>
<span class="nc" id="L175">          &quot;WKT or in the form [-180.0,-90.0,180.0,90.0]&quot;)</span>
    }
<span class="nc" id="L177">    value</span>
  }

  private def toInt(name: String, int: String): Option[Int] = {
<span class="nc" id="L181">    try { Some(int.toInt) } catch {</span>
<span class="nc bnc" id="L182" title="All 4 branches missed.">      case NonFatal(_) =&gt; logger.error(s&quot;Ignoring invalid int type from view params: $name=$int&quot;); None</span>
    }
  }

  private def toFloat(name: String, float: String): Option[Float] = {
<span class="nc" id="L187">    try { Some(float.toFloat) } catch {</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">      case NonFatal(_) =&gt; logger.error(s&quot;Ignoring invalid float type from view params: $name=$float&quot;); None</span>
    }
  }

  private def toBoolean(name: String, bool: String): Option[Boolean] = {
<span class="nc" id="L193">    try { Some(bool.toBoolean) } catch {</span>
<span class="nc bnc" id="L194" title="All 4 branches missed.">      case NonFatal(_) =&gt; logger.error(s&quot;Ignoring invalid int type from view params: $name=$bool&quot;); None</span>
    }
  }

  private def toFeatureType(name: String, sft: String): Option[SimpleFeatureType] = {
<span class="nc" id="L199">    try { Some(SimpleFeatureTypes.deserialize(sft)) } catch {</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">      case NonFatal(_) =&gt; logger.error(s&quot;Ignoring invalid simple feature type from view params: $name=$sft&quot;); None</span>
    }
  }

  private def buildHintsMap(obj: Object): Map[String, Hints.Key] = {
<span class="nc" id="L205">    val methods = obj.getClass.getDeclaredMethods.filter { m =&gt;</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">      m.getParameterCount == 0 &amp;&amp; classOf[Hints.Key].isAssignableFrom(m.getReturnType)</span>
    }
<span class="nc" id="L208">    val map = Map.newBuilder[String, Hints.Key]</span>
<span class="nc" id="L209">    map.sizeHint(methods.length)</span>
    // note: keys in the view params map are always uppercase
<span class="nc" id="L211">    methods.foreach(m =&gt; map += m.getName.toUpperCase(Locale.US) -&gt; m.invoke(obj).asInstanceOf[Hints.Key])</span>
<span class="nc" id="L212">    map.result()</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>