<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Stat.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats</a> &gt; <span class="el_source">Stat.scala</span></div><h1>Stat.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats

import com.google.gson._
import org.apache.commons.text.StringEscapeUtils
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.index.stats.impl.StatParser
import org.locationtech.geomesa.utils.geotools.GeoToolsDateFormat
import org.locationtech.geomesa.utils.text.WKTUtils
import org.locationtech.jts.geom.Geometry

import java.lang.reflect.Type
import java.lang.{Double =&gt; jDouble, Float =&gt; jFloat, Long =&gt; jLong}
import java.time.{LocalDateTime, ZoneOffset}
import java.util.Date
import scala.collection.JavaConverters._
import scala.reflect.ClassTag

/**
 * Stats used by the StatsIterator to compute various statistics server-side for a given query.
 */
<span class="nc" id="L30">trait Stat {</span>

  type S &lt;: Stat

  /**
    * The simple feature type that this stat operates on
    *
    * @return
    */
  def sft: SimpleFeatureType

  /**
   * Compute statistics based upon the given simple feature.
   * This method will be called for every SimpleFeature a query returns.
   *
   * @param sf feature to evaluate
   */
  def observe(sf: SimpleFeature): Unit

  /**
    * Tries to remove the given simple feature from the compiled statistics.
    * Note: may not be possible to un-observe a feature, in which case this method will
    * have no effect.
    *
    * @param sf feature to un-evaluate
    */
  def unobserve(sf: SimpleFeature): Unit

  /**
   * Add another stat to this stat. Avoids allocating another object.
   *
   * @param other the other stat to add
   */
  def +=(other: S): Unit

  /**
   * Non type-safe add - if stats are not the same type, will throw an exception
   *
   * @param other the other stat to add
   */
<span class="nc" id="L70">  def +=(other: Stat)(implicit d: DummyImplicit): Unit = this += other.asInstanceOf[S]</span>

  /**
    * Combine two stats into a new stat
    *
    * @param other the other stat to add
    */
  def +(other: S): S

  /**
    * Non type-safe add - if stats are not the same type, will throw an exception
    *
    * @param other the other stat to add
    */
<span class="nc" id="L84">  def +(other: Stat)(implicit d: DummyImplicit): Stat = this + other.asInstanceOf[S]</span>

  /**
   * Returns a JSON representation of the [[Stat]]
   *
   * @return stat as a json string
   */
<span class="nc" id="L91">  def toJson: String = Stat.JSON.toJson(toJsonObject)</span>

  /**
    * Returns a representation of the [[Stat]] to be serialized
    *
    * This function should return a representation (view) of the [[Stat]] to be serialized as JSON.
    * Instances of [[Map]] can be used to represent JSON dictionaries or [[Seq]] for JSON arrays.
    * A [[collection.SortedMap]] such as [[collection.immutable.ListMap]] is recommended if key order
    * should be deterministic.  Other types may be used but could require the creation and registration
    * of custom serializers dependent on the JSON framework being utilized (currently [[Gson]]).
    *
    * @return stat as a json serializable object
    */
  def toJsonObject: Any

  /**
   * Necessary method used by the StatIterator. Indicates if the stat has any values or not
   *
   * @return true if stat contains values
   */
  def isEmpty: Boolean

  /**
    * Compares the two stats for equivalence. We don't use standard 'equals' as it gets messy with
    * mutable state and hash codes
    *
    * @param other other stat to compare
    * @return true if equals
    */
  def isEquivalent(other: Stat): Boolean

  /**
   * Clears the stat to its original state when first initialized.
   * Necessary method used by the StatIterator.
   */
  def clear(): Unit
}

/**
 * This class contains parsers which dictate how to instantiate a particular Stat.
 * Stats are created by passing a stats string as a query hint (QueryHints.STATS_STRING).
 *
 * A valid stats string should adhere to the parsers here:
 * e.g. &quot;MinMax(attributeName);IteratorCount&quot; or &quot;RangeHistogram(attributeName,10,0,100)&quot;
 * (see tests for more use cases)
 */
<span class="nc" id="L137">object Stat {</span>

<span class="nc" id="L139">  private val ScalaMapSerializer = new JsonSerializer[Map[Any,Any]] {</span>
<span class="nc" id="L140">    def serialize(s: Map[Any,Any], t: Type, jsc: JsonSerializationContext): JsonElement = jsc.serialize(s.asJava)</span>
  }
<span class="nc" id="L142">  private val ScalaSeqSerializer = new JsonSerializer[Seq[Any]] {</span>
<span class="nc" id="L143">    def serialize(s: Seq[Any], t: Type, jsc: JsonSerializationContext): JsonElement = jsc.serialize(s.asJava)</span>
  }
<span class="nc" id="L145">  private val StatSerializer = new JsonSerializer[Stat] {</span>
<span class="nc" id="L146">    def serialize(s: Stat, t: Type, jsc: JsonSerializationContext): JsonElement = jsc.serialize(s.toJsonObject)</span>
  }
<span class="nc" id="L148">  private val GeometrySerializer = new JsonSerializer[Geometry] {</span>
    def serialize(g: Geometry, t: Type, jsc: JsonSerializationContext): JsonElement =
<span class="nc" id="L150">      new JsonPrimitive(WKTUtils.write(g))</span>
  }
<span class="nc" id="L152">  private val DateSerializer = new JsonSerializer[Date] {</span>
    def serialize(d: Date, t: Type, jsc: JsonSerializationContext): JsonElement =
<span class="nc" id="L154">      new JsonPrimitive(GeoToolsDateFormat.format(d.toInstant))</span>
  }
<span class="nc" id="L156">  private val DoubleSerializer = new JsonSerializer[jDouble]() {</span>
<span class="nc" id="L157">    def serialize(double: jDouble, t: Type, jsc: JsonSerializationContext): JsonElement = double match {</span>
      /* NaN check, use null to mirror existing behavior for missing/invalid values */
<span class="nc bnc" id="L159" title="All 2 branches missed.">      case d if jDouble.isNaN(d) =&gt; JsonNull.INSTANCE</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      case d if d == jDouble.NEGATIVE_INFINITY =&gt; new JsonPrimitive(&quot;Infinity&quot;)</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">      case d if d == jDouble.POSITIVE_INFINITY =&gt; new JsonPrimitive(&quot;+Infinity&quot;)</span>
<span class="nc" id="L162">      case _ =&gt; new JsonPrimitive(double)</span>
    }
  }
<span class="nc" id="L165">  private val FloatSerializer = new JsonSerializer[jFloat]() {</span>
<span class="nc" id="L166">    def serialize(float: jFloat, t: Type, jsc: JsonSerializationContext): JsonElement = float match {</span>
      /* NaN check, use null to mirror existing behavior for missing/invalid values */
<span class="nc bnc" id="L168" title="All 2 branches missed.">      case f if jFloat.isNaN(f) =&gt; JsonNull.INSTANCE</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">      case f if f == jFloat.NEGATIVE_INFINITY =&gt; new JsonPrimitive(&quot;Infinity&quot;)</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">      case f if f == jFloat.POSITIVE_INFINITY =&gt; new JsonPrimitive(&quot;+Infinity&quot;)</span>
<span class="nc" id="L171">      case _ =&gt; new JsonPrimitive(float)</span>
    }
  }

<span class="nc" id="L175">  private val JSON: Gson = new GsonBuilder()</span>
    .serializeNulls()
<span class="nc" id="L177">    .registerTypeAdapter(classOf[Double], DoubleSerializer)</span>
<span class="nc" id="L178">    .registerTypeAdapter(classOf[jDouble], DoubleSerializer)</span>
<span class="nc" id="L179">    .registerTypeAdapter(classOf[Float], FloatSerializer)</span>
<span class="nc" id="L180">    .registerTypeAdapter(classOf[jFloat], FloatSerializer)</span>
<span class="nc" id="L181">    .registerTypeHierarchyAdapter(classOf[Stat], StatSerializer)</span>
<span class="nc" id="L182">    .registerTypeHierarchyAdapter(classOf[Geometry], GeometrySerializer)</span>
<span class="nc" id="L183">    .registerTypeHierarchyAdapter(classOf[Date], DateSerializer)</span>
<span class="nc" id="L184">    .registerTypeHierarchyAdapter(classOf[Map[_,_]], ScalaMapSerializer)</span>
<span class="nc" id="L185">    .registerTypeHierarchyAdapter(classOf[Seq[_]], ScalaSeqSerializer)</span>
    .create()

<span class="nc" id="L188">  def apply(sft: SimpleFeatureType, s: String): Stat = StatParser.parse(sft, s)</span>

  /**
    * String that will be parsed to a count stat
    *
    * @return
    */
<span class="nc" id="L195">  def Count(): String = &quot;Count()&quot;</span>

  /**
    * String that will be parsed to a min/max stat
    *
    * @param attribute attribute name to min/max
    * @return
    */
<span class="nc" id="L203">  def MinMax(attribute: String): String = s&quot;MinMax(${safeString(attribute)})&quot;</span>

  /**
    * String that will be parsed to a histogram stat
    *
    * @param attribute attribute name to histogram
    * @return
    */
<span class="nc" id="L211">  def Enumeration(attribute: String): String = s&quot;Enumeration(${safeString(attribute)})&quot;</span>

  /**
    * String that will be parsed into a TopK stat
    *
    * @param attribute attribute name to evaluate
    * @return
    */
<span class="nc" id="L219">  def TopK(attribute: String): String = s&quot;TopK(${safeString(attribute)})&quot;</span>

  /**
    * String that will be parsed into a count min sketch stat
    *
    * @param attribute attribute to sketch
    * @param precision precision of the sketch - @see Frequency
    * @return
    */
  def Frequency(attribute: String, precision: Int): String =
<span class="nc" id="L229">    s&quot;Frequency(${safeString(attribute)},$precision)&quot;</span>

  /**
    * String that will be parsed into a count min sketch stat
    *
    * @param attribute attribute to sketch
    * @param dtg date attribute to use for binning
    * @param period time period to split on
    * @param precision precision of the sketch - @see Frequency
    * @return
    */
  def Frequency(attribute: String, dtg: String, period: TimePeriod, precision: Int): String =
<span class="nc" id="L241">    s&quot;Frequency(${safeString(attribute)},${safeString(dtg)},$period,$precision)&quot;</span>

  /**
    * String that will be parsed into a z3 count min sketch stat
    *
    * @param geom geometry attribute
    * @param dtg date attribute
    * @param period time period to split on
    * @param precision precision of the z value - @see FrequencyZ3
    * @return
    */
  def Z3Frequency(geom: String, dtg: String, period: TimePeriod, precision: Int): String =
<span class="nc" id="L253">    s&quot;Z3Frequency(${safeString(geom)},${safeString(dtg)},$period,$precision)&quot;</span>

  /**
    * String that will be parsed to a binned histogram stat
    *
    * @param attribute attribute name to histogram
    * @param bins the number of bins to create
    * @param min min value for the histogram
    * @param max max value for the histogram
    * @tparam T class type of the histogram attribute
    * @return
    */
  def Histogram[T](attribute: String, bins: Int, min: T, max: T)(implicit ct: ClassTag[T]): String = {
<span class="nc" id="L266">    val stringify = stringifier(ct.runtimeClass)</span>
<span class="nc" id="L267">    s&quot;Histogram(${safeString(attribute)},$bins,${safeString(stringify(min))},${safeString(stringify(max))})&quot;</span>
  }

  /**
    * String that will be parsed into a z3 range histogram stat
    *
    * @param geom geometry attribute
    * @param dtg date attribute
    * @param period time period to split on
    * @param length number of the bins per week - @see RangeHistogramZ3
    * @return
    */
  def Z3Histogram(geom: String, dtg: String, period: TimePeriod, length: Int): String =
<span class="nc" id="L280">    s&quot;Z3Histogram(${safeString(geom)},${safeString(dtg)},$period,$length)&quot;</span>

  /**
    * String that will be parsed to a iterator stack counter
    *
    * @return
    */
<span class="nc" id="L287">  def IteratorStackCount(): String = &quot;IteratorStackCount()&quot;</span>

  /**
    * String that will be parsed to a sequence of stat
    *
    * @param stats input strings that will be parsed as individual stats
    * @return
    */
<span class="nc" id="L295">  def SeqStat(stats: Seq[String]): String = stats.mkString(&quot;;&quot;)</span>

  /**
    * Groups results by attribute and runs stats for each group.
    *
    * @param attribute attribute to group stats by
    * @param groupedStat stat to apply to grouped attributes
    * @return
    */
<span class="nc" id="L304">  def GroupBy(attribute: String, groupedStat: String): String = s&quot;GroupBy(${safeString(attribute)},$groupedStat)&quot;</span>

  /**
    * String that will be parsed into a multi variate descriptive stat
    *
    * @param attributes attribute name to evaluate
    * @return
    */
<span class="nc" id="L312">  def DescriptiveStats(attributes: Seq[String]): String = s&quot;DescriptiveStats(${attributes.map(safeString).mkString(&quot;,&quot;)})&quot;</span>

  /**
    * Combines a sequence of stats. This will not modify any of the inputs.
    *
    * @param stats stats to combine
    * @return
    */
  def combine[T &lt;: Stat](stats: Seq[T]): Option[T] = {
<span class="nc bnc" id="L321" title="All 2 branches missed.">    if (stats.length &lt; 2) {</span>
<span class="nc" id="L322">      stats.headOption</span>
    } else {
      // create a new stat so that we don't modify the existing ones
<span class="nc" id="L325">      val summed = stats.head + stats.tail.head</span>
<span class="nc" id="L326">      stats.drop(2).foreach(summed += _)</span>
<span class="nc" id="L327">      Some(summed.asInstanceOf[T])</span>
    }
  }

  // note: adds quotes around the string
<span class="nc" id="L332">  private def safeString(s: String): String = s&quot;&quot;&quot;&quot;${StringEscapeUtils.escapeJava(s)}&quot;&quot;&quot;&quot;</span>

  /**
    * Converts a value to a string
    *
    * @param clas class of the input value
    * @param json will the result be used in json? will quote appropriately if so
    * @tparam T type of input
    * @return
    */
<span class="nc" id="L342">  def stringifier[T](clas: Class[T], json: Boolean = false): Any =&gt; String = {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">    val toString: Any =&gt; String = if (classOf[Geometry].isAssignableFrom(clas)) {</span>
<span class="nc" id="L344">      v =&gt; WKTUtils.write(v.asInstanceOf[Geometry])</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">    } else if (classOf[Date].isAssignableFrom(clas)) {</span>
<span class="nc" id="L346">      v =&gt; GeoToolsDateFormat.format(v.asInstanceOf[Date].toInstant)</span>
    } else {
<span class="nc" id="L348">      v =&gt; v.toString</span>
    }

    // add quotes to json strings if needed
<span class="nc bnc" id="L352" title="All 10 branches missed.">    if (json &amp;&amp; (!classOf[Number].isAssignableFrom(clas) &amp;&amp; clas != classOf[java.lang.Boolean])) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">      v =&gt; if (v == null) { &quot;null&quot; } else { s&quot;&quot;&quot;&quot;${toString(v)}&quot;&quot;&quot;&quot; }</span>
    } else {
<span class="nc bnc" id="L355" title="All 2 branches missed.">      v =&gt; if (v == null) { &quot;null&quot; } else { toString(v) }</span>
    }
  }

  /**
    * Converts a string back to a value
    *
    * @param clas class of the stringified value
    * @tparam T type of the value class
    * @return
    */
  def destringifier[T](clas: Class[T]): String =&gt; T = {
<span class="nc bnc" id="L367" title="All 6 branches missed.">    if (clas == classOf[String]) {</span>
<span class="nc bnc" id="L368" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else { s.asInstanceOf[T] }</span>
<span class="nc bnc" id="L369" title="All 6 branches missed.">    } else if (clas == classOf[Integer]) {</span>
<span class="nc bnc" id="L370" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else { s.toInt.asInstanceOf[T] }</span>
<span class="nc bnc" id="L371" title="All 6 branches missed.">    } else if (clas == classOf[jLong]) {</span>
<span class="nc bnc" id="L372" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else { s.toLong.asInstanceOf[T] }</span>
<span class="nc bnc" id="L373" title="All 6 branches missed.">    } else if (clas == classOf[jFloat]) {</span>
<span class="nc bnc" id="L374" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else { s.toFloat.asInstanceOf[T] }</span>
<span class="nc bnc" id="L375" title="All 6 branches missed.">    } else if (clas == classOf[jDouble]) {</span>
<span class="nc bnc" id="L376" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else { s.toDouble.asInstanceOf[T] }</span>
<span class="nc bnc" id="L377" title="All 6 branches missed.">    } else if (clas == classOf[java.lang.Boolean]) {</span>
<span class="nc bnc" id="L378" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else { s.toBoolean.asInstanceOf[T] }</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">    } else if (classOf[Geometry].isAssignableFrom(clas)) {</span>
<span class="nc bnc" id="L380" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else { WKTUtils.read(s).asInstanceOf[T] }</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">    } else if (classOf[Date].isAssignableFrom(clas)) {</span>
<span class="nc bnc" id="L382" title="All 6 branches missed.">      s =&gt; if (s == &quot;null&quot;) { null.asInstanceOf[T] } else {</span>
<span class="nc" id="L383">        Date.from(LocalDateTime.parse(s, GeoToolsDateFormat).toInstant(ZoneOffset.UTC)).asInstanceOf[T]</span>
      }
    } else {
<span class="nc" id="L386">      throw new RuntimeException(s&quot;Unexpected class binding for stat attribute: $clas&quot;)</span>
    }
  }

<span class="nc" id="L390">  trait ImmutableStat extends Stat {</span>
<span class="nc" id="L391">    override def observe(sf: SimpleFeature): Unit = fail()</span>
<span class="nc" id="L392">    override def unobserve(sf: SimpleFeature): Unit = fail()</span>
<span class="nc" id="L393">    override def +=(other: S): Unit = fail()</span>
<span class="nc" id="L394">    override def clear(): Unit = fail()</span>

<span class="nc" id="L396">    private def fail(): Unit = throw new RuntimeException(&quot;This stat is immutable&quot;)</span>
  }
<span class="nc" id="L398">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>