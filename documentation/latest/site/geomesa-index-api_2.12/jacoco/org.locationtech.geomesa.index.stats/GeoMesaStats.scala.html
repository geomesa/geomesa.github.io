<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaStats.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats</a> &gt; <span class="el_source">GeoMesaStats.scala</span></div><h1>GeoMesaStats.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats

import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.filter.visitor.BoundsFilterVisitor
import org.locationtech.geomesa.index.stats.GeoMesaStats.GeoMesaStatWriter
import org.locationtech.geomesa.index.stats.impl._
import org.locationtech.geomesa.utils.geotools._
import org.locationtech.jts.geom.Geometry

import java.io.{Closeable, Flushable}
import java.util.Date

/**
 * Tracks stats for a schema - spatial/temporal bounds, number of records, etc. Persistence of
 * stats is not part of this trait, as different implementations will likely have different method signatures.
 */
<span class="nc" id="L30">trait GeoMesaStats extends Closeable {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  /**
    * Gets a writer for updating stats
    *
    * @return
    */
  def writer: GeoMesaStatWriter

  /**
    * Gets the number of features that will be returned for a query. May return -1 if exact is false
    * and estimate is unavailable.
    *
    * @param sft simple feature type
    * @param filter cql filter
    * @param exact rough estimate, or precise count. note: precise count will likely be expensive.
   *  @param queryHints query hints that should be used for query execution
    * @return count of features, if available - will always be Some if exact == true
    */
<span class="nc" id="L51">  def getCount(sft: SimpleFeatureType, filter: Filter = Filter.INCLUDE, exact: Boolean = false, queryHints: Hints = new Hints()): Option[Long]</span>

  /**
    * Get the bounds for data that will be returned for a query
    *
    * @param sft simple feature type
    * @param filter cql filter
    * @param exact rough estimate, or precise bounds. note: precise bounds will likely be expensive.
    * @return bounds
    */
  def getBounds(
      sft: SimpleFeatureType,
<span class="nc" id="L63">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L64">      exact: Boolean = false): ReferencedEnvelope = {</span>
<span class="nc" id="L65">    val filterBounds = BoundsFilterVisitor.visit(filter)</span>
<span class="nc" id="L66">    Option(sft.getGeomField).flatMap(getMinMax[Geometry](sft, _, filter, exact)) match {</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">      case None =&gt; filterBounds</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">      case Some(bounds) =&gt;</span>
<span class="nc" id="L69">        val env = bounds.min.getEnvelopeInternal</span>
<span class="nc" id="L70">        env.expandToInclude(bounds.max.getEnvelopeInternal)</span>
<span class="nc" id="L71">        filterBounds.intersection(env)</span>
    }
  }

  /**
    * Get the minimum and maximum values for the given attribute
    *
    * @param sft simple feature type
    * @param attribute attribute name to examine
    * @param filter cql filter
    * @param exact rough estimate, or precise values. note: precise values will likely be expensive.
    * @tparam T attribute type - must correspond to attribute binding
    * @return mix/max values and overall cardinality. types will be consistent with the binding of the attribute
    */
  def getMinMax[T](
      sft: SimpleFeatureType,
      attribute: String,
<span class="nc" id="L88">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L89">      exact: Boolean = false): Option[MinMax[T]]</span>

  /**
    * Get an enumeration stat
    *
    * @param sft simple feature type
    * @param attribute attribute name to query
    * @param filter cql filter
    * @param exact rough estimates, or precise values. note: precise values will likely be expensive.
    * @tparam T attribute type - must correspond to attribute binding
    * @return
    */
  def getEnumeration[T](
      sft: SimpleFeatureType,
      attribute: String,
<span class="nc" id="L104">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L105">      exact: Boolean = false): Option[EnumerationStat[T]]</span>

  /**
    * Get a frequency stat
    *
    * @param sft simple feature type
    * @param attribute attribute name to query
    * @param precision precision of the estimate - @see org.locationtech.geomesa.utils.stats.Frequency
    * @param filter cql filter
    * @param exact rough estimates, or precise values. note: precise values will likely be expensive.
    * @tparam T attribute type - must correspond to attribute binding
    * @return
    */
  def getFrequency[T](
      sft: SimpleFeatureType,
      attribute: String,
      precision: Int,
<span class="nc" id="L122">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L123">      exact: Boolean = false): Option[Frequency[T]]</span>

  /**
    * Get a top k stat
    *
    * @param sft simple feature type
    * @param attribute attribute name to query
    * @param filter cql filter
    * @param exact rough estimates, or precise values. note: precise values will likely be expensive.
    * @tparam T attribute type - must correspond to attribute binding
    * @return
    */
  def getTopK[T](
      sft: SimpleFeatureType,
      attribute: String,
<span class="nc" id="L138">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L139">      exact: Boolean = false): Option[TopK[T]]</span>

  /**
    * Get a histogram stat
    *
    * @param sft simple feature type
    * @param attribute attribute name to query
    * @param bins number of buckets used to group values
    * @param min minimum value used to create the initial histogram buckets
    * @param max maximum value used to create the initial histogram buckets
    * @param filter cql filter
    * @param exact rough estimates, or precise values. note: precise values will likely be expensive.
    * @tparam T attribute type - must correspond to attribute binding
    * @return
    */
  def getHistogram[T](
      sft: SimpleFeatureType,
      attribute: String,
      bins: Int,
      min: T,
      max: T,
<span class="nc" id="L160">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L161">      exact: Boolean = false): Option[Histogram[T]]</span>

  /**
    * Get a Z3 histogram stat, where values are grouped based on combined geometry + date
    *
    * @param sft simple feature type
    * @param geom geometry attribute to query
    * @param dtg date attribute to query
    * @param period time period used to calculate bins for each value
    * @param bins number of buckets used to group values
    * @param filter cql filter
    * @param exact rough estimates, or precise values. note: precise values will likely be expensive.
    * @return
    */
  def getZ3Histogram(
      sft: SimpleFeatureType,
      geom: String,
      dtg: String,
      period: TimePeriod,
      bins: Int,
<span class="nc" id="L181">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L182">      exact: Boolean = false): Option[Z3Histogram]</span>

  /**
    * Gets arbitrary stats for multiple queries
    *
    * @param sft simple feature type
    * @param queries stats strings
    * @param filter cql filter
    * @param exact rough estimate, or precise values. note: precise values will likely be expensive.
    * @tparam T type bounds, must match stat query strings
    * @return
    */
  def getSeqStat[T &lt;: Stat](
      sft: SimpleFeatureType,
      queries: Seq[String],
<span class="nc" id="L197">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L198">      exact: Boolean = false): Seq[T] = {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    if (queries.isEmpty) {</span>
<span class="nc" id="L200">      Seq.empty</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">    } else if (queries.lengthCompare(1) == 0) {</span>
<span class="nc" id="L202">      getStat(sft, queries.head, filter, exact).toSeq</span>
    } else {
<span class="nc" id="L204">      getStat[SeqStat](sft, Stat.SeqStat(queries), filter, exact) match {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        case None    =&gt; Seq.empty</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        case Some(s) =&gt; s.stats.asInstanceOf[Seq[T]]</span>
      }
    }
  }

  /**
    * Get arbitrary stats
    *
    * @param sft simple feature type
    * @param query stats string
    * @param filter cql filter
    * @param exact rough estimate, or precise values. note: precise values will likely be expensive.
    * @tparam T type bounds, must match stat query strings
    * @return stats, if any
    */
  def getStat[T &lt;: Stat](
      sft: SimpleFeatureType,
      query: String,
<span class="nc" id="L224">      filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L225">      exact: Boolean = false): Option[T]</span>
}

<span class="nc" id="L228">object GeoMesaStats {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  // date bucket size in milliseconds for the date frequency - one day
<span class="nc" id="L233">  val DateFrequencyPrecision: Int = 1000 * 60 * 60 * 24</span>

  // how many buckets to sort each attribute into
  // max space on disk = 8 bytes * size - we use optimized serialization so likely 1-3 bytes * size
  // buckets up to ~2M values will take 3 bytes or less
<span class="nc" id="L238">  val MaxHistogramSize: Int = 10000 // with ~1B records ~100k records per bin and ~29 kb on disk</span>
<span class="nc" id="L239">  val DefaultHistogramSize: Int = 1000</span>

<span class="nc" id="L241">  val StatClasses: Seq[Class[_ &lt;: AnyRef]] =</span>
<span class="nc" id="L242">    Seq(classOf[Geometry], classOf[String], classOf[Integer], classOf[java.lang.Long],</span>
<span class="nc" id="L243">      classOf[java.lang.Float], classOf[java.lang.Double], classOf[Date])</span>

  /**
    * Get the default bounds for a range histogram
    *
    * @param binding class type
    * @tparam T class type
    * @return bounds
    */
  def defaultBounds[T](binding: Class[T]): (T, T) = {
<span class="nc" id="L253">    val default = binding match {</span>
<span class="nc bnc" id="L254" title="All 6 branches missed.">      case b if b == classOf[String]                  =&gt; &quot;&quot;</span>
<span class="nc bnc" id="L255" title="All 6 branches missed.">      case b if b == classOf[Integer]                 =&gt; 0</span>
<span class="nc bnc" id="L256" title="All 6 branches missed.">      case b if b == classOf[java.lang.Long]          =&gt; 0L</span>
<span class="nc bnc" id="L257" title="All 6 branches missed.">      case b if b == classOf[java.lang.Float]         =&gt; 0f</span>
<span class="nc bnc" id="L258" title="All 6 branches missed.">      case b if b == classOf[java.lang.Double]        =&gt; 0d</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      case b if classOf[Date].isAssignableFrom(b)     =&gt; new Date()</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      case b if classOf[Geometry].isAssignableFrom(b) =&gt; GeometryUtils.zeroPoint</span>
<span class="nc" id="L261">      case _ =&gt; throw new UnsupportedOperationException(s&quot;Can't handle binding of type $binding&quot;)</span>
    }
<span class="nc" id="L263">    Histogram.buffer(default.asInstanceOf[T])</span>
  }

  /**
    * Gets the default precision for a frequency stat
    *
    * @param binding class type
    * @return precision
    */
  def defaultPrecision(binding: Class[_]): Int = {
<span class="nc" id="L273">    binding match {</span>
<span class="nc bnc" id="L274" title="All 6 branches missed.">      case c if c == classOf[String]              =&gt; 20   // number of characters we will compare</span>
<span class="nc bnc" id="L275" title="All 6 branches missed.">      case c if c == classOf[Integer]             =&gt; 1    // size of a 'bin'</span>
<span class="nc bnc" id="L276" title="All 6 branches missed.">      case c if c == classOf[java.lang.Long]      =&gt; 1    // size of a 'bin'</span>
<span class="nc bnc" id="L277" title="All 6 branches missed.">      case c if c == classOf[java.lang.Float]     =&gt; 1000 // 10 ^ decimal places we'll keep</span>
<span class="nc bnc" id="L278" title="All 6 branches missed.">      case c if c == classOf[java.lang.Double]    =&gt; 1000 // 10 ^ decimal places we'll keep</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">      case c if classOf[Date].isAssignableFrom(c) =&gt; 1000 * 60 * 60 // size of a 'bin' - one hour</span>
<span class="nc" id="L280">      case c =&gt; throw new UnsupportedOperationException(s&quot;Can't handle binding of type $c&quot;)</span>
    }
  }

  // determines if it is possible to run a min/max and histogram on the attribute
  // TODO GEOMESA-1217 support list/maps in stats
  def okForStats(d: AttributeDescriptor): Boolean =
<span class="nc bnc" id="L287" title="All 4 branches missed.">    !d.isMultiValued &amp;&amp; StatClasses.exists(_.isAssignableFrom(d.getType.getBinding))</span>

  /**
    * Trait for writing/updating stats
    */
  trait GeoMesaStatWriter {

    /**
      * Updates the persisted stats for the given schema
      *
      * @param sft simple feature type
      */
    def analyze(sft: SimpleFeatureType): Seq[Stat]

    /**
      * Gets an object to track stats as they are written
      *
      * @param sft simple feature type
      * @return updater
      */
    def updater(sft: SimpleFeatureType): StatUpdater

    /**
      * Renames a schema and/or attributes
      *
      * @param sft simple feature type
      * @param previous old feature type to migrate
      */
    def rename(sft: SimpleFeatureType, previous: SimpleFeatureType): Unit

    /**
      * Deletes any stats associated with the given schema
      *
      * @param sft simple feature type
      */
    def clear(sft: SimpleFeatureType): Unit
  }

  /**
    * Trait for tracking stats based on simple features
    */
  trait StatUpdater extends Closeable with Flushable {
    def add(sf: SimpleFeature): Unit
    def remove(sf: SimpleFeature): Unit
  }
<span class="nc" id="L332">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>