<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatSerializer.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">StatSerializer.scala</span></div><h1>StatSerializer.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import com.clearspring.analytics.stream.cardinality.RegisterSet
import com.esotericsoftware.kryo.io.{Input, Output}
import org.ejml.data.DMatrixRMaj
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.curve.TimePeriod
import org.locationtech.geomesa.features.kryo.impl.NonMutatingInput
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.Stat.ImmutableStat
import org.locationtech.geomesa.index.stats.clearspring.{HyperLogLog, StreamSummary}
import org.locationtech.geomesa.index.stats.impl.MinMax.MinMaxDefaults
import org.locationtech.geomesa.utils.cache.{CacheKeyGenerator, SoftThreadLocal}
import org.locationtech.geomesa.utils.text.WKBUtils
import org.locationtech.jts.geom.Geometry

import java.lang.{Double =&gt; jDouble, Float =&gt; jFloat, Long =&gt; jLong}
import java.util.Date
import scala.collection.mutable.ArrayBuffer
import scala.reflect.ClassTag

/**
  * Serialize and deserialize stats
  */
<span class="nc" id="L33">trait StatSerializer {</span>
  def serialize(stat: Stat): Array[Byte]
<span class="nc" id="L35">  def deserialize(bytes: Array[Byte], immutable: Boolean = false): Stat =</span>
<span class="nc" id="L36">    deserialize(bytes, 0, bytes.length, immutable)</span>
  def deserialize(bytes: Array[Byte], offset: Int, length: Int, immutable: Boolean): Stat
}

<span class="nc" id="L40">object StatSerializer {</span>

<span class="nc" id="L42">  private val serializers = scala.collection.mutable.Map.empty[String, StatSerializer]</span>

<span class="nc" id="L44">  def apply(sft: SimpleFeatureType): StatSerializer = serializers.synchronized {</span>
<span class="nc" id="L45">    serializers.getOrElseUpdate(CacheKeyGenerator.cacheKey(sft), new KryoStatSerializer(sft))</span>
  }

  /**
    * Kryo implementation of stat serializer. Thread-safe.
    *
    * @param sft simple feature type
    */
<span class="nc" id="L53">  class KryoStatSerializer(sft: SimpleFeatureType) extends StatSerializer {</span>

    override def serialize(stat: Stat): Array[Byte] = {
<span class="nc" id="L56">      val output = KryoStatSerializer.outputs.getOrElseUpdate(new Output(1024, -1))</span>
<span class="nc" id="L57">      output.setOutputStream(null) // resets the buffer</span>
<span class="nc" id="L58">      KryoStatSerializer.write(output, sft, stat)</span>
<span class="nc" id="L59">      output.toBytes</span>
    }

    override def deserialize(bytes: Array[Byte], offset: Int, length: Int, immutable: Boolean): Stat = {
<span class="nc" id="L63">      val input = KryoStatSerializer.inputs.getOrElseUpdate(new NonMutatingInput())</span>
<span class="nc" id="L64">      input.setBuffer(bytes, offset, length)</span>
<span class="nc" id="L65">      KryoStatSerializer.read(input, sft, immutable)</span>
    }
  }

<span class="nc" id="L69">  object KryoStatSerializer {</span>

<span class="nc" id="L71">    private val inputs  = new SoftThreadLocal[Input]()</span>
<span class="nc" id="L72">    private val outputs = new SoftThreadLocal[Output]()</span>

    // bytes indicating the type of stat - currently using up to 25

<span class="nc" id="L76">    private val SeqStatByte: Byte           = 0</span>
<span class="nc" id="L77">    private val CountByte: Byte             = 1</span>
<span class="nc" id="L78">    private val IteratorStackByte: Byte     = 3</span>

<span class="nc" id="L80">    private val MinMaxByteV1: Byte          = 2</span>
<span class="nc" id="L81">    private val MinMaxByteV2: Byte          = 16</span>
<span class="nc" id="L82">    private val MinMaxByte: Byte            = 25</span>

<span class="nc" id="L84">    private val EnumerationByteV1: Byte     = 4</span>
<span class="nc" id="L85">    private val EnumerationByte: Byte       = 17</span>

<span class="nc" id="L87">    private val HistogramByteV1: Byte       = 5</span>
<span class="nc" id="L88">    private val HistogramByte: Byte         = 18</span>

<span class="nc" id="L90">    private val FrequencyByteV1: Byte       = 6</span>
<span class="nc" id="L91">    private val FrequencyByteV2: Byte       = 10</span>
<span class="nc" id="L92">    private val FrequencyByte: Byte         = 19</span>

<span class="nc" id="L94">    private val Z3HistogramByteV1: Byte     = 7</span>
<span class="nc" id="L95">    private val Z3HistogramByteV2: Byte     = 11</span>
<span class="nc" id="L96">    private val Z3HistogramByte: Byte       = 20</span>

<span class="nc" id="L98">    private val Z3FrequencyByteV1: Byte     = 8</span>
<span class="nc" id="L99">    private val Z3FrequencyByteV2: Byte     = 12</span>
<span class="nc" id="L100">    private val Z3FrequencyByte: Byte       = 21</span>

<span class="nc" id="L102">    private val DescriptiveStatByteV1: Byte = 13</span>
<span class="nc" id="L103">    private val DescriptiveStatByte: Byte   = 22</span>

<span class="nc" id="L105">    private val GroupByByteV1: Byte         = 14</span>
<span class="nc" id="L106">    private val GroupByByte: Byte           = 23</span>

<span class="nc" id="L108">    private val TopKByteV1: Byte            = 9</span>
<span class="nc" id="L109">    private val TopKByteV2: Byte            = 15</span>
<span class="nc" id="L110">    private val TopKByte: Byte              = 24</span>

    private def write(output: Output, sft: SimpleFeatureType, stat: Stat): Unit = {
<span class="nc" id="L113">      stat match {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        case s: CountStat           =&gt; output.writeByte(CountByte);           writeCount(output, s)</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        case s: MinMax[_]           =&gt; output.writeByte(MinMaxByte);          writeMinMax(output, sft, s)</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        case s: EnumerationStat[_]  =&gt; output.writeByte(EnumerationByte);     writeEnumeration(output, sft, s)</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        case s: TopK[_]             =&gt; output.writeByte(TopKByte);            writeTopK(output, sft, s)</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        case s: Histogram[_]        =&gt; output.writeByte(HistogramByte);       writeHistogram(output, sft, s)</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        case s: Frequency[_]        =&gt; output.writeByte(FrequencyByte);       writeFrequency(output, sft, s)</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        case s: Z3Histogram         =&gt; output.writeByte(Z3HistogramByte);     writeZ3Histogram(output, sft, s)</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        case s: Z3Frequency         =&gt; output.writeByte(Z3FrequencyByte);     writeZ3Frequency(output, sft, s)</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        case s: IteratorStackCount  =&gt; output.writeByte(IteratorStackByte);   writeIteratorStackCount(output, s)</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        case s: SeqStat             =&gt; output.writeByte(SeqStatByte);         writeSeqStat(output, sft, s)</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        case s: DescriptiveStats    =&gt; output.writeByte(DescriptiveStatByte); writeDescriptiveStats(output, sft, s)</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        case s: GroupBy[_]          =&gt; output.writeByte(GroupByByte);         writeGroupBy(output, sft, s)</span>
<span class="nc" id="L126">        case _ =&gt; throw new UnsupportedOperationException(s&quot;Unhandled stat $stat&quot;)</span>
      }
    }

    private def read(input: Input, sft: SimpleFeatureType, immutable: Boolean): Stat = {
<span class="nc" id="L131">      input.readByte() match {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        case CountByte             =&gt; readCount(input, sft, immutable)</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        case MinMaxByte            =&gt; readMinMax(input, sft, immutable, 3)</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        case EnumerationByte       =&gt; readEnumeration(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        case TopKByte              =&gt; readTopK(input, sft, immutable, 3)</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        case HistogramByte         =&gt; readHistogram(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        case FrequencyByte         =&gt; readFrequency(input, sft, immutable, 3)</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        case Z3HistogramByte       =&gt; readZ3Histogram(input, sft, immutable, 3)</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        case Z3FrequencyByte       =&gt; readZ3Frequency(input, sft, immutable, 3)</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        case IteratorStackByte     =&gt; readIteratorStackCount(input, sft, immutable)</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        case SeqStatByte           =&gt; readSeqStat(input, sft, immutable)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        case DescriptiveStatByte   =&gt; readDescriptiveStat(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">        case GroupByByte           =&gt; readGroupBy(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        case EnumerationByteV1     =&gt; readEnumeration(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        case HistogramByteV1       =&gt; readHistogram(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        case FrequencyByteV2       =&gt; readFrequency(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        case Z3HistogramByteV2     =&gt; readZ3Histogram(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        case Z3FrequencyByteV2     =&gt; readZ3Frequency(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        case DescriptiveStatByteV1 =&gt; readDescriptiveStat(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        case GroupByByteV1         =&gt; readGroupBy(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        case TopKByteV2            =&gt; readTopK(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        case MinMaxByteV2          =&gt; readMinMax(input, sft, immutable, 2)</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        case FrequencyByteV1       =&gt; readFrequency(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        case Z3HistogramByteV1     =&gt; readZ3Histogram(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        case Z3FrequencyByteV1     =&gt; readZ3Frequency(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        case MinMaxByteV1          =&gt; readMinMax(input, sft, immutable, 1)</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        case TopKByteV1            =&gt; readTopK(input, sft, immutable, 1)</span>
<span class="nc" id="L158">        case _ =&gt; throw new RuntimeException(&quot;Trying to read malformed or invalid serialized stat&quot;)</span>
      }
    }

    private def writeGroupBy(output: Output, sft: SimpleFeatureType, stat: GroupBy[_]): Unit = {
<span class="nc" id="L163">      output.writeAscii(stat.property)</span>
<span class="nc" id="L164">      output.writeString(stat.stat)</span>
<span class="nc" id="L165">      output.writeInt(stat.groups.keys.size, true)</span>
<span class="nc" id="L166">      val keyWriter = writer(output, sft.getDescriptor(stat.property).getType.getBinding)</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">      stat.groups.foreach { case (key, groupedStat) =&gt;</span>
<span class="nc" id="L168">        keyWriter(key)</span>
<span class="nc" id="L169">        write(output, sft, groupedStat)</span>
      }
    }

    private def readGroupBy(input: Input, sft: SimpleFeatureType, immutable: Boolean, version: Int): GroupBy[_] = {
<span class="nc bnc" id="L174" title="All 3 branches missed.">      val attribute = version match {</span>
<span class="nc" id="L175">        case 2 =&gt; input.readString</span>
<span class="nc" id="L176">        case 1 =&gt; sft.getDescriptor(input.readInt(true)).getLocalName</span>
<span class="nc" id="L177">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid group by serialization version: $version&quot;)</span>
      }
<span class="nc" id="L179">      val exampleStat = input.readString()</span>
<span class="nc" id="L180">      val keyLength   = input.readInt(true)</span>

<span class="nc" id="L182">      val classTag = ClassTag[Any](sft.getDescriptor(attribute).getType.getBinding)</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L184">        new GroupBy(sft, attribute, exampleStat)(classTag) with ImmutableStat</span>
      } else {
<span class="nc" id="L186">        new GroupBy(sft, attribute, exampleStat)(classTag)</span>
      }

<span class="nc" id="L189">      val keyReader = reader(input, sft.getDescriptor(attribute).getType.getBinding)</span>

<span class="nc" id="L191">      var i = 0</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">      while (i &lt; keyLength) {</span>
<span class="nc" id="L193">        val key = keyReader.apply()</span>
<span class="nc" id="L194">        val groupedStat = read(input, sft, immutable)</span>
<span class="nc" id="L195">        stat.groups.put(key, groupedStat)</span>
<span class="nc" id="L196">        i += 1</span>
      }
<span class="nc" id="L198">      stat</span>
    }

    private def writeDescriptiveStats(output: Output, sft: SimpleFeatureType, stat: DescriptiveStats): Unit = {
<span class="nc" id="L202">      output.writeInt(stat.properties.size, true)</span>
<span class="nc" id="L203">      stat.properties.foreach(output.writeAscii)</span>

<span class="nc" id="L205">      def writeArray(array: Array[Double]): Unit = for(v &lt;- array) { output.writeDouble(v) }</span>

<span class="nc" id="L207">      writeArray(stat._min.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L208">      writeArray(stat._max.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L209">      writeArray(stat._sum.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L210">      writeArray(stat._mean.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L211">      writeArray(stat._m2n.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L212">      writeArray(stat._m3n.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L213">      writeArray(stat._m4n.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L214">      writeArray(stat._c2.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>

<span class="nc" id="L216">      output.writeLong(stat._count, true)</span>
    }

    private def readDescriptiveStat(input: Input,
                                    sft: SimpleFeatureType,
                                    immutable: Boolean,
                                    version: Int): DescriptiveStats = {
<span class="nc" id="L223">      val size = input.readInt(true)</span>
<span class="nc bnc" id="L224" title="All 3 branches missed.">      val attributes = version match {</span>
<span class="nc" id="L225">        case 2 =&gt; Seq.fill(size)(input.readString)</span>
<span class="nc" id="L226">        case 1 =&gt; Seq.fill(size)(sft.getDescriptor(input.readInt(true)).getLocalName)</span>
<span class="nc" id="L227">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid descriptive stats serialization version: $version&quot;)</span>
      }

<span class="nc bnc" id="L230" title="All 2 branches missed.">      val stats = if (immutable) {</span>
<span class="nc" id="L231">        new DescriptiveStats(sft, attributes) with ImmutableStat</span>
      } else {
<span class="nc" id="L233">        new DescriptiveStats(sft, attributes)</span>
      }

<span class="nc" id="L236">      def readArray(array: Array[Double]): Unit = for(i &lt;- array.indices) { array(i) = input.readDouble }</span>

<span class="nc" id="L238">      readArray(stats._min.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L239">      readArray(stats._max.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L240">      readArray(stats._sum.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L241">      readArray(stats._mean.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L242">      readArray(stats._m2n.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L243">      readArray(stats._m3n.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L244">      readArray(stats._m4n.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>
<span class="nc" id="L245">      readArray(stats._c2.getMatrix.asInstanceOf[DMatrixRMaj].data)</span>

<span class="nc" id="L247">      stats._count = input.readLong(true)</span>

<span class="nc" id="L249">      stats</span>
    }

    private def writeSeqStat(output: Output, sft: SimpleFeatureType, stat: SeqStat): Unit =
<span class="nc" id="L253">      stat.stats.foreach(write(output, sft, _))</span>

    private def readSeqStat(input: Input, sft: SimpleFeatureType, immutable: Boolean): SeqStat = {
<span class="nc" id="L256">      val stats = ArrayBuffer.empty[Stat]</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      while (input.available() &gt; 0) {</span>
<span class="nc" id="L258">        stats.append(read(input, sft, immutable))</span>
      }
<span class="nc bnc" id="L260" title="All 2 branches missed.">      if (immutable) {</span>
<span class="nc" id="L261">        new SeqStat(sft, stats.toSeq) with ImmutableStat</span>
      } else {
<span class="nc" id="L263">        new SeqStat(sft, stats.toSeq)</span>
      }
    }

<span class="nc" id="L267">    private def writeCount(output: Output, stat: CountStat): Unit = output.writeLong(stat.counter, true)</span>

    private def readCount(input: Input, sft: SimpleFeatureType, immutable: Boolean): CountStat = {
<span class="nc bnc" id="L270" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L271">        new CountStat(sft) with ImmutableStat</span>
      } else {
<span class="nc" id="L273">        new CountStat(sft)</span>
      }
<span class="nc" id="L275">      stat.counter = input.readLong(true)</span>
<span class="nc" id="L276">      stat</span>
    }

    private def writeMinMax(output: Output, sft: SimpleFeatureType, stat: MinMax[_]): Unit = {
<span class="nc" id="L280">      output.writeAscii(stat.property)</span>
<span class="nc" id="L281">      output.writeInt(stat.hpp.log2m, true)</span>
<span class="nc" id="L282">      output.writeInt(stat.hpp.registerSet.size, true)</span>
<span class="nc" id="L283">      stat.hpp.registerSet.rawBits.foreach(output.writeInt)</span>

<span class="nc" id="L285">      val write = writer(output, sft.getDescriptor(stat.property).getType.getBinding)</span>
<span class="nc" id="L286">      write(stat.minValue)</span>
<span class="nc" id="L287">      write(stat.maxValue)</span>
    }

    private def readMinMax(input: Input, sft: SimpleFeatureType, immutable: Boolean, version: Int): MinMax[_] = {
<span class="nc bnc" id="L291" title="All 3 branches missed.">      val attribute = version match {</span>
<span class="nc" id="L292">        case 3     =&gt; input.readString()</span>
<span class="nc" id="L293">        case 1 | 2 =&gt; sft.getDescriptor(input.readInt(true)).getLocalName</span>
<span class="nc" id="L294">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid min/max serialization version: $version&quot;)</span>
      }
<span class="nc bnc" id="L296" title="All 2 branches missed.">      val hpp = if (version &gt; 1) {</span>
<span class="nc" id="L297">        val log2m = input.readInt(true)</span>
<span class="nc" id="L298">        val size = input.readInt(true)</span>
<span class="nc" id="L299">        val bytes = Array.fill(size)(input.readInt)</span>
<span class="nc" id="L300">        HyperLogLog(log2m, bytes)</span>
      } else {
<span class="nc" id="L302">        val hppBytes = Array.ofDim[Byte](input.readInt(true))</span>
<span class="nc" id="L303">        input.read(hppBytes)</span>
<span class="nc" id="L304">        val clearspring = com.clearspring.analytics.stream.cardinality.HyperLogLog.Builder.build(hppBytes)</span>
        // use reflection to access private variables
        def getField[T](name: String): T = {
<span class="nc" id="L307">          val field = clearspring.getClass.getDeclaredField(name)</span>
<span class="nc" id="L308">          field.setAccessible(true)</span>
<span class="nc" id="L309">          field.get(clearspring).asInstanceOf[T]</span>
        }
<span class="nc" id="L311">        val log2m = getField[Int](&quot;log2m&quot;)</span>
<span class="nc" id="L312">        val registerSet = getField[RegisterSet](&quot;registerSet&quot;).bits</span>
<span class="nc" id="L313">        HyperLogLog(log2m, registerSet)</span>
      }

<span class="nc" id="L316">      val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L317">      val read = reader(input, binding)</span>
<span class="nc" id="L318">      val min = read()</span>
<span class="nc" id="L319">      val max = read()</span>

<span class="nc" id="L321">      val defaults = MinMaxDefaults[Any](binding)</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (immutable) {</span>
<span class="nc" id="L324">        new MinMax[Any](sft, attribute, min, max, hpp)(defaults) with ImmutableStat</span>
      } else {
<span class="nc" id="L326">        new MinMax[Any](sft, attribute, min, max, hpp)(defaults)</span>
      }
    }

    private def writeEnumeration(output: Output, sft: SimpleFeatureType, stat: EnumerationStat[_]): Unit = {
<span class="nc" id="L331">      output.writeAscii(stat.property)</span>
<span class="nc" id="L332">      output.writeInt(stat.enumeration.size, true)</span>

<span class="nc" id="L334">      val write = writer(output, sft.getDescriptor(stat.property).getType.getBinding)</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">      stat.enumeration.foreach { case (key, count) =&gt; write(key); output.writeLong(count, true) }</span>
    }

    private def readEnumeration(input: Input,
                                sft: SimpleFeatureType,
                                immutable: Boolean,
                                version: Int): EnumerationStat[_] = {
<span class="nc bnc" id="L342" title="All 3 branches missed.">      val attribute = version match {</span>
<span class="nc" id="L343">        case 2 =&gt; input.readString</span>
<span class="nc" id="L344">        case 1 =&gt; sft.getDescriptor(input.readInt(true)).getLocalName</span>
<span class="nc" id="L345">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid group by serialization version: $version&quot;)</span>
      }
<span class="nc" id="L347">      val size = input.readInt(true)</span>

<span class="nc" id="L349">      val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L350">      val read = reader(input, binding)</span>

<span class="nc" id="L352">      val classTag = ClassTag[Any](binding)</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L354">        new EnumerationStat[Any](sft, attribute)(classTag) with ImmutableStat</span>
      } else {
<span class="nc" id="L356">        new EnumerationStat[Any](sft, attribute)(classTag)</span>
      }

<span class="nc" id="L359">      var i = 0</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">      while (i &lt; size) {</span>
<span class="nc" id="L361">        stat.enumeration(read()) = input.readLong(true)</span>
<span class="nc" id="L362">        i += 1</span>
      }

<span class="nc" id="L365">      stat</span>
    }

    private def writeTopK(output: Output, sft: SimpleFeatureType, stat: TopK[_]): Unit = {
<span class="nc" id="L369">      output.writeAscii(stat.property)</span>
<span class="nc" id="L370">      output.writeInt(stat.size, true)</span>

<span class="nc" id="L372">      val write = writer(output, sft.getDescriptor(stat.property).getType.getBinding)</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">      stat.topK(Int.MaxValue).foreach { case (item, count) =&gt; write(item); output.writeLong(count, true) }</span>
    }

    private def readTopK(input: Input, sft: SimpleFeatureType, immutable: Boolean, version: Int): TopK[_] = {
<span class="nc bnc" id="L378" title="All 3 branches missed.">      val attribute = version match {</span>
<span class="nc" id="L379">        case 3     =&gt; input.readString()</span>
<span class="nc" id="L380">        case 1 | 2 =&gt; sft.getDescriptor(input.readInt(true)).getLocalName</span>
<span class="nc" id="L381">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid top-k serialization version: $version&quot;)</span>
      }
<span class="nc" id="L383">      val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L384">      val read = reader(input, binding)</span>

<span class="nc bnc" id="L386" title="All 2 branches missed.">      val summary = if (version &gt; 1) {</span>
<span class="nc" id="L387">        val size = input.readInt(true)</span>
<span class="nc" id="L388">        val counters = (0 until size).map(_ =&gt; (read(), input.readLong(true)))</span>
<span class="nc" id="L389">        StreamSummary[Any](TopK.StreamCapacity, counters)</span>
      } else {
        import scala.collection.JavaConverters._
<span class="nc" id="L392">        val summaryBytes = input.readBytes(input.readInt(true))</span>
<span class="nc" id="L393">        val clearspring = new com.clearspring.analytics.stream.StreamSummary[Any](summaryBytes)</span>
<span class="nc" id="L394">        val geomesa = StreamSummary[Any](TopK.StreamCapacity)</span>
<span class="nc" id="L395">        clearspring.topK(clearspring.size()).asScala.foreach(c =&gt; geomesa.offer(c.getItem, c.getCount))</span>
<span class="nc" id="L396">        geomesa</span>
      }

<span class="nc bnc" id="L399" title="All 2 branches missed.">      if (immutable) {</span>
<span class="nc" id="L400">        new TopK[Any](sft, attribute, summary) with ImmutableStat</span>
      } else {
<span class="nc" id="L402">        new TopK[Any](sft, attribute, summary)</span>
      }
    }

    private def writeHistogram(output: Output, sft: SimpleFeatureType, stat: Histogram[_]): Unit = {
<span class="nc" id="L407">      output.writeAscii(stat.property)</span>
<span class="nc" id="L408">      output.writeInt(stat.length, true)</span>

<span class="nc" id="L410">      val write = writer(output, sft.getDescriptor(stat.property).getType.getBinding)</span>
<span class="nc" id="L411">      write(stat.bounds._1)</span>
<span class="nc" id="L412">      write(stat.bounds._2)</span>

<span class="nc" id="L414">      writeCountArray(output, stat.bins.counts)</span>
    }

    private def readHistogram(input: Input, sft: SimpleFeatureType, immutable: Boolean, version: Int): Histogram[_] = {
<span class="nc bnc" id="L418" title="All 3 branches missed.">      val attribute = version match {</span>
<span class="nc" id="L419">        case 2 =&gt; input.readString</span>
<span class="nc" id="L420">        case 1 =&gt; sft.getDescriptor(input.readInt(true)).getLocalName</span>
<span class="nc" id="L421">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid group by serialization version: $version&quot;)</span>
      }
<span class="nc" id="L423">      val length = input.readInt(true)</span>

<span class="nc" id="L425">      val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L426">      val read = reader(input, binding)</span>

<span class="nc" id="L428">      val min = read()</span>
<span class="nc" id="L429">      val max = read()</span>

<span class="nc" id="L431">      val defaults = MinMaxDefaults[Any](binding)</span>
<span class="nc" id="L432">      val classTag = ClassTag[Any](binding)</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L434">        new Histogram[Any](sft, attribute, length, (min, max))(defaults, classTag) with ImmutableStat</span>
      } else {
<span class="nc" id="L436">        new Histogram[Any](sft, attribute, length, (min, max))(defaults, classTag)</span>
      }

<span class="nc" id="L439">      readCountArray(input, stat.bins.counts)</span>

<span class="nc" id="L441">      stat</span>
    }

    private def writeZ3Histogram(output: Output, sft: SimpleFeatureType, stat: Z3Histogram): Unit = {
<span class="nc" id="L445">      output.writeAscii(stat.geom)</span>
<span class="nc" id="L446">      output.writeAscii(stat.dtg)</span>
<span class="nc" id="L447">      output.writeAscii(stat.period.toString)</span>
<span class="nc" id="L448">      output.writeInt(stat.length, true)</span>

<span class="nc bnc" id="L450" title="All 2 branches missed.">      val bins = stat.binMap.filter(_._2.counts.exists(_ != 0L))</span>

<span class="nc" id="L452">      output.writeInt(bins.size, true)</span>

<span class="nc bnc" id="L454" title="All 2 branches missed.">      bins.foreach { case (w, bin) =&gt;</span>
<span class="nc" id="L455">        output.writeShort(w)</span>
<span class="nc" id="L456">        writeCountArray(output, bin.counts)</span>
      }
    }

    private def readZ3Histogram(input: Input, sft: SimpleFeatureType, immutable: Boolean, version: Int): Z3Histogram = {
<span class="nc bnc" id="L461" title="All 9 branches missed.">      val Seq(geom, dtg) = version match {</span>
<span class="nc" id="L462">        case 3     =&gt; Seq.fill(2)(input.readString())</span>
<span class="nc" id="L463">        case 1 | 2 =&gt; Seq.fill(2)(sft.getDescriptor(input.readInt(true)).getLocalName)</span>
<span class="nc" id="L464">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid z3 histogram serialization version: $version&quot;)</span>
      }
<span class="nc bnc" id="L466" title="All 2 branches missed.">      val period = if (version &gt; 1) { TimePeriod.withName(input.readString()) } else { TimePeriod.Week }</span>
<span class="nc" id="L467">      val length = input.readInt(true)</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L470">        new Z3Histogram(sft, geom, dtg, period, length) with ImmutableStat</span>
      } else {
<span class="nc" id="L472">        new Z3Histogram(sft, geom, dtg, period, length)</span>
      }

<span class="nc" id="L475">      val numWeeks = input.readInt(true)</span>
<span class="nc" id="L476">      var week = 0</span>

<span class="nc bnc" id="L478" title="All 2 branches missed.">      while (week &lt; numWeeks) {</span>
<span class="nc" id="L479">        val bins = stat.newBins</span>
<span class="nc" id="L480">        stat.binMap.put(input.readShort, bins)</span>
<span class="nc" id="L481">        readCountArray(input, bins.counts)</span>
<span class="nc" id="L482">        week += 1</span>
      }

<span class="nc" id="L485">      stat</span>
    }

    private def writeFrequency(output: Output, sft: SimpleFeatureType, stat: Frequency[_]): Unit = {
<span class="nc" id="L489">      output.writeAscii(stat.property)</span>
<span class="nc" id="L490">      output.writeAscii(stat.dtg.orNull)</span>
<span class="nc" id="L491">      output.writeAscii(stat.period.toString)</span>
<span class="nc" id="L492">      output.writeInt(stat.precision, true)</span>
<span class="nc" id="L493">      output.writeDouble(stat.eps)</span>
<span class="nc" id="L494">      output.writeDouble(stat.confidence)</span>

<span class="nc bnc" id="L496" title="All 2 branches missed.">      val sketches = stat.sketchMap.filter(_._2.size &gt; 0)</span>
<span class="nc" id="L497">      output.writeInt(sketches.size, true)</span>

<span class="nc bnc" id="L499" title="All 2 branches missed.">      sketches.foreach { case (w, sketch) =&gt;</span>
<span class="nc" id="L500">        output.writeShort(w)</span>
<span class="nc" id="L501">        var i = 0</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        while (i &lt; sketch.table.length) {</span>
<span class="nc" id="L503">          writeCountArray(output, sketch.table(i))</span>
<span class="nc" id="L504">          i += 1</span>
        }
<span class="nc" id="L506">        output.writeLong(sketch.size, true)</span>
      }
    }

    private def readFrequency(input: Input, sft: SimpleFeatureType, immutable: Boolean, version: Int): Frequency[_] = {
<span class="nc" id="L511">      def name(i: Int): String = sft.getDescriptor(i).getLocalName</span>
<span class="nc bnc" id="L512" title="All 5 branches missed.">      val (attribute, dtg) = version match {</span>
<span class="nc" id="L513">        case 3     =&gt; (input.readString(), Option(input.readString()))</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">        case 1 | 2 =&gt; (name(input.readInt(true)), Some(input.readInt(true)).filter(_ != -1).map(name))</span>
<span class="nc" id="L515">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid frequency serialization version: $version&quot;)</span>
      }
<span class="nc bnc" id="L517" title="All 2 branches missed.">      val period = if (version &gt; 1) { TimePeriod.withName(input.readString()) } else { TimePeriod.Week }</span>
<span class="nc" id="L518">      val precision = input.readInt(true)</span>
<span class="nc" id="L519">      val eps = input.readDouble()</span>
<span class="nc" id="L520">      val confidence = input.readDouble()</span>

<span class="nc" id="L522">      val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L524">        new Frequency[Any](sft, attribute, dtg, period, precision, eps, confidence)(ClassTag[Any](binding)) with ImmutableStat</span>
      } else {
<span class="nc" id="L526">        new Frequency[Any](sft, attribute, dtg, period, precision, eps, confidence)(ClassTag[Any](binding))</span>
      }

<span class="nc" id="L529">      val sketchCount = input.readInt(true)</span>
<span class="nc" id="L530">      var c = 0</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">      while (c &lt; sketchCount) {</span>
<span class="nc" id="L532">        val week = input.readShort</span>
<span class="nc" id="L533">        val sketch = stat.newSketch</span>
<span class="nc" id="L534">        stat.sketchMap.put(week, sketch)</span>
<span class="nc" id="L535">        var i = 0</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        while (i &lt; sketch.table.length) {</span>
<span class="nc" id="L537">          readCountArray(input, sketch.table(i))</span>
<span class="nc" id="L538">          i += 1</span>
        }
<span class="nc" id="L540">        sketch._size = input.readLong(true)</span>
<span class="nc" id="L541">        c += 1</span>
      }

<span class="nc" id="L544">      stat</span>
    }

    private def writeZ3Frequency(output: Output, sft: SimpleFeatureType, stat: Z3Frequency): Unit = {
<span class="nc" id="L548">      output.writeAscii(stat.geom)</span>
<span class="nc" id="L549">      output.writeAscii(stat.dtg)</span>
<span class="nc" id="L550">      output.writeAscii(stat.period.toString)</span>
<span class="nc" id="L551">      output.writeInt(stat.precision, true)</span>
<span class="nc" id="L552">      output.writeDouble(stat.eps)</span>
<span class="nc" id="L553">      output.writeDouble(stat.confidence)</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">      val sketches = stat.sketches.filter(_._2.size &gt; 0)</span>
<span class="nc" id="L556">      output.writeInt(sketches.size, true)</span>

<span class="nc bnc" id="L558" title="All 2 branches missed.">      sketches.foreach { case (w, sketch) =&gt;</span>
<span class="nc" id="L559">        output.writeShort(w)</span>
<span class="nc" id="L560">        var i = 0</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        while (i &lt; sketch.table.length) {</span>
<span class="nc" id="L562">          writeCountArray(output, sketch.table(i))</span>
<span class="nc" id="L563">          i += 1</span>
        }

<span class="nc" id="L566">        output.writeLong(sketch.size, true)</span>
      }
    }

    private def readZ3Frequency(input: Input, sft: SimpleFeatureType, immutable: Boolean, version: Int): Z3Frequency = {
<span class="nc bnc" id="L571" title="All 9 branches missed.">      val Seq(geom, dtg) = version match {</span>
<span class="nc" id="L572">        case 3     =&gt; Seq.fill(2)(input.readString())</span>
<span class="nc" id="L573">        case 1 | 2 =&gt; Seq.fill(2)(sft.getDescriptor(input.readInt(true)).getLocalName)</span>
<span class="nc" id="L574">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid frequency serialization version: $version&quot;)</span>
      }
<span class="nc bnc" id="L576" title="All 2 branches missed.">      val period = if (version &gt; 1) { TimePeriod.withName(input.readString()) } else { TimePeriod.Week }</span>
<span class="nc" id="L577">      val precision = input.readInt(true)</span>
<span class="nc" id="L578">      val eps = input.readDouble()</span>
<span class="nc" id="L579">      val confidence = input.readDouble()</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L582">        new Z3Frequency(sft, geom, dtg, period, precision, eps, confidence) with ImmutableStat</span>
      } else {
<span class="nc" id="L584">        new Z3Frequency(sft, geom, dtg, period, precision, eps, confidence)</span>
      }

<span class="nc" id="L587">      val numSketches = input.readInt(true)</span>
<span class="nc" id="L588">      var sketchCount = 0</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">      while (sketchCount &lt; numSketches) {</span>
<span class="nc" id="L591">        val sketch = stat.newSketch</span>
<span class="nc" id="L592">        stat.sketches.put(input.readShort, sketch)</span>
<span class="nc" id="L593">        var i = 0</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        while (i &lt; sketch.table.length) {</span>
<span class="nc" id="L595">          readCountArray(input, sketch.table(i))</span>
<span class="nc" id="L596">          i += 1</span>
        }

<span class="nc" id="L599">        sketch._size = input.readLong(true)</span>

<span class="nc" id="L601">        sketchCount += 1</span>
      }

<span class="nc" id="L604">      stat</span>
    }

    private def writeIteratorStackCount(output: Output, stat: IteratorStackCount): Unit =
<span class="nc" id="L608">      output.writeLong(stat.counter, true)</span>

    private def readIteratorStackCount(input: Input, sft: SimpleFeatureType, immutable: Boolean): IteratorStackCount = {
<span class="nc bnc" id="L611" title="All 2 branches missed.">      val stat = if (immutable) {</span>
<span class="nc" id="L612">        new IteratorStackCount(sft) with ImmutableStat</span>
      } else {
<span class="nc" id="L614">        new IteratorStackCount(sft)</span>
      }
<span class="nc" id="L616">      stat.counter = input.readLong(true)</span>
<span class="nc" id="L617">      stat</span>
    }

    private def writeCountArray(output: Output, counts: Array[Long]): Unit = {
<span class="nc" id="L621">      var i = 0</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">      while (i &lt; counts.length) {</span>
<span class="nc" id="L623">        val count = counts(i)</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L625">          var nextNonZero = i + 1</span>
<span class="nc bnc" id="L626" title="All 4 branches missed.">          while (nextNonZero &lt; counts.length &amp;&amp; counts(nextNonZero) == 0) {</span>
<span class="nc" id="L627">            nextNonZero += 1</span>
          }
<span class="nc" id="L629">          val numZeros = nextNonZero - i</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">          if (numZeros &gt; 4) {</span>
            // write a max long as an indicator that we have sparse values, then write the number of zeros
<span class="nc" id="L632">            output.writeLong(Long.MaxValue, true)</span>
<span class="nc" id="L633">            output.writeInt(numZeros, true)</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">          } else if (numZeros &gt; 0) {</span>
<span class="nc" id="L635">            (0 until numZeros).foreach(_ =&gt; output.writeLong(0L, true))</span>
          }
<span class="nc" id="L637">          i = nextNonZero</span>
        } else {
<span class="nc" id="L639">          output.writeLong(count, true)</span>
<span class="nc" id="L640">          i += 1</span>
        }
      }
    }

    private def readCountArray(input: Input, counts: Array[Long]): Unit = {
<span class="nc" id="L646">      var i = 0</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">      while (i &lt; counts.length) {</span>
<span class="nc" id="L648">        val count = input.readLong(true)</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">        if (count == Long.MaxValue) {</span>
<span class="nc" id="L650">          i += input.readInt(true) // skip sparsely written values</span>
        } else {
<span class="nc" id="L652">          counts(i) = count</span>
<span class="nc" id="L653">          i += 1</span>
        }
      }
    }

    private def writer(output: Output, binding: Class[_]): Any =&gt; Unit = {
<span class="nc bnc" id="L659" title="All 6 branches missed.">      if (binding == classOf[String]) {</span>
<span class="nc" id="L660">        value =&gt; output.writeString(value.asInstanceOf[String])</span>
<span class="nc bnc" id="L661" title="All 6 branches missed.">      } else if (binding == classOf[Integer]) {</span>
<span class="nc" id="L662">        value =&gt; output.writeInt(value.asInstanceOf[Integer], true)</span>
<span class="nc bnc" id="L663" title="All 6 branches missed.">      } else if (binding == classOf[jLong]) {</span>
<span class="nc" id="L664">        value =&gt; output.writeLong(value.asInstanceOf[jLong], true)</span>
<span class="nc bnc" id="L665" title="All 6 branches missed.">      } else if (binding == classOf[jFloat]) {</span>
<span class="nc" id="L666">        value =&gt; output.writeFloat(value.asInstanceOf[jFloat])</span>
<span class="nc bnc" id="L667" title="All 6 branches missed.">      } else if (binding == classOf[jDouble]) {</span>
<span class="nc" id="L668">        value =&gt; output.writeDouble(value.asInstanceOf[jDouble])</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">      } else if (classOf[Date].isAssignableFrom(binding)) {</span>
<span class="nc" id="L670">        value =&gt; output.writeLong(value.asInstanceOf[Date].getTime, true)</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">      } else if (classOf[Geometry].isAssignableFrom(binding)) {</span>
<span class="nc" id="L672">        value =&gt; {</span>
<span class="nc" id="L673">          val b1 = WKBUtils.write(value.asInstanceOf[Geometry])</span>
<span class="nc" id="L674">          output.writeInt(b1.length, true)</span>
<span class="nc" id="L675">          output.write(b1)</span>
        }
      } else {
<span class="nc" id="L678">        throw new Exception(s&quot;Cannot serialize stat due to invalid type: $binding&quot;)</span>
      }
    }

    private def reader(input: Input, binding: Class[_]): () =&gt; Any = {
<span class="nc bnc" id="L683" title="All 6 branches missed.">      if (binding == classOf[String]) {</span>
<span class="nc" id="L684">        () =&gt; input.readString()</span>
<span class="nc bnc" id="L685" title="All 6 branches missed.">      } else if (binding == classOf[Integer]) {</span>
<span class="nc" id="L686">        () =&gt; input.readInt(true)</span>
<span class="nc bnc" id="L687" title="All 6 branches missed.">      } else if (binding == classOf[jLong]) {</span>
<span class="nc" id="L688">        () =&gt; input.readLong(true)</span>
<span class="nc bnc" id="L689" title="All 6 branches missed.">      } else if (binding == classOf[jFloat]) {</span>
<span class="nc" id="L690">        () =&gt; input.readFloat()</span>
<span class="nc bnc" id="L691" title="All 6 branches missed.">      } else if (binding == classOf[jDouble]) {</span>
<span class="nc" id="L692">        () =&gt; input.readDouble()</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">      } else if (classOf[Date].isAssignableFrom(binding)) {</span>
<span class="nc" id="L694">        () =&gt; new Date(input.readLong(true))</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">      } else if (classOf[Geometry].isAssignableFrom(binding)) {</span>
<span class="nc" id="L696">        () =&gt; {</span>
<span class="nc" id="L697">          val b = Array.ofDim[Byte](input.readInt(true))</span>
<span class="nc" id="L698">          input.read(b)</span>
<span class="nc" id="L699">          WKBUtils.read(b)</span>
        }
      } else {
<span class="nc" id="L702">        throw new Exception(s&quot;Cannot deserialize stat due to invalid type: $binding&quot;)</span>
      }
    }
  }
<span class="nc" id="L706">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>