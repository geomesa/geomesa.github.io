<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatParser.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">StatParser.scala</span></div><h1>StatParser.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.curve.TimePeriod
import org.locationtech.geomesa.curve.TimePeriod._
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.impl.MinMax.MinMaxDefaults
import org.locationtech.geomesa.utils.text.BasicParser
import org.parboiled.errors.{ErrorUtils, ParsingException}
import org.parboiled.scala._
import org.parboiled.scala.rules.Rule1

import scala.reflect.ClassTag

<span class="nc" id="L23">object StatParser {</span>

<span class="nc" id="L25">  private val Parser = new StatParser()</span>

<span class="nc" id="L27">  private val sfts = new ThreadLocal[SimpleFeatureType]</span>

  @throws(classOf[ParsingException])
<span class="nc" id="L30">  def parse(sft: SimpleFeatureType, stat: String, report: Boolean = true): Stat = {</span>
<span class="nc bnc" id="L31" title="All 2 branches missed.">    if (stat == null) {</span>
<span class="nc" id="L32">      throw new IllegalArgumentException(&quot;Stat must not be null&quot;)</span>
    }
<span class="nc bnc" id="L34" title="All 2 branches missed.">    val runner = if (report) { ReportingParseRunner(Parser.stat) } else { BasicParseRunner(Parser.stat) }</span>
<span class="nc" id="L35">    sfts.set(sft)</span>
    try {
<span class="nc" id="L37">      val parsing = runner.run(stat)</span>
<span class="nc" id="L38">      parsing.result.getOrElse {</span>
<span class="nc" id="L39">        throw new ParsingException(s&quot;Invalid stat string: ${ErrorUtils.printParseErrors(parsing)}&quot;)</span>
      }
    } finally {
<span class="nc" id="L42">      sfts.remove()</span>
    }
  }

  @throws(classOf[ParsingException])
<span class="nc" id="L47">  def propertyNames(sft: SimpleFeatureType, stat: String, report: Boolean = true): Seq[String] = {</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">    if (stat == null) {</span>
<span class="nc" id="L49">      throw new IllegalArgumentException(&quot;Stat must not be null&quot;)</span>
    }
<span class="nc bnc" id="L51" title="All 2 branches missed.">    val runner = if (report) { ReportingParseRunner(Parser.attributes) } else { BasicParseRunner(Parser.attributes) }</span>
<span class="nc" id="L52">    sfts.set(sft)</span>
    try {
<span class="nc" id="L54">      val parsing = runner.run(stat)</span>
<span class="nc" id="L55">      parsing.result.getOrElse {</span>
<span class="nc" id="L56">        throw new ParsingException(s&quot;Invalid stat string: ${ErrorUtils.printParseErrors(parsing)}&quot;)</span>
      }
    } finally {
<span class="nc" id="L59">      sfts.remove()</span>
    }
  }

<span class="nc" id="L63">  private def sft: SimpleFeatureType = sfts.get</span>
}

<span class="nc" id="L66">private class StatParser extends BasicParser {</span>

  import StatParser.sft

  // main parsing rule
<span class="nc" id="L71">  def stat: Rule1[Stat] = rule { stats ~ EOI }</span>

<span class="nc" id="L73">  def attributes: Rule1[Seq[String]] = rule { properties ~ EOI  ~~&gt; { p =&gt; p.distinct} }</span>

<span class="nc" id="L75">  private def stats: Rule1[Stat] = rule {</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">    oneOrMore(singleStat, &quot;;&quot;) ~~&gt; { s =&gt; if (s.lengthCompare(1) == 0) { s.head } else { new SeqStat(sft, s) }}</span>
  }

<span class="nc" id="L79">  private def properties: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L80">    oneOrMore(names, &quot;;&quot;) ~~&gt; { s =&gt; s.flatten }</span>
  }

<span class="nc" id="L83">  private def singleStat: Rule1[Stat] = rule {</span>
<span class="nc" id="L84">    count | minMax | groupBy | descriptiveStats | enumeration | topK | histogram |</span>
<span class="nc" id="L85">        frequency | z3Histogram | z3Frequency | iteratorStack</span>
  }

<span class="nc" id="L88">  private def names: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L89">    countNames | minMaxNames | groupByNames | descriptiveStatsNames | enumerationNames |</span>
<span class="nc" id="L90">        topKNames | histogramNames | frequencyNames | z3HistogramNames | z3FrequencyNames | iteratorStackNames</span>
  }

<span class="nc" id="L93">  private def groupBy: Rule1[Stat] = rule {</span>
<span class="nc" id="L94">    &quot;GroupBy(&quot; ~ attribute ~ &quot;,&quot; ~ (stats ~&gt; { s =&gt; s }) ~ &quot;)&quot; ~~&gt; { (attribute, _, groupedStats) =&gt;</span>
<span class="nc" id="L95">      new GroupBy(sft, attribute, groupedStats)</span>
    }
  }

<span class="nc" id="L99">  private def groupByNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L100">    &quot;GroupBy(&quot; ~ attribute ~ &quot;,&quot; ~ properties ~ &quot;)&quot; ~~&gt; { (attribute, groupedStats) =&gt;</span>
<span class="nc" id="L101">      groupedStats.+:(attribute)</span>
    }
  }

<span class="nc" id="L105">  private def count: Rule1[Stat] = rule {</span>
<span class="nc" id="L106">    &quot;Count()&quot; ~&gt; { _ =&gt; new CountStat(sft) }</span>
  }

<span class="nc" id="L109">  private def countNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L110">    &quot;Count()&quot; ~&gt; { _ =&gt; Seq.empty }</span>
  }

<span class="nc" id="L113">  private def minMax: Rule1[Stat] = rule {</span>
<span class="nc" id="L114">    &quot;MinMax(&quot; ~ attribute ~ &quot;)&quot; ~~&gt; { attribute =&gt;</span>
<span class="nc" id="L115">      val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L116">      new MinMax[Any](sft, attribute)(MinMaxDefaults(binding))</span>
    }
  }

<span class="nc" id="L120">  private def minMaxNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L121">    &quot;MinMax(&quot; ~ attribute ~ &quot;)&quot; ~~&gt; { attribute =&gt; Seq(attribute) }</span>
  }

<span class="nc" id="L124">  private def iteratorStack: Rule1[Stat] = rule {</span>
<span class="nc" id="L125">    &quot;IteratorStackCount()&quot; ~&gt; { _ =&gt; new IteratorStackCount(sft) }</span>
  }

<span class="nc" id="L128">  private def iteratorStackNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L129">    &quot;IteratorStackCount()&quot; ~&gt; { _ =&gt; Seq.empty }</span>
  }

<span class="nc" id="L132">  private def enumeration: Rule1[Stat] = rule {</span>
<span class="nc" id="L133">    &quot;Enumeration(&quot; ~ attribute ~ &quot;)&quot; ~~&gt; { attribute =&gt;</span>
<span class="nc" id="L134">      val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L135">      new EnumerationStat[Any](sft, attribute)(ClassTag(binding))</span>
    }
  }

<span class="nc" id="L139">  private def enumerationNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L140">    &quot;Enumeration(&quot; ~ attribute ~ &quot;)&quot; ~~&gt; { attribute =&gt; Seq(attribute) }</span>
  }

<span class="nc" id="L143">  private def topK: Rule1[Stat] = rule {</span>
<span class="nc" id="L144">    &quot;TopK(&quot; ~ attribute ~ &quot;)&quot; ~~&gt; { attribute =&gt;</span>
<span class="nc" id="L145">      new TopK[Any](sft, attribute)</span>
    }
  }

<span class="nc" id="L149">  private def topKNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L150">    &quot;TopK(&quot; ~ attribute ~ &quot;)&quot; ~~&gt; { attribute =&gt; Seq(attribute) }</span>
  }

<span class="nc" id="L153">  private def descriptiveStats: Rule1[Stat] = rule {</span>
<span class="nc" id="L154">    &quot;DescriptiveStats(&quot; ~ oneOrMore(attribute, &quot;,&quot;) ~ &quot;)&quot; ~~&gt; { attributes =&gt;</span>
<span class="nc" id="L155">      new DescriptiveStats(sft, attributes)</span>
    }
  }

<span class="nc" id="L159">  private def descriptiveStatsNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L160">    &quot;DescriptiveStats(&quot; ~ oneOrMore(attribute, &quot;,&quot;) ~ &quot;)&quot; ~~&gt; { attributes =&gt; attributes }</span>
  }

<span class="nc" id="L163">  private def histogram: Rule1[Stat] = rule {</span>
<span class="nc" id="L164">    &quot;Histogram(&quot; ~ attribute ~ &quot;,&quot; ~ int ~ &quot;,&quot; ~ string ~ &quot;,&quot; ~ string ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L165">      (attribute, numBins, lower, upper) =&gt; {</span>
<span class="nc" id="L166">        val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L167">        val destringify = Stat.destringifier(binding)</span>
<span class="nc" id="L168">        val tLower = destringify(lower)</span>
<span class="nc" id="L169">        val tUpper = destringify(upper)</span>
<span class="nc" id="L170">        new Histogram[Any](sft, attribute, numBins, (tLower, tUpper))(MinMaxDefaults(binding), ClassTag(binding))</span>
      }
    }
  }

<span class="nc" id="L175">  private def histogramNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L176">    &quot;Histogram(&quot; ~ attribute ~ &quot;,&quot; ~ int ~ &quot;,&quot; ~ string ~ &quot;,&quot; ~ string ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L177">      (attribute, _, _, _) =&gt; Seq(attribute)</span>
    }
  }

<span class="nc" id="L181">  private def frequency: Rule1[Stat] = rule {</span>
<span class="nc" id="L182">    &quot;Frequency(&quot; ~ attribute ~ &quot;,&quot; ~ optional(attribute ~ &quot;,&quot; ~ timePeriod ~ &quot;,&quot;) ~ int ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L183">      (attribute, dtgAndPeriod, precision) =&gt; {</span>
<span class="nc" id="L184">        val dtg = dtgAndPeriod.map(_._1)</span>
<span class="nc" id="L185">        val period = dtgAndPeriod.map(_._2).getOrElse(TimePeriod.Week)</span>
<span class="nc" id="L186">        val binding = sft.getDescriptor(attribute).getType.getBinding</span>
<span class="nc" id="L187">        new Frequency[Any](sft, attribute, dtg, period, precision)(ClassTag(binding))</span>
      }
    }
  }

<span class="nc" id="L192">  private def frequencyNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L193">    &quot;Frequency(&quot; ~ attribute ~ &quot;,&quot; ~ optional(attribute ~ &quot;,&quot; ~ timePeriod ~ &quot;,&quot;) ~ int ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L194">      (attribute, dtgAndPeriod, _) =&gt; Seq(attribute) ++ dtgAndPeriod.map(_._1).toSeq</span>
    }
  }

<span class="nc" id="L198">  private def z3Histogram: Rule1[Stat] = rule {</span>
<span class="nc" id="L199">    &quot;Z3Histogram(&quot; ~ attribute ~ &quot;,&quot; ~ attribute ~ &quot;,&quot; ~ timePeriod ~ &quot;,&quot; ~ int ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L200">      (geom, dtg, period, length) =&gt; new Z3Histogram(sft, geom, dtg, period, length)</span>
    }
  }

<span class="nc" id="L204">  private def z3HistogramNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L205">    &quot;Z3Histogram(&quot; ~ attribute ~ &quot;,&quot; ~ attribute ~ &quot;,&quot; ~ timePeriod ~ &quot;,&quot; ~ int ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L206">      (geom, dtg, _, _) =&gt; Seq(geom, dtg)</span>
    }
  }

<span class="nc" id="L210">  private def z3Frequency: Rule1[Stat] = rule {</span>
<span class="nc" id="L211">    &quot;Z3Frequency(&quot; ~ attribute ~ &quot;,&quot; ~ attribute ~ &quot;,&quot; ~ timePeriod ~ &quot;,&quot; ~ int ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L212">      (geom, dtg, period, precision) =&gt; new Z3Frequency(sft, geom, dtg, period, precision)</span>
    }
  }

<span class="nc" id="L216">  private def z3FrequencyNames: Rule1[Seq[String]] = rule {</span>
<span class="nc" id="L217">    &quot;Z3Frequency(&quot; ~ attribute ~ &quot;,&quot; ~ attribute ~ &quot;,&quot; ~ timePeriod ~ &quot;,&quot; ~ int ~ &quot;)&quot; ~~&gt; {</span>
<span class="nc" id="L218">      (geom, dtg, _, _) =&gt; Seq(geom, dtg)</span>
    }
  }

<span class="nc" id="L222">  private def timePeriod: Rule1[TimePeriod] = rule {</span>
<span class="nc" id="L223">    string ~~&gt; { period =&gt; TimePeriod.withName(period.toLowerCase) }</span>
  }

<span class="nc" id="L226">  private def attribute: Rule1[String] = rule {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    string ~~~? { s =&gt; sft.indexOf(s) != -1 }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>