<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Z3Histogram.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">Z3Histogram.scala</span></div><h1>Z3Histogram.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.geometry.jts.JTSFactoryFinder
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.curve.{BinnedTime, TimePeriod, Z3SFC}
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.impl.BinnedArray.LongBinning
import org.locationtech.geomesa.index.stats.impl.MinMax.MinMaxGeometry
import org.locationtech.jts.geom.{Coordinate, Geometry, Point}

import java.util.Date

/**
  * The histogram's state is stored in an indexed array, where the index is the bin number
  * and the values are the counts.
  *
  * Tracks geometry and date attributes as a single value.
  *
  * @param sft simple feature type
  * @param geom geometry attribute in the sft
  * @param dtg date attribute in the sft
  * @param period time period to use for z index
  * @param length number of bins the histogram has, per period
 */
<span class="nc bnc" id="L35" title="All 4 branches missed.">class Z3Histogram(</span>
<span class="nc" id="L36">    val sft: SimpleFeatureType,</span>
<span class="nc" id="L37">    val geom: String,</span>
<span class="nc" id="L38">    val dtg: String,</span>
<span class="nc" id="L39">    val period: TimePeriod,</span>
<span class="nc" id="L40">    val length: Int</span>
<span class="nc" id="L41">  ) extends Stat with LazyLogging {</span>

  import Z3Histogram._

  override type S = Z3Histogram

<span class="nc" id="L47">  private val g = sft.indexOf(geom)</span>
<span class="nc" id="L48">  private val d = sft.indexOf(dtg)</span>

<span class="nc" id="L50">  private val sfc = Z3SFC(period)</span>
<span class="nc" id="L51">  private val timeToBin = BinnedTime.timeToBinnedTime(period)</span>
<span class="nc" id="L52">  private val binToDate = BinnedTime.binnedTimeToDate(period)</span>
<span class="nc" id="L53">  private val minZ = sfc.index(minGeom.getX, minGeom.getY, sfc.time.min.toLong)</span>
<span class="nc" id="L54">  private val maxZ = sfc.index(maxGeom.getX, maxGeom.getY, sfc.time.max.toLong)</span>

<span class="nc bnc" id="L56" title="All 4 branches missed.">  private lazy val jsonFormat = period match {</span>
<span class="nc bnc" id="L57" title="All 6 branches missed.">    case TimePeriod.Day   =&gt; s&quot;$period-%05d&quot;</span>
<span class="nc bnc" id="L58" title="All 6 branches missed.">    case TimePeriod.Week  =&gt; s&quot;$period-%04d&quot;</span>
<span class="nc bnc" id="L59" title="All 6 branches missed.">    case TimePeriod.Month =&gt; s&quot;$period-%03d&quot;</span>
<span class="nc bnc" id="L60" title="All 6 branches missed.">    case TimePeriod.Year  =&gt; s&quot;$period-%02d&quot;</span>
  }

<span class="nc" id="L63">  private [stats] val binMap = scala.collection.mutable.Map.empty[Short, BinnedArray[java.lang.Long]]</span>
<span class="nc" id="L64">  private [stats] def newBins = new BinnedArray(new LongBinning(length, (minZ, maxZ)))</span>

<span class="nc" id="L66">  def timeBins: Seq[Short] = binMap.keys.toSeq.sorted</span>
<span class="nc" id="L67">  def count(timeBin: Short, i: Int): Long = binMap.get(timeBin).map(_.counts(i)).getOrElse(0L)</span>

<span class="nc" id="L69">  def directIndex(timeBin: Short, value: Long): Int = binMap.get(timeBin).map(_.indexOf(value)).getOrElse(-1)</span>

  def indexOf(value: (Geometry, Date)): (Short, Int) = {
<span class="nc bnc" id="L72" title="All 2 branches missed.">    val (timeBin, z) = toKey(value._1, value._2, lenient = false)</span>
<span class="nc" id="L73">    (timeBin, directIndex(timeBin, z))</span>
  }

<span class="nc" id="L76">  def medianValue(timeBin: Short, i: Int): (Geometry, Date) = fromKey(timeBin, binMap(timeBin).medianValue(i))</span>

  private def toKey(geom: Geometry, dtg: Date, lenient: Boolean): (Short, Long) = {
    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
<span class="nc bnc" id="L80" title="All 2 branches missed.">    val BinnedTime(bin, offset) = timeToBin(dtg.getTime)</span>
<span class="nc" id="L81">    val centroid = geom.safeCentroid()</span>
<span class="nc" id="L82">    val z = sfc.index(centroid.getX, centroid.getY, offset, lenient)</span>
<span class="nc" id="L83">    (bin, z)</span>
  }

  private def fromKey(timeBin: Short, z: Long): (Geometry, Date) = {
<span class="nc bnc" id="L87" title="All 2 branches missed.">    val (x, y, t) = sfc.invert(z)</span>
<span class="nc" id="L88">    val dtg = Date.from(binToDate(BinnedTime(timeBin, t)).toInstant)</span>
<span class="nc" id="L89">    val geom = Z3Histogram.gf.createPoint(new Coordinate(x, y))</span>
<span class="nc" id="L90">    (geom, dtg)</span>
  }

  /**
    * Split the stat into a separate stat per time bin of z data. Allows for separate handling of the reduced
    * data set.
    *
    * @return
    */
  def splitByTime: Seq[(Short, Z3Histogram)] = {
<span class="nc bnc" id="L100" title="All 2 branches missed.">    binMap.toSeq.map { case (w, bins) =&gt;</span>
<span class="nc" id="L101">      val hist = new Z3Histogram(sft, geom, dtg, period, length)</span>
<span class="nc" id="L102">      hist.binMap.put(w, bins)</span>
<span class="nc" id="L103">      (w, hist)</span>
    }
  }

  override def observe(sf: SimpleFeature): Unit = {
<span class="nc" id="L108">    val geom = sf.getAttribute(g).asInstanceOf[Geometry]</span>
<span class="nc" id="L109">    val dtg  = sf.getAttribute(d).asInstanceOf[Date]</span>
<span class="nc bnc" id="L110" title="All 4 branches missed.">    if (geom != null &amp;&amp; dtg != null) {</span>
      try {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        val (timeBin, z3) = toKey(geom, dtg, lenient = false)</span>
<span class="nc" id="L113">        binMap.getOrElseUpdate(timeBin, newBins).add(z3, 1L)</span>
      } catch {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        case e: Exception =&gt; logger.warn(s&quot;Error observing geom '$geom' and date '$dtg': ${e.toString}&quot;)</span>
      }
    }
  }

  override def unobserve(sf: SimpleFeature): Unit = {
<span class="nc" id="L121">    val geom = sf.getAttribute(g).asInstanceOf[Geometry]</span>
<span class="nc" id="L122">    val dtg  = sf.getAttribute(d).asInstanceOf[Date]</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">    if (geom != null &amp;&amp; dtg != null) {</span>
      try {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        val (timeBin, z3) = toKey(geom, dtg, lenient = true)</span>
<span class="nc" id="L126">        binMap.get(timeBin).foreach(_.add(z3, -1L))</span>
      } catch {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        case e: Exception =&gt; logger.warn(s&quot;Error un-observing geom '$geom' and date '$dtg': ${e.toString}&quot;)</span>
      }
    }
  }

  /**
    * Creates a new histogram by combining another histogram with this one
    */
  override def +(other: Z3Histogram): Z3Histogram = {
<span class="nc" id="L137">    val plus = new Z3Histogram(sft, geom, dtg, period, length)</span>
<span class="nc" id="L138">    plus += this</span>
<span class="nc" id="L139">    plus += other</span>
<span class="nc" id="L140">    plus</span>
  }

  /**
    * Copies another histogram into this one
    */
  override def +=(other: Z3Histogram): Unit = {
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (length != other.length) {</span>
<span class="nc" id="L148">      throw new UnsupportedOperationException(&quot;Can only add z3 histograms with the same length&quot;)</span>
    }
<span class="nc bnc" id="L150" title="All 2 branches missed.">    other.binMap.foreach { case (w, bins) =&gt;</span>
<span class="nc" id="L151">      binMap.get(w) match {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        case None =&gt; binMap.put(w, bins) // note: sharing a reference now</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        case Some(b) =&gt;</span>
<span class="nc" id="L154">          var i = 0</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">          while (i &lt; b.length) {</span>
<span class="nc" id="L156">            b.counts(i) += bins.counts(i)</span>
<span class="nc" id="L157">            i += 1</span>
          }
      }
    }
  }

  override def toJsonObject: Any =
<span class="nc" id="L164">    binMap.toSeq.sortBy(_._1)</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">      .map { case (p, bins) =&gt; (String.format(jsonFormat, Short.box(p)), bins) }</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">      .map { case (label, bins) =&gt; Map(label-&gt; Map(&quot;bins&quot; -&gt; bins.counts)) }</span>

<span class="nc bnc" id="L168" title="All 2 branches missed.">  override def isEmpty: Boolean = binMap.values.forall(_.counts.forall(_ == 0))</span>

<span class="nc" id="L170">  override def clear(): Unit = binMap.values.foreach(_.clear())</span>

<span class="nc" id="L172">  override def isEquivalent(other: Stat): Boolean = other match {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">    case that: Z3Histogram =&gt;</span>
<span class="nc bnc" id="L174" title="All 10 branches missed.">      g == that.g &amp;&amp; d == that.d &amp;&amp; period == that.period &amp;&amp;</span>
<span class="nc bnc" id="L175" title="All 8 branches missed.">          length == that.length &amp;&amp; binMap.keySet == that.binMap.keySet &amp;&amp;</span>
<span class="nc bnc" id="L176" title="All 4 branches missed.">          binMap.forall { case (w, bins) =&gt; java.util.Arrays.equals(bins.counts, that.binMap(w).counts) }</span>
<span class="nc" id="L177">    case _ =&gt; false</span>
  }
}

<span class="nc" id="L181">object Z3Histogram {</span>

<span class="nc" id="L183">  private val gf = JTSFactoryFinder.getGeometryFactory</span>

<span class="nc" id="L185">  val minGeom: Point = MinMaxGeometry.min.asInstanceOf[Point]</span>
<span class="nc" id="L186">  val maxGeom: Point = MinMaxGeometry.max.asInstanceOf[Point]</span>
<span class="nc" id="L187">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>