<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BinnedArray.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">BinnedArray.scala</span></div><h1>BinnedArray.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import org.locationtech.geomesa.curve.Z2SFC
import org.locationtech.geomesa.index.stats.impl.BinnedArray.Binning
import org.locationtech.geomesa.utils.geotools.GeometryUtils
import org.locationtech.jts.geom.{Coordinate, Geometry, Point}

import java.lang.{Double =&gt; jDouble, Float =&gt; jFloat, Long =&gt; jLong}
import java.util.{Date, Locale}
import scala.reflect.ClassTag

/**
  * Puts inputs into sorted bins and stores count of each bin
  *
  * @param binning binning logic
  * @tparam T type of input value
  */
<span class="nc" id="L26">class BinnedArray[T](binning: Binning[T]) {</span>

<span class="nc" id="L28">  private [stats] val counts = Array.fill[Long](length)(0L)</span>

<span class="nc" id="L30">  def length: Int = binning.length</span>

<span class="nc" id="L32">  def bounds: (T, T) = binning.bounds</span>

  /**
    * Gets the count of entries in the given bin
    *
    * @param index bin index
    * @return count
    */
<span class="nc" id="L40">  def apply(index: Int): Long = counts(index)</span>

  /**
    * Clears the counts
    */
  def clear(): Unit = {
<span class="nc" id="L46">    var i = 0</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L48">      counts(i) = 0L</span>
<span class="nc" id="L49">      i +=1</span>
    }
  }

  /**
    * Increment the count for the bin corresponding to this value
    *
    * @param value value
    * @param count how much to increment
    */
<span class="nc" id="L59">  def add(value: T, count: Long = 1L): Unit = {</span>
<span class="nc" id="L60">    val i = indexOf(value)</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">    if (i != -1) {</span>
<span class="nc" id="L62">      counts(i) += count</span>
    }
  }

  /**
    * Maps a value that has already been transformed into a number to a bin index.
    *
    * @param value value
    * @return bin index, or -1 if value is out of bounds
    */
<span class="nc" id="L72">  def directIndex(value: Long): Int = binning.directIndex(value)</span>

  /**
    * Maps a value to a bin index.
    *
    * @param value value
    * @return bin index, or -1 if value is out of bounds
    */
<span class="nc" id="L80">  def indexOf(value: T): Int = binning.indexOf(value)</span>

  /**
    * Gets a value corresponding to the midpoint of a bin.
    *
    * @param index index into the array
    * @return representative value for the bin
    */
<span class="nc" id="L88">  def medianValue(index: Int): T = binning.medianValue(index)</span>

  /**
    * Gets the min and max values that will go into a bin
    *
    * @param index index into the array
    * @return bounds for the bin
    */
<span class="nc" id="L96">  def bounds(index: Int): (T, T) = binning.bounds(index)</span>

  /**
    * Indicates if the value is below the range of this array
    *
    * @param value value
    * @return true if below, false otherwise (implies above if indexOf == -1)
    */
<span class="nc" id="L104">  def isBelow(value: T): Boolean = binning.isBelow(value)</span>
}

<span class="nc" id="L107">object BinnedArray {</span>

<span class="nc" id="L109">  def apply[T : ClassTag](length: Int, bounds: (T, T)): BinnedArray[T] = new BinnedArray[T](Binning(length, bounds))</span>

  /**
   * Logic for converting inputs into bins
   *
   * @param length number of bins
   * @param bounds upper and lower bounds for the input values
   * @tparam T type of input value
   */
<span class="nc" id="L118">  abstract class Binning[T](val length: Int, val bounds: (T, T)) {</span>

    /**
     * Maps a value that has already been transformed into a number to a bin index.
     *
     * @param value value
     * @return bin index, or -1 if value is out of bounds
     */
    def directIndex(value: Long): Int

    /**
     * Maps a value to a bin index.
     *
     * @param value value
     * @return bin index, or -1 if value is out of bounds
     */
    def indexOf(value: T): Int

    /**
     * Gets a value corresponding to the midpoint of a bin.
     *
     * @param index index into the array
     * @return representative value for the bin
     */
    def medianValue(index: Int): T

    /**
     * Gets the min and max values that will go into a bin
     *
     * @param index index into the array
     * @return bounds for the bin
     */
    def bounds(index: Int): (T, T)

    /**
     * Indicates if the value is below the range of this array
     *
     * @param value value
     * @return true if below, false otherwise (implies above if indexOf == -1)
     */
    def isBelow(value: T): Boolean
  }

<span class="nc" id="L161">  object Binning {</span>
    def apply[T : ClassTag](length: Int, bounds: (T, T)): Binning[T] = {
<span class="nc" id="L163">      val clas = implicitly[ClassTag[T]].runtimeClass</span>
<span class="nc bnc" id="L164" title="All 6 branches missed.">      val binning = if (clas == classOf[String]) {</span>
<span class="nc" id="L165">        new StringBinning(length, bounds.asInstanceOf[(String, String)])</span>
<span class="nc bnc" id="L166" title="All 6 branches missed.">      } else if (clas == classOf[Integer]) {</span>
<span class="nc" id="L167">        new IntBinning(length, bounds.asInstanceOf[(Integer, Integer)])</span>
<span class="nc bnc" id="L168" title="All 6 branches missed.">      } else if (clas == classOf[jLong]) {</span>
<span class="nc" id="L169">        new LongBinning(length, bounds.asInstanceOf[(jLong, jLong)])</span>
<span class="nc bnc" id="L170" title="All 6 branches missed.">      } else if (clas == classOf[jFloat]) {</span>
<span class="nc" id="L171">        new FloatBinning(length, bounds.asInstanceOf[(jFloat, jFloat)])</span>
<span class="nc bnc" id="L172" title="All 6 branches missed.">      } else if (clas == classOf[jDouble]) {</span>
<span class="nc" id="L173">        new DoubleBinning(length, bounds.asInstanceOf[(jDouble, jDouble)])</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">      } else if (classOf[Date].isAssignableFrom(clas)) {</span>
<span class="nc" id="L175">        new DateBinning(length, bounds.asInstanceOf[(Date, Date)])</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      } else if (classOf[Geometry].isAssignableFrom(clas)) {</span>
<span class="nc" id="L177">        new GeometryBinning(length, bounds.asInstanceOf[(Geometry, Geometry)])</span>
      } else {
<span class="nc" id="L179">        throw new UnsupportedOperationException(s&quot;BinnedArray not implemented for ${clas.getName}&quot;)</span>
      }
<span class="nc" id="L181">      binning.asInstanceOf[Binning[T]]</span>
    }
  }

<span class="nc" id="L185">  abstract class WholeNumberBinning[T](length: Int, bounds: (T, T)) extends Binning[T](length, bounds) {</span>

<span class="nc" id="L187">    private val min = convertToLong(bounds._1)</span>
<span class="nc" id="L188">    private val max = convertToLong(bounds._2)</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">    require(min &lt; max,</span>
<span class="nc" id="L191">      s&quot;Upper bound must be greater than lower bound: lower='${bounds._1}'($min) upper='${bounds._2}'($max)&quot;)</span>

<span class="nc" id="L193">    private val binSize = (max - min).toDouble / length</span>

    override def directIndex(value: Long): Int = {
<span class="nc bnc" id="L196" title="All 4 branches missed.">      if (value &lt; min || value &gt; max) { -1 } else {</span>
<span class="nc" id="L197">        val i = math.floor((value - min) / binSize).toInt</span>
        // i == length check catches the upper bound
<span class="nc bnc" id="L199" title="All 6 branches missed.">        if (i &lt; 0 || i &gt; length) -1 else if (i == length) length - 1 else i</span>
      }
    }

<span class="nc" id="L203">    override def indexOf(value: T): Int = directIndex(convertToLong(value))</span>

    override def medianValue(index: Int): T = {
<span class="nc bnc" id="L206" title="All 4 branches missed.">      if (index &lt; 0 || index &gt; length) {</span>
<span class="nc" id="L207">        throw new ArrayIndexOutOfBoundsException(index)</span>
      }
<span class="nc" id="L209">      val long = min + math.round(binSize / 2 + binSize * index)</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">      if (long &gt; max) bounds._2 else convertFromLong(long)</span>
    }

    override def bounds(index: Int): (T, T) = {
<span class="nc bnc" id="L214" title="All 4 branches missed.">      if (index &lt; 0 || index &gt; length) {</span>
<span class="nc" id="L215">        throw new ArrayIndexOutOfBoundsException(index)</span>
      }
<span class="nc" id="L217">      val loLong = min + math.ceil(binSize * index).toLong</span>
<span class="nc" id="L218">      val hiLong = math.max(loLong, min + math.floor(binSize * (index + 1)).toLong)</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">      val lo = if (loLong &lt;= min) bounds._1 else convertFromLong(loLong)</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">      val hi = if (hiLong &gt;= max) bounds._2 else convertFromLong(hiLong)</span>

<span class="nc" id="L222">      (lo, hi)</span>
    }

<span class="nc bnc" id="L225" title="All 2 branches missed.">    override def isBelow(value: T): Boolean = convertToLong(value) &lt; min</span>

    /**
     * Maps a value to a long used to allocate values in bins
     *
     * @param value value to convert
     * @return value as a long
     */
    protected def convertToLong(value: T): Long

    /**
     * Maps a long back to a value
     *
     * @param value value as a long
     * @return value
     */
    protected def convertFromLong(value: Long): T
  }

<span class="nc" id="L244">  class IntBinning(length: Int, bounds: (Integer, Integer)) extends WholeNumberBinning[Integer](length, bounds) {</span>
<span class="nc" id="L245">    override protected def convertToLong(value: Integer): Long = value.toLong</span>
<span class="nc" id="L246">    override protected def convertFromLong(value: Long): Integer = value.toInt</span>
  }

<span class="nc" id="L249">  class LongBinning(length: Int, bounds: (jLong, jLong)) extends WholeNumberBinning[jLong](length, bounds) {</span>
<span class="nc" id="L250">    override protected def convertToLong(value: jLong): Long = value</span>
<span class="nc" id="L251">    override protected def convertFromLong(value: Long): jLong = value</span>
  }

<span class="nc" id="L254">  class DateBinning(length: Int, bounds: (Date, Date)) extends WholeNumberBinning[Date](length, bounds) {</span>
<span class="nc" id="L255">    override protected def convertToLong(value: Date): Long = value.getTime</span>
<span class="nc" id="L256">    override protected def convertFromLong(value: Long): Date = new Date(value)</span>
  }

  /**
   * Sorts geometries based on the z-value of their centroid
   *
   * @param length number of bins
   * @param bounds upper and lower bounds for the input values
   */
<span class="nc" id="L265">  class GeometryBinning(length: Int, bounds: (Geometry, Geometry))</span>
<span class="nc" id="L266">      extends WholeNumberBinning[Geometry](length, bounds) {</span>

    override protected def convertToLong(value: Geometry): Long = {
      import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
<span class="nc" id="L270">      val centroid = value match {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        case p: Point =&gt; p</span>
<span class="nc" id="L272">        case g =&gt; g.safeCentroid()</span>
      }
<span class="nc" id="L274">      Z2SFC.index(centroid.getX, centroid.getY, lenient = true)</span>
    }

    override protected def convertFromLong(value: Long): Geometry = {
<span class="nc bnc" id="L278" title="All 2 branches missed.">      val (x, y) = Z2SFC.invert(value)</span>
<span class="nc" id="L279">      GeometryUtils.geoFactory.createPoint(new Coordinate(x, y))</span>
    }
  }

<span class="nc" id="L283">  class FloatBinning(length: Int, bounds: (jFloat, jFloat)) extends Binning[jFloat](length, bounds) {</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">    require(bounds._1 &lt; bounds._2,</span>
<span class="nc" id="L286">      s&quot;Upper bound must be greater than lower bound: lower='${bounds._1}' upper='${bounds._2}'&quot;)</span>

<span class="nc" id="L288">    private val binSize = (bounds._2 - bounds._1) / length</span>

<span class="nc" id="L290">    override def directIndex(value: Long): Int = -1</span>

    override def indexOf(value: jFloat): Int = {
<span class="nc bnc" id="L293" title="All 4 branches missed.">      if (value &lt; bounds._1 || value &gt; bounds._2) { -1 } else {</span>
<span class="nc" id="L294">        val i = math.floor((value - bounds._1) / binSize).toInt</span>
        // i == length check catches the upper bound
<span class="nc bnc" id="L296" title="All 6 branches missed.">        if (i &lt; 0 || i &gt; length) -1 else if (i == length) length - 1 else i</span>
      }
    }

    override def medianValue(index: Int): jFloat = {
<span class="nc bnc" id="L301" title="All 4 branches missed.">      if (index &lt; 0 || index &gt; length) {</span>
<span class="nc" id="L302">        throw new ArrayIndexOutOfBoundsException(index)</span>
      }
<span class="nc" id="L304">      bounds._1 + binSize / 2 + binSize * index</span>
    }

    override def bounds(index: Int): (jFloat, jFloat) = {
<span class="nc bnc" id="L308" title="All 4 branches missed.">      if (index &lt; 0 || index &gt; length) {</span>
<span class="nc" id="L309">        throw new ArrayIndexOutOfBoundsException(index)</span>
      }
<span class="nc" id="L311">      (bounds._1 + binSize * index, bounds._1 + binSize * (index + 1))</span>
    }

<span class="nc bnc" id="L314" title="All 2 branches missed.">    override def isBelow(value: jFloat): Boolean = value &lt; bounds._1</span>
  }

<span class="nc" id="L317">  class DoubleBinning(length: Int, bounds: (jDouble, jDouble)) extends Binning[jDouble](length, bounds) {</span>

<span class="nc bnc" id="L319" title="All 2 branches missed.">    require(bounds._1 &lt; bounds._2,</span>
<span class="nc" id="L320">      s&quot;Upper bound must be greater than lower bound: lower='${bounds._1}' upper='${bounds._2}'&quot;)</span>

<span class="nc" id="L322">    private val binSize = (bounds._2 - bounds._1) / length</span>

<span class="nc" id="L324">    override def directIndex(value: Long): Int = -1</span>

    override def indexOf(value: jDouble): Int = {
<span class="nc bnc" id="L327" title="All 4 branches missed.">      if (value &lt; bounds._1 || value &gt; bounds._2) { -1 } else {</span>
<span class="nc" id="L328">        val i = math.floor((value - bounds._1) / binSize).toInt</span>
        // i == length check catches the upper bound
<span class="nc bnc" id="L330" title="All 6 branches missed.">        if (i &lt; 0 || i &gt; length) -1 else if (i == length) length - 1 else i</span>
      }
    }

    override def medianValue(index: Int): jDouble = {
<span class="nc bnc" id="L335" title="All 4 branches missed.">      if (index &lt; 0 || index &gt; length) {</span>
<span class="nc" id="L336">        throw new ArrayIndexOutOfBoundsException(index)</span>
      }
<span class="nc" id="L338">      bounds._1 + binSize / 2 + binSize * index</span>
    }

    override def bounds(index: Int): (jDouble, jDouble) = {
<span class="nc bnc" id="L342" title="All 4 branches missed.">      if (index &lt; 0 || index &gt; length) {</span>
<span class="nc" id="L343">        throw new ArrayIndexOutOfBoundsException(index)</span>
      }
<span class="nc" id="L345">      (bounds._1 + binSize * index, bounds._1 + binSize * (index + 1))</span>
    }

<span class="nc bnc" id="L348" title="All 2 branches missed.">    override def isBelow(value: jDouble): Boolean = value &lt; bounds._1</span>
  }

  /**
   * Bins strings. Will set up bins based on the longest-common-prefix of the bounds. Estimates
   * bins by considering inputs to be roughly equivalent to base36 longs.
   *
   * @param length number of bins
   * @param rawBounds upper and lower bounds for the input values
   */
<span class="nc" id="L358">  class StringBinning(length: Int, rawBounds: (String, String))</span>
<span class="nc" id="L359">      extends WholeNumberBinning[String](length, StringBinning.normalizeBounds(rawBounds)) {</span>

    import StringBinning.{Base36Lowest, normalize}

<span class="nc bnc" id="L363" title="All 12 branches missed.">    private lazy val (start, end): (String, String) = bounds</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">    private lazy val normalizedLength = start.length</span>
<span class="nc bnc" id="L365" title="All 8 branches missed.">    private lazy val prefixLength = start.zip(end).indexWhere { case (l, r) =&gt; l != r }</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">    private lazy val prefix = start.substring(0, prefixLength)</span>

    override protected def convertToLong(value: String): Long = {
<span class="nc" id="L369">      val normalized = normalize(value).padTo(normalizedLength, '0')</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">      if (normalized &lt; start) { 0L } else if (normalized &gt; end) { Long.MaxValue } else {</span>
        // note: 12 is the most base-36 numbers we can fit in Long.MaxValue
<span class="nc" id="L372">        val sigDigits = normalized.substring(prefixLength).padTo(12, Base36Lowest).substring(0, 12)</span>
<span class="nc" id="L373">        jLong.parseLong(sigDigits, 36)</span>
      }
    }

    override protected def convertFromLong(value: Long): String =
<span class="nc" id="L378">      prefix + jLong.toString(value, 36).reverse.padTo(12, Base36Lowest).reverse.replaceFirst(&quot;0+$&quot;, &quot;&quot;)</span>
  }

<span class="nc" id="L381">  object StringBinning {</span>

<span class="nc" id="L383">    private val Base36Chars = (0 until 36).map(Integer.toString(_, 36).toLowerCase(Locale.US).charAt(0)).toArray</span>
<span class="nc" id="L384">    val Base36Lowest: Char  = Base36Chars.head</span>
<span class="nc" id="L385">    val Base36Highest: Char = Base36Chars.last</span>

<span class="nc" id="L387">    def normalize(s: String): String = s.toLowerCase(Locale.US).replaceAll(&quot;[^0-9a-z]&quot;, Base36Lowest.toString)</span>

    def normalizeBounds(bounds: (String, String)): (String, String) = {
<span class="nc" id="L390">      val length = math.max(bounds._1.length, bounds._2.length)</span>
<span class="nc" id="L391">      val loBase36 = normalize(bounds._1)</span>
<span class="nc" id="L392">      val hiBase36 = normalize(bounds._2)</span>
      // pad them and make sure they are in sorted order
<span class="nc bnc" id="L394" title="All 4 branches missed.">      val (loPadded, hiPadded) = if (loBase36 &lt; hiBase36) {</span>
<span class="nc" id="L395">        (loBase36.padTo(length, Base36Lowest), hiBase36.padTo(length, Base36Highest))</span>
      } else {
<span class="nc" id="L397">        (hiBase36.padTo(length, Base36Lowest), loBase36.padTo(length, Base36Highest))</span>
      }
      // ensure that they haven't become the same string
<span class="nc bnc" id="L400" title="All 8 branches missed.">      val (loDistinct, hiDistinct) = if (loPadded == hiPadded) {</span>
<span class="nc" id="L401">        (loPadded + Base36Lowest, hiPadded + Base36Highest)</span>
      } else {
<span class="nc" id="L403">        (loPadded, hiPadded)</span>
      }
      // check to make sure they fit in a long (12 chars)
<span class="nc bnc" id="L406" title="All 4 branches missed.">      val prefixLength = loDistinct.zip(hiDistinct).indexWhere { case (l, r) =&gt; l != r }</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">      val loFit = if (loDistinct.length &gt; prefixLength + 12) loDistinct.take(prefixLength + 12) else loDistinct</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">      val hiFit = if (hiDistinct.length &gt; prefixLength + 12) hiDistinct.take(prefixLength + 12) else hiDistinct</span>
      // check one last time that they aren't the same
<span class="nc bnc" id="L410" title="All 6 branches missed.">      if (loFit == hiFit) {</span>
<span class="nc" id="L411">        (loFit.dropRight(1) + Base36Lowest, hiFit.dropRight(1) + Base36Highest)</span>
      } else {
<span class="nc" id="L413">        (loFit, hiFit)</span>
      }
    }
  }
<span class="nc" id="L417">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>