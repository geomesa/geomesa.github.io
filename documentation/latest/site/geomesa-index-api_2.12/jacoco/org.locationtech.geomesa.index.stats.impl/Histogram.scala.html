<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Histogram.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">Histogram.scala</span></div><h1>Histogram.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.impl.BinnedArray.Binning
import org.locationtech.geomesa.index.stats.impl.BinnedArray.StringBinning.{Base36Highest, Base36Lowest}
import org.locationtech.geomesa.utils.geotools.GeometryUtils
import org.locationtech.jts.geom.{Coordinate, Geometry}

import java.util.Date
import scala.collection.immutable.ListMap
import scala.reflect.ClassTag
import scala.util.Try

/**
  * The histogram's state is stored in an indexed array, where the index is the bin number
  * and the values are the counts.
  *
  * e.g. a range of 0 to 3 with 3 bins will result in these bins: [0, 1), [1, 2), [2, 3) and the
  * array will contain three entries.
  *
  * @param sft simple feature type
  * @param property property name for the attribute the histogram is being made for
  * @param initialBins number of bins the histogram has
  * @param initialEndpoints lower/upper end of histogram
  * @tparam T a comparable type which must have a StatHelperFunctions type class
  */
<span class="nc bnc" id="L37" title="All 4 branches missed.">class Histogram[T](</span>
<span class="nc" id="L38">    val sft: SimpleFeatureType,</span>
<span class="nc" id="L39">    val property: String,</span>
    initialBins: Int,
    initialEndpoints: (T, T)
  )(
<span class="nc" id="L43">    implicit val defaults: MinMax.MinMaxDefaults[T],</span>
<span class="nc" id="L44">    val ct: ClassTag[T]</span>
<span class="nc" id="L45">  ) extends Stat with LazyLogging {</span>

  override type S = Histogram[T]

<span class="nc" id="L49">  private val i = sft.indexOf(property)</span>
<span class="nc" id="L50">  private [stats] var bins: BinnedArray[T] = BinnedArray[T](initialBins, initialEndpoints)</span>

<span class="nc" id="L52">  def length: Int = bins.length</span>
<span class="nc" id="L53">  def directIndex(value: Long): Int = bins.directIndex(value)</span>
<span class="nc" id="L54">  def indexOf(value: T): Int = bins.indexOf(value)</span>
<span class="nc" id="L55">  def count(i: Int): Long = bins.counts(i)</span>
<span class="nc" id="L56">  def min: T = bins.bounds._1</span>
<span class="nc" id="L57">  def max: T = bins.bounds._2</span>
<span class="nc" id="L58">  def bounds: (T, T) = bins.bounds</span>
<span class="nc" id="L59">  def bounds(i: Int): (T, T) = bins.bounds(i)</span>
<span class="nc" id="L60">  def medianValue(i: Int): T = bins.medianValue(i)</span>

  /**
    * Copies another histogram into this one. In comparison to +=, this method will preserve the
    * current bounds and length.
    *
    * @param other other histogram
    */
  def addCountsFrom(other: Histogram[T]): Unit = {
<span class="nc bnc" id="L69" title="All 8 branches missed.">    if (length == other.length &amp;&amp; bounds == other.bounds) {</span>
<span class="nc" id="L70">      this += other</span>
    } else {
<span class="nc" id="L72">      Histogram.copyInto(bins, other.bins)</span>
    }
  }

  override def observe(sf: SimpleFeature): Unit = {
<span class="nc" id="L77">    val value = sf.getAttribute(i)</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">    if (value != null) {</span>
      try {
<span class="nc" id="L80">        val i = bins.indexOf(value.asInstanceOf[T])</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (i == -1) {</span>
<span class="nc" id="L82">          bins = Histogram.expandBins(value.asInstanceOf[T], bins)</span>
<span class="nc" id="L83">          bins.add(value.asInstanceOf[T])</span>
        } else {
<span class="nc" id="L85">          bins.counts(i) += 1</span>
        }
      } catch {
<span class="nc bnc" id="L88" title="All 2 branches missed.">        case e: Exception =&gt; logger.warn(s&quot;Error observing value '$value': ${e.toString}&quot;)</span>
      }
    }
  }

  override def unobserve(sf: SimpleFeature): Unit = {
<span class="nc" id="L94">    val value = sf.getAttribute(i)</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">    if (value != null) {</span>
      try {
<span class="nc" id="L97">        val i = bins.indexOf(value.asInstanceOf[T])</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (i == -1) {</span>
<span class="nc" id="L99">          bins = Histogram.expandBins(value.asInstanceOf[T], bins)</span>
<span class="nc" id="L100">          bins.add(value.asInstanceOf[T], -1)</span>
        } else {
<span class="nc" id="L102">          bins.counts(i) -= 1</span>
        }
      } catch {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        case e: Exception =&gt; logger.warn(s&quot;Error un-observing value '$value': ${e.toString}&quot;)</span>
      }
    }
  }

  /**
    * Creates a new histogram by combining another histogram with this one.
    * Bounds and length will both be the greater from each histogram.
    */
  override def +(other: Histogram[T]): Histogram[T] = {
<span class="nc" id="L115">    val plus = new Histogram(sft, property, length, bounds)</span>
<span class="nc" id="L116">    plus += this</span>
<span class="nc" id="L117">    plus += other</span>
<span class="nc" id="L118">    plus</span>
  }

  /**
    * Copies another histogram into this one.
    * Current bounds and length will be expanded if necessary.
    */
  override def +=(other: Histogram[T]): Unit = {
<span class="nc bnc" id="L126" title="All 8 branches missed.">    if (length == other.length &amp;&amp; bounds == other.bounds) {</span>
      // hists match - we can just copy counts in directly
<span class="nc" id="L128">      var i = 0</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      while (i &lt; bins.length) {</span>
<span class="nc" id="L130">        bins.counts(i) += other.bins.counts(i)</span>
<span class="nc" id="L131">        i += 1</span>
      }
<span class="nc bnc" id="L133" title="All 2 branches missed.">    } else if (other.isEmpty) {</span>
      // no-op
<span class="nc bnc" id="L135" title="All 2 branches missed.">    } else if (isEmpty) {</span>
      // copy the data from the other histogram
<span class="nc" id="L137">      bins = BinnedArray(other.length, other.bounds)</span>
<span class="nc" id="L138">      var i = 0</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">      while (i &lt; bins.length) {</span>
<span class="nc" id="L140">        bins.counts(i) = other.bins.counts(i)</span>
<span class="nc" id="L141">        i += 1</span>
      }
    } else {
      // figure out the new bounds and size
<span class="nc" id="L145">      val newEndpoints = Histogram.checkEndpoints(bins, other.bins)</span>
<span class="nc" id="L146">      val newLength = math.max(length, other.length)</span>
<span class="nc bnc" id="L147" title="All 8 branches missed.">      if (newEndpoints != bounds || newLength != length) {</span>
        // if the other hist was not 'contained' in this one, we have to re-create the bins
<span class="nc" id="L149">        val newBins = BinnedArray(newLength, newEndpoints)</span>
<span class="nc" id="L150">        Histogram.copyInto(newBins, bins)</span>
<span class="nc" id="L151">        bins = newBins</span>
      }
      // now copy over the other bins
<span class="nc" id="L154">      Histogram.copyInto(bins, other.bins)</span>
    }
  }

  override def toJsonObject: Map[String, Any] = {
<span class="nc" id="L159">    val binSeq = Seq.tabulate(bins.length) { bin =&gt;</span>
<span class="nc" id="L160">      ListMap[String, Any](</span>
<span class="nc" id="L161">        &quot;index&quot;       -&gt; bin,</span>
<span class="nc" id="L162">        &quot;lower-bound&quot; -&gt; bounds(bin)._1,</span>
<span class="nc" id="L163">        &quot;upper-bound&quot; -&gt; bounds(bin)._2,</span>
<span class="nc" id="L164">        &quot;count&quot;       -&gt; bins.counts(bin)</span>
      )
    }
<span class="nc" id="L167">    ListMap(&quot;lower-bound&quot; -&gt; bounds._1, &quot;upper-bound&quot; -&gt; bounds._2, &quot;bins&quot; -&gt; binSeq)</span>
  }

<span class="nc bnc" id="L170" title="All 2 branches missed.">  override def isEmpty: Boolean = bins.counts.forall(_ == 0)</span>

<span class="nc" id="L172">  override def clear(): Unit = bins.clear()</span>

<span class="nc" id="L174">  override def isEquivalent(other: Stat): Boolean = other match {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">    case that: Histogram[T] =&gt;</span>
<span class="nc bnc" id="L176" title="All 12 branches missed.">      property == that.property &amp;&amp; bounds == that.bounds &amp;&amp;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">          java.util.Arrays.equals(bins.counts, that.bins.counts)</span>
<span class="nc" id="L178">    case _ =&gt; false</span>
  }
}

<span class="nc" id="L182">object Histogram {</span>

  /**
    * Takes a single value and creates a range from it. Since the range histogram lower bound has to be
    * strictly less than the upper bound, this lets us use a single value to create a valid histogram.
    *
    * @param value value to buffer
    * @tparam T type of the value
    * @return valid bounds for a histogram
    */
  def buffer[T](value: T): (T, T) = {
    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
<span class="nc" id="L194">    val buf = value match {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      case v: Int    =&gt; (v - 100, v + 100)</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">      case v: Long   =&gt; (v - 100, v + 100)</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">      case v: Float  =&gt; (v - 100, v + 100)</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">      case v: Double =&gt; (v - 100, v + 100)</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      case v: String =&gt; (s&quot;$v$Base36Lowest&quot;, s&quot;$v$Base36Highest&quot;)</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      case v: Date   =&gt; (new Date(v.getTime - 60000), new Date(v.getTime + 60000))</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">      case v: Geometry =&gt;</span>
<span class="nc" id="L202">        val env = v.safeCentroid().buffer(10.0).getEnvelopeInternal</span>
<span class="nc" id="L203">        val min = GeometryUtils.geoFactory.createPoint(new Coordinate(env.getMinX, env.getMinY))</span>
<span class="nc" id="L204">        val max = GeometryUtils.geoFactory.createPoint(new Coordinate(env.getMaxX, env.getMaxY))</span>
<span class="nc" id="L205">        (min, max)</span>
    }
<span class="nc" id="L207">    buf.asInstanceOf[(T, T)]</span>
  }

  /**
   * Checks if 2 values map to the same bin
   *
   * @param o1 object 1
   * @param o2 object 2
   * @param bins number of binds
   * @tparam T type binding
   * @return
   */
  def equivalent[T: ClassTag](o1: T, o2: T, bins: Int): Boolean =
<span class="nc" id="L220">     Try(Binning(bins, (o1, o2))).isFailure // this will fail if the two values map to the same bin</span>

  /**
    * Creates a new binned array that encompasses the new value.
    *
    * Assumes that the value is not already within the bounds for the existing binned array.
    */
  def expandBins[T](value: T, old: BinnedArray[T])(implicit defaults: MinMax.MinMaxDefaults[T],ct: ClassTag[T]): BinnedArray[T] = {
<span class="nc" id="L228">    val min = defaults.min(value, old.bounds._1)</span>
<span class="nc" id="L229">    val max = defaults.max(value, old.bounds._2)</span>
<span class="nc" id="L230">    val bins = BinnedArray[T](old.length, (min, max))</span>
<span class="nc" id="L231">    copyInto(bins, old)</span>
<span class="nc" id="L232">    bins</span>
  }

  /**
    * Gets new endpoints that encompass both arrays. If either array has empty values to start or end, the
    * bounds will be trimmed down to be the start/end of non-empty values.
    */
  def checkEndpoints[T](left: BinnedArray[T], right: BinnedArray[T])(implicit defaults: MinMax.MinMaxDefaults[T]): (T, T) = {
<span class="nc bnc" id="L240" title="All 2 branches missed.">    val (lMin, lMax) = getActualBounds(left)</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">    val (rMin, rMax) = getActualBounds(right)</span>
<span class="nc" id="L242">    (defaults.min(lMin, rMin), defaults.max(lMax, rMax))</span>
  }

  /**
    * Gets the bounds of the array that actually contain values.
    */
  private def getActualBounds[T](bins: BinnedArray[T]): (T, T) = {
<span class="nc bnc" id="L249" title="All 2 branches missed.">    val minIndex = bins.counts.indexWhere(_ != 0)</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    val maxIndex = bins.counts.length - bins.counts.reverse.indexWhere(_ != 0) - 1</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">    val min = if (minIndex &lt;= 0) bins.bounds._1 else bins.bounds(minIndex)._1</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">    val max = if (maxIndex &gt;= bins.counts.length -1) bins.bounds._2 else bins.bounds(maxIndex)._2</span>
<span class="nc" id="L253">    (min, max)</span>
  }

  /**
    * Copies data from one binned array into the other. Arrays are assumed to have different
    * sizes and/or endpoints. If arrays have the same characteristics, this method is
    * needlessly expensive/complicated/inexact.
    */
  def copyInto[T](to: BinnedArray[T], from: BinnedArray[T]): Unit = {
    def toIndex(value: T): Int = {
<span class="nc" id="L263">      val i = to.indexOf(value)</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">      if (i != -1) i else if (to.isBelow(value)) 0 else to.length - 1</span>
    }

<span class="nc" id="L267">    var i = 0</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">    while (i &lt; from.length) {</span>
<span class="nc" id="L269">      val count = from.counts(i)</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">      if (count &gt; 0) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        val (min, max) = from.bounds(i)</span>
<span class="nc" id="L272">        val lo = toIndex(min)</span>
<span class="nc" id="L273">        val hi = toIndex(max)</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (lo == hi) {</span>
<span class="nc" id="L275">          to.counts(lo) += count</span>
        } else {
<span class="nc" id="L277">          val size = hi - lo + 1</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">          require(size &gt; 0,</span>
<span class="nc" id="L279">            s&quot;Error calculating bounds for ${min.getClass.getSimpleName} from ${from.bounds} to ${to.bounds}&quot;)</span>
<span class="nc" id="L280">          val avgCount = count / size</span>
<span class="nc" id="L281">          val remainingCount = count % size</span>
<span class="nc" id="L282">          val mid = lo + (size / 2)</span>
<span class="nc" id="L283">          var j = lo</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">          while (j &lt;= hi) {</span>
<span class="nc" id="L285">            to.counts(j) += avgCount</span>
<span class="nc" id="L286">            j += 1</span>
          }
<span class="nc" id="L288">          to.counts(mid) += remainingCount</span>
        }
      }
<span class="nc" id="L291">      i += 1</span>
    }
  }
<span class="nc" id="L294">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>