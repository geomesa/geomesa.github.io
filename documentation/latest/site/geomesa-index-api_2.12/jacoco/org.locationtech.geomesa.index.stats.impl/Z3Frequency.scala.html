<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Z3Frequency.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">Z3Frequency.scala</span></div><h1>Z3Frequency.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.curve.{BinnedTime, Z3SFC}
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.clearspring.CountMinSketch
import org.locationtech.jts.geom.Geometry

import java.util.Date
import scala.collection.immutable.ListMap

/**
  * Estimates frequency counts at scale. Tracks geometry and date attributes as a single value.
  *
  * @param sft simple feature type
  * @param geom geometry attribute in the sft
  * @param dtg date attribute in the sft
  * @param period time period to use for z index
  * @param precision number of bits of z-index that will be used
  * @param eps (epsilon) with probability at least @see confidence, estimates will be within eps * N
  * @param confidence percent - with probability at least confidence, estimates will be within @see eps * N
  */
<span class="nc bnc" id="L33" title="All 4 branches missed.">class Z3Frequency(</span>
<span class="nc" id="L34">    val sft: SimpleFeatureType,</span>
<span class="nc" id="L35">    val geom: String,</span>
<span class="nc" id="L36">    val dtg: String,</span>
<span class="nc" id="L37">    val period: TimePeriod,</span>
<span class="nc" id="L38">    val precision: Int,</span>
<span class="nc" id="L39">    val eps: Double = 0.005,</span>
<span class="nc" id="L40">    val confidence: Double = 0.95</span>
<span class="nc" id="L41">  ) extends Stat with LazyLogging {</span>

  override type S = Z3Frequency

<span class="nc" id="L45">  private val g = sft.indexOf(geom)</span>
<span class="nc" id="L46">  private val d = sft.indexOf(dtg)</span>

<span class="nc" id="L48">  private val mask = Frequency.getMask(precision)</span>
<span class="nc" id="L49">  private val sfc = Z3SFC(period)</span>
<span class="nc" id="L50">  private val timeToBin = BinnedTime.timeToBinnedTime(period)</span>

<span class="nc" id="L52">  private [stats] val sketches = scala.collection.mutable.Map.empty[Short, CountMinSketch]</span>
<span class="nc" id="L53">  private [stats] def newSketch: CountMinSketch = CountMinSketch(eps, confidence, Frequency.Seed)</span>

  private def toKey(geom: Geometry, dtg: Date): (Short, Long) = {
    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
<span class="nc bnc" id="L57" title="All 2 branches missed.">    val BinnedTime(b, o) = timeToBin(dtg.getTime)</span>
<span class="nc" id="L58">    val centroid = geom.safeCentroid()</span>
<span class="nc" id="L59">    val z = sfc.index(centroid.getX, centroid.getY, o) &amp; mask</span>
<span class="nc" id="L60">    (b, z)</span>
  }

  /**
    * Gets the count for the given values
    *
    * @param geom geometry
    * @param dtg date
    * @return count of the values
    */
  def count(geom: Geometry, dtg: Date): Long = {
<span class="nc bnc" id="L71" title="All 2 branches missed.">    val (bin, z3) = toKey(geom, dtg)</span>
<span class="nc" id="L72">    countDirect(bin, z3)</span>
  }

  /**
    * Gets the count for a time bin and z3. Useful if the values are known ahead of time.
    *
    * @param bin period since the epoch
    * @param z3 z value
    * @return count of the values
    */
<span class="nc" id="L82">  def countDirect(bin: Short, z3: Long): Long = sketches.get(bin).map(_.estimateCount(z3)).getOrElse(0L)</span>

  /**
    * Number of observations in the frequency map
    *
    * @return number of observations
    */
<span class="nc" id="L89">  def size: Long = sketches.values.map(_.size).sum</span>

  /**
    * Split the stat into a separate stat per time bin of z data. Allows for separate handling of the reduced
    * data set.
    *
    * @return
    */
  def splitByTime: Seq[(Short, Z3Frequency)] = {
<span class="nc bnc" id="L98" title="All 2 branches missed.">    sketches.toSeq.map { case (w, sketch) =&gt;</span>
<span class="nc" id="L99">      val freq = new Z3Frequency(sft, geom, dtg, period, precision, eps, confidence)</span>
<span class="nc" id="L100">      freq.sketches.put(w, sketch)</span>
<span class="nc" id="L101">      (w, freq)</span>
    }
  }

  override def observe(sf: SimpleFeature): Unit = {
<span class="nc" id="L106">    val geom = sf.getAttribute(g).asInstanceOf[Geometry]</span>
<span class="nc" id="L107">    val dtg  = sf.getAttribute(d).asInstanceOf[Date]</span>
<span class="nc bnc" id="L108" title="All 4 branches missed.">    if (geom != null &amp;&amp; dtg != null) {</span>
      try {
<span class="nc bnc" id="L110" title="All 2 branches missed.">        val (bin, z3) = toKey(geom, dtg)</span>
<span class="nc" id="L111">        sketches.getOrElseUpdate(bin, newSketch).add(z3, 1L)</span>
      } catch {
<span class="nc bnc" id="L113" title="All 2 branches missed.">        case e: Exception =&gt; logger.warn(s&quot;Error observing geom '$geom' and date '$dtg': ${e.toString}&quot;)</span>
      }
    }
  }

  // no-op
<span class="nc" id="L119">  override def unobserve(sf: SimpleFeature): Unit = {}</span>

  override def +(other: Z3Frequency): Z3Frequency = {
<span class="nc" id="L122">    val plus = new Z3Frequency(sft, geom, dtg, period, precision, eps, confidence)</span>
<span class="nc" id="L123">    plus += this</span>
<span class="nc" id="L124">    plus += other</span>
<span class="nc" id="L125">    plus</span>
  }

  override def +=(other: Z3Frequency): Unit = {
<span class="nc bnc" id="L129" title="All 4 branches missed.">    other.sketches.filter(_._2.size &gt; 0).foreach { case (w, sketch) =&gt;</span>
<span class="nc" id="L130">      sketches.getOrElseUpdate(w, newSketch) += sketch</span>
    }
  }

<span class="nc" id="L134">  override def clear(): Unit = sketches.values.foreach(_.clear())</span>

<span class="nc bnc" id="L136" title="All 2 branches missed.">  override def isEmpty: Boolean = sketches.values.forall(_.size == 0)</span>

  override def toJsonObject: Any = {
<span class="nc bnc" id="L139" title="All 2 branches missed.">    val (e, c) = sketches.values.headOption.map(s =&gt; (s.eps, s.confidence)).getOrElse((0d, 0d))</span>
<span class="nc" id="L140">    ListMap(&quot;eps&quot; -&gt; e, &quot;confidence&quot; -&gt; c, &quot;size&quot; -&gt; size)</span>
  }

  override def isEquivalent(other: Stat): Boolean = {
<span class="nc" id="L144">    other match {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">      case s: Z3Frequency =&gt;</span>
<span class="nc bnc" id="L146" title="All 20 branches missed.">        geom == s.geom &amp;&amp; dtg == s.dtg &amp;&amp; period == s.period &amp;&amp; precision == s.precision &amp;&amp; {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">          val nonEmpty = sketches.filter(_._2.size &gt; 0)</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">          val sNonEmpty = s.sketches.filter(_._2.size &gt; 0)</span>
<span class="nc bnc" id="L149" title="All 8 branches missed.">          nonEmpty.keys == sNonEmpty.keys &amp;&amp; nonEmpty.keys.forall { k =&gt;</span>
<span class="nc" id="L150">            sketches(k).isEquivalent(s.sketches(k))</span>
          }
        }
<span class="nc" id="L153">      case _ =&gt; false</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>