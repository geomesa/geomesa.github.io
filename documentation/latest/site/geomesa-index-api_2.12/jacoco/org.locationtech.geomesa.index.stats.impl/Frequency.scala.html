<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Frequency.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">Frequency.scala</span></div><h1>Frequency.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import com.clearspring.analytics.stream.frequency.IFrequency
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.curve.{BinnedTime, Z2SFC}
import org.locationtech.geomesa.index.stats.Stat
import org.locationtech.geomesa.index.stats.clearspring.CountMinSketch
import org.locationtech.geomesa.zorder.sfcurve.IndexRange
import org.locationtech.jts.geom.Geometry

import java.util.{Date, Locale}
import scala.collection.immutable.ListMap
import scala.reflect.ClassTag

/**
  *  Estimates frequency counts at scale
  *
  * @param sft simple feature type
  * @param property attribute the sketch is being made for
  * @param dtg primary date attribute of the sft, if there is one
  * @param period time period to use for splitting by date
  * @param eps (epsilon) with probability at least @see confidence, estimates will be within eps * N
  * @param confidence percent - with probability at least confidence, estimates will be within @see eps * N
  * @param precision for geometry types, this is the number of bits of z-index to keep (max of 64)
  *                  (note: first 2 bits do not hold any info)
  *                  for date types, this is the number of milliseconds to group for binning
  *                  for number types, this is the number of digits that will be grouped together
  *                  for floating point types, this is the number of decimal places that will be considered
  *                  for string types, this is the number of characters that will be considered
  * @param ct class tag
  * @tparam T type parameter, should match the type binding of the attribute
  */
<span class="nc" id="L42">class Frequency[T](</span>
<span class="nc" id="L43">    val sft: SimpleFeatureType,</span>
<span class="nc" id="L44">    val property: String,</span>
<span class="nc" id="L45">    val dtg: Option[String],</span>
<span class="nc" id="L46">    val period: TimePeriod,</span>
<span class="nc" id="L47">    val precision: Int,</span>
<span class="nc" id="L48">    val eps: Double = 0.005,</span>
<span class="nc" id="L49">    val confidence: Double = 0.95</span>
  )(
<span class="nc" id="L51">    implicit val ct: ClassTag[T]</span>
<span class="nc" id="L52">  ) extends Stat {</span>

  override type S = Frequency[T]

<span class="nc" id="L56">  private val i = sft.indexOf(property)</span>
<span class="nc" id="L57">  private val d = dtg.map(sft.indexOf).getOrElse(-1)</span>

<span class="nc" id="L59">  private [stats] val sketchMap = scala.collection.mutable.Map.empty[Short, CountMinSketch]</span>
<span class="nc" id="L60">  private [stats] def newSketch = CountMinSketch(eps, confidence, Frequency.Seed)</span>
<span class="nc" id="L61">  private val timeToBin = BinnedTime.timeToBinnedTime(period)</span>

<span class="nc" id="L63">  private val addAttribute = Frequency.add[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span>
<span class="nc" id="L64">  private val getCount = Frequency.count[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span>

  /**
    * Gets the time bins covered by this frequency
    *
    * @return
    */
<span class="nc" id="L71">  def timeBins: Seq[Short] = sketchMap.keys.toSeq.sorted</span>

  /**
    * Gets the count for a given value, across all time bins
    *
    * @param value value to consider
    * @return count of the value
    */
<span class="nc bnc" id="L79" title="All 2 branches missed.">  def count(value: T): Long = if (sketchMap.isEmpty) { 0L } else { sketchMap.values.map(getCount(_, value)).sum }</span>

  /**
    * Gets the count for a given value in a particular time bin
    *
    * @param timeBin period since the epoch
    * @param value value to consider
    * @return count of the value
    */
<span class="nc" id="L88">  def count(timeBin: Short, value: T): Long = sketchMap.get(timeBin).map(getCount(_, value)).getOrElse(0L)</span>

  /**
    * Gets the count for a given value, which has already been converted into a string, across all time bins.
    * Useful if you know the string key space ahead of time.
    *
    * @param value value to consider, converted into an appropriate string key
    * @return count of the value
    */
  def countDirect(value: String): Long =
<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (sketchMap.isEmpty) { 0L } else { sketchMap.values.map(_.estimateCount(value)).sum }</span>

  /**
    * Gets the count for a given value, which has already been converted into a string. Useful
    * if you know the string key space ahead of time.
    *
    * @param timeBin period since the epoch
    * @param value value to consider, converted into an appropriate string key
    * @return count of the value
    */
  def countDirect(timeBin: Short, value: String): Long =
<span class="nc" id="L109">    sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span>

  /**
    * Gets the count for a given value, which has already been converted into a long, across all time bins.
    * Useful if you know the long key space ahead of time (e.g. with z-values).
    *
    * @param value value to consider, converted into an appropriate long key
    * @return count of the value
    */
  def countDirect(value: Long): Long =
<span class="nc bnc" id="L119" title="All 2 branches missed.">    if (sketchMap.isEmpty) { 0L } else { sketchMap.values.map(_.estimateCount(value)).sum }</span>

  /**
    * Gets the count for a given value, which has already been converted into a long. Useful
    * if you know the long key space ahead of time (e.g. with z-values).
    *
    * @param timeBin period since the epoch
    * @param value value to consider, converted into an appropriate long key
    * @return count of the value
    */
  def countDirect(timeBin: Short, value: Long): Long =
<span class="nc" id="L130">    sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span>

  /**
    * Number of observations in the frequency map
    *
    * @return number of observations
    */
<span class="nc bnc" id="L137" title="All 2 branches missed.">  def size: Long = if (sketchMap.isEmpty) { 0L } else { sketchMap.values.map(_.size).sum }</span>

  /**
    * Number of observations in the frequency map
    *
    * @return number of observations
    */
<span class="nc" id="L144">  def size(timeBin: Short): Long = sketchMap.get(timeBin).map(_.size).getOrElse(0L)</span>

  /**
    * Split the stat into a separate stat per time bin of z data. Allows for separate handling of the reduced
    * data set.
    *
    * @return
    */
  def splitByTime: Seq[(Short, Frequency[T])] = {
<span class="nc bnc" id="L153" title="All 2 branches missed.">    sketchMap.toSeq.map { case (w, sketch) =&gt;</span>
<span class="nc" id="L154">      val freq = new Frequency[T](sft, property, dtg, period, precision, eps, confidence)</span>
<span class="nc" id="L155">      freq.sketchMap.put(w, sketch)</span>
<span class="nc" id="L156">      (w, freq)</span>
    }
  }

  override def observe(sf: SimpleFeature): Unit = {
<span class="nc" id="L161">    val value = sf.getAttribute(i).asInstanceOf[T]</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (value != null) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">      val timeBin: Short = if (d == -1) { Frequency.DefaultTimeBin } else {</span>
<span class="nc" id="L164">        val dtg = sf.getAttribute(d).asInstanceOf[Date]</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (dtg == null) { Frequency.DefaultTimeBin } else { timeToBin(dtg.getTime).bin }</span>
      }
<span class="nc" id="L167">      addAttribute(sketchMap.getOrElseUpdate(timeBin, newSketch), value)</span>
    }
  }

  // no-op
<span class="nc" id="L172">  override def unobserve(sf: SimpleFeature): Unit = {}</span>

  override def +(other: Frequency[T]): Frequency[T] = {
<span class="nc" id="L175">    val plus = new Frequency[T](sft, property, dtg, period, precision, eps, confidence)</span>
<span class="nc" id="L176">    plus += this</span>
<span class="nc" id="L177">    plus += other</span>
<span class="nc" id="L178">    plus</span>
  }

  override def +=(other: Frequency[T]): Unit = {
<span class="nc bnc" id="L182" title="All 2 branches missed.">    other.sketchMap.foreach { case (w, sketch) =&gt;</span>
<span class="nc" id="L183">      sketchMap.get(w) match {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        case None =&gt; sketchMap.put(w, sketch) // note: sharing a reference now</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        case Some(s) =&gt; s += sketch</span>
      }
    }
  }

<span class="nc" id="L190">  override def clear(): Unit = sketchMap.values.foreach(_.clear())</span>

<span class="nc bnc" id="L192" title="All 6 branches missed.">  override def isEmpty: Boolean = sketchMap.isEmpty || sketchMap.values.forall(_.size == 0)</span>

<span class="nc" id="L194">  override def toJsonObject = ListMap(&quot;epsilon&quot; -&gt; eps, &quot;confidence&quot; -&gt; confidence, &quot;size&quot; -&gt; size)</span>

  override def isEquivalent(other: Stat): Boolean = {
<span class="nc" id="L197">    other match {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">      case s: Frequency[T] =&gt;</span>
<span class="nc bnc" id="L199" title="All 20 branches missed.">        property == s.property &amp;&amp; dtg == s.dtg &amp;&amp; period == s.period &amp;&amp; precision == s.precision &amp;&amp; {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">          val sketches = sketchMap.filter(_._2.size != 0)</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">          val otherSketches = s.sketchMap.filter(_._2.size != 0)</span>
<span class="nc bnc" id="L202" title="All 10 branches missed.">          sketches.keySet == otherSketches.keySet &amp;&amp; sketches.forall {</span>
<span class="nc" id="L203">            case (w, sketch) =&gt; sketch.isEquivalent(otherSketches(w))</span>
          }
        }
<span class="nc" id="L206">      case _ =&gt; false</span>
    }
  }
}

<span class="nc" id="L211">object Frequency {</span>

  // the seed for our frequencies - frequencies can only be combined if they have the same seed.
<span class="nc" id="L214">  val Seed: Int = -27</span>

  // default time bin we use for features without a date
<span class="nc" id="L217">  val DefaultTimeBin: Short = 0</span>

  /**
    * Enumerate all the values contained in a sequence of ranges, using the supplied precision.
    * Because frequency can only do point lookups, this can be used to convert a range into a sequence
    * of points.
    *
    * For example, [1, 4] would be converted into Seq(1, 2, 3, 4)
    *
    * @param ranges ranges to enumerate
    * @param precision precision of the ranges, in bits [1, 64]
    * @return the enumerated values
    */
<span class="nc" id="L230">  def enumerate(ranges: Seq[IndexRange], precision: Long): Iterator[Long] = {</span>
<span class="nc" id="L231">    val shift = 64 - precision</span>
<span class="nc" id="L232">    ranges.toIterator.flatMap { r =&gt;</span>
<span class="nc" id="L233">      val c = (r.upper &gt;&gt; shift) - (r.lower &gt;&gt; shift)</span>
<span class="nc" id="L234">      new Iterator[Long] {</span>
<span class="nc" id="L235">        var i = 0L</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        override def hasNext: Boolean = i &lt;= c</span>
<span class="nc" id="L237">        override def next(): Long = try { r.lower + (i &lt;&lt; shift) } finally { i += 1 }</span>
      }
    }
  }

  private def add[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Unit = {
<span class="nc bnc" id="L243" title="All 2 branches missed.">    if (classOf[Geometry].isAssignableFrom(clas)) {</span>
<span class="nc" id="L244">      val mask = getMask(precision)</span>
<span class="nc" id="L245">      (sketch, value) =&gt; sketch.add(geomToKey(value.asInstanceOf[Geometry], mask), 1L)</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    } else if (classOf[Date].isAssignableFrom(clas)) {</span>
<span class="nc" id="L247">      (sketch, value) =&gt; sketch.add(dateToKey(value.asInstanceOf[Date], precision), 1L)</span>
<span class="nc bnc" id="L248" title="All 6 branches missed.">    } else if (clas == classOf[String]) {</span>
<span class="nc" id="L249">      (sketch, value) =&gt; sketch.add(stringToKey(value.asInstanceOf[String], precision), 1L)</span>
<span class="nc bnc" id="L250" title="All 6 branches missed.">    } else if (clas == classOf[java.lang.Long]) {</span>
<span class="nc" id="L251">      (sketch, value) =&gt; sketch.add(longToKey(value.asInstanceOf[Long], precision), 1L)</span>
<span class="nc bnc" id="L252" title="All 6 branches missed.">    } else if (clas == classOf[Integer]) {</span>
<span class="nc" id="L253">      (sketch, value) =&gt; sketch.add(intToKey(value.asInstanceOf[Int], precision), 1L)</span>
<span class="nc bnc" id="L254" title="All 6 branches missed.">    } else if (clas == classOf[java.lang.Float]) {</span>
<span class="nc" id="L255">      (sketch, value) =&gt; sketch.add(floatToKey(value.asInstanceOf[Float], precision), 1L)</span>
<span class="nc bnc" id="L256" title="All 6 branches missed.">    } else if (clas == classOf[java.lang.Double]) {</span>
<span class="nc" id="L257">      (sketch, value) =&gt; sketch.add(doubleToKey(value.asInstanceOf[Double], precision), 1L)</span>
    } else {
<span class="nc" id="L259">      throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span>
    }
  }

  private def count[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Long = {
<span class="nc bnc" id="L264" title="All 2 branches missed.">    if (classOf[Geometry].isAssignableFrom(clas)) {</span>
<span class="nc" id="L265">      val mask = getMask(precision)</span>
<span class="nc" id="L266">      (sketch, value) =&gt; sketch.estimateCount(geomToKey(value.asInstanceOf[Geometry], mask))</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">    } else if (classOf[Date].isAssignableFrom(clas)) {</span>
<span class="nc" id="L268">      (sketch, value) =&gt; sketch.estimateCount(dateToKey(value.asInstanceOf[Date], precision))</span>
<span class="nc bnc" id="L269" title="All 6 branches missed.">    } else if (clas == classOf[String]) {</span>
<span class="nc" id="L270">      (sketch, value) =&gt; sketch.estimateCount(stringToKey(value.asInstanceOf[String], precision))</span>
<span class="nc bnc" id="L271" title="All 6 branches missed.">    } else if (clas == classOf[java.lang.Long]) {</span>
<span class="nc" id="L272">      (sketch, value) =&gt; sketch.estimateCount(longToKey(value.asInstanceOf[Long], precision))</span>
<span class="nc bnc" id="L273" title="All 6 branches missed.">    } else if (clas == classOf[Integer]) {</span>
<span class="nc" id="L274">      (sketch, value) =&gt; sketch.estimateCount(intToKey(value.asInstanceOf[Int], precision))</span>
<span class="nc bnc" id="L275" title="All 6 branches missed.">    } else if (clas == classOf[java.lang.Float]) {</span>
<span class="nc" id="L276">      (sketch, value) =&gt; sketch.estimateCount(floatToKey(value.asInstanceOf[Float], precision))</span>
<span class="nc bnc" id="L277" title="All 6 branches missed.">    } else if (clas == classOf[java.lang.Double]) {</span>
<span class="nc" id="L278">      (sketch, value) =&gt; sketch.estimateCount(doubleToKey(value.asInstanceOf[Double], precision))</span>
    } else {
<span class="nc" id="L280">      throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span>
    }
  }

  // mask for right-zeroing bits
  private [stats] def getMask(precision: Int): Long = {
<span class="nc bnc" id="L286" title="All 4 branches missed.">    require(precision &gt;= 0 &amp;&amp; precision &lt;= 64, &quot;Precision must be in the range [0, 64]&quot;)</span>
<span class="nc" id="L287">    Long.MaxValue &lt;&lt; (64 - precision)</span>
  }

  private [stats] def geomToKey(value: Geometry, mask: Long): Long = {
    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
<span class="nc" id="L292">    val centroid = value.safeCentroid()</span>
<span class="nc" id="L293">    Z2SFC.index(centroid.getX, centroid.getY) &amp; mask</span>
  }

  private [stats] def stringToKey(value: String, precision: Int): String = {
<span class="nc bnc" id="L297" title="All 2 branches missed.">    if (value.length &gt; precision) {</span>
<span class="nc" id="L298">      value.substring(0, precision).toLowerCase(Locale.US)</span>
    } else {
<span class="nc" id="L300">      value.toLowerCase(Locale.US)</span>
    }
  }
<span class="nc" id="L303">  private [stats] def dateToKey(value: Date, precision: Int): Long = value.getTime / precision</span>
<span class="nc" id="L304">  private [stats] def longToKey(value: Long, precision: Int): Long = value / precision</span>
<span class="nc" id="L305">  private [stats] def intToKey(value: Int, precision: Int): Long = value / precision</span>
<span class="nc" id="L306">  private [stats] def floatToKey(value: Float, precision: Int): Long = math.round(value * precision)</span>
<span class="nc" id="L307">  private [stats] def doubleToKey(value: Double, precision: Int): Long = math.round(value * precision)</span>
<span class="nc" id="L308">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>