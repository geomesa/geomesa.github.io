<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DescriptiveStats.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.stats.impl</a> &gt; <span class="el_source">DescriptiveStats.scala</span></div><h1>DescriptiveStats.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.stats.impl

import org.ejml.data.DMatrixRMaj
import org.ejml.dense.row.CommonOps_DDRM
import org.ejml.simple.SimpleMatrix
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.index.stats.Stat

import scala.Array._
import scala.collection.immutable.ListMap

<span class="nc" id="L20">class DescriptiveStats(val sft: SimpleFeatureType, val properties: Seq[String]) extends Stat with Serializable {</span>

  import DescriptiveStats.{DoubleOps, SimpleMatrixOps, toDMatrixRMaj}

  override type S = DescriptiveStats

<span class="nc" id="L26">  private val indices = properties.map(sft.indexOf).toArray</span>

<span class="nc" id="L28">  private val size = properties.size</span>
<span class="nc" id="L29">  private val size_squared = size * size</span>

<span class="nc" id="L31">  private [stats] var _count = 0L</span>
<span class="nc" id="L32">  private [stats] val _min:  SimpleMatrix = new SimpleMatrix(size, 1)</span>
<span class="nc" id="L33">  private [stats] val _max:  SimpleMatrix = new SimpleMatrix(size, 1)</span>
<span class="nc" id="L34">  private [stats] val _sum:  SimpleMatrix = new SimpleMatrix(size, 1)</span>
<span class="nc" id="L35">  private [stats] val _mean: SimpleMatrix = new SimpleMatrix(size, 1)</span>
<span class="nc" id="L36">  private [stats] val _m2n:  SimpleMatrix = new SimpleMatrix(size, 1)</span>
<span class="nc" id="L37">  private [stats] val _m3n:  SimpleMatrix = new SimpleMatrix(size, 1)</span>
<span class="nc" id="L38">  private [stats] val _m4n:  SimpleMatrix = new SimpleMatrix(size, 1)</span>
<span class="nc" id="L39">  private [stats] val _c2:   SimpleMatrix = new SimpleMatrix(size, size)</span>

<span class="nc" id="L41">  clear()</span>

  override def clear(): Unit = {
<span class="nc" id="L44">    _count = 0L</span>
<span class="nc" id="L45">    CommonOps_DDRM.fill(_min, java.lang.Double.MAX_VALUE)</span>
<span class="nc" id="L46">    CommonOps_DDRM.fill(_max, 0d - java.lang.Double.MAX_VALUE)</span>
<span class="nc" id="L47">    CommonOps_DDRM.fill(_sum, 0d)</span>
<span class="nc" id="L48">    CommonOps_DDRM.fill(_mean, 1d)</span>
<span class="nc" id="L49">    CommonOps_DDRM.fill(_m2n, 0d)</span>
<span class="nc" id="L50">    CommonOps_DDRM.fill(_m3n, 0d)</span>
<span class="nc" id="L51">    CommonOps_DDRM.fill(_m4n, 0d)</span>
<span class="nc" id="L52">    CommonOps_DDRM.fill(_c2, 0d)</span>
  }

  def copyFrom(that: DescriptiveStats): Unit = {
<span class="nc" id="L56">    _count = that._count</span>
<span class="nc" id="L57">    copyTo(_min, that._min)</span>
<span class="nc" id="L58">    copyTo(_max, that._max)</span>
<span class="nc" id="L59">    copyTo(_sum, that._sum)</span>
<span class="nc" id="L60">    copyTo(_mean, that._mean)</span>
<span class="nc" id="L61">    copyTo(_m2n, that._m2n)</span>
<span class="nc" id="L62">    copyTo(_m3n, that._m3n)</span>
<span class="nc" id="L63">    copyTo(_m4n, that._m4n)</span>
<span class="nc" id="L64">    copyTo(_c2, that._c2)</span>
  }

  private def copyTo(to: SimpleMatrix, from: SimpleMatrix): Unit = {
<span class="nc" id="L68">    to.reshape(from.numRows(), from.numCols())</span>
<span class="nc" id="L69">    System.arraycopy(from.data, 0, to.data, 0, from.data.length)</span>
  }

<span class="nc" id="L72">  def count: Long = _count</span>

<span class="nc bnc" id="L74" title="All 2 branches missed.">  def minimum: Array[Double] = (if (isEmpty) _max else _min).getMatrix.asInstanceOf[DMatrixRMaj].data.clone()</span>

<span class="nc bnc" id="L76" title="All 2 branches missed.">  def maximum: Array[Double] = (if (isEmpty) _min else _max).getMatrix.asInstanceOf[DMatrixRMaj].data.clone()</span>

<span class="nc" id="L78">  def bounds: Array[(Double, Double)] = minimum.zip(maximum)</span>

<span class="nc" id="L80">  def sum: Array[Double] = _sum.getMatrix.asInstanceOf[DMatrixRMaj].data.clone()</span>

<span class="nc" id="L82">  def mean: Array[Double] = requireCount(1) { _mean }</span>

<span class="nc" id="L84">  def centralMoment2: Array[Double] = requireCount(1) { _m2n / _count }</span>

<span class="nc" id="L86">  def centralMoment3: Array[Double] = requireCount(1) { _m3n / _count }</span>

<span class="nc" id="L88">  def centralMoment4: Array[Double] = requireCount(1) { _m4n / _count }</span>

<span class="nc" id="L90">  def populationVariance: Array[Double] = requireCount(1) { _m2n / _count }</span>

<span class="nc" id="L92">  def populationStandardDeviation: Array[Double] = requireCount(1) { (_m2n / _count) ** 0.5 }</span>

<span class="nc" id="L94">  def populationSkewness: Array[Double] = requireCount(1) { Math.sqrt(_count) * _m3n / (_m2n ** 1.5)  }</span>

<span class="nc" id="L96">  def populationKurtosis: Array[Double] = requireCount(1) { _m4n * _count / (_m2n ** 2.0) }</span>

<span class="nc" id="L98">  def populationExcessKurtosis: Array[Double] = populationKurtosis.map(_ - 3.0 )</span>

<span class="nc" id="L100">  def sampleVariance: Array[Double] = requireCount(2) { _m2n / (_count - 1) }</span>

<span class="nc" id="L102">  def sampleStandardDeviation: Array[Double] = requireCount(2) { (_m2n / (_count - 1)) ** 0.5 }</span>

<span class="nc" id="L104">  def sampleSkewness: Array[Double] = requireCount(3) {</span>
<span class="nc" id="L105">    _m3n * (_count * Math.sqrt(_count - 1) / (_count - 2)) / (_m2n ** 1.5)</span>
  }

<span class="nc" id="L108">  def sampleKurtosis: Array[Double] = requireCount(4) {</span>
<span class="nc" id="L109">    _m4n * (count * (_count + 1) * (_count - 1) / (_count - 2) / (_count - 3)) / (_m2n ** 2.0)</span>
  }

<span class="nc" id="L112">  def sampleExcessKurtosis: Array[Double] = sampleKurtosis.map(_ - 3.0 )</span>

<span class="nc" id="L114">  def coMoment2: Array[Double] = requireCount(2, size_squared) { _c2 }</span>

<span class="nc" id="L116">  def populationCovariance: Array[Double] = requireCount(2, size_squared) { _c2 / _count }</span>

<span class="nc" id="L118">  def populationCorrelation: Array[Double] = requireCount(2, size_squared) {</span>
<span class="nc" id="L119">    val mn2_sqrt = _m2n ** 0.5; (_c2 / (mn2_sqrt |*| mn2_sqrt.T)).diag(1.0)</span>
  }

<span class="nc" id="L122">  def sampleCovariance: Array[Double] = requireCount(2, size_squared) { _c2 / (_count -1 ) }</span>

  /* population and sample calculations are equal w/ df term cancellation */
<span class="nc" id="L125">  def sampleCorrelation: Array[Double] = populationCorrelation</span>

  // The cast feels sketchy...
<span class="nc" id="L128">  private def requireCount(count: Int, length: Int = size)(op: =&gt; SimpleMatrix): Array[Double] =</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (_count &lt; count) Array.fill(length)(Double.NaN) else op.getMatrix.asInstanceOf[DMatrixRMaj].data.clone()</span>

  override def observe(sf: SimpleFeature): Unit = {
<span class="nc" id="L132">    val values = Array.newBuilder[Double]</span>
<span class="nc" id="L133">    values.sizeHint(indices.length)</span>

<span class="nc" id="L135">    var i = 0</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    while (i &lt; indices.length) {</span>
<span class="nc" id="L137">      sf.getAttribute(indices(i)) match {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        case n: Number =&gt;</span>
<span class="nc" id="L139">          val double = n.doubleValue()</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">          if (double != double) {</span>
<span class="nc" id="L141">            return // NaN, short-circuit evaluation</span>
          }
<span class="nc" id="L143">          values += double</span>

<span class="nc bnc" id="L145" title="All 2 branches missed.">        case null =&gt; return // short-circuit evaluation</span>

<span class="nc" id="L147">        case n =&gt; throw new IllegalArgumentException(s&quot;Not a number: $n&quot;)</span>
      }
<span class="nc" id="L149">      i += 1</span>
    }

<span class="nc" id="L152">    val values_v = new SimpleMatrix(size, 1, true, values.result())</span>

<span class="nc bnc" id="L154" title="All 2 branches missed.">    if (_count &lt; 1) {</span>
<span class="nc" id="L155">      _count = 1</span>
<span class="nc" id="L156">      _min.insertIntoThis(0, 0, values_v)</span>
<span class="nc" id="L157">      _max.insertIntoThis(0, 0, values_v)</span>
<span class="nc" id="L158">      _sum.insertIntoThis(0, 0, values_v)</span>
<span class="nc" id="L159">      _mean.insertIntoThis(0, 0, values_v)</span>
<span class="nc" id="L160">    } else {</span>

<span class="nc" id="L162">      _sum += values_v</span>

<span class="nc" id="L164">      val r = _count</span>
<span class="nc" id="L165">      val n = { _count += 1; _count }</span>
<span class="nc" id="L166">      val n_i = 1d / n</span>

<span class="nc" id="L168">      val delta = values_v - _mean</span>

<span class="nc" id="L170">      val A = delta * n_i</span>
<span class="nc" id="L171">      _mean += A</span>

<span class="nc" id="L173">      _m4n += A * (A * A * delta * r * (n * (n - 3d) + 3d) + A * _m2n * 6d - _m3n * 4d)</span>

<span class="nc" id="L175">      val B = values_v - _mean</span>
<span class="nc" id="L176">      _m3n += A * (B * delta * (n - 2d) - _m2n * 3d)</span>
<span class="nc" id="L177">      _m2n += delta * B</span>


      /* optimize original code (below) by special handling of diagonal and reflection about it
       * _c2 += (delta |*| delta.T * (n_i * r))
       */
<span class="nc" id="L183">      val coef = n_i * r</span>
<span class="nc" id="L184">      var ri = 0</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">      while (ri &lt; size) {</span>
<span class="nc" id="L186">        _c2.set(ri, ri, _m2n.get(ri)) // c2 diagonal is equal to m2n</span>
<span class="nc" id="L187">        val rd = delta.get(ri)</span>
<span class="nc" id="L188">        var ci = ri + 1  // traverse upper diagonal</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        while (ci &lt; size) {</span>
<span class="nc" id="L190">          val c2 = _c2.get(ri, ci) + rd * delta.get(ci) * coef</span>
<span class="nc" id="L191">          _c2.set(ri, ci, c2) // set upper diagonal</span>
<span class="nc" id="L192">          _c2.set(ci, ri, c2) // set lower diagonal</span>
<span class="nc" id="L193">          ci += 1</span>
        }
<span class="nc" id="L195">        ri += 1</span>
      } // c2 update

<span class="nc" id="L198">      var i = 0</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      while (i &lt; size) {</span>
<span class="nc" id="L200">        val v = values_v.get(i)</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (v &gt; _max.get(i)) {</span>
<span class="nc" id="L202">          _max.set(i, v)</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        } else if (v &lt; _min.get(i)) { // 'else if' optimization due to how min/max set when _count == 1 (below)</span>
<span class="nc" id="L204">          _min.set(i, v)</span>
        }
<span class="nc" id="L206">        i += 1</span>
      } // min/max update

    }
  }

<span class="nc" id="L212">  override def unobserve(sf: SimpleFeature): Unit = {}</span>

  override def +(that: DescriptiveStats): DescriptiveStats = {
<span class="nc" id="L215">    val stats = new DescriptiveStats(sft, properties)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (that.isEmpty) {</span>
<span class="nc" id="L217">      stats.copyFrom(this)</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">    } else if (this.isEmpty) {</span>
<span class="nc" id="L219">      stats.copyFrom(that)</span>
    } else {
<span class="nc" id="L221">      stats.copyFrom(this)</span>
<span class="nc" id="L222">      stats += that</span>
    }
<span class="nc" id="L224">    stats</span>
  }

  override def +=(that: DescriptiveStats): Unit = {
<span class="nc bnc" id="L228" title="All 6 branches missed.">    if (this == that)</span>
<span class="nc" id="L229">      return</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (that.isEmpty)</span>
<span class="nc" id="L231">      return</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">    if (this.isEmpty) {</span>
<span class="nc" id="L233">      copyFrom(that)</span>
    } else {

<span class="nc" id="L236">      val n1 = this._count</span>
<span class="nc" id="L237">      val n2 = that._count</span>
<span class="nc" id="L238">      val n1_squared = n1 * n1</span>
<span class="nc" id="L239">      val n2_squared = n2 * n2</span>
<span class="nc" id="L240">      val n_product = n1 * n2</span>
<span class="nc" id="L241">      val n = n1 + n2</span>
<span class="nc" id="L242">      val n_i = 1d / n</span>

<span class="nc" id="L244">      val delta = that._mean - this._mean</span>

<span class="nc" id="L246">      val A = delta * n_i</span>
<span class="nc" id="L247">      val A_squared = A * A</span>

<span class="nc" id="L249">      _m4n += that._m4n +</span>
<span class="nc" id="L250">        n_product * (n1_squared - n_product + n2_squared) * delta * A * A_squared +</span>
<span class="nc" id="L251">        (that._m2n * n1_squared + _m2n * n2_squared) * A_squared * 6d +</span>
<span class="nc" id="L252">        (that._m3n * n1 - _m3n * n2) * A * 4d</span>

<span class="nc" id="L254">      _m3n += that._m3n +</span>
<span class="nc" id="L255">        n_product * (n1 - n2) * delta * A_squared +</span>
<span class="nc" id="L256">        (that._m2n * n1 - _m2n * n2) * A * 3d</span>

<span class="nc" id="L258">      _m2n += that._m2n +</span>
<span class="nc" id="L259">        delta * A * n_product</span>

      /* optimize original code (below) by special handling of diagonal and reflection about it
       * _c2 += (that._c2 + (delta |*| delta.T) * (n_product * n_i))
       */
<span class="nc" id="L264">      val coef = n_product * n_i</span>
<span class="nc" id="L265">      var ri = 0</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">      while (ri &lt; size) {</span>
<span class="nc" id="L267">        _c2.set(ri, ri, _m2n.get(ri)) // c2 diagonal is equal to m2n</span>
<span class="nc" id="L268">        val rd = delta.get(ri)</span>
<span class="nc" id="L269">        var ci = ri + 1 // traverse upper diagonal</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        while (ci &lt; size) {</span>
<span class="nc" id="L271">          val c2 = _c2.get(ri, ci) + that._c2.get(ri,ci) + rd * delta.get(ci) * coef</span>
<span class="nc" id="L272">          _c2.set(ri, ci, c2) // set upper diagonal</span>
<span class="nc" id="L273">          _c2.set(ci, ri, c2) // set lower diagonal</span>
<span class="nc" id="L274">          ci += 1</span>
        }
<span class="nc" id="L276">        ri += 1</span>
      } // c2 update

<span class="nc" id="L279">      _mean += A * n2</span>

<span class="nc" id="L281">      _sum += that._sum</span>

<span class="nc" id="L283">      var i = 0</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">      while (i &lt; size) {</span>
<span class="nc" id="L285">        val min = that._min.get(i)</span>
<span class="nc" id="L286">        val max = that._max.get(i)</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (min &lt; _min.get(i)) {</span>
<span class="nc" id="L288">          _min.set(i, min)</span>
        }
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (max &gt; _max.get(i)) {</span>
<span class="nc" id="L291">          _max.set(i, max)</span>
        }
<span class="nc" id="L293">        i += 1</span>
      }  // min/max update

<span class="nc" id="L296">      _count += that._count</span>
    }
  }

<span class="nc bnc" id="L300" title="All 2 branches missed.">  override def isEmpty: Boolean = _count &lt; 1</span>

<span class="nc" id="L302">  override def isEquivalent(other: Stat): Boolean = other match {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    case that: DescriptiveStats =&gt;</span>
<span class="nc bnc" id="L304" title="All 6 branches missed.">      properties == that.properties &amp;&amp;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        _count  == that._count &amp;&amp;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        _min.isIdenticalWithinTolerances(that._min, 1e-6, 1e-12) &amp;&amp;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        _max.isIdenticalWithinTolerances(that._max, 1e-6, 1e-12) &amp;&amp;</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        _sum.isIdenticalWithinTolerances(that._sum, 1e-6, 1e-12) &amp;&amp;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        _mean.isIdenticalWithinTolerances(that._mean, 1e-6, 1e-12) &amp;&amp;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        _m2n.isIdenticalWithinTolerances(that._m2n, 1e-6, 1e-12) &amp;&amp;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        _m3n.isIdenticalWithinTolerances(that._m3n, 1e-6, 1e-12) &amp;&amp;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        _m4n.isIdenticalWithinTolerances(that._m4n, 1e-6, 1e-12) &amp;&amp;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        _c2.isIdenticalWithinTolerances(that._c2, 1e-6, 1e-12)</span>
<span class="nc" id="L314">    case _ =&gt; false</span>
  }

  override def toJsonObject: Map[String, Any] =
<span class="nc bnc" id="L318" title="All 2 branches missed.">    if (isEmpty) {</span>
<span class="nc" id="L319">      Map(&quot;count&quot; -&gt; 0)</span>
    } else {
<span class="nc" id="L321">      ListMap(</span>
<span class="nc" id="L322">        &quot;count&quot; -&gt; count,</span>
<span class="nc" id="L323">        &quot;minimum&quot; -&gt; minimum,</span>
<span class="nc" id="L324">        &quot;maximum&quot; -&gt; maximum,</span>
<span class="nc" id="L325">        &quot;mean&quot; -&gt; mean,</span>
<span class="nc" id="L326">        &quot;population_variance&quot; -&gt; populationVariance,</span>
<span class="nc" id="L327">        &quot;population_standard_deviation&quot; -&gt; populationStandardDeviation,</span>
<span class="nc" id="L328">        &quot;population_skewness&quot; -&gt; populationSkewness,</span>
<span class="nc" id="L329">        &quot;population_kurtosis&quot; -&gt; populationKurtosis,</span>
<span class="nc" id="L330">        &quot;population_excess_kurtosis&quot; -&gt; populationExcessKurtosis,</span>
<span class="nc" id="L331">        &quot;sample_variance&quot; -&gt; sampleVariance,</span>
<span class="nc" id="L332">        &quot;sample_standard_deviation&quot; -&gt; sampleStandardDeviation,</span>
<span class="nc" id="L333">        &quot;sample_skewness&quot; -&gt; sampleSkewness,</span>
<span class="nc" id="L334">        &quot;sample_kurtosis&quot; -&gt; sampleKurtosis,</span>
<span class="nc" id="L335">        &quot;sample_excess_kurtosis&quot; -&gt; sampleExcessKurtosis,</span>
<span class="nc" id="L336">        &quot;population_covariance&quot; -&gt; populationCovariance,</span>
<span class="nc" id="L337">        &quot;population_correlation&quot; -&gt; populationCorrelation,</span>
<span class="nc" id="L338">        &quot;sample_covariance&quot; -&gt; sampleCovariance,</span>
<span class="nc" id="L339">        &quot;sample_correlation&quot; -&gt; sampleCorrelation</span>
      )
    }
}

<span class="nc" id="L344">object DescriptiveStats {</span>

<span class="nc" id="L346">  private implicit def toDMatrixRMaj(sm: SimpleMatrix): DMatrixRMaj = sm.getMatrix[DMatrixRMaj]</span>

<span class="nc bnc" id="L348" title="All 12 branches missed.">  implicit class SimpleMatrixOps(val a: SimpleMatrix) extends AnyVal {</span>

<span class="nc" id="L350">    def +(b: SimpleMatrix): SimpleMatrix = a.plus(b)</span>

<span class="nc" id="L352">    def +=(b: SimpleMatrix): Unit = CommonOps_DDRM.add[DMatrixRMaj](a, b, a)</span>

<span class="nc" id="L354">    def -(b: SimpleMatrix): SimpleMatrix = a.minus(b)</span>

<span class="nc" id="L356">    def *(b: Double): SimpleMatrix = a.scale(b)</span>
<span class="nc" id="L357">    def *(b: SimpleMatrix): SimpleMatrix = a.elementMult(b)</span>

<span class="nc" id="L359">    def /(b: Double): SimpleMatrix = a.divide(b)</span>
<span class="nc" id="L360">    def /(b: SimpleMatrix): SimpleMatrix = a.elementDiv(b)</span>

<span class="nc" id="L362">    def **(b: Double): SimpleMatrix = a.elementPower(b)</span>

<span class="nc" id="L364">    def diag(v: Double): SimpleMatrix = {</span>
<span class="nc" id="L365">      val m = new SimpleMatrix(a)</span>
<span class="nc" id="L366">      (0 until Math.min(m.getNumRows, m.getNumCols)).foreach(i =&gt; m.set(i, i, v))</span>
<span class="nc" id="L367">      m</span>
    }

<span class="nc" id="L370">    def |*|(b: SimpleMatrix): SimpleMatrix = a.mult(b)</span>

<span class="nc" id="L372">    def T: SimpleMatrix = a.transpose</span>

<span class="nc" id="L374">    def isIdenticalWithinTolerances(b: SimpleMatrix, rel_tol: Double = 1e-9, abs_tol: Double = 1e-15): Boolean = {</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">      if (a.numRows != b.numRows || a.numCols != b.numCols) {</span>
<span class="nc" id="L376">        return false</span>
      }
<span class="nc bnc" id="L378" title="All 4 branches missed.">      require(rel_tol &gt;= 0 &amp;&amp; abs_tol &gt;=0, &quot;Tolerance must be greater than or equal to zero.&quot;)</span>
<span class="nc" id="L379">      val length = a.getNumElements</span>
<span class="nc" id="L380">      var i = 0</span>

<span class="nc bnc" id="L382" title="All 2 branches missed.">      while (i &lt; length) {</span>
<span class="nc" id="L383">        val va = a.get(i)</span>
<span class="nc" id="L384">        val vb = b.get(i)</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        val va_nan = va != va     /* quick NaN test */</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        val vb_nan = vb != vb     /* quick NaN test */</span>
<span class="nc bnc" id="L387" title="All 4 branches missed.">        if (va_nan || vb_nan) {   /* if either NaN */</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">          if (va_nan != vb_nan) { /* then both should be NaN */</span>
<span class="nc" id="L389">            return false</span>
          }
        } else {
<span class="nc" id="L392">          val va_inf = java.lang.Double.isInfinite(va)</span>
<span class="nc" id="L393">          val vb_inf = java.lang.Double.isInfinite(vb)</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">          if (va_inf || vb_inf) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (va != vb) {</span>
<span class="nc" id="L396">              return false</span>
            }
          } else {
            /* check absolute tolerance, important for low magnitude values (0) */
<span class="nc" id="L400">            val diff = Math.abs(va - vb)</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (diff &gt; abs_tol) {</span>
<span class="nc" id="L402">              val va_abs = Math.abs(va)</span>
<span class="nc" id="L403">              val vb_abs = Math.abs(vb)</span>
              /* check relative tolerance, important for high magnitude values */
<span class="nc bnc" id="L405" title="All 2 branches missed.">              if (diff &gt; Math.max(va_abs, vb_abs) * rel_tol) {</span>
<span class="nc" id="L406">                return false</span>
              }
            }
          }
        }
<span class="nc" id="L411">        i += 1</span>
      }
<span class="nc" id="L413">      true</span>
    }
  }

<span class="nc" id="L417">  private implicit class DoubleOps(val a: Double) extends AnyRef {</span>
<span class="nc" id="L418">    def *(b: SimpleMatrix): SimpleMatrix = b.scale(a)</span>
  }
<span class="nc" id="L420">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>