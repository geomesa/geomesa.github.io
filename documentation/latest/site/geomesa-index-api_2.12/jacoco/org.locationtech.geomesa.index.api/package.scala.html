<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>package.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.api</a> &gt; <span class="el_source">package.scala</span></div><h1>package.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index

import org.geotools.api.filter.Filter
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.filter.{FilterHelper, andOption}
import org.locationtech.geomesa.index.utils.{ExplainNull, Explainer}
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.text.StringSerialization

import java.nio.charset.StandardCharsets
import scala.util.control.NonFatal

<span class="nc" id="L21">package object api {</span>

  /**
    * Full key/value pair, for inserts or deletes
    */
  sealed trait RowKeyValue[T] {

    /**
      * Sharing bytes, pulled out from the row key
      *
      * @return
      */
    def sharing: Array[Byte]

    /**
      * Shard bytes, pulled out from the row key
      *
      * @return
      */
    def shard: Array[Byte]

    /**
      * Tier bytes, pulled out from the row key
      *
      * @return
      */
    def tier: Array[Byte]

    /**
      * Feature id bytes, pulled out from the row key
      *
      * @return
      */
    def id: Array[Byte]

    /**
      * Key values
      *
      * @return
      */
    def values: Seq[KeyValue]

    /**
      * Copy the row keys but use new values
      *
      * @param values new values
      * @return
      */
    def copy(values: Seq[KeyValue]): RowKeyValue[T]
  }

  /**
    * Single row key value
    *
    * @param row full binary row value, incorporates the rest of the member variables (except values)
    * @param sharing sharing bytes, pulled out from the row key
    * @param shard shard bytes, pulled out from the row key
    * @param key raw row key value (not including sharing, shard, tier, or id)
    * @param tier tier bytes, pulled out from the row key
    * @param id feature id bytes, pulled out from the row key
    * @param values key values
    */
<span class="nc bnc" id="L83" title="All 10 branches missed.">  case class SingleRowKeyValue[T](row: Array[Byte],</span>
<span class="nc" id="L84">                                  sharing: Array[Byte],</span>
<span class="nc" id="L85">                                  shard: Array[Byte],</span>
<span class="nc" id="L86">                                  key: T,</span>
<span class="nc" id="L87">                                  tier: Array[Byte],</span>
<span class="nc" id="L88">                                  id: Array[Byte],</span>
<span class="nc" id="L89">                                  values: Seq[KeyValue]) extends RowKeyValue[T] {</span>

    override def copy(values: Seq[KeyValue]): SingleRowKeyValue[T] =
<span class="nc" id="L92">      SingleRowKeyValue(row, sharing, shard, key, tier, id, values)</span>

<span class="nc" id="L94">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L95" title="All 10 branches missed.">      case k: SingleRowKeyValue[_] =&gt; java.util.Arrays.equals(row, k.row) &amp;&amp; values == k.values</span>
<span class="nc" id="L96">      case _ =&gt; false</span>
    }

    override def hashCode(): Int =
<span class="nc" id="L100">      Seq(java.util.Arrays.hashCode(row), values.hashCode).foldLeft(0)((a, b) =&gt; 31 * a + b)</span>

    override def toString: String = {
<span class="nc bnc" id="L103" title="All 2 branches missed.">      val tail = if (values.lengthCompare(2) &lt; 0) { s&quot;value=${values.headOption.getOrElse(&quot;&quot;)}&quot; } else {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        values.zipWithIndex.map { case (v, i) =&gt; s&quot;value$i=$v&quot; }.mkString(&quot;,&quot;)</span>
      }
<span class="nc" id="L106">      s&quot;SingleRowKeyValue(row=${ByteArrays.toHex(row)},sharing=${ByteArrays.toHex(sharing)},&quot; +</span>
<span class="nc" id="L107">          s&quot;shard=${ByteArrays.toHex(shard)},key=$key,tier=${ByteArrays.toHex(tier)},id=${ByteArrays.toHex(id)},$tail)&quot;</span>
    }
  }

  /**
    * Multiple rows with common key values
    *
    * @param rows full binary row values, incorporates the rest of the member variables (except values)
    * @param sharing sharing bytes, pulled out from the row key
    * @param shard shard bytes, pulled out from the row key
    * @param keys raw row key values (not including sharing, shard, tier, or id)
    * @param tier tier bytes, pulled out from the row key
    * @param id feature id bytes, pulled out from the row key
    * @param values key values
    */
<span class="nc bnc" id="L122" title="All 10 branches missed.">  case class MultiRowKeyValue[T](rows: Seq[Array[Byte]],</span>
<span class="nc" id="L123">                                 sharing: Array[Byte],</span>
<span class="nc" id="L124">                                 shard: Array[Byte],</span>
<span class="nc" id="L125">                                 keys: Seq[T],</span>
<span class="nc" id="L126">                                 tier: Array[Byte],</span>
<span class="nc" id="L127">                                 id: Array[Byte],</span>
<span class="nc" id="L128">                                 values: Seq[KeyValue]) extends RowKeyValue[T] {</span>

    def split: Seq[SingleRowKeyValue[T]] = {
<span class="nc" id="L131">      val key = keys.iterator</span>
<span class="nc" id="L132">      rows.map(row =&gt; SingleRowKeyValue(row, sharing, shard, key.next, tier, id, values))</span>
    }

    override def copy(values: Seq[KeyValue]): MultiRowKeyValue[T] =
<span class="nc" id="L136">      MultiRowKeyValue(rows, sharing, shard, keys, tier, id, values)</span>

<span class="nc" id="L138">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">      case k: MultiRowKeyValue[_] =&gt;</span>
<span class="nc bnc" id="L140" title="All 8 branches missed.">        rows.length == k.rows.length &amp;&amp; values == k.values &amp;&amp; {</span>
<span class="nc" id="L141">          var i = 0</span>
<span class="nc" id="L142">          var equals = true</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">          while (i &lt; rows.length) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (!java.util.Arrays.equals(rows(i), k.rows(i))) {</span>
<span class="nc" id="L145">              equals = false</span>
<span class="nc" id="L146">              i = rows.length</span>
            } else {
<span class="nc" id="L148">              i += 1</span>
            }
          }
<span class="nc bnc" id="L151" title="All 2 branches missed.">          equals</span>
        }

<span class="nc" id="L154">      case _ =&gt; false</span>
    }

    override def hashCode(): Int =
<span class="nc" id="L158">      (rows.map(java.util.Arrays.hashCode) :+ values.hashCode).foldLeft(0)((a, b) =&gt; 31 * a + b)</span>

    override def toString: String = {
<span class="nc bnc" id="L161" title="All 2 branches missed.">      val tail = if (values.lengthCompare(2) &lt; 0) { s&quot;value=${values.headOption.getOrElse(&quot;&quot;)}&quot; } else {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        values.zipWithIndex.map { case (v, i) =&gt; s&quot;value$i=$v&quot; }.mkString(&quot;,&quot;)</span>
      }
<span class="nc" id="L164">      s&quot;MultiRowKeyValue(rows=${rows.map(ByteArrays.toHex).mkString(&quot;,&quot;)},sharing=${ByteArrays.toHex(sharing)},&quot; +</span>
<span class="nc" id="L165">          s&quot;shard=${ByteArrays.toHex(shard)},keys=${keys.mkString(&quot;,&quot;)},tier=${ByteArrays.toHex(tier)},&quot; +</span>
<span class="nc" id="L166">          s&quot;id=${ByteArrays.toHex(id)},$tail)&quot;</span>
    }
  }

  /**
    * Key value
    *
    * @param cf column family
    * @param cq column qualifier
    * @param vis visibility
    * @param toValue serialized simple feature value (lazily evaluated)
    */
<span class="nc" id="L178">  class KeyValue(val cf: Array[Byte],</span>
<span class="nc" id="L179">                 val cq: Array[Byte],</span>
<span class="nc" id="L180">                 val vis: Array[Byte],</span>
<span class="nc" id="L181">                 toValue: =&gt; Array[Byte]) {</span>

<span class="nc bnc" id="L183" title="All 4 branches missed.">    lazy val value: Array[Byte] = toValue</span>

<span class="nc" id="L185">    private val state = Stream(cf, cq, vis) #::: Stream(value)</span>

<span class="nc" id="L187">    def copy(cf: Array[Byte] = cf, cq: Array[Byte] = cq, vis: Array[Byte] = vis, toValue: =&gt; Array[Byte] = toValue): KeyValue =</span>
<span class="nc" id="L188">      new KeyValue(cf, cq, vis, toValue)</span>

<span class="nc" id="L190">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">      case k: KeyValue =&gt; val iter = k.state.iterator; state.forall(java.util.Arrays.equals(_, iter.next))</span>
<span class="nc" id="L192">      case _ =&gt; false</span>
    }

<span class="nc" id="L195">    override def hashCode(): Int = state.map(java.util.Arrays.hashCode).foldLeft(0)((a, b) =&gt; 31 * a + b)</span>

<span class="nc" id="L197">    override def toString: String = s&quot;KeyValue(cf=${ByteArrays.toHex(cf)},cq=${ByteArrays.toHex(cq)}&quot; +</span>
<span class="nc" id="L198">        s&quot;,vis=${new String(vis, StandardCharsets.UTF_8)},value=${ByteArrays.toHex(value)})&quot;</span>
  }

<span class="nc" id="L201">  object KeyValue {</span>
    def apply(cf: Array[Byte], cq: Array[Byte], vis: Array[Byte], toValue: =&gt; Array[Byte]): KeyValue =
<span class="nc" id="L203">      new KeyValue(cf, cq, vis, toValue)</span>
    def unapply(kv: KeyValue): Option[(Array[Byte], Array[Byte], Array[Byte], Array[Byte])] =
<span class="nc" id="L205">      Some((kv.cf, kv.cq, kv.vis, kv.value))</span>
  }

  /**
    * Ranges, filters, and hints for executing a query
    *
    * @param filter filter strategy
    * @param ranges ranges, as bytes
    * @param keyRanges ranges, as raw values (for columnar data stores)
    * @param tieredKeyRanges tiered ranges, as raw values (for columnar data stores)
    * @param ecql secondary filter not encapsulated in the ranges
    * @param values raw query values (e.g. extracted geometries, dates, etc)
    */
<span class="nc bnc" id="L218" title="All 53 branches missed.">  case class QueryStrategy(</span>
<span class="nc" id="L219">      filter: FilterStrategy,</span>
<span class="nc" id="L220">      ranges: Seq[ByteRange],</span>
<span class="nc" id="L221">      keyRanges: Seq[ScanRange[_]],</span>
<span class="nc" id="L222">      tieredKeyRanges: Seq[ByteRange],</span>
<span class="nc" id="L223">      ecql: Option[Filter],</span>
<span class="nc" id="L224">      values: Option[_]) {</span>
<span class="nc" id="L225">    def index: GeoMesaFeatureIndex[_, _] = filter.index</span>
<span class="nc" id="L226">    def hints: Hints = filter.hints</span>
  }

  /**
   * A query filter split up into a 'primary' that will be used with the given feature index for range planning,
   * and a 'secondary' that is not captured in the ranges.
   *
   * @param index feature index to scan
   * @param primary primary filter used for range generation
   * @param secondary secondary filter not captured in the ranges
   * @param temporal does the filter strategy have a temporal component
   * @param costMultiplier a multiplier to take into account when evaluating the cost of this
   *                 query plan. Values &lt; 1f will prioritize this plan, while values &gt; 1f
   *                 will de-prioritize this plan
   */
<span class="nc bnc" id="L241" title="All 47 branches missed.">  case class FilterStrategy(</span>
<span class="nc" id="L242">      index: GeoMesaFeatureIndex[_, _],</span>
<span class="nc" id="L243">      primary: Option[Filter],</span>
<span class="nc" id="L244">      secondary: Option[Filter],</span>
<span class="nc" id="L245">      temporal: Boolean,</span>
<span class="nc" id="L246">      costMultiplier: Float,</span>
<span class="nc" id="L247">      hints: Hints) {</span>

<span class="nc" id="L249">    private var queryStrategy: QueryStrategy = _</span>

<span class="nc bnc" id="L251" title="All 4 branches missed.">    lazy val filter: Option[Filter] = andOption(primary.toSeq ++ secondary)</span>

<span class="nc" id="L253">    def isFullTableScan: Boolean = primary.isEmpty</span>

<span class="nc bnc" id="L255" title="All 2 branches missed.">    def isPreferredScan: Boolean = costMultiplier &lt; FilterStrategy.PreferredMultiplierThreshold</span>

<span class="nc" id="L257">    def getQueryStrategy(explain: Explainer = ExplainNull): QueryStrategy = synchronized {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">      if (queryStrategy == null) {</span>
<span class="nc" id="L259">        explain.pushLevel(s&quot;Creating query strategy for ${index.identifier}&quot;)</span>
<span class="nc" id="L260">        val start = System.currentTimeMillis()</span>
<span class="nc" id="L261">        queryStrategy = try { index.getQueryStrategy(this, explain) } finally {</span>
<span class="nc" id="L262">          explain(s&quot;Query strategy took ${System.currentTimeMillis() - start}ms&quot;).popLevel()</span>
        }
      } else {
<span class="nc" id="L265">        explain(s&quot;Using cached query strategy for ${index.identifier}&quot;)</span>
      }
<span class="nc" id="L267">      queryStrategy</span>
    }

    override lazy val toString: String =
<span class="nc bnc" id="L271" title="All 4 branches missed.">      s&quot;$index[${primary.map(FilterHelper.toString).getOrElse(&quot;INCLUDE&quot;)}]&quot; +</span>
<span class="nc" id="L272">          s&quot;[${secondary.map(FilterHelper.toString).getOrElse(&quot;None&quot;)}]($costMultiplier)&quot;</span>
  }

<span class="nc" id="L275">  object FilterStrategy {</span>
<span class="nc" id="L276">    val PreferredMultiplierThreshold = 2f</span>
  }

  /**
    * A series of queries required to satisfy a filter - basically split on ORs
    */
<span class="nc bnc" id="L282" title="All 18 branches missed.">  case class FilterPlan(strategies: Seq[FilterStrategy]) {</span>
<span class="nc bnc" id="L283" title="All 4 branches missed.">    override lazy val toString: String = s&quot;FilterPlan[${strategies.mkString(&quot;,&quot;)}]&quot;</span>
  }

  /**
    * Trait for ranges of keys that have been converted into bytes
    */
  sealed trait ByteRange

  // normal range with two endpoints
<span class="nc bnc" id="L292" title="All 17 branches missed.">  case class BoundedByteRange(lower: Array[Byte], upper: Array[Byte]) extends ByteRange</span>
  // special case where a range matches a single row - needs to be handled differently sometimes
<span class="nc bnc" id="L294" title="All 14 branches missed.">  case class SingleRowByteRange(row: Array[Byte]) extends ByteRange</span>

  // the following classes are only returned from `getRangeBytes` if 'tier = true'

  // indicates that the upper bound is unbounded and can't be tiered
<span class="nc bnc" id="L299" title="All 17 branches missed.">  case class LowerBoundedByteRange(lower: Array[Byte], upper: Array[Byte]) extends ByteRange</span>
  // indicates that the lower bound is unbounded and can't be tiered
<span class="nc bnc" id="L301" title="All 17 branches missed.">  case class UpperBoundedByteRange(lower: Array[Byte], upper: Array[Byte]) extends ByteRange</span>
  // indicates that both bounds are unbounded and can't be tiered
<span class="nc bnc" id="L303" title="All 17 branches missed.">  case class UnboundedByteRange(lower: Array[Byte], upper: Array[Byte]) extends ByteRange</span>

<span class="nc" id="L305">  object ByteRange {</span>

    import ByteArrays.ByteOrdering

<span class="nc" id="L309">    val UnboundedLowerRange: Array[Byte] = Array.empty</span>
<span class="nc" id="L310">    val UnboundedUpperRange: Array[Byte] = Array.fill(3)(ByteArrays.MaxByte)</span>

    def min(ranges: Seq[ByteRange]): Array[Byte] = {
<span class="nc bnc" id="L313" title="All 2 branches missed.">      if (ranges.isEmpty) { UnboundedLowerRange } else {</span>
<span class="nc" id="L314">        ranges.collect {</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">          case BoundedByteRange(lo, _) =&gt; lo</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">          case SingleRowByteRange(row) =&gt; row</span>
<span class="nc" id="L317">          case r =&gt; throw new IllegalArgumentException(s&quot;Unexpected range type $r&quot;)</span>
<span class="nc" id="L318">        }.min</span>
      }
    }

    def max(ranges: Seq[ByteRange]): Array[Byte] = {
<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (ranges.isEmpty) { UnboundedUpperRange } else {</span>
<span class="nc" id="L324">        ranges.collect {</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">          case BoundedByteRange(_, hi) =&gt; hi</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">          case SingleRowByteRange(row) =&gt; row</span>
<span class="nc" id="L327">          case r =&gt; throw new IllegalArgumentException(s&quot;Unexpected range type $r&quot;)</span>
<span class="nc" id="L328">        }.max</span>
      }
    }
  }

  /**
    * Ranges of native key objects, that haven't been converted to bytes yet
    *
    * @tparam T key type
    */
<span class="nc" id="L338">  sealed trait ScanRange[T]</span>

  // specialize long to avoid boxing for z2/xz2 index
<span class="nc bnc" id="L341" title="All 19 branches missed.">  case class BoundedRange[@specialized(Long) T](lower: T, upper: T) extends ScanRange[T]</span>
<span class="nc bnc" id="L342" title="All 14 branches missed.">  case class SingleRowRange[T](row: T) extends ScanRange[T]</span>
<span class="nc bnc" id="L343" title="All 14 branches missed.">  case class PrefixRange[T](prefix: T) extends ScanRange[T]</span>
<span class="nc bnc" id="L344" title="All 14 branches missed.">  case class LowerBoundedRange[T](lower: T) extends ScanRange[T]</span>
<span class="nc bnc" id="L345" title="All 14 branches missed.">  case class UpperBoundedRange[T](upper: T) extends ScanRange[T]</span>
<span class="nc bnc" id="L346" title="All 14 branches missed.">  case class UnboundedRange[T](empty: T) extends ScanRange[T]</span>

  /**
    * Trait for simple serialization that can be defined using a Map of strings. Implementations must have
    * a zero-arg constructor to allow for instantiation via reflection
    */
  trait SerializableState {

    /**
      * Initialize an instance after deserialization
      *
      * @param state state
      */
    def init(state: Map[String, String]): Unit

    /**
      * The state used to serialize this instance
      *
      * @return
      */
    def state: Map[String, String]
  }

<span class="nc" id="L369">  object SerializableState {</span>

    /**
      * Serialize an object
      *
      * @param obj object to serialize
      * @return
      */
    def serialize(obj: SerializableState): String =
<span class="nc" id="L378">      s&quot;${obj.getClass.getName},${StringSerialization.encodeMap(obj.state)}&quot;</span>

    /**
      * Deserialize a serialized object
      *
      * @param serialized serialized object
      * @return
      */
    def deserialize[T &lt;: SerializableState](serialized: String): T = {
<span class="nc" id="L387">      try {</span>
<span class="nc" id="L388">        val i = serialized.indexOf(',')</span>
<span class="nc" id="L389">        val instance = Class.forName(serialized.substring(0, i)).newInstance().asInstanceOf[T]</span>
<span class="nc" id="L390">        instance.init(StringSerialization.decodeMap(serialized.substring(i + 1)))</span>
<span class="nc" id="L391">        instance</span>
      } catch {
<span class="nc bnc" id="L393" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new RuntimeException(s&quot;Deserialize error for: $serialized&quot;, e)</span>
      }
    }
  }
<span class="nc" id="L397">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>