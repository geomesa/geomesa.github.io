<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexAdapter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.api</a> &gt; <span class="el_source">IndexAdapter.scala</span></div><h1>IndexAdapter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.api

import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.index.api.IndexAdapter.IndexWriter
import org.locationtech.geomesa.index.api.WritableFeature.FeatureWrapper
import org.locationtech.geomesa.index.conf.ColumnGroups
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.utils.{ExplainNull, Explainer}
import org.locationtech.geomesa.security.VisibilityChecker

import java.io.{Closeable, Flushable}
import java.util.UUID
import scala.util.control.NonFatal

/**
  * Interface between generic methods and back-end specific code
  *
  * @tparam DS data store binding
  */
<span class="nc" id="L28">trait IndexAdapter[DS &lt;: GeoMesaDataStore[DS]] {</span>

<span class="nc" id="L30">  val groups: ColumnGroups = new ColumnGroups()</span>

<span class="nc" id="L32">  val tableNameLimit: Option[Int] = None</span>

  /**
    * Create a table
    *
    * @param index index
    * @param partition table partition
    * @param splits splits
    */
  def createTable(index: GeoMesaFeatureIndex[_, _], partition: Option[String], splits: =&gt; Seq[Array[Byte]]): Unit

  /**
    * Rename a table
    *
    * @param from current table name
    * @param to new table name
    */
  def renameTable(from: String, to: String): Unit

  /**
    * Delete a table
    *
    * @param tables table names
    */
  def deleteTables(tables: Seq[String]): Unit

  /**
    * Truncate a table
    *
    * @param tables tables
    * @param prefix prefix filter, or none for all rows
    */
  def clearTables(tables: Seq[String], prefix: Option[Array[Byte]]): Unit

  /**
    * Writer for the given feature indices
    *
    * @param sft simple feature type
    * @param indices indices
    * @param partition partition to write, if any
    * @return
    */
  def createWriter(
      sft: SimpleFeatureType,
      indices: Seq[GeoMesaFeatureIndex[_, _]],
<span class="nc" id="L77">      partition: Option[String] = None,</span>
<span class="nc" id="L78">      atomic: Boolean = false): IndexWriter</span>

  /**
    * Create a query plan
    *
    * @param strategy strategy
    * @return
    */
  def createQueryPlan(strategy: QueryStrategy): QueryPlan

  /**
   * Gets the cost of running a filter strategy, if possible. The exact values returned do not matter, as long as they
   * are consistent relative to each other
   *
   * @param strategy strategy to evaluate
   * @param explain explainer
   * @return
   */
<span class="nc" id="L96">  def getStrategyCost(strategy: FilterStrategy, explain: Explainer = ExplainNull): Option[Long]</span>
}

<span class="nc" id="L99">object IndexAdapter {</span>

  /**
    * Checks a table name for a max limit. If the table name exceeds the limit, then it will be
    * truncated and a UUID appended. Note that if the limit is less than 34 (one char prefix,
    * an underscore separator, and 32 chars for a UUID), this method will throw an exception
    *
    * @param name desired name
    * @param limit database limit on the length of a table name
    * @return
    */
  @throws[IllegalArgumentException](&quot;Limit does not fit a UUID (34 chars)&quot;)
  def truncateTableName(name: String, limit: Int): String = {
<span class="nc" id="L112">    val offset = limit - 33</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">    if (offset &lt;= 0) {</span>
<span class="nc" id="L114">      throw new IllegalArgumentException(s&quot;Limit is too small to fit a UUID, must be at least 34 chars: $limit&quot;)</span>
    }
<span class="nc" id="L116">    s&quot;${name.substring(0, offset)}_${UUID.randomUUID().toString.replaceAllLiterally(&quot;-&quot;, &quot;&quot;)}&quot;</span>
  }

  trait IndexWriter extends Closeable with Flushable {

    /**
      * Write the feature. This method should ensure that the feature is not partially written, by first
      * validating that all of the indices can index it successfully
      *
      * @param feature feature
      */
    def append(feature: SimpleFeature): Unit

    /**
     * Write the feature, replacing a previous version. This method should ensure that the feature is
     * not partially written, by first validating that all of the indices can index it successfully
     *
     * @param updated new feature
     * @param previous old feature that should be replaced
     */
    def update(updated: SimpleFeature, previous: SimpleFeature): Unit

    /**
      * Delete the feature
      *
      * @param feature feature
      */
    def delete(feature: SimpleFeature): Unit
  }

  /**
   * Writes features to a particular back-end data store implementation
   *
   * @param indices indices being written to
   * @param wrapper creates writable feature
   */
<span class="nc" id="L152">  abstract class BaseIndexWriter[T &lt;: WritableFeature](</span>
      indices: Seq[GeoMesaFeatureIndex[_, _]],
<span class="nc" id="L154">      wrapper: FeatureWrapper[T]</span>
<span class="nc" id="L155">    ) extends IndexWriter {</span>

<span class="nc" id="L157">    private val converters = indices.map(_.createConverter()).toArray</span>
<span class="nc" id="L158">    private val values = Array.ofDim[RowKeyValue[_]](indices.length)</span>
<span class="nc" id="L159">    private val previousValues = Array.ofDim[RowKeyValue[_]](indices.length)</span>

    override def append(feature: SimpleFeature): Unit = {
<span class="nc" id="L162">      val writable = wrapper.wrap(feature)</span>

<span class="nc" id="L164">      try {</span>
<span class="nc" id="L165">        var i = 0</span>
        // calculate all the mutations up front to ensure that there aren't any validation errors
<span class="nc bnc" id="L167" title="All 2 branches missed.">        while (i &lt; converters.length) {</span>
<span class="nc" id="L168">          values(i) = converters(i).convert(writable)</span>
<span class="nc" id="L169">          i +=1</span>
        }
      } catch {
<span class="nc bnc" id="L172" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new IllegalArgumentException(&quot;Error creating keys for insert:&quot;, e)</span>
      }

<span class="nc" id="L175">      append(writable, values)</span>
    }

    override def update(updated: SimpleFeature, previous: SimpleFeature): Unit = {
<span class="nc" id="L179">      val writable = wrapper.wrap(updated)</span>
<span class="nc" id="L180">      val removable = wrapper.wrap(previous)</span>

<span class="nc" id="L182">      try {</span>
<span class="nc" id="L183">        var i = 0</span>
        // calculate all the mutations up front to ensure that there aren't any validation errors
<span class="nc bnc" id="L185" title="All 2 branches missed.">        while (i &lt; converters.length) {</span>
<span class="nc" id="L186">          values(i) = converters(i).convert(writable)</span>
<span class="nc" id="L187">          previousValues(i) = converters(i).convert(removable)</span>
<span class="nc" id="L188">          i +=1</span>
        }
      } catch {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new IllegalArgumentException(&quot;Error creating keys for insert:&quot;, e)</span>
      }

<span class="nc" id="L194">      update(writable, values, removable, previousValues)</span>
    }

    override def delete(feature: SimpleFeature): Unit = {
<span class="nc" id="L198">      val writable = wrapper.wrap(feature, delete = true)</span>

<span class="nc" id="L200">      try {</span>
<span class="nc" id="L201">        var i = 0</span>
        // we assume that all converters will pass as this feature was already written once
<span class="nc bnc" id="L203" title="All 2 branches missed.">        while (i &lt; converters.length) {</span>
<span class="nc" id="L204">          values(i) = converters(i).convert(writable, lenient = true)</span>
<span class="nc" id="L205">          i += 1</span>
        }
      } catch {
<span class="nc bnc" id="L208" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new IllegalArgumentException(&quot;Error creating keys for delete:&quot;, e)</span>
      }

<span class="nc" id="L211">      delete(writable, values)</span>
    }

    /**
      * Write values derived from the feature
      *
      * @param feature feature being written
      * @param values derived values, one per index
      */
    protected def append(feature: T, values: Array[RowKeyValue[_]]): Unit

    /**
     * Write values derived from the feature
     *
     * @param feature feature being written
     * @param values derived values, one per index
     * @param previous the previous feature being updated/replaced
     * @param previousValues derived values for the previous feature
     */
    protected def update(feature: T, values: Array[RowKeyValue[_]], previous: T, previousValues: Array[RowKeyValue[_]]): Unit

    /**
      * Delete values derived from the feature
      *
      * @param feature feature being deleted
      * @param values derived values, one per index
      */
    protected def delete(feature: T, values: Array[RowKeyValue[_]]): Unit
  }

  /**
   * Mixin trait to require visibilities on write
   */
<span class="nc" id="L244">  trait RequiredVisibilityWriter extends IndexWriter with VisibilityChecker {</span>
    abstract override def append(feature: SimpleFeature): Unit = {
<span class="nc" id="L246">      requireVisibilities(feature)</span>
<span class="nc" id="L247">      super.append(feature)</span>
    }
    abstract override def update(feature: SimpleFeature, previous: SimpleFeature): Unit = {
<span class="nc" id="L250">      requireVisibilities(feature)</span>
<span class="nc" id="L251">      super.update(feature, previous)</span>
    }
    abstract override def delete(feature: SimpleFeature): Unit = {
<span class="nc" id="L254">      requireVisibilities(feature)</span>
<span class="nc" id="L255">      super.delete(feature)</span>
    }
  }
<span class="nc" id="L258">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>