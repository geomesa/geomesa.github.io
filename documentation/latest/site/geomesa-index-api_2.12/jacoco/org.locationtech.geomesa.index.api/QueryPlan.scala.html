<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryPlan.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.api</a> &gt; <span class="el_source">QueryPlan.scala</span></div><h1>QueryPlan.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.api

import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.features.kryo.KryoFeatureSerializer
import org.locationtech.geomesa.index.api.QueryPlan.{FeatureReducer, ResultsToFeatures}
import org.locationtech.geomesa.index.iterators.IteratorCache
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.index.utils.Reprojection.QueryReferenceSystems
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType._
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.index.VisibilityLevel

import java.util.Objects
import scala.util.Try

/**
  * Plan for querying a GeoMesaDataStore
  */
trait QueryPlan {

  /**
    * Type of raw results returned from the underlying database
    */
  type Results

  /**
    * Runs the query plan against the underlying database
    *
    * @return
    */
  def scan(): CloseableIterator[Results]

  /**
    * Transform results coming back from a raw scan into features
    *
    * @return
    */
  def resultsToFeatures: ResultsToFeatures[Results]

  /**
    * Optional reduce step for simple features coming back
    *
    * @return
    */
  def reducer: Option[FeatureReducer]

  /**
    * Sort fields and reverse order flags (true flips order to descending, false keeps order as ascending)
    *
    * @return
    */
  def sort: Option[Seq[(String, Boolean)]]

  /**
    * Max features to return from the scan
    *
    * @return
    */
  def maxFeatures: Option[Int]

  /**
    * Geometry projection
    *
    * @return
    */
  def projection: Option[QueryReferenceSystems]

  /**
    * Explains details on how this query plan will be executed
    *
    * @param explainer explainer to use for explanation
    */
  def explain(explainer: Explainer): Unit
}

<span class="nc" id="L85">object QueryPlan {</span>

  /**
   * Query plan that uses a query strategy
   */
<span class="nc" id="L90">  trait QueryStrategyPlan extends QueryPlan {</span>
    def strategy: QueryStrategy
<span class="nc" id="L92">    def filter: FilterStrategy = strategy.filter</span>
  }

  /**
    * Convert scan results to simple features. Must have a zero-arg constructor to allow re-creation from
    * a serialized form.
    *
    * Converters are encouraged to also allow direct instantiation via an alternate constructor, as
    * serialization is generally only used for map/reduce jobs. Similarly, state is encouraged to be
    * lazily evaluated.
    *
    * @tparam T result type
    */
  trait ResultsToFeatures[T] extends SerializableState {

    /**
      * Simple feature type that will be returned from `apply`
      *
      * @return
      */
    def schema: SimpleFeatureType

    /**
      * Convert a result to a feature
      *
      * @param result result
      * @return
      */
    def apply(result: T): SimpleFeature
  }

<span class="nc" id="L123">  object ResultsToFeatures {</span>

    /**
      * Serialize a results to features as a string
      *
      * @param obj object
      * @tparam T result type
      * @return
      */
<span class="nc" id="L132">    def serialize[T](obj: ResultsToFeatures[T]): String = SerializableState.serialize(obj)</span>

    /**
      * Deserialize a results to features from a string
      *
      * @param serialized serialized object
      * @tparam T result type
      * @return
      */
<span class="nc" id="L141">    def deserialize[T](serialized: String): ResultsToFeatures[T] = SerializableState.deserialize(serialized)</span>

    /**
      * Empty results to features used in placeholders - don't invoke `apply` on the result.
      *
      * @tparam T result type
      * @return
      */
<span class="nc" id="L149">    def empty[T]: ResultsToFeatures[T] = EmptyResultsToFeatures.asInstanceOf[ResultsToFeatures[T]]</span>

    /**
      * Identity function
      *
      * @return
      */
<span class="nc" id="L156">    def identity(sft: SimpleFeatureType): ResultsToFeatures[SimpleFeature] = new IdentityResultsToFeatures(sft)</span>

    /**
      * For 'empty' query plans - don't invoke `apply`
      */
<span class="nc" id="L161">    object EmptyResultsToFeatures extends ResultsToFeatures[Void] {</span>
<span class="nc" id="L162">      override val state: Map[String, String] = Map.empty</span>
<span class="nc" id="L163">      override def init(state: Map[String, String]): Unit = {}</span>
<span class="nc" id="L164">      override def schema: SimpleFeatureType = null</span>
<span class="nc" id="L165">      override def apply(result: Void): SimpleFeature = null</span>
    }

    /**
      * Identity function - for situations where features are already deserialized
      *
      * @param sft simple feature type
      */
<span class="nc" id="L173">    class IdentityResultsToFeatures(private var sft: SimpleFeatureType) extends ResultsToFeatures[SimpleFeature] {</span>

<span class="nc" id="L175">      def this() = this(null) // no-arg constructor required for serialization</span>

<span class="nc" id="L177">      override def state: Map[String, String] = Map(</span>
<span class="nc" id="L178">        &quot;name&quot; -&gt; sft.getTypeName,</span>
<span class="nc" id="L179">        &quot;spec&quot; -&gt; SimpleFeatureTypes.encodeType(sft, includeUserData = true)</span>
      )

      override def init(state: Map[String, String]): Unit =
<span class="nc" id="L183">        sft = SimpleFeatureTypes.createType(state(&quot;name&quot;), state(&quot;spec&quot;))</span>

<span class="nc" id="L185">      override def schema: SimpleFeatureType = sft</span>

<span class="nc" id="L187">      override def apply(result: SimpleFeature): SimpleFeature = result</span>

<span class="nc" id="L189">      def canEqual(other: Any): Boolean = other.isInstanceOf[IdentityResultsToFeatures]</span>

<span class="nc" id="L191">      override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L192" title="All 10 branches missed.">        case that: IdentityResultsToFeatures if that.canEqual(this) =&gt; sft == that.sft</span>
<span class="nc" id="L193">        case _ =&gt; false</span>
      }

      override def hashCode(): Int = {
<span class="nc" id="L197">        val state = Seq(sft)</span>
<span class="nc" id="L198">        state.map(Objects.hashCode).foldLeft(0)((a, b) =&gt; 31 * a + b)</span>
      }
    }
  }

  /**
    * Client-side reduce for the results of a scan. Must have a zero-arg constructor to allow re-creation from
    * a serialized form.
    *
    * Reducers are encouraged to also allow direct instantiation via an alternate constructor, as
    * serialization is generally only used for map/reduce jobs. Similarly, state is encouraged to be
    * lazily evaluated.
    */
<span class="nc" id="L211">  trait FeatureReducer extends SerializableState {</span>

    /**
      * Reduce the results of a scan
      *
      * @param features features
      * @return
      */
    def apply(features: CloseableIterator[SimpleFeature]): CloseableIterator[SimpleFeature]

    override def toString: String = {
      // TODO GEOMESA-3035 show local transform state in explain log
<span class="nc" id="L223">      val s = Try(state).getOrElse(Map(&quot;unserializable state&quot; -&gt; &quot;???&quot;))</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">      s&quot;class:${getClass.getSimpleName}, state:{${s.map { case (k, v) =&gt; s&quot;$k=$v&quot; }.mkString(&quot;, &quot;)}}&quot;</span>
    }
  }

<span class="nc" id="L228">  object FeatureReducer {</span>

    /**
      * Serialize a feature reducer
      *
      * @param obj object to serialize
      * @return
      */
<span class="nc" id="L236">    def serialize(obj: FeatureReducer): String = SerializableState.serialize(obj)</span>

    /**
      * Deserialize a feature reducer
      *
      * @param serialized serialized object
      * @return
      */
<span class="nc" id="L244">    def deserialize(serialized: String): FeatureReducer = SerializableState.deserialize(serialized)</span>
  }

  /**
    * Abstract base class for converting the results from a normal feature index
    *
    * @param index index
    * @param sft simple feature type returned from the scan
    * @tparam T result type
    */
<span class="nc" id="L254">  abstract class IndexResultsToFeatures[T](</span>
<span class="nc" id="L255">      protected var index: GeoMesaFeatureIndex[_, _],</span>
<span class="nc" id="L256">      protected var sft: SimpleFeatureType</span>
<span class="nc" id="L257">    ) extends ResultsToFeatures[T] {</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">    protected var serializer: KryoFeatureSerializer = if (index == null) { null } else { createSerializer }</span>

    override def init(state: Map[String, String]): Unit = {
<span class="nc" id="L262">      val spec = state(&quot;spec&quot;)</span>
<span class="nc" id="L263">      sft = SimpleFeatureTypes.createType(state(&quot;name&quot;), spec)</span>
<span class="nc" id="L264">      index = state.get(&quot;isft&quot;) match {</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        case None =&gt; IteratorCache.index(sft, spec, state(&quot;idx&quot;))</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        case Some(isft) =&gt; IteratorCache.index(IteratorCache.sft(isft), isft, state(&quot;idx&quot;))</span>
      }
<span class="nc" id="L268">      serializer = createSerializer</span>
    }

    override def state: Map[String, String] = {
<span class="nc" id="L272">      val base = Map(</span>
<span class="nc" id="L273">        &quot;name&quot; -&gt; sft.getTypeName,</span>
<span class="nc" id="L274">        &quot;spec&quot; -&gt; SimpleFeatureTypes.encodeType(sft, includeUserData = true),</span>
<span class="nc" id="L275">        &quot;idx&quot;  -&gt; index.identifier</span>
      )
<span class="nc bnc" id="L277" title="All 6 branches missed.">      if (index.sft == sft) { base } else {</span>
<span class="nc" id="L278">        base.updated(&quot;isft&quot;, SimpleFeatureTypes.encodeType(index.sft, includeUserData = true))</span>
      }
    }

<span class="nc" id="L282">    override def schema: SimpleFeatureType = sft</span>

    protected def createSerializer: KryoFeatureSerializer = {
<span class="nc bnc" id="L285" title="All 6 branches missed.">      val hasAttributeLevelVis = sft.getVisibilityLevel == VisibilityLevel.Attribute</span>
<span class="nc" id="L286">      val builder = KryoFeatureSerializer.builder(sft)</span>
      // note: attribute level vis are serialized into the user data since they can't be held by a single key
<span class="nc bnc" id="L288" title="All 8 branches missed.">      val toBuild = (index.serializedWithId, hasAttributeLevelVis) match {</span>
<span class="nc bnc" id="L289" title="All 4 branches missed.">        case (true, true)   =&gt; builder.withId.withUserData</span>
<span class="nc bnc" id="L290" title="All 4 branches missed.">        case (true, false)  =&gt; builder.withId.withoutUserData</span>
<span class="nc bnc" id="L291" title="All 4 branches missed.">        case (false, true)  =&gt; builder.withoutId.withUserData</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">        case (false, false) =&gt; builder.withoutId.withoutUserData</span>
      }
<span class="nc" id="L294">      toBuild.build()</span>
    }

<span class="nc" id="L297">    def canEqual(other: Any): Boolean = other.isInstanceOf[IndexResultsToFeatures[T]]</span>

<span class="nc" id="L299">    override def equals(other: Any): Boolean = other match {</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">      case that: IndexResultsToFeatures[T] if that.canEqual(this) =&gt;</span>
<span class="nc bnc" id="L301" title="All 6 branches missed.">        sft == that.sft &amp;&amp; {</span>
<span class="nc bnc" id="L302" title="All 8 branches missed.">          if (index == null) { that.index == null } else if (that.index == null) { false } else {</span>
<span class="nc bnc" id="L303" title="All 12 branches missed.">            index.identifier == that.index.identifier &amp;&amp; index.sft == that.index.sft</span>
          }
        }

<span class="nc" id="L307">      case _ =&gt; false</span>
    }

    override def hashCode(): Int = {
<span class="nc" id="L311">      val state = Seq(index, sft)</span>
<span class="nc" id="L312">      state.map(Objects.hashCode).foldLeft(0)((a, b) =&gt; 31 * a + b)</span>
    }
  }
<span class="nc" id="L315">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>