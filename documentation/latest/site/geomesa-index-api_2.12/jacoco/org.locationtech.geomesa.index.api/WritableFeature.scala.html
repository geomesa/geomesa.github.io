<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WritableFeature.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.api</a> &gt; <span class="el_source">WritableFeature.scala</span></div><h1>WritableFeature.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.api

import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.features.kryo.serialization.IndexValueSerializer
import org.locationtech.geomesa.features.{ScalaSimpleFeature, SimpleFeatureSerializer}
import org.locationtech.geomesa.index.conf.ColumnGroups
import org.locationtech.geomesa.security.SecurityUtils.FEATURE_VISIBILITY
import org.locationtech.geomesa.utils.index.VisibilityLevel

import java.nio.charset.StandardCharsets
import scala.collection.mutable.ArrayBuffer
import scala.util.hashing.MurmurHash3

/**
  * Wraps a simple feature for writing. Usually contains cached values that will be written to multiple indices,
  * to e.g. avoid re-serializing a simple feature multiple times
  */
<span class="nc" id="L26">trait WritableFeature {</span>

  /**
    * Underlying simple feature
    *
    * @return
    */
  def feature: SimpleFeature

  /**
   * Key-value pairs representing this feature
   *
   * @return
   */
  def values: Seq[KeyValue]

  /**
   * Key-value pairs representing this feature, for reduced 'join' indices
   *
   * @return
   */
  def reducedValues: Seq[KeyValue]

  /**
    * Feature ID bytes
    */
  def id: Array[Byte]

  /**
    * Hash of the simple feature ID - can be used for sharding.
    *
    * Note: we could use the idBytes here, but for back compatibility of deletes we don't want to change it
    */
<span class="nc" id="L59">  lazy val idHash: Int = Math.abs(MurmurHash3.stringHash(feature.getID))</span>

  /**
    * Convenience method for getting an attribute from the underlying feature
    *
    * @param i index of the attribute
    * @tparam T type of the attribute
    * @return
    */
<span class="nc" id="L68">  def getAttribute[T](i: Int): T = feature.getAttribute(i).asInstanceOf[T]</span>
}

<span class="nc" id="L71">object WritableFeature {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L75">  private val EmptyBytes = Array.empty[Byte]</span>

  /**
    * Creates a function for wrapping a feature into a WritableFeature
    *
    * @param sft simple feature type
    * @param groups column groups
    * @return
    */
  def wrapper(sft: SimpleFeatureType, groups: ColumnGroups): FeatureWrapper[WritableFeature] = {
<span class="nc" id="L85">    val idSerializer: String =&gt; Array[Byte] = GeoMesaFeatureIndex.idToBytes(sft)</span>
<span class="nc" id="L86">    val serializers: Seq[(Array[Byte], SimpleFeatureSerializer)] = groups.serializers(sft)</span>
<span class="nc" id="L87">    val indexSerializer: SimpleFeatureSerializer = IndexValueSerializer(sft)</span>

<span class="nc" id="L89">    sft.getVisibilityLevel match {</span>
<span class="nc bnc" id="L90" title="All 6 branches missed.">      case VisibilityLevel.Feature =&gt;</span>
<span class="nc" id="L91">        new FeatureLevelFeatureWrapper(serializers, indexSerializer, idSerializer)</span>

<span class="nc bnc" id="L93" title="All 6 branches missed.">      case VisibilityLevel.Attribute =&gt;</span>
<span class="nc bnc" id="L94" title="All 8 branches missed.">        val Seq((colFamily, serializer)) = serializers // there should only be 1</span>
<span class="nc" id="L95">        new AttributeLevelFeatureWrapper(colFamily, serializer, indexSerializer, idSerializer)</span>
    }
  }

  /**
    * Creates a writable feature from a feature
    */
  trait FeatureWrapper[+T &lt;: WritableFeature] {

    /**
      * Create a writable feature
      *
      * @param feature feature
      * @param delete true if the feature is an already written feature that we are deleting
      * @return
      */
<span class="nc" id="L111">    def wrap(feature: SimpleFeature, delete: Boolean = false): T</span>
  }

  /**
   * Wrapper that supports feature-level visibility
   *
   * @param serializers feature serializers, per column group
   * @param indexValueSerializer index value serializer
   * @param idSerializer feature id serializer
   */
<span class="nc" id="L121">  private class FeatureLevelFeatureWrapper(</span>
<span class="nc" id="L122">      serializers: Seq[(Array[Byte], SimpleFeatureSerializer)],</span>
<span class="nc" id="L123">      indexValueSerializer: SimpleFeatureSerializer,</span>
<span class="nc" id="L124">      idSerializer: String =&gt; Array[Byte]</span>
<span class="nc" id="L125">    ) extends FeatureWrapper[WritableFeature] {</span>
    override def wrap(feature: SimpleFeature, delete: Boolean): WritableFeature =
<span class="nc" id="L127">      new FeatureLevelWritableFeature(feature, serializers, indexValueSerializer, idSerializer)</span>
  }

  /**
   * Wrapper that supports attribute-level visibilities
   *
   * @param colFamily attribute vis col family
   * @param serializer serializer
   * @param indexValueSerializer index value serializer
   * @param idSerializer feature id serializer
   */
<span class="nc" id="L138">  private class AttributeLevelFeatureWrapper(</span>
<span class="nc" id="L139">      colFamily: Array[Byte],</span>
<span class="nc" id="L140">      serializer: SimpleFeatureSerializer,</span>
<span class="nc" id="L141">      indexValueSerializer: SimpleFeatureSerializer,</span>
<span class="nc" id="L142">      idSerializer: String =&gt; Array[Byte]</span>
<span class="nc" id="L143">    ) extends FeatureWrapper[WritableFeature] {</span>
    override def wrap(feature: SimpleFeature, delete: Boolean): WritableFeature =
<span class="nc" id="L145">      new AttributeLevelWritableFeature(feature, colFamily, serializer, indexValueSerializer, idSerializer)</span>
  }

  /**
    * Writable feature for feature-level visibilities
    *
    * @param feature simple feature
    * @param serializers serializers, per column group
    * @param idSerializer feature id serializer
    */
<span class="nc bnc" id="L155" title="All 4 branches missed.">  private class FeatureLevelWritableFeature(</span>
<span class="nc" id="L156">      val feature: SimpleFeature,</span>
<span class="nc" id="L157">      serializers: Seq[(Array[Byte], SimpleFeatureSerializer)],</span>
<span class="nc" id="L158">      indexValueSerializer: SimpleFeatureSerializer,</span>
<span class="nc" id="L159">      idSerializer: String =&gt; Array[Byte]</span>
<span class="nc" id="L160">    ) extends WritableFeature {</span>

<span class="nc bnc" id="L162" title="All 4 branches missed.">    private lazy val visibility = {</span>
<span class="nc" id="L163">      val vis = feature.getUserData.get(FEATURE_VISIBILITY).asInstanceOf[String]</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      if (vis == null) { EmptyBytes } else { vis.getBytes(StandardCharsets.UTF_8) }</span>
    }

<span class="nc bnc" id="L167" title="All 4 branches missed.">    private lazy val indexValue = indexValueSerializer.serialize(feature)</span>

<span class="nc bnc" id="L169" title="All 4 branches missed.">    override lazy val id: Array[Byte] = idSerializer.apply(feature.getID)</span>

<span class="nc bnc" id="L171" title="All 6 branches missed.">    override lazy val values: Seq[KeyValue] = serializers.map { case (colFamily, serializer) =&gt;</span>
<span class="nc" id="L172">      KeyValue(colFamily, EmptyBytes, visibility, serializer.serialize(feature))</span>
    }

<span class="nc bnc" id="L175" title="All 4 branches missed.">    override lazy val reducedValues: Seq[KeyValue] = values.map(_.copy(toValue = indexValue))</span>
  }

  /**
    * Writable feature for attribute-level visibilities
    *
    * @param feature simple feature
    * @param colFamily attribute vis col family
    * @param serializer serializer
    * @param idSerializer feature id serializer
    */
<span class="nc bnc" id="L186" title="All 4 branches missed.">  private class AttributeLevelWritableFeature(</span>
<span class="nc" id="L187">      val feature: SimpleFeature,</span>
<span class="nc" id="L188">      colFamily: Array[Byte],</span>
<span class="nc" id="L189">      serializer: SimpleFeatureSerializer,</span>
<span class="nc" id="L190">      indexValueSerializer: SimpleFeatureSerializer,</span>
<span class="nc" id="L191">      idSerializer: String =&gt; Array[Byte]</span>
<span class="nc" id="L192">    ) extends WritableFeature {</span>

<span class="nc bnc" id="L194" title="All 4 branches missed.">    private lazy val indexGroups: Seq[(Array[Byte], Array[Byte], SimpleFeature)] = {</span>
<span class="nc" id="L195">      val attributeCount = feature.getFeatureType.getAttributeCount</span>
<span class="nc" id="L196">      val userData = feature.getUserData.get(FEATURE_VISIBILITY).asInstanceOf[String]</span>
<span class="nc" id="L197">      val grouped = scala.collection.mutable.Map.empty[String, ArrayBuffer[Byte]]</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">      if (userData == null || userData.isEmpty) {</span>
<span class="nc" id="L199">        grouped += &quot;&quot; -&gt; ArrayBuffer.tabulate[Byte](attributeCount)(_.toByte)</span>
<span class="nc" id="L200">      } else {</span>
<span class="nc" id="L201">        val visibilities = userData.split(&quot;,&quot;)</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        require(visibilities.length == feature.getFeatureType.getAttributeCount,</span>
<span class="nc" id="L203">          s&quot;Per-attribute visibilities do not match feature type (${feature.getFeatureType.getAttributeCount} values expected): $userData&quot;)</span>
<span class="nc" id="L204">        var i = 0</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        while (i &lt; visibilities.length) {</span>
<span class="nc" id="L206">          grouped.getOrElseUpdate(visibilities(i), ArrayBuffer.empty[Byte]) += i.toByte</span>
<span class="nc" id="L207">          i += 1</span>
        }
      }
<span class="nc bnc" id="L210" title="All 2 branches missed.">      grouped.toSeq.map { case (vis, builder) =&gt;</span>
<span class="nc" id="L211">        val indices = builder.toArray</span>
<span class="nc" id="L212">        val sf = new ScalaSimpleFeature(feature.getFeatureType, &quot;&quot;)</span>
<span class="nc" id="L213">        indices.foreach(i =&gt; sf.setAttributeNoConvert(i, feature.getAttribute(i)))</span>
<span class="nc" id="L214">        (vis.getBytes(StandardCharsets.UTF_8), indices, sf)</span>
      }
    }

<span class="nc bnc" id="L218" title="All 4 branches missed.">    override lazy val id: Array[Byte] = idSerializer.apply(feature.getID)</span>

<span class="nc bnc" id="L220" title="All 4 branches missed.">    override lazy val values: Seq[KeyValue] =</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">      indexGroups.map { case (vis, indices, sf) =&gt; KeyValue(colFamily, indices, vis, serializer.serialize(sf)) }</span>

<span class="nc bnc" id="L223" title="All 4 branches missed.">    override lazy val reducedValues: Seq[KeyValue] =</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">      indexGroups.map { case (vis, indices, sf) =&gt; KeyValue(colFamily, indices, vis, indexValueSerializer.serialize(sf)) }</span>
  }
<span class="nc" id="L226">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>