<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MergedQueryRunner.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.view</a> &gt; <span class="el_source">MergedQueryRunner.scala</span></div><h1>MergedQueryRunner.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.view

import com.typesafe.scalalogging.LazyLogging
import io.micrometer.core.instrument.Tags
import org.geotools.api.data.{DataStore, FeatureReader, Query, Transaction}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.index.api.QueryPlan
import org.locationtech.geomesa.index.api.QueryPlan.ResultsToFeatures.IdentityResultsToFeatures
import org.locationtech.geomesa.index.api.QueryPlan.{FeatureReducer, ResultsToFeatures}
import org.locationtech.geomesa.index.conf.QueryHints
import org.locationtech.geomesa.index.iterators.ArrowScan.DeltaReducer
import org.locationtech.geomesa.index.iterators.{DensityScan, StatsScan}
import org.locationtech.geomesa.index.planning.LocalQueryRunner._
import org.locationtech.geomesa.index.planning.QueryInterceptor.QueryInterceptorFactory
import org.locationtech.geomesa.index.planning.QueryRunner
import org.locationtech.geomesa.index.stats.HasGeoMesaStats
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.index.utils.Reprojection.QueryReferenceSystems
import org.locationtech.geomesa.index.view.MergedQueryRunner.{MergedQueryPlan, Queryable}
import org.locationtech.geomesa.metrics.micrometer.utils.TagUtils
import org.locationtech.geomesa.utils.bin.BinaryOutputEncoder
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.{SimpleFeatureOrdering, SimpleFeatureTypes}
import org.locationtech.geomesa.utils.iterators.DeduplicatingSimpleFeatureIterator

/**
 * Query runner for merging results from multiple stores
 *
 * @param ds merged data store
 * @param stores delegate stores
 * @param deduplicate deduplicate the results between stores
 * @param parallel run scans in parallel (vs sequentially)
 */
<span class="nc bnc" id="L43" title="All 8 branches missed.">class MergedQueryRunner(</span>
    ds: HasGeoMesaStats,
<span class="nc" id="L45">    stores: Seq[(Queryable, Option[Filter])],</span>
<span class="nc" id="L46">    deduplicate: Boolean,</span>
<span class="nc" id="L47">    parallel: Boolean</span>
<span class="nc" id="L48">  ) extends QueryRunner with LazyLogging {</span>

  import org.locationtech.geomesa.index.conf.QueryHints.RichHints

  // query interceptors are handled by the individual data stores
<span class="nc" id="L53">  override protected val interceptors: QueryInterceptorFactory = QueryInterceptorFactory.empty()</span>

<span class="nc" id="L55">  override protected def tags(typeName: String): Tags = TagUtils.typeNameTag(typeName).and(&quot;store&quot;, &quot;merged&quot;, &quot;catalog&quot;, &quot;&quot;)</span>

  override protected def getQueryPlans(sft: SimpleFeatureType, query: Query, explain: Explainer): Seq[QueryPlan] = {
    // TODO deduplicate arrow, bin, density queries...
<span class="nc" id="L59">    val hints = query.getHints</span>
<span class="nc" id="L60">    val toFeatures = new IdentityResultsToFeatures(hints.getReturnSft)</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">    val plan = if (hints.isArrowQuery) {</span>
<span class="nc" id="L62">      val scan = () =&gt; scanner(sft, query, org.locationtech.geomesa.arrow.ArrowEncodedSft, new ArrowProcessor(_, hints))</span>
<span class="nc" id="L63">      val reducer = new DeltaReducer(hints.getTransformSchema.getOrElse(sft), hints, sorted = false)</span>
<span class="nc" id="L64">      MergedQueryPlan(scan, toFeatures, Some(reducer), hints.getMaxFeatures)</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">    } else if (hints.isBinQuery) {</span>
<span class="nc bnc" id="L66" title="All 4 branches missed.">      if (query.getSortBy != null &amp;&amp; !query.getSortBy.isEmpty) {</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        logger.warn(&quot;Ignoring sort for BIN query&quot;)</span>
      }
<span class="nc" id="L69">      val scan = () =&gt; scanner(sft, query, BinaryOutputEncoder.BinEncodedSft, new BinProcessor(_, hints))</span>
<span class="nc" id="L70">      MergedQueryPlan(scan, toFeatures, None, hints.getMaxFeatures)</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">    } else if (hints.isDensityQuery) {</span>
<span class="nc" id="L72">      val scan = () =&gt; scanner(sft, query, DensityScan.DensitySft, new DensityProcessor(_, hints))</span>
<span class="nc" id="L73">      MergedQueryPlan(scan, toFeatures, None, hints.getMaxFeatures)</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">    } else if (hints.isStatsQuery) {</span>
<span class="nc" id="L75">      val scan = () =&gt; scanner(sft, query, StatsScan.StatsSft, new StatsProcessor(_, hints))</span>
<span class="nc" id="L76">      val reducer = StatsScan.StatsReducer(sft, hints)</span>
<span class="nc" id="L77">      MergedQueryPlan(scan, toFeatures, Some(reducer), hints.getMaxFeatures)</span>
    } else {
      // we assume the delegate stores can handle normal transforms/etc appropriately
<span class="nc" id="L80">      val scanner = () =&gt; {</span>
<span class="nc" id="L81">        val readers = getReaders(sft, query).map(CloseableIterator(_))</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        val deduped = if (deduplicate) {</span>
          // we re-use the feature id cache across readers
<span class="nc" id="L84">          val cache = scala.collection.mutable.HashSet.empty[String]</span>
<span class="nc" id="L85">          readers.map(new DeduplicatingSimpleFeatureIterator(_, cache))</span>
        } else {
<span class="nc" id="L87">          readers</span>
        }
<span class="nc" id="L89">        val sorted = hints.getSortFields match {</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">          case None =&gt; doParallelScan(deduped)</span>
          // the delegate stores should sort their results, so we can sort merge them
<span class="nc bnc" id="L92" title="All 2 branches missed.">          case Some(sort) =&gt; new SortedMergeIterator(deduped)(SimpleFeatureOrdering(hints.getReturnSft, sort))</span>
        }
<span class="nc" id="L94">        sorted</span>
      }
<span class="nc" id="L96">      MergedQueryPlan(scanner, toFeatures, None, hints.getMaxFeatures)</span>
    }
<span class="nc" id="L98">    Seq(plan)</span>
  }

  // query each delegate store
  private def getReaders(sft: SimpleFeatureType, query: Query): Seq[FeatureReader[SimpleFeatureType, SimpleFeature]] = {
<span class="nc bnc" id="L103" title="All 2 branches missed.">    stores.map { case (store, filter) =&gt;</span>
<span class="nc" id="L104">      val copy = new Query(query) // make sure to coy the hints so they aren't shared</span>
      // suppress the reduce step for gm stores so that we can do the merge here
<span class="nc" id="L106">      copy.getHints.put(QueryHints.Internal.SKIP_REDUCE, java.lang.Boolean.TRUE)</span>
<span class="nc" id="L107">      store.getFeatureReader(mergeFilter(sft, copy, filter), Transaction.AUTO_COMMIT)</span>
    }
  }

  private def scanner(
      sft: SimpleFeatureType,
      query: Query,
      encodedType: SimpleFeatureType,
      fallbackProcessor: SimpleFeatureType =&gt; LocalScanProcessor): CloseableIterator[SimpleFeature] = {
<span class="nc" id="L116">    val readers = getReaders(sft, query).map { reader =&gt;</span>
<span class="nc" id="L117">      val schema = reader.getFeatureType</span>
<span class="nc bnc" id="L118" title="All 6 branches missed.">      if (schema == encodedType) {</span>
        // processing has been handled by the store already
<span class="nc" id="L120">        CloseableIterator(reader)</span>
      } else {
        // the store just returned normal features, do the processing here
<span class="nc" id="L123">        val copy = SimpleFeatureTypes.immutable(schema, sft.getUserData) // copy default dtg, etc if necessary</span>
<span class="nc" id="L124">        fallbackProcessor(copy).apply(CloseableIterator(reader))</span>
      }
    }
<span class="nc" id="L127">    doParallelScan(readers)</span>
  }

  private def doParallelScan(readers: Seq[CloseableIterator[SimpleFeature]]): CloseableIterator[SimpleFeature] = {
<span class="nc bnc" id="L131" title="All 2 branches missed.">    if (parallel) {</span>
      // not truly parallel but should kick them all off up front
<span class="nc" id="L133">      readers.foreach(_.hasNext)</span>
    }
<span class="nc" id="L135">    CloseableIterator(readers.iterator).flatMap(i =&gt; i)</span>
  }
}

<span class="nc" id="L139">object MergedQueryRunner {</span>

  trait Queryable {
    def getFeatureReader(q: Query, t: Transaction): FeatureReader[SimpleFeatureType, SimpleFeature]
  }

<span class="nc bnc" id="L145" title="All 18 branches missed.">  case class DataStoreQueryable(ds: DataStore) extends Queryable {</span>
    override def getFeatureReader(q: Query, t: Transaction): FeatureReader[SimpleFeatureType, SimpleFeature] =
<span class="nc" id="L147">      ds.getFeatureReader(q, t)</span>
  }

<span class="nc bnc" id="L150" title="All 39 branches missed.">  case class MergedQueryPlan(</span>
<span class="nc" id="L151">      scanner: () =&gt; CloseableIterator[SimpleFeature],</span>
<span class="nc" id="L152">      resultsToFeatures: ResultsToFeatures[SimpleFeature],</span>
<span class="nc" id="L153">      reducer: Option[FeatureReducer],</span>
<span class="nc" id="L154">      maxFeatures: Option[Int],</span>
<span class="nc" id="L155">    ) extends QueryPlan {</span>
    override type Results = SimpleFeature
<span class="nc" id="L157">    override def sort: Option[Seq[(String, Boolean)]] = None</span>
<span class="nc" id="L158">    override def projection: Option[QueryReferenceSystems] = None</span>
<span class="nc" id="L159">    override def scan(): CloseableIterator[SimpleFeature] = scanner()</span>
    override def explain(explainer: Explainer): Unit = {
<span class="nc" id="L161">      explainer.pushLevel(&quot;MergedQueryPlan:&quot;)</span>
<span class="nc" id="L162">      explainer(s&quot;Reduce: ${reducer.getOrElse(&quot;none&quot;)}&quot;)</span>
<span class="nc" id="L163">      explainer.popLevel()</span>
    }
  }
<span class="nc" id="L166">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>