<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MergedFeatureSourceView.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.view</a> &gt; <span class="el_source">MergedFeatureSourceView.scala</span></div><h1>MergedFeatureSourceView.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.view

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data._
import org.geotools.api.feature.`type`.Name
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.filter.sort.SortBy
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.geometry.jts.ReferencedEnvelope
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureCollection.GeoMesaFeatureVisitingCollection
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureSource.DelegatingResourceInfo
import org.locationtech.geomesa.index.view.MergedFeatureSourceView.MergedQueryCapabilities
import org.locationtech.geomesa.utils.concurrent.CachedThreadPool

import java.awt.RenderingHints.Key
import java.util.Collections
import java.util.concurrent.CopyOnWriteArrayList

/**
  * Feature source for merged data store view
  *
  * @param ds data store
  * @param sources delegate feature sources
 *  @param parallel scan stores in parallel (vs sequentially)
  * @param sft simple feature type
  */
<span class="nc bnc" id="L36" title="All 4 branches missed.">class MergedFeatureSourceView(</span>
<span class="nc" id="L37">    ds: MergedDataStoreView,</span>
<span class="nc" id="L38">    sources: Seq[(SimpleFeatureSource, Option[Filter])],</span>
<span class="nc" id="L39">    parallel: Boolean,</span>
<span class="nc" id="L40">    sft: SimpleFeatureType</span>
<span class="nc" id="L41">  ) extends SimpleFeatureSource with LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc bnc" id="L45" title="All 4 branches missed.">  lazy private val hints = Collections.unmodifiableSet(Collections.emptySet[Key])</span>

<span class="nc bnc" id="L47" title="All 4 branches missed.">  lazy private val capabilities = new MergedQueryCapabilities(sources.map(_._1.getQueryCapabilities))</span>

<span class="nc" id="L49">  override def getSchema: SimpleFeatureType = sft</span>

  override def getCount(query: Query): Int = {
    val total =
<span class="nc bnc" id="L53" title="All 2 branches missed.">      if (parallel) {</span>
        def getSingle(sourceAndFilter: (SimpleFeatureSource, Option[Filter])): Int = {
<span class="nc bnc" id="L55" title="All 2 branches missed.">          val (source, filter) = sourceAndFilter</span>
<span class="nc" id="L56">          source.getCount(mergeFilter(sft, query, filter))</span>
        }
<span class="nc" id="L58">        val results = new CopyOnWriteArrayList[Int]()</span>
<span class="nc" id="L59">        sources.toList.map(s =&gt; CachedThreadPool.submit(() =&gt; results.add(getSingle(s)))).foreach(_.get)</span>
<span class="nc bnc" id="L60" title="All 4 branches missed.">        results.asScala.foldLeft(0)((sum, count) =&gt; if (sum &lt; 0 || count &lt; 0) { -1 } else { sum + count })</span>
      } else {
        // if one of our sources can't get a count (i.e. is negative), give up and return -1
<span class="nc bnc" id="L63" title="All 4 branches missed.">        sources.foldLeft(0) { case (sum, (source, filter)) =&gt;</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">          lazy val count = source.getCount(mergeFilter(sft, query, filter))</span>
<span class="nc bnc" id="L65" title="All 4 branches missed.">          if (sum &lt; 0 || count &lt; 0) { -1 } else { sum + count }</span>
        }
      }
<span class="nc bnc" id="L68" title="All 2 branches missed.">    if (query.isMaxFeaturesUnlimited) {</span>
<span class="nc" id="L69">      total</span>
    } else {
<span class="nc" id="L71">      math.min(total, query.getMaxFeatures)</span>
    }
  }

  override def getBounds: ReferencedEnvelope = {
    def getSingle(sourceAndFilter: (SimpleFeatureSource, Option[Filter])): Option[ReferencedEnvelope] = {
<span class="nc bnc" id="L77" title="All 4 branches missed.">      sourceAndFilter match {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        case (source, None)    =&gt; Option(source.getBounds)</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        case (source, Some(f)) =&gt; Option(source.getBounds(new Query(sft.getTypeName, f)))</span>
      }
    }

<span class="nc bnc" id="L83" title="All 2 branches missed.">    val sourceBounds = if (parallel) {</span>
<span class="nc" id="L84">      val results = new CopyOnWriteArrayList[ReferencedEnvelope]()</span>
<span class="nc" id="L85">      sources.toList.map(s =&gt; CachedThreadPool.submit(() =&gt; getSingle(s).foreach(results.add))).foreach(_.get)</span>
<span class="nc" id="L86">      results.asScala</span>
    } else {
<span class="nc" id="L88">      sources.flatMap(getSingle)</span>
    }

<span class="nc" id="L91">    val bounds = new ReferencedEnvelope(org.locationtech.geomesa.utils.geotools.CRS_EPSG_4326)</span>
<span class="nc" id="L92">    sourceBounds.foreach(bounds.expandToInclude)</span>
<span class="nc" id="L93">    bounds</span>
  }

  override def getBounds(query: Query): ReferencedEnvelope = {
    def getSingle(sourceAndFilter: (SimpleFeatureSource, Option[Filter])): Option[ReferencedEnvelope] =
<span class="nc" id="L98">      Option(sourceAndFilter._1.getBounds(mergeFilter(sft, query, sourceAndFilter._2)))</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">    val sourceBounds = if (parallel) {</span>
<span class="nc" id="L101">      val results = new CopyOnWriteArrayList[ReferencedEnvelope]()</span>
<span class="nc" id="L102">      sources.toList.map(s =&gt; CachedThreadPool.submit(() =&gt; getSingle(s).foreach(results.add))).foreach(_.get)</span>
<span class="nc" id="L103">      results.asScala</span>
    } else {
<span class="nc" id="L105">      sources.flatMap(getSingle)</span>
    }

<span class="nc" id="L108">    val bounds = new ReferencedEnvelope(org.locationtech.geomesa.utils.geotools.CRS_EPSG_4326)</span>
<span class="nc" id="L109">    sourceBounds.foreach(bounds.expandToInclude)</span>
<span class="nc" id="L110">    bounds</span>
  }

<span class="nc" id="L113">  override def getQueryCapabilities: QueryCapabilities = capabilities</span>

<span class="nc" id="L115">  override def getFeatures: SimpleFeatureCollection = getFeatures(Filter.INCLUDE)</span>

<span class="nc" id="L117">  override def getFeatures(filter: Filter): SimpleFeatureCollection = getFeatures(new Query(sft.getTypeName, filter))</span>

<span class="nc" id="L119">  override def getFeatures(query: Query): SimpleFeatureCollection = new MergedFeatureCollection(query)</span>

<span class="nc" id="L121">  override def getName: Name = getSchema.getName</span>

<span class="nc" id="L123">  override def getDataStore: DataStore = ds</span>

<span class="nc" id="L125">  override def getSupportedHints: java.util.Set[Key] = hints</span>

<span class="nc" id="L127">  override def getInfo: ResourceInfo = new DelegatingResourceInfo(this)</span>

<span class="nc" id="L129">  override def addFeatureListener(listener: FeatureListener): Unit = throw new UnsupportedOperationException()</span>

<span class="nc" id="L131">  override def removeFeatureListener(listener: FeatureListener): Unit = throw new UnsupportedOperationException()</span>

  /**
    * Feature collection implementation
    *
    * @param query query
    */
<span class="nc bnc" id="L138" title="All 2 branches missed.">  class MergedFeatureCollection(query: Query)</span>
<span class="nc" id="L139">      extends GeoMesaFeatureVisitingCollection(MergedFeatureSourceView.this, ds.stats, query) {</span>

<span class="nc bnc" id="L141" title="All 4 branches missed.">    private lazy val featureReader = ds.getFeatureReader(sft, Transaction.AUTO_COMMIT, query)</span>

<span class="nc" id="L143">    override def getSchema: SimpleFeatureType = featureReader.schema</span>

<span class="nc" id="L145">    override def reader(): FeatureReader[SimpleFeatureType, SimpleFeature] = featureReader.reader()</span>

<span class="nc" id="L147">    override def getBounds: ReferencedEnvelope = MergedFeatureSourceView.this.getBounds(query)</span>

<span class="nc" id="L149">    override def getCount: Int = MergedFeatureSourceView.this.getCount(query)</span>

    override def size: Int = {
      // note: we shouldn't return -1 here, but we don't return the actual value unless EXACT_COUNT is set
<span class="nc" id="L153">      val count = getCount</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      if (count &lt; 0) { 0 } else { count }</span>
    }
  }
}

<span class="nc" id="L159">object MergedFeatureSourceView {</span>

  /**
    * Query capabilities
    *
    * @param capabilities delegates
    */
<span class="nc" id="L166">  class MergedQueryCapabilities(capabilities: Seq[QueryCapabilities]) extends QueryCapabilities {</span>
<span class="nc" id="L167">    override def isOffsetSupported: Boolean = capabilities.forall(_.isOffsetSupported)</span>
    override def supportsSorting(sortAttributes: SortBy*): Boolean =
<span class="nc" id="L169">      capabilities.forall(_.supportsSorting(sortAttributes: _*))</span>
<span class="nc" id="L170">    override def isReliableFIDSupported: Boolean = capabilities.forall(_.isReliableFIDSupported)</span>
<span class="nc" id="L171">    override def isUseProvidedFIDSupported: Boolean = capabilities.forall(_.isUseProvidedFIDSupported)</span>
<span class="nc" id="L172">    override def isJoiningSupported: Boolean = capabilities.forall(_.isJoiningSupported)</span>
<span class="nc" id="L173">    override def isVersionSupported: Boolean = capabilities.forall(_.isVersionSupported)</span>
  }
<span class="nc" id="L175">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>