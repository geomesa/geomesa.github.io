<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>package.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.view</a> &gt; <span class="el_source">package.scala</span></div><h1>package.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data._
import org.geotools.api.feature.`type`.{GeometryDescriptor, Name}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.geotools.data._
import org.geotools.feature.{AttributeTypeBuilder, FeatureTypes, NameImpl}
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.filter.{Bounds, FilterHelper, FilterValues}
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.{SchemaBuilder, SimpleFeatureTypes}
import org.locationtech.geomesa.utils.io.CloseWithLogging

import java.io.IOException
import java.time.ZonedDateTime

<span class="nc bnc" id="L27" title="All 4 branches missed.">package object view extends LazyLogging {</span>

  import org.locationtech.geomesa.filter.andFilters
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  /**
    * Helper method to merge a filtered data store query
    *
    * @param query query
    * @param filter data store filter
    * @return
    */
  def mergeFilter(sft: SimpleFeatureType, query: Query, filter: Option[Filter]): Query = {
<span class="nc" id="L40">    mergeFilter(sft, query.getFilter, filter) match {</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">      case f if f.eq(query.getFilter) =&gt; query</span>
      case f =&gt;
<span class="nc" id="L43">        val q = new Query(query)</span>
<span class="nc" id="L44">        q.setFilter(f)</span>
<span class="nc" id="L45">        q</span>
    }
  }

  /**
    * Helper method to merge a filtered data store query
    *
    * @param filter filter
    * @param option data store filter
    * @return
    */
  def mergeFilter(sft: SimpleFeatureType, filter: Filter, option: Option[Filter]): Filter = {
<span class="nc" id="L57">    option match {</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">      case None =&gt; filter</span>
<span class="nc bnc" id="L59" title="All 8 branches missed.">      case Some(f) if filter == Filter.INCLUDE =&gt; f</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      case Some(f) =&gt;</span>
        // check for disjoint dates between the store filter and the query filter
<span class="nc" id="L62">        val intersected = sft.getDtgField.flatMap { dtg =&gt;</span>
          // note: don't cache this call, as it can contain things like `currentDate()` that will change per invocation
<span class="nc" id="L64">          Some(FilterHelper.extractIntervals(f, dtg)).filter(_.nonEmpty).flatMap { left =&gt;</span>
<span class="nc" id="L65">            val right = FilterHelper.extractIntervals(filter, dtg)</span>
<span class="nc" id="L66">            val merged = FilterValues.and[Bounds[ZonedDateTime]](Bounds.intersection)(left, right)</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">            if (merged.disjoint) {</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">              logger.debug(s&quot;Suppressing query with filter (${ECQL.toCQL(filter)}) AND (${ECQL.toCQL(f)})&quot;)</span>
<span class="nc" id="L69">              Some(Filter.EXCLUDE)</span>
            } else {
<span class="nc" id="L71">              None</span>
            }
          }
        }
<span class="nc" id="L75">        intersected.getOrElse(andFilters(Seq(filter, f)))</span>
    }
  }

  /**
    * Read only data store - does not support creating/updating/deleting schemas or features
    */
<span class="nc" id="L82">  trait ReadOnlyDataStore extends DataStore {</span>

<span class="nc" id="L84">    private def error = throw new UnsupportedOperationException(&quot;This data store is read-only&quot;)</span>

<span class="nc" id="L86">    override def createSchema(featureType: SimpleFeatureType): Unit = error</span>
<span class="nc" id="L87">    override def updateSchema(typeName: Name, featureType: SimpleFeatureType): Unit = error</span>
<span class="nc" id="L88">    override def updateSchema(typeName: String, featureType: SimpleFeatureType): Unit = error</span>
<span class="nc" id="L89">    override def removeSchema(typeName: Name): Unit = error</span>
<span class="nc" id="L90">    override def removeSchema(typeName: String): Unit = error</span>
<span class="nc" id="L91">    override def getFeatureWriter(typeName: String, transaction: Transaction): SimpleFeatureWriter = error</span>
<span class="nc" id="L92">    override def getFeatureWriter(typeName: String, filter: Filter, transaction: Transaction): SimpleFeatureWriter = error</span>
<span class="nc" id="L93">    override def getFeatureWriterAppend(typeName: String, transaction: Transaction): SimpleFeatureWriter = error</span>
  }

  /**
    * Data store that merges the schemas from multiple delegate stores and presents them as a unified result
    *
    * @param stores delegate stores
    * @param namespace schema namespace
    */
<span class="nc" id="L102">  abstract class MergedDataStoreSchemas(stores: Seq[DataStore], namespace: Option[String])</span>
<span class="nc" id="L103">      extends ReadOnlyDataStore {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L107">    override def getTypeNames: Array[String] = stores.map(_.getTypeNames).reduceLeft(_ intersect _)</span>

    override def getNames: java.util.List[Name] =
<span class="nc" id="L110">      java.util.Arrays.asList(getTypeNames.map(t =&gt; new NameImpl(namespace.orNull, t)): _*)</span>

<span class="nc" id="L112">    override def getSchema(name: Name): SimpleFeatureType = getSchema(name.getLocalPart)</span>

    override def getSchema(typeName: String): SimpleFeatureType = {
<span class="nc" id="L115">      val schemas = stores.map(_.getSchema(typeName))</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">      if (schemas.contains(null)) {</span>
<span class="nc" id="L118">        return null</span>
      }

<span class="nc bnc" id="L121" title="All 2 branches missed.">      lazy val fail = new IOException(&quot;Delegate schemas do not match: &quot; +</span>
<span class="nc" id="L122">          schemas.map(SimpleFeatureTypes.encodeType).mkString(&quot; :: &quot;))</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">      schemas.reduceLeft[SimpleFeatureType] { case (left, right) =&gt;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (left.getAttributeCount != right.getAttributeCount) {</span>
<span class="nc" id="L126">          throw fail</span>
        }
<span class="nc" id="L128">        val builder = new SchemaBuilder()</span>
<span class="nc" id="L129">        val attribute = new AttributeTypeBuilder()</span>

<span class="nc" id="L131">        val leftDescriptors = left.getAttributeDescriptors.iterator()</span>
<span class="nc" id="L132">        val rightDescriptors = right.getAttributeDescriptors.iterator()</span>

<span class="nc bnc" id="L134" title="All 2 branches missed.">        while (leftDescriptors.hasNext) {</span>
<span class="nc" id="L135">          val leftDescriptor = leftDescriptors.next</span>
<span class="nc" id="L136">          val rightDescriptor = rightDescriptors.next</span>
<span class="nc bnc" id="L137" title="All 6 branches missed.">          if (leftDescriptor.getLocalName != rightDescriptor.getLocalName) {</span>
<span class="nc" id="L138">            throw fail</span>
          }
<span class="nc" id="L140">          val leftBinding = leftDescriptor.getType.getBinding</span>
<span class="nc" id="L141">          val rightBinding = rightDescriptor.getType.getBinding</span>
          // determine a common binding if possible, for things like java.sql.TimeStamp vs java.util.Date
<span class="nc bnc" id="L143" title="All 8 branches missed.">          if (leftBinding == rightBinding || leftBinding.isAssignableFrom(rightBinding)) {</span>
<span class="nc" id="L144">            attribute.binding(leftBinding)</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">          } else if (rightBinding.isAssignableFrom(leftBinding)) {</span>
<span class="nc" id="L146">            attribute.binding(rightBinding)</span>
          } else {
<span class="nc" id="L148">            throw fail</span>
          }

          // add the user data from each descriptor so the delegate stores have it if needed
<span class="nc bnc" id="L152" title="All 2 branches missed.">          leftDescriptor.getUserData.asScala.foreach { case (k, v) =&gt; attribute.userData(k, v) }</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">          rightDescriptor.getUserData.asScala.foreach { case (k, v) =&gt; attribute.userData(k, v) }</span>

<span class="nc bnc" id="L155" title="All 4 branches missed.">          Some(leftDescriptor).collect { case g: GeometryDescriptor =&gt; attribute.crs(g.getCoordinateReferenceSystem) }</span>

<span class="nc" id="L157">          builder.addAttribute(attribute.buildDescriptor(leftDescriptor.getLocalName))</span>
        }
<span class="nc" id="L159">        builder.build(namespace.orNull, typeName)</span>
      }
    }

<span class="nc" id="L163">    override def dispose(): Unit = stores.foreach(_.dispose())</span>

    override def getInfo: ServiceInfo = {
<span class="nc" id="L166">      val info = new DefaultServiceInfo()</span>
<span class="nc" id="L167">      info.setDescription(s&quot;Features from ${getClass.getSimpleName}&quot;)</span>
<span class="nc" id="L168">      info.setSchema(FeatureTypes.DEFAULT_NAMESPACE)</span>
<span class="nc" id="L169">      info</span>
    }

<span class="nc" id="L172">    override def getLockingManager: LockingManager = null</span>
  }

  /**
   * Does a sorted merge of already sorted streams
   *
   * @param streams streams, each individually sorted
   * @param ordering ordering
   * @tparam T type bounds
   */
<span class="nc" id="L182">  class SortedMergeIterator[T](streams: Seq[CloseableIterator[T]])(implicit ordering: Ordering[T])</span>
<span class="nc" id="L183">    extends CloseableIterator[T] {</span>

<span class="nc" id="L185">    private val indexedStreams = streams.toIndexedSeq</span>
    // reverse the ordering so we get the head of the queue as the first value
<span class="nc" id="L187">    private val heads = scala.collection.mutable.PriorityQueue.empty[(T, Int)](Ordering.Tuple2(ordering.reverse, Ordering.Int))</span>

<span class="nc" id="L189">    init()</span>

    private def init(): Unit = {
<span class="nc" id="L192">      var i = 0</span>
<span class="nc" id="L193">      streams.foreach { s =&gt;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (s.hasNext) {</span>
<span class="nc" id="L195">          heads += ((s.next, i))</span>
        }
<span class="nc" id="L197">        i += 1</span>
      }
    }

<span class="nc" id="L201">    override def hasNext: Boolean = heads.nonEmpty</span>

    override def next(): T = {
<span class="nc bnc" id="L204" title="All 2 branches missed.">      val (n, i) = heads.dequeue()</span>
<span class="nc" id="L205">      val stream = indexedStreams(i)</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">      if (stream.hasNext) {</span>
<span class="nc" id="L207">        heads += ((stream.next, i))</span>
      }
<span class="nc" id="L209">      n</span>
    }

<span class="nc" id="L212">    override def close(): Unit = CloseWithLogging(streams)</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>