<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttributeFilterStrategy.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.strategies</a> &gt; <span class="el_source">AttributeFilterStrategy.scala</span></div><h1>AttributeFilterStrategy.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.strategies

import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter._
import org.geotools.api.filter.expression.{Expression, PropertyName}
import org.geotools.api.filter.temporal.{After, Before, During, TEquals}
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.filter._
import org.locationtech.geomesa.filter.visitor.FilterExtractingVisitor
import org.locationtech.geomesa.index.api.{FilterStrategy, GeoMesaFeatureIndex}
import org.locationtech.geomesa.utils.index.Cardinality

import java.util.Date

<span class="nc" id="L23">trait AttributeFilterStrategy[T, U] extends GeoMesaFeatureIndex[T, U] {</span>

  import AttributeFilterStrategy.isTemporal
  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

<span class="nc bnc" id="L28" title="All 6 branches missed.">  private val Seq(attribute, tiered @ _*) = attributes</span>
<span class="nc" id="L29">  private val descriptor = sft.getDescriptor(attribute)</span>
<span class="nc" id="L30">  private val isList = descriptor.isList</span>
<span class="nc bnc" id="L31" title="All 2 branches missed.">  private val binding = if (isList) { descriptor.getListType() } else { descriptor.getType.getBinding }</span>

  override def getFilterStrategy(filter: Filter, hints: Hints): Option[FilterStrategy] = {

<span class="nc" id="L35">    val (primary, secondary) =</span>
<span class="nc bnc" id="L36" title="All 2 branches missed.">      FilterExtractingVisitor(filter, attribute, sft, AttributeFilterStrategy.attributeCheck(sft))</span>

<span class="nc" id="L38">    primary.flatMap { extracted =&gt;</span>
<span class="nc" id="L39">      val bounds = FilterHelper.extractAttributeBounds(extracted, attribute, binding)</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">      if (bounds.isEmpty) { None } else {</span>
<span class="nc bnc" id="L41" title="All 4 branches missed.">        val isEquals = bounds.precise &amp;&amp; bounds.forall(_.isEquals)</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">        lazy val secondaryFilterAttributes = tiered.union(secondary.toSeq.flatMap(FilterHelper.propertyNames))</span>
<span class="nc bnc" id="L43" title="All 6 branches missed.">        val temporal = isTemporal(sft, attribute) || (isEquals &amp;&amp; secondaryFilterAttributes.exists(isTemporal(sft, _)))</span>
        val basePriority =
<span class="nc bnc" id="L45" title="All 6 branches missed.">          if (isEquals || (bounds.disjoint &amp;&amp; !isList)) {</span>
<span class="nc" id="L46">            1f // TODO account for secondary index</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">          } else if (!bounds.forall(_.isBounded)) {</span>
<span class="nc" id="L48">            1000f // not null</span>
          } else {
<span class="nc" id="L50">            2.5f // range query</span>
          }
        // prioritize attributes based on cardinality hint
<span class="nc" id="L53">        val priority = descriptor.getCardinality() match {</span>
<span class="nc bnc" id="L54" title="All 6 branches missed.">          case Cardinality.HIGH    =&gt; basePriority / 10f</span>
<span class="nc bnc" id="L55" title="All 6 branches missed.">          case Cardinality.UNKNOWN =&gt; basePriority</span>
<span class="nc bnc" id="L56" title="All 6 branches missed.">          case Cardinality.LOW     =&gt; basePriority * 10f</span>
        }
<span class="nc" id="L58">        Some(FilterStrategy(this, primary, secondary, temporal, priority, hints))</span>
      }
    }
  }
}

<span class="nc" id="L64">object AttributeFilterStrategy {</span>

  /**
    * Checks for attribute filters that we can satisfy using the attribute index strategy
    *
    * @param filter filter to evaluate
    * @return true if we can process it as an attribute query
    */
  def attributeCheck(sft: SimpleFeatureType)(filter: Filter): Boolean = {
<span class="nc" id="L73">    filter match {</span>
<span class="nc bnc" id="L74" title="All 6 branches missed.">      case _: And | _: Or =&gt; true // note: implies further processing of children</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">      case _: PropertyIsEqualTo =&gt; true</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      case _: PropertyIsBetween =&gt; true</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">      case _: PropertyIsGreaterThan | _: PropertyIsLessThan =&gt; true</span>
<span class="nc bnc" id="L78" title="All 6 branches missed.">      case _: PropertyIsGreaterThanOrEqualTo | _: PropertyIsLessThanOrEqualTo =&gt; true</span>
<span class="nc bnc" id="L79" title="All 10 branches missed.">      case _: During |  _: Before | _: After | _: TEquals =&gt; true</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">      case _: PropertyIsNull =&gt; true // we need this to be able to handle 'not null'</span>
<span class="nc bnc" id="L81" title="All 6 branches missed.">      case f: PropertyIsLike =&gt; isStringProperty(sft, f.getExpression) &amp;&amp; likeEligible(f)</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">      case f: Not =&gt; f.getFilter.isInstanceOf[PropertyIsNull]</span>
<span class="nc" id="L83">      case _ =&gt; false</span>
    }
  }

<span class="nc" id="L87">  def isStringProperty(sft: SimpleFeatureType, e: Expression): Boolean = e match {</span>
<span class="nc bnc" id="L88" title="All 8 branches missed.">    case p: PropertyName =&gt; Option(sft.getDescriptor(p.getPropertyName)).exists(_.getType.getBinding == classOf[String])</span>
<span class="nc" id="L89">    case _ =&gt; false</span>
  }

  private def isTemporal(sft: SimpleFeatureType, attribute: String): Boolean =
<span class="nc" id="L93">    classOf[Date].isAssignableFrom(sft.getDescriptor(attribute).getType.getBinding)</span>
<span class="nc" id="L94">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>