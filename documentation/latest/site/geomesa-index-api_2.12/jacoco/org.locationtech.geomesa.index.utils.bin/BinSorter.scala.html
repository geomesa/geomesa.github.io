<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BinSorter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.utils.bin</a> &gt; <span class="el_source">BinSorter.scala</span></div><h1>BinSorter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.utils.bin

import com.typesafe.scalalogging.LazyLogging

/**
  * Sorts aggregated bin arrays
  */
<span class="nc bnc" id="L16" title="All 4 branches missed.">object BinSorter extends LazyLogging {</span>

  /**
    * If the length of an array to be sorted is less than this
    * constant, insertion sort is used in preference to Quicksort.
    *
    * This length is 'logical' length, so the array is really binSize * length
    */
<span class="nc" id="L24">  private val INSERTION_SORT_THRESHOLD = 3</span>

<span class="nc" id="L26">  private val swapBuffers = new ThreadLocal[Array[Byte]]() {</span>
<span class="nc" id="L27">    override def initialValue(): Array[Byte] = Array.ofDim[Byte](24) // the larger bin size</span>
  }

<span class="nc" id="L30">  private val priorityOrdering = new Ordering[(Array[Byte], Int)]() {</span>
    override def compare(x: (Array[Byte], Int), y: (Array[Byte], Int)): Int =
<span class="nc" id="L32">      BinSorter.compare(y._1, y._2, x._1, x._2) // reverse for priority queue</span>
  }

  /**
    * Compares two bin chunks by date
    */
  def compare(left: Array[Byte], leftOffset: Int, right: Array[Byte], rightOffset: Int): Int =
<span class="nc" id="L39">    compareIntLittleEndian(left, leftOffset + 4, right, rightOffset + 4) // offset + 4 is dtg</span>

  /**
    * Comparison based on the integer encoding used by ByteBuffer
    * original code is in private/protected java.nio packages
    */
  private def compareIntLittleEndian(left: Array[Byte],
                                     leftOffset: Int,
                                     right: Array[Byte],
                                     rightOffset: Int): Int = {
<span class="nc" id="L49">    val l3 = left(leftOffset + 3)</span>
<span class="nc" id="L50">    val r3 = right(rightOffset + 3)</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">    if (l3 &lt; r3) {</span>
<span class="nc" id="L52">      return -1</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">    } else if (l3 &gt; r3) {</span>
<span class="nc" id="L54">      return 1</span>
    }
<span class="nc" id="L56">    val l2 = left(leftOffset + 2) &amp; 0xff</span>
<span class="nc" id="L57">    val r2 = right(rightOffset + 2) &amp; 0xff</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">    if (l2 &lt; r2) {</span>
<span class="nc" id="L59">      return -1</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">    } else if (l2 &gt; r2) {</span>
<span class="nc" id="L61">      return 1</span>
    }
<span class="nc" id="L63">    val l1 = left(leftOffset + 1) &amp; 0xff</span>
<span class="nc" id="L64">    val r1 = right(rightOffset + 1) &amp; 0xff</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (l1 &lt; r1) {</span>
<span class="nc" id="L66">      return -1</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    } else if (l1 &gt; r1) {</span>
<span class="nc" id="L68">      return 1</span>
    }
<span class="nc" id="L70">    val l0 = left(leftOffset) &amp; 0xff</span>
<span class="nc" id="L71">    val r0 = right(rightOffset) &amp; 0xff</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">    if (l0 == r0) {</span>
<span class="nc" id="L73">      0</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">    } else if (l0 &lt; r0) {</span>
<span class="nc" id="L75">      -1</span>
    } else {
<span class="nc" id="L77">      1</span>
    }
  }

  /**
    * Takes a sequence of (already sorted) aggregates and combines them in a final sort. Uses
    * a priority queue to compare the head element across each aggregate.
    */
<span class="nc" id="L85">  def mergeSort(aggregates: Iterator[Array[Byte]], binSize: Int): Iterator[(Array[Byte], Int)] = {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    if (aggregates.isEmpty) {</span>
<span class="nc" id="L87">      return Iterator.empty</span>
    }
<span class="nc" id="L89">    val queue = new scala.collection.mutable.PriorityQueue[(Array[Byte], Int)]()(priorityOrdering)</span>
<span class="nc" id="L90">    val sizes = scala.collection.mutable.ArrayBuffer.empty[Int]</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">    while (aggregates.hasNext) {</span>
<span class="nc" id="L92">      val next = aggregates.next()</span>
<span class="nc" id="L93">      sizes.append(next.length / binSize)</span>
<span class="nc" id="L94">      queue.enqueue((next, 0))</span>
    }

<span class="nc bnc" id="L97" title="All 2 branches missed.">    logger.debug(s&quot;Got back ${queue.length} aggregates with an average size of ${sizes.sum / sizes.length}&quot; +</span>
<span class="nc" id="L98">      s&quot; chunks and a median size of ${sizes.sorted.apply(sizes.length / 2)} chunks&quot;)</span>

<span class="nc" id="L100">    new Iterator[(Array[Byte], Int)] {</span>
<span class="nc" id="L101">      override def hasNext: Boolean = queue.nonEmpty</span>
      override def next(): (Array[Byte], Int) = {
<span class="nc bnc" id="L103" title="All 2 branches missed.">        val (aggregate, offset) = queue.dequeue()</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (offset &lt; aggregate.length - binSize) {</span>
<span class="nc" id="L105">          queue.enqueue((aggregate, offset + binSize))</span>
        }
<span class="nc" id="L107">        (aggregate, offset)</span>
      }
    }
  }

  /**
    * Performs a merge sort into a new byte array
    */
  def mergeSort(left: Array[Byte], right: Array[Byte], binSize: Int): Array[Byte] = {
<span class="nc bnc" id="L116" title="All 2 branches missed.">    if (left.length == 0) {</span>
<span class="nc" id="L117">      return right</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">    } else if (right.length == 0) {</span>
<span class="nc" id="L119">      return left</span>
    }
<span class="nc" id="L121">    val result = Array.ofDim[Byte](left.length + right.length)</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">    var (leftIndex, rightIndex, resultIndex) = (0, 0, 0)</span>

<span class="nc bnc" id="L124" title="All 4 branches missed.">    while (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      if (compare(left, leftIndex, right, rightIndex) &gt; 0) {</span>
<span class="nc" id="L126">        System.arraycopy(right, rightIndex, result, resultIndex, binSize)</span>
<span class="nc" id="L127">        rightIndex += binSize</span>
      } else {
<span class="nc" id="L129">        System.arraycopy(left, leftIndex, result, resultIndex, binSize)</span>
<span class="nc" id="L130">        leftIndex += binSize</span>
      }
<span class="nc" id="L132">      resultIndex += binSize</span>
    }
<span class="nc bnc" id="L134" title="All 2 branches missed.">    while (leftIndex &lt; left.length) {</span>
<span class="nc" id="L135">      System.arraycopy(left, leftIndex, result, resultIndex, binSize)</span>
<span class="nc" id="L136">      leftIndex += binSize</span>
<span class="nc" id="L137">      resultIndex += binSize</span>
    }
<span class="nc bnc" id="L139" title="All 2 branches missed.">    while (rightIndex &lt; right.length) {</span>
<span class="nc" id="L140">      System.arraycopy(right, rightIndex, result, resultIndex, binSize)</span>
<span class="nc" id="L141">      rightIndex += binSize</span>
<span class="nc" id="L142">      resultIndex += binSize</span>
    }
<span class="nc" id="L144">    result</span>
  }

  /**
    * Sorts the specified range of the array by Dual-Pivot Quicksort.
    * Modified version of java's DualPivotQuicksort
    *
    * @param bytes the array to be sorted
    * @param left the index of the first element, inclusive, to be sorted
    * @param right the index of the last element, inclusive, to be sorted
    */
  def quickSort(bytes: Array[Byte], left: Int, right: Int, binSize: Int): Unit =
<span class="nc" id="L156">    quickSort(bytes, left, right, binSize, leftmost = true)</span>

  /**
    * Optimized for non-leftmost insertion sort
    */
  def quickSort(bytes: Array[Byte], left: Int, right: Int, binSize: Int, leftmost: Boolean): Unit = {

<span class="nc" id="L163">    val length = (right + binSize - left) / binSize</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">    if (length &lt; INSERTION_SORT_THRESHOLD) {</span>
      // Use insertion sort on tiny arrays
<span class="nc bnc" id="L167" title="All 2 branches missed.">      if (leftmost) {</span>
        // Traditional (without sentinel) insertion sort is used in case of the leftmost part
<span class="nc" id="L169">        var i = left + binSize</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        while (i &lt;= right) {</span>
<span class="nc" id="L171">          var j = i</span>
<span class="nc" id="L172">          val ai = getThreadLocalChunk(bytes, i, binSize)</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">          while (j &gt; left &amp;&amp; compare(bytes, j - binSize, ai, 0) &gt; 0) {</span>
<span class="nc" id="L174">            System.arraycopy(bytes, j - binSize, bytes, j, binSize)</span>
<span class="nc" id="L175">            j -= binSize</span>
          }
<span class="nc bnc" id="L177" title="All 2 branches missed.">          if (j != i) {</span>
            // we don't need to copy if nothing moved
<span class="nc" id="L179">            System.arraycopy(ai, 0, bytes, j, binSize)</span>
          }
<span class="nc" id="L181">          i += binSize</span>
        }
      } else {
        // optimized insertions sort when we know we have 'sentinel' elements to the left
        /*
         * Every element from adjoining part plays the role
         * of sentinel, therefore this allows us to avoid the
         * left range check on each iteration. Moreover, we use
         * the more optimized algorithm, so called pair insertion
         * sort, which is faster (in the context of Quicksort)
         * than traditional implementation of insertion sort.
         */
        // Skip the longest ascending sequence
<span class="nc" id="L194">        var i = left</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (i &gt;= right) {</span>
<span class="nc" id="L196">          return</span>
        }
<span class="nc bnc" id="L198" title="All 2 branches missed.">        while ({ i += binSize; compare(bytes, i , bytes, i - binSize) &gt;= 0 }) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">          if (i &gt;= right) {</span>
<span class="nc" id="L200">            return</span>
          }
        }

<span class="nc" id="L204">        val a1 = Array.ofDim[Byte](binSize)</span>
<span class="nc" id="L205">        val a2 = Array.ofDim[Byte](binSize)</span>

<span class="nc" id="L207">        var k = i</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        while ({ i += binSize; i } &lt;= right) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">          if (compare(bytes, k, bytes, i) &lt; 0) {</span>
<span class="nc" id="L210">            System.arraycopy(bytes, k, a2, 0, binSize)</span>
<span class="nc" id="L211">            System.arraycopy(bytes, i, a1, 0, binSize)</span>
          } else {
<span class="nc" id="L213">            System.arraycopy(bytes, k, a1, 0, binSize)</span>
<span class="nc" id="L214">            System.arraycopy(bytes, i, a2, 0, binSize)</span>
          }
<span class="nc bnc" id="L216" title="All 2 branches missed.">          while ({ k -= binSize; compare(a1, 0, bytes, k) &lt; 0 }) {</span>
<span class="nc" id="L217">            System.arraycopy(bytes, k, bytes, k + 2 * binSize, binSize)</span>
          }
<span class="nc" id="L219">          k += binSize</span>
<span class="nc" id="L220">          System.arraycopy(a1, 0, bytes, k + binSize, binSize)</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">          while ({ k -= binSize; compare(a2, 0, bytes, k) &lt; 0 }) {</span>
<span class="nc" id="L222">            System.arraycopy(bytes, k, bytes, k + binSize, binSize)</span>
          }
<span class="nc" id="L224">          System.arraycopy(a2, 0, bytes, k + binSize, binSize)</span>

<span class="nc" id="L226">          i += binSize</span>
<span class="nc" id="L227">          k = i</span>
        }

<span class="nc" id="L230">        var j = right</span>
<span class="nc" id="L231">        val last = getThreadLocalChunk(bytes, j, binSize)</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        while ({ j -= binSize; compare(last, 0, bytes, j) &lt; 0 }) {</span>
<span class="nc" id="L233">          System.arraycopy(bytes, j, bytes, j + binSize, binSize)</span>
        }
<span class="nc" id="L235">        System.arraycopy(last, 0, bytes, j + binSize, binSize)</span>
      }
<span class="nc" id="L237">      return</span>
    }

    /*
     * Sort five evenly spaced elements around (and including) the
     * center element in the range. These elements will be used for
     * pivot selection as described below. The choice for spacing
     * these elements was empirically determined to work well on
     * a wide variety of inputs.
     */
<span class="nc" id="L247">    val seventh = (length / 7) * binSize</span>

<span class="nc" id="L249">    val e3 = (((left + right) / binSize) / 2) * binSize // The midpoint</span>
<span class="nc" id="L250">    val e2 = e3 - seventh</span>
<span class="nc" id="L251">    val e1 = e2 - seventh</span>
<span class="nc" id="L252">    val e4 = e3 + seventh</span>
<span class="nc" id="L253">    val e5 = e4 + seventh</span>

    def swap(left: Int, right: Int) = {
<span class="nc" id="L256">      val chunk = getThreadLocalChunk(bytes, left, binSize)</span>
<span class="nc" id="L257">      System.arraycopy(bytes, right, bytes, left, binSize)</span>
<span class="nc" id="L258">      System.arraycopy(chunk, 0, bytes, right, binSize)</span>
    }

    // Sort these elements using insertion sort
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (compare(bytes, e2, bytes, e1) &lt; 0) { swap(e2, e1) }</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">    if (compare(bytes, e3, bytes, e2) &lt; 0) { swap(e3, e2)</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">      if (compare(bytes, e2, bytes, e1) &lt; 0) { swap(e2, e1) }</span>
    }
<span class="nc bnc" id="L267" title="All 2 branches missed.">    if (compare(bytes, e4, bytes, e3) &lt; 0) { swap(e4, e3)</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (compare(bytes, e3, bytes, e2) &lt; 0) { swap(e3, e2)</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (compare(bytes, e2, bytes, e1) &lt; 0) {swap(e2, e1) }</span>
      }
    }
<span class="nc bnc" id="L272" title="All 2 branches missed.">    if (compare(bytes, e5, bytes, e4) &lt; 0) { swap(e5, e4)</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">      if (compare(bytes, e4, bytes, e3) &lt; 0) { swap(e4, e3)</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (compare(bytes, e3, bytes, e2) &lt; 0) { swap(e3, e2)</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">          if (compare(bytes, e2, bytes, e1) &lt; 0) { swap(e2, e1) }</span>
        }
      }
    }

    // Pointers
<span class="nc" id="L281">    var less  = left  // The index of the first element of center part</span>
<span class="nc" id="L282">    var great = right // The index before the first element of right part</span>

<span class="nc bnc" id="L284" title="All 4 branches missed.">    if (compare(bytes, e1, bytes, e2) != 0 &amp;&amp; compare(bytes, e2, bytes, e3) != 0 &amp;&amp;</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">      compare(bytes, e3, bytes, e4) != 0 &amp;&amp; compare(bytes, e4, bytes, e5) != 0 ) {</span>
      /*
       * Use the second and fourth of the five sorted elements as pivots.
       * These values are inexpensive approximations of the first and
       * second terciles of the array. Note that pivot1 &lt;= pivot2.
       */
<span class="nc" id="L291">      val pivot1 = Array.ofDim[Byte](binSize)</span>
<span class="nc" id="L292">      System.arraycopy(bytes, e2, pivot1, 0, binSize)</span>
<span class="nc" id="L293">      val pivot2 = Array.ofDim[Byte](binSize)</span>
<span class="nc" id="L294">      System.arraycopy(bytes, e4, pivot2, 0, binSize)</span>

      /*
       * The first and the last elements to be sorted are moved to the
       * locations formerly occupied by the pivots. When partitioning
       * is complete, the pivots are swapped back into their final
       * positions, and excluded from subsequent sorting.
       */
<span class="nc" id="L302">      System.arraycopy(bytes, left, bytes, e2, binSize)</span>
<span class="nc" id="L303">      System.arraycopy(bytes, right, bytes, e4, binSize)</span>

      // Skip elements, which are less or greater than pivot values.
<span class="nc bnc" id="L306" title="All 2 branches missed.">      while ({ less += binSize; compare(bytes, less, pivot1, 0) &lt; 0 }) {}</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      while ({ great -= binSize; compare(bytes, great, pivot2, 0) &gt; 0 }) {}</span>

      /*
       * Partitioning:
       *
       *   left part           center part                   right part
       * +--------------------------------------------------------------+
       * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |
       * +--------------------------------------------------------------+
       *               ^                          ^       ^
       *               |                          |       |
       *              less                        k     great
       *
       * Invariants:
       *
       *              all in (left, less)   &lt; pivot1
       *    pivot1 &lt;= all in [less, k)     &lt;= pivot2
       *              all in (great, right) &gt; pivot2
       *
       * Pointer k is the first index of ?-part.
       */

<span class="nc" id="L329">      var k = less - binSize</span>
<span class="nc" id="L330">      var loop = true</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">      while (loop &amp;&amp; { k += binSize; k } &lt;= great) {</span>
<span class="nc" id="L332">        val ak = getThreadLocalChunk(bytes, k, binSize)</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (compare(ak, 0, pivot1, 0) &lt; 0) { // Move a[k] to left part</span>
<span class="nc" id="L334">          System.arraycopy(bytes, less, bytes, k, binSize)</span>
<span class="nc" id="L335">          System.arraycopy(ak, 0, bytes, less, binSize)</span>
<span class="nc" id="L336">          less += binSize</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        } else if (compare(ak, 0, pivot2, 0) &gt; 0) { // Move a[k] to right part</span>
<span class="nc bnc" id="L338" title="All 4 branches missed.">          while (loop &amp;&amp; compare(bytes, great, pivot2, 0) &gt; 0) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (great == k) {</span>
<span class="nc" id="L340">              loop = false</span>
            }
<span class="nc" id="L342">            great -= binSize</span>
          }
<span class="nc bnc" id="L344" title="All 2 branches missed.">          if (loop) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (compare(bytes, great, pivot1, 0) &lt; 0) { // a[great] &lt;= pivot2</span>
<span class="nc" id="L346">              System.arraycopy(bytes, less, bytes, k, binSize)</span>
<span class="nc" id="L347">              System.arraycopy(bytes, great, bytes, less, binSize)</span>
<span class="nc" id="L348">              less += binSize</span>
            } else { // pivot1 &lt;= a[great] &lt;= pivot2
<span class="nc" id="L350">              System.arraycopy(bytes, great, bytes, k, binSize)</span>
            }
<span class="nc" id="L352">            System.arraycopy(ak, 0, bytes, great, binSize)</span>
<span class="nc" id="L353">            great -= binSize</span>
          }
        }
      }

      // Swap pivots into their final positions
<span class="nc" id="L359">      System.arraycopy(bytes, less - binSize, bytes, left, binSize)</span>
<span class="nc" id="L360">      System.arraycopy(pivot1, 0, bytes, less - binSize, binSize)</span>
<span class="nc" id="L361">      System.arraycopy(bytes, great + binSize, bytes, right, binSize)</span>
<span class="nc" id="L362">      System.arraycopy(pivot2, 0, bytes, great + binSize, binSize)</span>

      // Sort left and right parts recursively, excluding known pivots
<span class="nc" id="L365">      quickSort(bytes, left, less - 2 * binSize, binSize, leftmost)</span>
<span class="nc" id="L366">      quickSort(bytes, great + 2 * binSize, right, binSize, leftmost = false)</span>

      /*
       * If center part is too large (comprises &gt; 4/7 of the array),
       * swap internal pivot values to ends.
       */
<span class="nc bnc" id="L372" title="All 4 branches missed.">      if (less &lt; e1 &amp;&amp; e5 &lt; great) {</span>

        // Skip elements, which are equal to pivot values.
<span class="nc bnc" id="L375" title="All 2 branches missed.">        while (compare(bytes, less, pivot1, 0) == 0) { less += binSize }</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        while (compare(bytes, great, pivot2, 0) == 0) { great -= binSize }</span>

        /*
         * Partitioning:
         *
         *   left part         center part                  right part
         * +----------------------------------------------------------+
         * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |
         * +----------------------------------------------------------+
         *              ^                        ^       ^
         *              |                        |       |
         *             less                      k     great
         *
         * Invariants:
         *
         *              all in (*,  less) == pivot1
         *     pivot1 &lt; all in [less,  k)  &lt; pivot2
         *              all in (great, *) == pivot2
         *
         * Pointer k is the first index of ?-part.
         */
<span class="nc" id="L397">        var k = less - binSize</span>
<span class="nc" id="L398">        loop = true</span>
<span class="nc bnc" id="L399" title="All 4 branches missed.">        while (loop &amp;&amp; { k += binSize; k } &lt;= great) {</span>
<span class="nc" id="L400">          val ak = getThreadLocalChunk(bytes, k, binSize)</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">          if (compare(ak, 0, pivot1, 0) == 0) { // Move a[k] to left part</span>
<span class="nc" id="L402">            System.arraycopy(bytes, less, bytes, k, binSize)</span>
<span class="nc" id="L403">            System.arraycopy(ak, 0, bytes, less, binSize)</span>
<span class="nc" id="L404">            less += binSize</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">          } else if (compare(ak, 0, pivot2, 0) == 0) { // Move a[k] to right part</span>
<span class="nc bnc" id="L406" title="All 4 branches missed.">            while (loop &amp;&amp; compare(bytes, great, pivot2, 0) == 0) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">              if (great == k) {</span>
<span class="nc" id="L408">                loop = false</span>
              }
<span class="nc" id="L410">              great -= binSize</span>
            }
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (loop) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">              if (compare(bytes, great, pivot1, 0) == 0) { // a[great] &lt; pivot2</span>
<span class="nc" id="L414">                System.arraycopy(bytes, less, bytes, k, binSize)</span>
<span class="nc" id="L415">                System.arraycopy(bytes, great, bytes, less, binSize)</span>
<span class="nc" id="L416">                less += binSize</span>
              } else { // pivot1 &lt; a[great] &lt; pivot2
<span class="nc" id="L418">                System.arraycopy(bytes, great, bytes, k, binSize)</span>
              }
<span class="nc" id="L420">              System.arraycopy(ak, 0, bytes, great, binSize)</span>
<span class="nc" id="L421">              great -= binSize</span>
            }
          }
        }
      }

      // Sort center part recursively
<span class="nc" id="L428">      quickSort(bytes, less, great, binSize, leftmost = false)</span>
    } else { // Partitioning with one pivot

      /*
       * Use the third of the five sorted elements as pivot.
       * This value is inexpensive approximation of the median.
       */
<span class="nc" id="L435">      val pivot = Array.ofDim[Byte](binSize)</span>
<span class="nc" id="L436">      System.arraycopy(bytes, e3, pivot, 0, binSize)</span>

      /*
       * Partitioning degenerates to the traditional 3-way
       * (or &quot;Dutch National Flag&quot;) schema:
       *
       *   left part    center part              right part
       * +-------------------------------------------------+
       * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |
       * +-------------------------------------------------+
       *              ^              ^        ^
       *              |              |        |
       *             less            k      great
       *
       * Invariants:
       *
       *   all in (left, less)   &lt; pivot
       *   all in [less, k)     == pivot
       *   all in (great, right) &gt; pivot
       *
       * Pointer k is the first index of ?-part.
       */
<span class="nc" id="L458">      var k = less</span>
<span class="nc" id="L459">      var loop = true</span>
<span class="nc bnc" id="L460" title="All 4 branches missed.">      while (loop &amp;&amp; k &lt;= great) {</span>
<span class="nc" id="L461">        val comp = compare(bytes, k, pivot, 0)</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (comp != 0) {</span>
<span class="nc" id="L463">          val ak = getThreadLocalChunk(bytes, k, binSize)</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">          if (comp &lt; 0) { // Move a[k] to left part</span>
<span class="nc" id="L465">            System.arraycopy(bytes, less, bytes, k, binSize)</span>
<span class="nc" id="L466">            System.arraycopy(ak, 0, bytes, less, binSize)</span>
<span class="nc" id="L467">            less += binSize</span>
          } else { // a[k] &gt; pivot - Move a[k] to right part
<span class="nc bnc" id="L469" title="All 4 branches missed.">            while (loop &amp;&amp; compare(bytes, great, pivot, 0) &gt; 0) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">              if (k == great) {</span>
<span class="nc" id="L471">                loop = false</span>
              }
<span class="nc" id="L473">              great -= binSize</span>
            }
<span class="nc bnc" id="L475" title="All 2 branches missed.">            if (loop) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">              if (compare(bytes, great, pivot, 0) &lt; 0) { // a[great] &lt;= pivot</span>
<span class="nc" id="L477">                System.arraycopy(bytes, less, bytes, k, binSize)</span>
<span class="nc" id="L478">                System.arraycopy(bytes, great, bytes, less, binSize)</span>
<span class="nc" id="L479">                less += binSize</span>
              } else { // a[great] == pivot
<span class="nc" id="L481">                System.arraycopy(bytes, great, bytes, k, binSize)</span>
              }
<span class="nc" id="L483">              System.arraycopy(ak, 0, bytes, great, binSize)</span>
<span class="nc" id="L484">              great -= binSize</span>
            }
          }
        }
<span class="nc" id="L488">        k += binSize</span>
      }

      /*
       * Sort left and right parts recursively.
       * All elements from center part are equal
       * and, therefore, already sorted.
       */
<span class="nc" id="L496">      quickSort(bytes, left, less - binSize, binSize, leftmost)</span>
<span class="nc" id="L497">      quickSort(bytes, great + binSize, right, binSize, leftmost = false)</span>
    }
  }

  // take care - uses thread-local state
  private def getThreadLocalChunk(bytes: Array[Byte], offset: Int, binSize: Int): Array[Byte] = {
<span class="nc" id="L503">    val chunk = swapBuffers.get()</span>
<span class="nc" id="L504">    System.arraycopy(bytes, offset, chunk, 0, binSize)</span>
<span class="nc" id="L505">    chunk</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>