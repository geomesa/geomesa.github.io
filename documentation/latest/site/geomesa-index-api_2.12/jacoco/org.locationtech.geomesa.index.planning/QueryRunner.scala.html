<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryRunner.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.planning</a> &gt; <span class="el_source">QueryRunner.scala</span></div><h1>QueryRunner.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.planning

import com.google.gson.GsonBuilder
import com.typesafe.scalalogging.Logger
import io.micrometer.core.instrument.{Metrics, Tags, Timer}
import org.geotools.api.data.Query
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.filter.sort.SortOrder
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.index.api.QueryPlan
import org.locationtech.geomesa.index.conf.QueryHints
import org.locationtech.geomesa.index.geoserver.ViewParams
import org.locationtech.geomesa.index.iterators.{BinAggregatingScan, DensityScan, StatsScan}
import org.locationtech.geomesa.index.planning.QueryInterceptor.QueryInterceptorFactory
import org.locationtech.geomesa.index.planning.QueryRunner._
import org.locationtech.geomesa.index.stats.impl.StatParser
import org.locationtech.geomesa.index.utils.Reprojection.QueryReferenceSystems
import org.locationtech.geomesa.index.utils.{ExplainLogging, Explainer, Reprojection, SortingSimpleFeatureIterator}
import org.locationtech.geomesa.utils.bin.BinaryOutputEncoder
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.Transform.Transforms
import org.locationtech.geomesa.utils.geotools.{GeometryUtils, SimpleFeatureTypes, Transform}
import org.locationtech.geomesa.utils.iterators.{CountingIterator, ExceptionalIterator, TimedIterator}
import org.slf4j.LoggerFactory

import java.time.Duration
import java.util.concurrent.{ConcurrentHashMap, TimeUnit}

<span class="nc" id="L41">trait QueryRunner {</span>

  import org.locationtech.geomesa.index.conf.QueryHints.RichHints

  /**
    * Execute a query
    *
    * @param sft simple feature type
    * @param original query to run
    * @param explain explain output
    * @return
    */
<span class="nc" id="L53">  def query(sft: SimpleFeatureType, original: Query, explain: Explainer = new ExplainLogging): QueryResult = {</span>
<span class="nc" id="L54">    val start = System.nanoTime()</span>
<span class="nc" id="L55">    val query = configureQuery(sft, original)</span>
<span class="nc" id="L56">    val hints = query.getHints</span>

<span class="nc" id="L58">    explain.pushLevel(s&quot;Planning '${query.getTypeName}' ${FilterHelper.toString(query.getFilter)}&quot;)</span>
<span class="nc" id="L59">    explain(s&quot;Original filter: ${FilterHelper.toString(original.getFilter)}&quot;)</span>
<span class="nc" id="L60">    explain(s&quot;Hints: bin[${hints.isBinQuery}] arrow[${hints.isArrowQuery}] density[${hints.isDensityQuery}] &quot; +</span>
<span class="nc" id="L61">      s&quot;stats[${hints.isStatsQuery}] &quot; +</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">      s&quot;sampling[${hints.getSampling.map { case (s, f) =&gt; s&quot;$s${f.map(&quot;:&quot; + _).getOrElse(&quot;&quot;)}&quot;}.getOrElse(&quot;none&quot;)}]&quot;)</span>
<span class="nc" id="L63">    explain(s&quot;Sort: ${hints.getSortFields.map(QueryHints.sortReadableString).getOrElse(&quot;none&quot;)}&quot;)</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">    explain(s&quot;Transforms: ${hints.getTransformDefinition.map(t =&gt; if (t.isEmpty) { &quot;empty&quot; } else { t }).getOrElse(&quot;none&quot;)}&quot;)</span>
<span class="nc" id="L65">    explain(s&quot;Max features: ${hints.getMaxFeatures.getOrElse(&quot;none&quot;)}&quot;)</span>
<span class="nc" id="L66">    hints.getFilterCompatibility.foreach(c =&gt; explain(s&quot;Filter compatibility: $c&quot;))</span>

<span class="nc" id="L68">    val plans = getQueryPlans(sft, query, explain)</span>

    // ensure we're not making incorrect assumptions by only looking at the head plan
<span class="nc" id="L71">    sanityCheck(plans, _.sort, &quot;Sort&quot;)</span>
<span class="nc" id="L72">    sanityCheck(plans, _.maxFeatures, &quot;Max features&quot;)</span>
<span class="nc" id="L73">    sanityCheck(plans, _.projection, &quot;Projection&quot;)</span>
<span class="nc" id="L74">    sanityCheck(plans, _.reducer, &quot;Reduce&quot;)</span>

    // processing steps we apply to the scan results
<span class="nc" id="L77">    val steps = plans.headOption.toSeq.flatMap { plan =&gt;</span>
<span class="nc" id="L78">      val sort: Option[QueryStep] = plan.sort.map(s =&gt; new SortingSimpleFeatureIterator(_, s))</span>
<span class="nc" id="L79">      val limit: Option[QueryStep] = plan.maxFeatures.map { max =&gt;</span>
<span class="nc bnc" id="L80" title="All 6 branches missed.">        if (hints.getReturnSft == org.locationtech.geomesa.arrow.ArrowEncodedSft) {</span>
          // TODO handle arrow queries
<span class="nc" id="L82">          _.take(max)</span>
<span class="nc bnc" id="L83" title="All 6 branches missed.">        } else if (hints.getReturnSft == BinaryOutputEncoder.BinEncodedSft) {</span>
          // bin queries pack multiple records into each feature
          // to count the records, we have to count the total bytes coming back, instead of the number of features
<span class="nc" id="L86">          new BinaryOutputEncoder.FeatureLimitingIterator(_, max, hints.getBinLabelField.isDefined)</span>
        } else {
<span class="nc" id="L88">          _.take(max)</span>
        }
      }
<span class="nc" id="L91">      val reproject: Option[QueryStep] = plan.projection.map(Reprojection(hints.getReturnSft, _)).map(r =&gt; _.map(r.apply))</span>
<span class="nc" id="L92">      val reduce: Option[QueryStep] = plan.reducer.filterNot(_ =&gt; hints.isSkipReduce).map(r =&gt; r.apply)</span>

<span class="nc" id="L94">      sort ++ limit ++ reproject ++ reduce</span>
    }

<span class="nc" id="L97">    val timer: FinalQueryStep = new TimedIterator(_, Timers.scanning(query.getTypeName).record(_, TimeUnit.NANOSECONDS))</span>

<span class="nc" id="L99">    val planCreateTime = System.nanoTime() - start</span>
<span class="nc" id="L100">    Timers.planning(query.getTypeName).record(planCreateTime, TimeUnit.NANOSECONDS)</span>
<span class="nc" id="L101">    explain(s&quot;Query planning took ${planCreateTime / 1000000L}ms&quot;)</span>

<span class="nc" id="L103">    new QueryResult(hints.getReturnSft, hints, plans, planCreateTime, steps, timer)</span>
  }

  private def sanityCheck(plans: Seq[QueryPlan], part: QueryPlan =&gt; Any, id: String): Unit =
<span class="nc bnc" id="L107" title="All 2 branches missed.">    require(plans.tail.forall(p =&gt; part(p) == part(plans.head)),</span>
<span class="nc" id="L108">      s&quot;$id must be the same in all query plans: ${plans.map(part.apply).mkString(&quot;\n  &quot;, &quot;\n  &quot;, &quot;&quot;)}&quot;)</span>

  /**
   * Create query plans from a query. The query will already have been configured
   *
   * @param sft feature type
   * @param query query
   * @param explain explainer
   * @return
   */
  protected def getQueryPlans(sft: SimpleFeatureType, query: Query, explain: Explainer): Seq[QueryPlan]

  /**
    * Hook for query interceptors
    *
    * @return
    */
  protected def interceptors: QueryInterceptorFactory

  /**
   * Get any tags to add to timing metrics produced by this query runner
   *
   * @param typeName feature type name
   * @return
   */
  protected def tags(typeName: String): Tags

  /**
    * Configure the query - set hints, transforms, etc.
    *
    * @param original query to configure
    * @param sft simple feature type associated with the query
    */
  protected[geomesa] def configureQuery(sft: SimpleFeatureType, original: Query): Query = {
    import org.locationtech.geomesa.filter.{andFilters, ff, orFilters}
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L145">    val query = new Query(original)</span>

    // query rewriting
<span class="nc" id="L148">    interceptors(sft).foreach { interceptor =&gt;</span>
<span class="nc" id="L149">      interceptor.rewrite(query)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">      QueryRunner.logger.trace(s&quot;Query rewritten by $interceptor to: $query&quot;)</span>
    }

    // handle any params passed in through geoserver
<span class="nc" id="L154">    ViewParams.setHints(query)</span>

    // handle transforms and store them in the query hints
<span class="nc bnc" id="L157" title="All 2 branches missed.">    extractQueryTransforms(sft, query).foreach { case (schema, _, transforms) =&gt;</span>
<span class="nc" id="L158">      query.getHints.put(QueryHints.Internal.TRANSFORMS, transforms)</span>
<span class="nc" id="L159">      query.getHints.put(QueryHints.Internal.TRANSFORM_SCHEMA, schema)</span>
    }

    // set the return schema
<span class="nc" id="L163">    query.getHints.put(QueryHints.Internal.RETURN_SFT,</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      if (query.getHints.isBinQuery) {</span>
<span class="nc" id="L165">        BinaryOutputEncoder.BinEncodedSft</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">      } else if (query.getHints.isArrowQuery) {</span>
<span class="nc" id="L167">        org.locationtech.geomesa.arrow.ArrowEncodedSft</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      } else if (query.getHints.isDensityQuery) {</span>
<span class="nc" id="L169">        DensityScan.DensitySft</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">      } else if (query.getHints.isStatsQuery) {</span>
<span class="nc" id="L171">        StatsScan.StatsSft</span>
      } else {
<span class="nc" id="L173">        query.getHints.getTransformSchema.getOrElse(sft)</span>
      }
    )

<span class="nc" id="L177">    QueryRunner.setQuerySort(sft, query)</span>

    // set any reprojection into the hints
<span class="nc" id="L180">    QueryReferenceSystems(query).foreach { crs =&gt;</span>
<span class="nc" id="L181">      query.getHints.put(QueryHints.Internal.REPROJECTION, QueryHints.Internal.toProjectionHint(crs))</span>
    }

    // set max features into the hints
<span class="nc bnc" id="L185" title="All 2 branches missed.">    if (!query.isMaxFeaturesUnlimited) {</span>
<span class="nc" id="L186">      query.getHints.put(QueryHints.Internal.MAX_FEATURES, Int.box(query.getMaxFeatures))</span>
    }

    // add the bbox from the density query to the filter, if there is no more restrictive filter
<span class="nc" id="L190">    query.getHints.getDensityEnvelope.foreach { env =&gt;</span>
<span class="nc" id="L191">      val geom = query.getHints.getDensityGeometry.getOrElse(sft.getGeomField)</span>
<span class="nc" id="L192">      val geoms = FilterHelper.extractGeometries(query.getFilter, geom)</span>
<span class="nc bnc" id="L193" title="All 6 branches missed.">      if (geoms.isEmpty || geoms.exists(g =&gt; !env.contains(g.getEnvelopeInternal))) {</span>
<span class="nc" id="L194">        val split = GeometryUtils.splitBoundingBox(env.asInstanceOf[ReferencedEnvelope])</span>
<span class="nc" id="L195">        val bbox = orFilters(split.map(ff.bbox(ff.property(geom), _)))</span>
<span class="nc bnc" id="L196" title="All 6 branches missed.">        if (query.getFilter == Filter.INCLUDE) {</span>
<span class="nc" id="L197">          query.setFilter(bbox)</span>
        } else {
<span class="nc" id="L199">          query.setFilter(andFilters(Seq(query.getFilter, bbox)))</span>
        }
      }
    }

    // optimize the filter
<span class="nc bnc" id="L205" title="All 8 branches missed.">    if (query.getFilter != null &amp;&amp; query.getFilter != Filter.INCLUDE) {</span>
      // bind the literal values to the appropriate type, so that it isn't done every time the filter is evaluated
      // update the filter to remove namespaces, handle null property names, and tweak topological filters
      // replace filters with 'fast' implementations where possible
<span class="nc" id="L209">      query.setFilter(FastFilterFactory.optimize(sft, query.getFilter))</span>
    }

<span class="nc" id="L212">    query</span>
  }

  /**
   * Holder for per-instance cached timers
   */
<span class="nc bnc" id="L218" title="All 2 branches missed.">  private object Timers {</span>

<span class="nc" id="L220">    private val scanTimers = new ConcurrentHashMap[String, Timer]()</span>
<span class="nc" id="L221">    private val planTimers = new ConcurrentHashMap[String, Timer]()</span>

    def scanning(typeName: String): Timer =
<span class="nc" id="L224">      scanTimers.computeIfAbsent(typeName, _ =&gt;</span>
<span class="nc" id="L225">        Timer.builder(&quot;geomesa.query.execution&quot;)</span>
<span class="nc" id="L226">          .tags(tags(typeName))</span>
<span class="nc" id="L227">          .description(&quot;Time spent executing a query&quot;)</span>
          .publishPercentileHistogram()
<span class="nc" id="L229">          .minimumExpectedValue(Duration.ofMillis(1))</span>
<span class="nc" id="L230">          .maximumExpectedValue(Duration.ofMinutes(5))</span>
<span class="nc" id="L231">          .register(Metrics.globalRegistry)</span>
      )

    def planning(typeName: String): Timer =
<span class="nc" id="L235">      planTimers.computeIfAbsent(typeName, _ =&gt;</span>
<span class="nc" id="L236">        Timer.builder(&quot;geomesa.query.planning&quot;)</span>
<span class="nc" id="L237">          .tags(tags(typeName))</span>
<span class="nc" id="L238">          .description(&quot;Time spent planning a query&quot;)</span>
          .publishPercentileHistogram()
<span class="nc" id="L240">          .minimumExpectedValue(Duration.ofMillis(1))</span>
<span class="nc" id="L241">          .maximumExpectedValue(Duration.ofSeconds(1))</span>
<span class="nc" id="L242">          .register(Metrics.globalRegistry)</span>
      )
  }
<span class="nc" id="L245">}</span>

<span class="nc" id="L247">object QueryRunner {</span>

  import org.locationtech.geomesa.index.conf.QueryHints.RichHints
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

  private type QueryStep = CloseableIterator[SimpleFeature] =&gt; CloseableIterator[SimpleFeature]
  private type FinalQueryStep = CloseableIterator[SimpleFeature] =&gt; TimedIterator[SimpleFeature]

<span class="nc" id="L257">  private val logger = Logger(LoggerFactory.getLogger(classOf[QueryRunner]))</span>
<span class="nc" id="L258">  private val gson = new GsonBuilder().disableHtmlEscaping().serializeNulls().create()</span>

  // used for configuring input queries
<span class="nc bnc" id="L261" title="All 4 branches missed.">  private val default: QueryRunner = new QueryRunner {</span>
<span class="nc" id="L262">    override protected val interceptors: QueryInterceptorFactory = QueryInterceptorFactory.empty()</span>
    override protected def getQueryPlans(sft: SimpleFeatureType, query: Query, explain: Explainer): Seq[QueryPlan] =
<span class="nc" id="L264">      throw new UnsupportedOperationException()</span>
<span class="nc" id="L265">    override protected def tags(typeName: String): Tags = Tags.empty()</span>
  }

  /**
   * Configure a query, setting hints appropriately that we use in our query planning. Normally this is done
   * automatically as part of running a query.
   *
   * @param sft feature type
   * @param original query
   * @return a new query
   */
<span class="nc" id="L276">  def configureQuery(sft: SimpleFeatureType, original: Query): Query = default.configureQuery(sft, original)</span>

  /**
   * Extract and parse transforms from the query
   *
   * @param sft simple feature type
   * @param query query
   * @return
   */
  private def extractQueryTransforms(sft: SimpleFeatureType, query: Query): Option[(SimpleFeatureType, Seq[Transform], String)] = {
    // even if a transform is not specified, some queries only use a subset of attributes
    // specify them here so that it's easier to pick the best column group later
    def fromQueryType: Option[Seq[String]] = {
<span class="nc" id="L289">      val hints = query.getHints</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">      if (hints.isBinQuery) {</span>
<span class="nc" id="L291">        Some(BinAggregatingScan.propertyNames(hints, sft))</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">      } else if (hints.isDensityQuery) {</span>
<span class="nc" id="L293">        Some(DensityScan.propertyNames(hints, sft))</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      } else if (hints.isStatsQuery) {</span>
<span class="nc" id="L295">        Some(StatParser.propertyNames(sft, hints.getStatsQuery))</span>
      } else {
<span class="nc" id="L297">        None</span>
      }
    }

    // since we do sorting on the client, just add any sort-by attributes to the transform
    // TODO GEOMESA-2655 we should sort and then transform back to the requested props, but it's complicated...
    def withSort(props: Array[String]): Seq[String] = {
<span class="nc bnc" id="L304" title="All 2 branches missed.">      val names = props.map(p =&gt; if (p.contains('=')) { p.substring(0, p.indexOf('=')) } else { p })</span>
<span class="nc" id="L305">      props ++ Option(query.getSortBy).toSeq.flatMap { sort =&gt;</span>
<span class="nc" id="L306">        sort.flatMap(s =&gt; Option(s.getPropertyName).flatMap(p =&gt; Option(p.getPropertyName).filterNot(names.contains)))</span>
      }
    }

    // ignore transforms that don't actually do anything
<span class="nc bnc" id="L311" title="All 6 branches missed.">    def noop(props: Seq[String]): Boolean = props == sft.getAttributeDescriptors.asScala.map(_.getLocalName)</span>

<span class="nc" id="L313">    Option(query.getPropertyNames).map(withSort).filterNot(noop).orElse(fromQueryType).map { props =&gt;</span>
<span class="nc" id="L314">      val transforms = Transforms(sft, props)</span>
<span class="nc" id="L315">      val schema = Transforms.schema(sft, transforms)</span>
<span class="nc" id="L316">      val definition = props.mkString(Transform.DefinitionDelimiter)</span>
<span class="nc" id="L317">      (schema, transforms, definition)</span>
    }
  }

  /**
   * Sets query hints for sorting
   *
   * @param sft sft
   * @param query query
   */
  private def setQuerySort(sft: SimpleFeatureType, query: Query): Unit = {
<span class="nc" id="L328">    val sortBy = query.getSortBy</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">    if (sortBy != null &amp;&amp; sortBy.nonEmpty) {</span>
<span class="nc" id="L330">      val hints = query.getHints</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">      if (hints.isArrowQuery) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (sortBy.lengthCompare(1) &gt; 0) {</span>
<span class="nc" id="L333">          throw new IllegalArgumentException(&quot;Arrow queries only support sort by a single field: &quot; +</span>
<span class="nc" id="L334">            sortBy.mkString(&quot;, &quot;))</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        } else if (sortBy.head.getPropertyName == null) {</span>
<span class="nc" id="L336">          throw new IllegalArgumentException(&quot;Arrow queries only support sort by properties: &quot; +</span>
<span class="nc" id="L337">            sortBy.mkString(&quot;, &quot;))</span>
        }
<span class="nc" id="L339">        val field = sortBy.head.getPropertyName.getPropertyName</span>
<span class="nc bnc" id="L340" title="All 6 branches missed.">        val reverse = sortBy.head.getSortOrder == SortOrder.DESCENDING</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        hints.getArrowSort.foreach { case (f, r) =&gt;</span>
<span class="nc bnc" id="L342" title="All 8 branches missed.">          if (f != field || r != reverse) {</span>
<span class="nc" id="L343">            throw new IllegalArgumentException(s&quot;Query sort does not match Arrow hints sort: &quot; +</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">              s&quot;${sortBy.mkString(&quot;, &quot;)} != $f:${if (r) &quot;DESC&quot; else &quot;ASC&quot;}&quot;)</span>
          }
        }
<span class="nc" id="L347">        hints.put(QueryHints.ARROW_SORT_FIELD, field)</span>
<span class="nc" id="L348">        hints.put(QueryHints.ARROW_SORT_REVERSE, reverse)</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">      } else if (hints.isBinQuery) {</span>
<span class="nc" id="L350">        val dtg = hints.getBinDtgField.orElse(sft.getDtgField).orNull</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (dtg == null ||</span>
<span class="nc bnc" id="L352" title="All 6 branches missed.">          sortBy.map(s =&gt; Option(s.getPropertyName).map(_.getPropertyName).orNull).toSeq != Seq(dtg)) {</span>
<span class="nc" id="L353">          throw new IllegalArgumentException(&quot;BIN queries only support sort by a date-type field: &quot; +</span>
<span class="nc" id="L354">            sortBy.mkString(&quot;, &quot;))</span>
        }
<span class="nc bnc" id="L356" title="All 6 branches missed.">        if (sortBy.head.getSortOrder == SortOrder.DESCENDING) {</span>
<span class="nc" id="L357">          throw new IllegalArgumentException(&quot;BIN queries only support sort in ASCENDING order: &quot; +</span>
<span class="nc" id="L358">            sortBy.mkString(&quot;, &quot;))</span>
        }
<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (hints.get(QueryHints.BIN_SORT) != null &amp;&amp; !hints.isBinSorting) {</span>
<span class="nc" id="L361">          throw new IllegalArgumentException(&quot;Query sort order contradicts BIN sorting hint: &quot; +</span>
<span class="nc" id="L362">            sortBy.mkString(&quot;, &quot;))</span>
        }
<span class="nc" id="L364">        hints.put(QueryHints.BIN_SORT, java.lang.Boolean.TRUE)</span>
      } else {
<span class="nc" id="L366">        hints.put(QueryHints.Internal.SORT_FIELDS, QueryHints.Internal.toSortHint(sortBy))</span>
      }
    }
  }

  /**
   * Holds all the necessary pieces to actually run a query, but doesn't run it yet
   *
   * @param schema return schema of the iterators returned by this class
   * @param hints query hints
   * @param plans query plans for executing the query
   * @param planTimeNanos time spent planning the query
   * @param querySteps processing steps to apply on top of the query plans
   * @param timer final step to apply, creating a timed iterator for metrics tracking
   */
<span class="nc" id="L381">  class QueryResult(</span>
<span class="nc" id="L382">      val schema: SimpleFeatureType,</span>
<span class="nc" id="L383">      val hints: Hints,</span>
<span class="nc" id="L384">      val plans: Seq[QueryPlan],</span>
<span class="nc" id="L385">      val planTimeNanos: Long,</span>
<span class="nc" id="L386">      querySteps: Seq[QueryStep],</span>
<span class="nc" id="L387">      timer: FinalQueryStep) {</span>

    /**
     * Executes the query
     *
     * @return
     */
<span class="nc" id="L394">    def iterator(): CloseableIterator[SimpleFeature] = ExceptionalIterator(runQuery())</span>

    /**
     * Executes the query
     *
     * @param timerCallback callback for time spent running the query, will be invoked when the iterator is closed with the time in nanoseconds
     * @param counterCallback callback for the number of results returned by the query, will be invoked when the iterator is closed
     * @return
     */
    def iterator(timerCallback: Long =&gt; Unit, counterCallback: Long =&gt; Unit): CloseableIterator[SimpleFeature] = {
      val counter: SimpleFeature =&gt; Int =
<span class="nc bnc" id="L405" title="All 6 branches missed.">        if (schema == org.locationtech.geomesa.arrow.ArrowEncodedSft) {</span>
          // TODO handle arrow queries
<span class="nc" id="L407">          StandardCounter</span>
<span class="nc bnc" id="L408" title="All 6 branches missed.">        } else if (schema == BinaryOutputEncoder.BinEncodedSft) {</span>
<span class="nc" id="L409">          BinAggregatingScan.BinCounter(hints)</span>
        } else {
<span class="nc" id="L411">          StandardCounter</span>
        }
<span class="nc" id="L413">      ExceptionalIterator(new CountingIterator(runQuery().addCallback(timerCallback), counter, counterCallback))</span>
    }

    private def runQuery(): TimedIterator[SimpleFeature] = {
<span class="nc" id="L417">      val iter = CloseableIterator(plans.iterator).flatMap(p =&gt; p.scan().map(p.resultsToFeatures.apply))</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">      timer(querySteps.foldLeft(iter) { case (i, step) =&gt; step(i) })</span>
    }

    override def toString: String =
<span class="nc" id="L422">      s&quot;QueryResult(schema=${SimpleFeatureTypes.encodeType(schema)},hints=${gson.toJson(ViewParams.getReadableHints(hints))})&quot;</span>
  }

<span class="nc" id="L425">  private object StandardCounter extends (SimpleFeature =&gt; Int) {</span>
<span class="nc" id="L426">    override def apply(f: SimpleFeature): Int = 1</span>
  }
<span class="nc" id="L428">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>