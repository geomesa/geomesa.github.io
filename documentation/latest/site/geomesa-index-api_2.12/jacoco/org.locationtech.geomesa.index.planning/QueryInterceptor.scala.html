<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryInterceptor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.planning</a> &gt; <span class="el_source">QueryInterceptor.scala</span></div><h1>QueryInterceptor.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.planning

import com.github.benmanes.caffeine.cache.{CacheLoader, Caffeine}
import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.{DataStore, Query}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.index.api.QueryStrategy
import org.locationtech.geomesa.index.metadata.TableBasedMetadata
import org.locationtech.geomesa.index.planning.guard.{DefaultQueryGuard, FullTableScanQueryGuard}
import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
import org.locationtech.geomesa.utils.io.CloseWithLogging

import java.io.Closeable
import java.util.concurrent.TimeUnit
import scala.util.control.NonFatal

/**
  * Provides a hook to modify a query before executing it
  */
<span class="nc" id="L28">trait QueryInterceptor extends Closeable {</span>

  /**
    * Called exactly once after the interceptor is instantiated
    *
    * @param ds data store
    * @param sft simple feature type
    */
  def init(ds: DataStore, sft: SimpleFeatureType): Unit

  /**
    * Modifies the query in place
    *
    * @param query query
    */
  def rewrite(query: Query): Unit

  /**
   * Hook to allow interception of a query after extracting the query values
   *
   * @param strategy query strategy
   * @return an exception if the query should be stopped
   */
<span class="nc" id="L51">  def guard(strategy: QueryStrategy): Option[IllegalArgumentException] = None</span>
}

<span class="nc bnc" id="L54" title="All 4 branches missed.">object QueryInterceptor extends LazyLogging {</span>

  /**
    * Manages query interceptors
    */
<span class="nc" id="L59">  trait QueryInterceptorFactory extends Closeable {</span>

    def apply(sft: SimpleFeatureType): Seq[QueryInterceptor]

    /**
     * Runs any configured query guards, throwing any exceptions raised
     *
     * @param strategy query strategy
     */
    @throws[IllegalArgumentException]
    def runGuards(strategy: QueryStrategy): Unit =
<span class="nc" id="L70">      apply(strategy.index.sft).foreach(_.guard(strategy).foreach(e =&gt; throw e))</span>
  }

<span class="nc" id="L73">  object QueryInterceptorFactory {</span>

<span class="nc" id="L75">    private val Empty: QueryInterceptorFactory = new QueryInterceptorFactory {</span>
<span class="nc" id="L76">      override def apply(sft: SimpleFeatureType): Seq[QueryInterceptor] = Seq.empty</span>
<span class="nc" id="L77">      override def close(): Unit = {}</span>
    }

<span class="nc" id="L80">    def apply(ds: DataStore): QueryInterceptorFactory = new QueryInterceptorFactoryImpl(ds)</span>

<span class="nc" id="L82">    def empty(): QueryInterceptorFactory = Empty</span>

    /**
      * Manages query interceptor lifecycles for a given data store
      *
      * @param ds data store
      */
<span class="nc" id="L89">    private class QueryInterceptorFactoryImpl(ds: DataStore) extends QueryInterceptorFactory {</span>

      import scala.collection.JavaConverters._

<span class="nc" id="L93">      private val expiry = TableBasedMetadata.Expiry.toDuration.get.toMillis</span>

<span class="nc" id="L95">      private val cache =</span>
<span class="nc" id="L96">        Caffeine.newBuilder().refreshAfterWrite(expiry, TimeUnit.MILLISECONDS).build[String, Seq[QueryInterceptor]](</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">          new CacheLoader[String, Seq[QueryInterceptor]]() {</span>
<span class="nc" id="L98">            override def load(typeName: String): Seq[QueryInterceptor] = reload(typeName, Seq.empty)</span>
            override def reload(typeName: String, oldValue: Seq[QueryInterceptor]): Seq[QueryInterceptor] = {
              // only recreate the interceptors if they have changed
<span class="nc" id="L101">              val sft = ds.getSchema(typeName)</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">              if (sft == null) {</span>
<span class="nc" id="L103">                CloseWithLogging(oldValue)</span>
<span class="nc" id="L104">                return Seq.empty</span>
              }
<span class="nc" id="L106">              val classes = getInterceptorClasses(sft)</span>
<span class="nc bnc" id="L107" title="All 6 branches missed.">              if (classes == oldValue.map(_.getClass.getName)) {</span>
<span class="nc" id="L108">                oldValue</span>
              } else {
<span class="nc" id="L110">                CloseWithLogging(oldValue)</span>
<span class="nc" id="L111">                classes.flatMap(createInterceptor(ds, sft, _))</span>
              }
            }
          }
        )

<span class="nc" id="L117">      override def apply(sft: SimpleFeatureType): Seq[QueryInterceptor] = cache.get(sft.getTypeName)</span>

      override def close(): Unit = {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        cache.asMap.asScala.foreach { case (_, interceptors) =&gt; CloseWithLogging(interceptors) }</span>
<span class="nc" id="L121">        cache.invalidateAll()</span>
      }
    }
  }

<span class="nc" id="L126">  private def getInterceptorClasses(sft: SimpleFeatureType) : Seq[String] = {</span>
<span class="nc" id="L127">    val configured = sft.getQueryInterceptors</span>
    // add default full table scan check, if the more restrictive FullTableScanQueryGuard doesn't make it redundant
<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (Seq(classOf[FullTableScanQueryGuard], classOf[DefaultQueryGuard]).map(_.getName).exists(configured.contains)) {</span>
<span class="nc" id="L130">      configured</span>
    } else {
<span class="nc" id="L132">      configured :+ classOf[DefaultQueryGuard].getName</span>
    }
  }

  private def createInterceptor(ds: DataStore, sft: SimpleFeatureType, className: String): Option[QueryInterceptor] = {
<span class="nc" id="L137">    var interceptor: QueryInterceptor = null</span>
<span class="nc" id="L138">    try {</span>
<span class="nc" id="L139">      interceptor = Class.forName(className).getDeclaredConstructor().newInstance().asInstanceOf[QueryInterceptor]</span>
<span class="nc" id="L140">      interceptor.init(ds, sft)</span>
<span class="nc" id="L141">      Some(interceptor)</span>
    } catch {
<span class="nc bnc" id="L143" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        logger.error(s&quot;Error creating query interceptor '$className':&quot;, e)</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (interceptor != null) {</span>
<span class="nc" id="L146">          CloseWithLogging(interceptor)</span>
        }
<span class="nc" id="L148">        None</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>