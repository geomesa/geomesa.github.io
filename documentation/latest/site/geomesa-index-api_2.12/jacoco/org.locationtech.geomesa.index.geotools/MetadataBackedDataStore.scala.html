<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetadataBackedDataStore.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.geotools</a> &gt; <span class="el_source">MetadataBackedDataStore.scala</span></div><h1>MetadataBackedDataStore.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.geotools

import com.typesafe.scalalogging.LazyLogging
import io.micrometer.core.instrument.Tags
import org.geotools.api.data._
import org.geotools.api.feature.`type`.Name
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.geotools.data._
import org.geotools.feature.{FeatureTypes, NameImpl}
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.index.FlushableFeatureWriter
import org.locationtech.geomesa.index.geotools.GeoMesaDataStoreFactory.NamespaceConfig
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureReader.HasGeoMesaFeatureReader
import org.locationtech.geomesa.index.metadata.GeoMesaMetadata._
import org.locationtech.geomesa.index.metadata.HasGeoMesaMetadata
import org.locationtech.geomesa.index.planning.QueryInterceptor.QueryInterceptorFactory
import org.locationtech.geomesa.index.utils.DistributedLocking
import org.locationtech.geomesa.metrics.micrometer.utils.TagUtils
import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypeComparator.TypeComparison
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.Configs
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.InternalConfigs.TableSharingPrefix
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.geotools.{FeatureUtils, GeoToolsDateFormat, SimpleFeatureTypeComparator, SimpleFeatureTypes}
import org.locationtech.geomesa.utils.index.{GeoMesaSchemaValidator, ReservedWordCheck}
import org.locationtech.geomesa.utils.io.CloseWithLogging

import java.io.{Closeable, IOException}
import java.time.{Instant, ZoneOffset}
import java.util.{Locale, List =&gt; jList}
import scala.util.control.NonFatal

/**
  * Abstract base class for data store implementations using metadata to track schemas
  */
<span class="nc bnc" id="L45" title="All 4 branches missed.">abstract class MetadataBackedDataStore(config: NamespaceConfig) extends DataStore</span>
    with HasGeoMesaMetadata[String] with HasGeoMesaFeatureReader with DistributedLocking with LazyLogging {

  import scala.collection.JavaConverters._

  // TODO: GEOMESA-2360 - Remove global axis order hint from MetadataBackedDataStore
<span class="nc" id="L51">  Hints.putSystemDefault(Hints.FORCE_LONGITUDE_FIRST_AXIS_ORDER, true)</span>

<span class="nc" id="L53">  protected [geomesa] val interceptors: QueryInterceptorFactory = QueryInterceptorFactory(this)</span>

  // common metrics tags for this data store
<span class="nc" id="L56">  private val tags: Tags = {</span>
    val storeTag = {
<span class="nc" id="L58">      val name = getClass.getSimpleName.toLowerCase(Locale.US)</span>
<span class="nc" id="L59">      val i = name.lastIndexOf(&quot;datastore&quot;)</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      if (i &gt; 0) { name.substring(0, i) } else { name }</span>
    }
<span class="nc" id="L62">    Tags.of(&quot;store&quot;, storeTag, &quot;catalog&quot;, config.catalog)</span>
  }

  // hooks to allow extended functionality

  /**
    * Called just before persisting schema metadata. Allows for validation or configuration of user data
    *
    * @param sft simple feature type
    * @throws java.lang.IllegalArgumentException if schema is invalid and shouldn't be written
    */
  @throws(classOf[IllegalArgumentException])
  protected def preSchemaCreate(sft: SimpleFeatureType): Unit

  /**
    * Called just before updating schema metadata. Allows for validation or configuration of user data
    *
    * @param sft simple feature type
    * @param previous previous feature type before changes
    * @throws java.lang.IllegalArgumentException if schema is invalid and shouldn't be updated
    */
  @throws(classOf[IllegalArgumentException])
  protected def preSchemaUpdate(sft: SimpleFeatureType, previous: SimpleFeatureType): Unit

  /**
    * Called after schema metadata has been persisted. Allows for creating tables, etc
    *
    * @param sft simple feature type
    */
  protected def onSchemaCreated(sft: SimpleFeatureType): Unit

  /**
    * Called after schema metadata has been persisted. Allows for creating tables, etc
    *
    * @param sft simple feature type
    * @param previous previous feature type before changes
    */
  protected def onSchemaUpdated(sft: SimpleFeatureType, previous: SimpleFeatureType): Unit

  /**
    * Called after deleting schema metadata. Allows for deleting tables, etc
    *
    * @param sft simple feature type
    */
  protected def onSchemaDeleted(sft: SimpleFeatureType): Unit

  // methods from org.geotools.api.data.DataStore

  /**
    * @see org.geotools.api.data.DataStore#getTypeNames()
    * @return existing simple feature type names
    */
<span class="nc" id="L114">  override def getTypeNames: Array[String] = metadata.getFeatureTypes</span>

  /**
    * @see org.geotools.data.DataAccess#getNames()
    * @return existing simple feature type names
    */
  override def getNames: jList[Name] = {
<span class="nc" id="L121">    val names = new java.util.ArrayList[Name]</span>
<span class="nc" id="L122">    config.namespace match {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">      case None     =&gt; getTypeNames.foreach(name =&gt; names.add(new NameImpl(name)))</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">      case Some(ns) =&gt; getTypeNames.foreach(name =&gt; names.add(new NameImpl(ns, name)))</span>
    }
<span class="nc" id="L126">    names</span>
  }

  /**
    * Validates the schema and writes metadata to catalog.If the schema already exists,
    * continue without error.
    *
    * This method uses distributed locking to ensure a schema is only created once.
    *
    * @see org.geotools.data.DataAccess#createSchema(org.geotools.api.feature.type.FeatureType)
    * @param schema type to create
    */
  override def createSchema(schema: SimpleFeatureType): Unit = {
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (getSchema(schema.getTypeName) == null) {</span>
<span class="nc" id="L140">      val lock = acquireCatalogLock()</span>
      try {
        // check a second time now that we have the lock
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (getSchema(schema.getTypeName) == null) {</span>
          // ensure that we have a mutable type so we can set user data
<span class="nc" id="L145">          val sft = SimpleFeatureTypes.copy(schema)</span>
          // inspect and update the simple feature type for various components
          // do this before anything else so that any modifications will be in place
<span class="nc" id="L148">          GeoMesaSchemaValidator.validate(sft)</span>

          // set the enabled indices
<span class="nc" id="L151">          preSchemaCreate(sft)</span>

          // compute the metadata values - IMPORTANT: encode type has to be called after all user data is set
<span class="nc" id="L154">          val encodedAttributes = SimpleFeatureTypes.encodeType(sft, includeUserData = true)</span>
          // validate we can read out the encoded sft - invalid user data keys can break the parsing
<span class="nc" id="L156">          try { SimpleFeatureTypes.createType(&quot;&quot;, encodedAttributes) } catch {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            case NonFatal(e) =&gt; throw new IllegalArgumentException(&quot;Invalid schema:&quot;, e)</span>
          }
<span class="nc" id="L159">          val metadataMap = Map(</span>
<span class="nc" id="L160">            AttributesKey      -&gt; encodedAttributes,</span>
<span class="nc" id="L161">            StatsGenerationKey -&gt; GeoToolsDateFormat.format(Instant.now().atOffset(ZoneOffset.UTC))</span>
          )
<span class="nc" id="L163">          try {</span>
            // write out the metadata to the catalog table
<span class="nc" id="L165">            metadata.insert(sft.getTypeName, metadataMap)</span>

            // reload the sft so that we have any default metadata,
            // then copy over any additional keys that were in the original sft.
            // avoid calling getSchema directly, as that may trigger a remote version
            // check for indices that haven't been created yet
<span class="nc" id="L171">            val attributes = metadata.readRequired(sft.getTypeName, AttributesKey)</span>
<span class="nc" id="L172">            val reloadedSft = SimpleFeatureTypes.createType(sft.getTypeName, attributes)</span>
<span class="nc" id="L173">            val userData = new java.util.HashMap[AnyRef, AnyRef]()</span>
<span class="nc" id="L174">            userData.putAll(reloadedSft.getUserData)</span>
<span class="nc" id="L175">            reloadedSft.getUserData.putAll(sft.getUserData)</span>
<span class="nc" id="L176">            reloadedSft.getUserData.putAll(userData)</span>

            // create the tables
<span class="nc" id="L179">            onSchemaCreated(reloadedSft)</span>
          } catch {
<span class="nc bnc" id="L181" title="All 2 branches missed.">            case NonFatal(e) =&gt;</span>
              // If there was an error creating a schema, clean up.
<span class="nc" id="L183">              try {</span>
<span class="nc" id="L184">                metadata.delete(sft.getTypeName)</span>
              } catch {
<span class="nc bnc" id="L186" title="All 2 branches missed.">                case NonFatal(e2) =&gt; e.addSuppressed(e2)</span>
              }
<span class="nc" id="L188">              throw e</span>
          }
        }
      } finally {
<span class="nc" id="L192">        lock.close()</span>
      }
    }
  }

  /**
    * @see org.geotools.data.DataAccess#getSchema(org.geotools.api.feature.type.Name)
    * @param name feature type name
    * @return feature type, or null if it does not exist
    */
<span class="nc" id="L202">  override def getSchema(name: Name): SimpleFeatureType = getSchema(name.getLocalPart)</span>

  /**
   * @see org.geotools.api.data.DataStore#getSchema(java.lang.String)
   * @param typeName feature type name
   * @return feature type, or null if it does not exist
   */
  override def getSchema(typeName: String): SimpleFeatureType = {
<span class="nc" id="L210">    metadata.read(typeName, AttributesKey) match {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">      case None =&gt; null</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      case Some(spec) =&gt; SimpleFeatureTypes.createImmutableType(config.namespace.orNull, typeName, spec)</span>
    }
  }

  /**
    * Allows the following modifications to the schema:
    *   renaming the feature type
    *   renaming attributes
    *   appending new attributes
    *   enabling/disabling indices through RichSimpleFeatureType.setIndexVersion
    *   modifying keywords through user-data
    *
    * Other modifications are not supported.
    *
    * @see org.geotools.api.data.DataStore#updateSchema(java.lang.String, org.geotools.api.feature.simple.SimpleFeatureType)
    * @param typeName simple feature type name
    * @param sft new simple feature type
    */
  override def updateSchema(typeName: String, sft: SimpleFeatureType): Unit =
<span class="nc" id="L231">    updateSchema(new NameImpl(typeName), sft)</span>

  /**
    * Allows the following modifications to the schema:
    *   renaming the feature type
    *   renaming attributes
    *   appending new attributes
    *   enabling/disabling indices through RichSimpleFeatureType.setIndexVersion
    *   modifying keywords through user-data
    *
    * Other modifications are not supported.
    *
    * @see org.geotools.data.DataAccess#updateSchema(org.geotools.api.feature.type.Name, org.geotools.api.feature.type.FeatureType)
    * @param typeName simple feature type name
    * @param schema new simple feature type
    */
  override def updateSchema(typeName: Name, schema: SimpleFeatureType): Unit = {
    // validate that the type name has not changed, or that the new name is not already in use
<span class="nc bnc" id="L249" title="All 8 branches missed.">    if (typeName.getLocalPart != schema.getTypeName &amp;&amp; getTypeNames.contains(schema.getTypeName)) {</span>
<span class="nc" id="L250">      throw new IllegalArgumentException(</span>
<span class="nc" id="L251">        s&quot;Updated type name already exists: '$typeName' changed to '${schema.getTypeName}'&quot;)</span>
    }

<span class="nc" id="L254">    val lock = acquireCatalogLock()</span>
    try {
      // get previous schema and user data
<span class="nc" id="L257">      val previousSft = getSchema(typeName)</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">      if (previousSft == null) {</span>
<span class="nc" id="L260">        throw new IllegalArgumentException(s&quot;Schema '$typeName' does not exist&quot;)</span>
      }

<span class="nc" id="L263">      GeoMesaSchemaValidator.validate(schema)</span>

<span class="nc" id="L265">      validateSchemaUpdate(previousSft, schema).left.foreach(e =&gt; throw e)</span>

<span class="nc" id="L267">      val sft = SimpleFeatureTypes.mutable(schema)</span>

      // validation and normalization of the schema
<span class="nc" id="L270">      preSchemaUpdate(sft, previousSft)</span>

<span class="nc" id="L272">      val encodedAttributes = SimpleFeatureTypes.encodeType(sft, includeUserData = true)</span>
      // validate we can read out the encoded sft - invalid user data keys can break the parsing
<span class="nc" id="L274">      try { SimpleFeatureTypes.createType(&quot;&quot;, encodedAttributes) } catch {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new IllegalArgumentException(&quot;Invalid schema:&quot;, e)</span>
      }

      // if all is well, update the metadata - first back it up
<span class="nc bnc" id="L279" title="All 2 branches missed.">      if (FastConverter.convertOrElse[java.lang.Boolean](sft.getUserData.get(Configs.UpdateBackupMetadata), true)) {</span>
<span class="nc" id="L280">        metadata.backup(typeName.getLocalPart)</span>
      }

      // rename the old rows if the type name has changed
<span class="nc bnc" id="L284" title="All 6 branches missed.">      if (typeName.getLocalPart != schema.getTypeName) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        metadata.scan(typeName.getLocalPart, &quot;&quot;, cache = false).foreach { case (k, v) =&gt;</span>
<span class="nc" id="L286">          metadata.insert(sft.getTypeName, k, v)</span>
<span class="nc" id="L287">          metadata.remove(typeName.getLocalPart, k)</span>
        }
      }
      // now insert the new spec string
<span class="nc" id="L291">      metadata.insert(sft.getTypeName, AttributesKey, encodedAttributes)</span>

<span class="nc" id="L293">      onSchemaUpdated(sft, previousSft)</span>
    } finally {
<span class="nc" id="L295">      lock.close()</span>
    }
  }

  /**
    * Deletes the schema metadata
    *
    * @see org.geotools.api.data.DataStore#removeSchema(java.lang.String)
    * @param typeName simple feature type name
    */
  override def removeSchema(typeName: String): Unit = {
<span class="nc" id="L306">    val lock = acquireCatalogLock()</span>
    try {
<span class="nc" id="L308">      Option(getSchema(typeName)).foreach { sft =&gt;</span>
<span class="nc" id="L309">        onSchemaDeleted(sft)</span>
<span class="nc" id="L310">        metadata.delete(typeName)</span>
      }
    } finally {
<span class="nc" id="L313">      lock.close()</span>
    }
  }

  /**
    * @see org.geotools.data.DataAccess#removeSchema(org.geotools.api.feature.type.Name)
    * @param typeName simple feature type name
    */
<span class="nc" id="L321">  override def removeSchema(typeName: Name): Unit = removeSchema(typeName.getLocalPart)</span>

  /**
    * @see org.geotools.api.data.DataStore#getFeatureSource(java.lang.String)
    * @param typeName simple feature type name
    * @return featureStore, suitable for reading and writing
    */
<span class="nc" id="L328">  override def getFeatureSource(typeName: Name): SimpleFeatureSource = getFeatureSource(typeName.getLocalPart)</span>

  /**
   * @see org.geotools.api.data.DataStore#getFeatureReader(org.geotools.api.data.Query, org.geotools.api.data.Transaction)
   * @param query query to execute
   * @param transaction transaction to use (currently ignored)
   * @return feature reader
   */
  override def getFeatureReader(query: Query, transaction: Transaction): SimpleFeatureReader = {
<span class="nc bnc" id="L337" title="All 2 branches missed.">    require(query.getTypeName != null, &quot;Type name is required in the query&quot;)</span>
<span class="nc" id="L338">    val sft = getSchema(query.getTypeName)</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">    if (sft == null) {</span>
<span class="nc" id="L340">      throw new IOException(s&quot;Schema '${query.getTypeName}' has not been initialized. Please call 'createSchema' first.&quot;)</span>
    }
<span class="nc" id="L342">    getFeatureReader(sft, transaction, query).reader()</span>
  }

  /**
    * Create a general purpose writer that is capable of updates and deletes.
    * Does &lt;b&gt;not&lt;/b&gt; allow inserts. Will return all existing features.
    *
    * @see org.geotools.api.data.DataStore#getFeatureWriter(java.lang.String, org.geotools.api.data.Transaction)
    * @param typeName feature type name
    * @param transaction transaction (currently ignored)
    * @return feature writer
    */
  override def getFeatureWriter(typeName: String, transaction: Transaction): FlushableFeatureWriter =
<span class="nc" id="L355">    getFeatureWriter(typeName, Filter.INCLUDE, transaction)</span>

  /**
    * Create a general purpose writer that is capable of updates and deletes.
    * Does &lt;b&gt;not&lt;/b&gt; allow inserts.
    *
    * @see org.geotools.api.data.DataStore#getFeatureWriter(java.lang.String, org.geotools.api.filter.Filter,
    *        org.geotools.api.data.Transaction)
    * @param typeName feature type name
    * @param filter cql filter to select features for update/delete
    * @param transaction transaction (currently ignored)
    * @return feature writer
    */
  override def getFeatureWriter(typeName: String, filter: Filter, transaction: Transaction): FlushableFeatureWriter = {
<span class="nc" id="L369">    val sft = getSchema(typeName)</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if (sft == null) {</span>
<span class="nc" id="L371">      throw new IOException(s&quot;Schema '$typeName' has not been initialized. Please call 'createSchema' first.&quot;)</span>
    }
<span class="nc" id="L373">    getFeatureWriter(sft, transaction, Option(filter))</span>
  }

  /**
    * Creates a feature writer only for writing - does not allow updates or deletes.
    *
    * @see org.geotools.api.data.DataStore#getFeatureWriterAppend(java.lang.String, org.geotools.api.data.Transaction)
    * @param typeName feature type name
    * @param transaction transaction (currently ignored)
    * @return feature writer
    */
  override def getFeatureWriterAppend(typeName: String, transaction: Transaction): FlushableFeatureWriter = {
<span class="nc" id="L385">    val sft = getSchema(typeName)</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">    if (sft == null) {</span>
<span class="nc" id="L387">      throw new IOException(s&quot;Schema '$typeName' has not been initialized. Please call 'createSchema' first.&quot;)</span>
    }
<span class="nc" id="L389">    getFeatureWriter(sft, transaction, None)</span>
  }

  /**
   * Internal method to get a feature writer without reloading the simple feature type. We don't expose this
   * widely as we want to ensure that the sft has been loaded from our catalog
   *
   * @param sft simple feature type
   * @param transaction transaction
   * @param filter if defined, will do an updating write, otherwise will do an appending write
   * @return
   */
  private[geomesa] def getFeatureWriter(
      sft: SimpleFeatureType,
      transaction: Transaction,
      filter: Option[Filter]): FlushableFeatureWriter

  /**
    * @see org.geotools.data.DataAccess#getInfo()
    * @return service info
    */
  override def getInfo: ServiceInfo = {
<span class="nc" id="L411">    val info = new DefaultServiceInfo()</span>
<span class="nc" id="L412">    info.setDescription(s&quot;Features from ${getClass.getSimpleName}&quot;)</span>
<span class="nc" id="L413">    info.setSchema(FeatureTypes.DEFAULT_NAMESPACE)</span>
<span class="nc" id="L414">    info</span>
  }

  /**
    * We always return null, which indicates that we are handling transactions ourselves.
    *
    * @see org.geotools.api.data.DataStore#getLockingManager()
    * @return locking manager - null
    */
<span class="nc" id="L423">  override def getLockingManager: LockingManager = null</span>

  /**
    * Cleanup any open connections, etc. Equivalent to java.io.Closeable.close()
    *
    * @see org.geotools.data.DataAccess#dispose()
    */
  override def dispose(): Unit = {
<span class="nc" id="L431">    CloseWithLogging(metadata)</span>
<span class="nc" id="L432">    CloseWithLogging(interceptors)</span>
  }

  // end methods from org.geotools.api.data.DataStore

  /**
   * Get metrics tags for a given type name + this store
   *
   * @param typeName type name
   * @return
   */
<span class="nc" id="L443">  def tags(typeName: String): Tags = tags.and(TagUtils.typeNameTag(typeName))</span>

  /**
   * Validate a call to updateSchema, throwing errors on failed validation
   *
   * @param existing existing schema
   * @param schema updated sft
   * @return validation result
   */
  protected def validateSchemaUpdate(
      existing: SimpleFeatureType,
      schema: SimpleFeatureType): Either[UnsupportedOperationException, TypeComparison.Compatible] = {
    // validate that default geometry and date have not changed (rename is ok)
<span class="nc bnc" id="L456" title="All 2 branches missed.">    if (schema.getGeomIndex != existing.getGeomIndex) {</span>
<span class="nc" id="L457">      return Left(new UnsupportedOperationException(&quot;Changing the default geometry attribute is not supported&quot;))</span>
    }
<span class="nc bnc" id="L459" title="All 6 branches missed.">    if (schema.getDtgIndex != existing.getDtgIndex) {</span>
<span class="nc" id="L460">      return Left(new UnsupportedOperationException(&quot;Changing the default date attribute is not supported&quot;))</span>
    }

    // check that unmodifiable user data has not changed
<span class="nc" id="L464">    val userDataChanges = MetadataBackedDataStore.UnmodifiableUserDataKeys.flatMap { key =&gt;</span>
<span class="nc bnc" id="L465" title="All 6 branches missed.">      if (schema.userData[Any](key) == existing.userData[Any](key)) { None } else {</span>
<span class="nc" id="L466">        Some(s&quot;'$key'&quot;)</span>
      }
    }
<span class="nc bnc" id="L469" title="All 2 branches missed.">    if (userDataChanges.nonEmpty) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">      val msg = s&quot;${if (userDataChanges.size == 1) { &quot;&quot; } else { &quot;s&quot; }} ${userDataChanges.mkString(&quot;, &quot;)}&quot;</span>
<span class="nc" id="L471">      return Left(new UnsupportedOperationException(s&quot;Updating user data key$msg is not supported&quot;))</span>
    }

<span class="nc" id="L474">    SimpleFeatureTypeComparator.compare(existing, schema) match {</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">      case TypeComparison.AttributeRemoved =&gt;</span>
<span class="nc" id="L476">        Left(new UnsupportedOperationException(&quot;Removing attributes from the schema is not supported&quot;))</span>

<span class="nc bnc" id="L478" title="All 2 branches missed.">      case TypeComparison.AttributeTypeChanged(changes) =&gt;</span>
<span class="nc bnc" id="L479" title="All 4 branches missed.">        val msg = changes.map { case (name, (from, to)) =&gt; s&quot;$name from ${from.getName} to ${to.getName}&quot; }</span>
<span class="nc" id="L480">        Left(new UnsupportedOperationException(s&quot;Incompatible schema column type changes: ${msg.mkString(&quot;, &quot;)}&quot;))</span>

<span class="nc bnc" id="L482" title="All 2 branches missed.">      case c: TypeComparison.Compatible =&gt;</span>
        // check for reserved words - only check for new/renamed attributes
<span class="nc" id="L484">        val reserved = schema.getAttributeDescriptors.asScala.map(_.getLocalName).exists { name =&gt;</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">          existing.getDescriptor(name) == null &amp;&amp; FeatureUtils.ReservedWords.contains(name.toUpperCase(Locale.US))</span>
        }
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (reserved) {</span>
<span class="nc" id="L488">          try { ReservedWordCheck.validateAttributeNames(schema) } catch {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            case NonFatal(e) =&gt;</span>
<span class="nc" id="L490">              return Left(new UnsupportedOperationException(e.getMessage))</span>
          }
        }
<span class="nc" id="L493">        Right(c)</span>
    }
  }

  /**
   * Acquires a distributed lock for all data stores sharing this catalog table.
   * Make sure that you 'release' the lock in a finally block.
   */
  protected[geomesa] def acquireCatalogLock(): Closeable = {
    import org.locationtech.geomesa.index.DistributedLockTimeout
<span class="nc" id="L503">    val dsTypeName = getClass.getSimpleName.replaceAll(&quot;[^A-Za-z]&quot;, &quot;&quot;)</span>
<span class="nc" id="L504">    val path = s&quot;/org.locationtech.geomesa/ds/$dsTypeName/${config.catalog}&quot;</span>
<span class="nc" id="L505">    val timeout = DistributedLockTimeout.toDuration.getOrElse {</span>
      // note: should always be a valid fallback value so this exception should never be triggered
<span class="nc" id="L507">      throw new IllegalArgumentException(s&quot;Couldn't convert '${DistributedLockTimeout.get}' to a duration&quot;)</span>
    }
<span class="nc" id="L509">    acquireDistributedLock(path, timeout.toMillis).getOrElse {</span>
<span class="nc" id="L510">      throw new RuntimeException(s&quot;Could not acquire distributed lock at '$path' within $timeout&quot;)</span>
    }
  }
}

<span class="nc" id="L515">object MetadataBackedDataStore {</span>

  import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.Configs._

<span class="nc" id="L519">  private val UnmodifiableUserDataKeys =</span>
<span class="nc" id="L520">    Set(</span>
<span class="nc" id="L521">      TableSharing,</span>
<span class="nc" id="L522">      TableSharingPrefix,</span>
<span class="nc" id="L523">      IndexVisibilityLevel,</span>
<span class="nc" id="L524">      IndexZ3Interval,</span>
<span class="nc" id="L525">      IndexS3Interval,</span>
<span class="nc" id="L526">      IndexXzPrecision,</span>
<span class="nc" id="L527">      IndexZShards,</span>
<span class="nc" id="L528">      IndexZ2Shards,</span>
<span class="nc" id="L529">      IndexZ3Shards,</span>
<span class="nc" id="L530">      IndexIdShards,</span>
<span class="nc" id="L531">      IndexAttributeShards</span>
    )
<span class="nc" id="L533">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>