<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaFeatureCollection.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.geotools</a> &gt; <span class="el_source">GeoMesaFeatureCollection.scala</span></div><h1>GeoMesaFeatureCollection.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.geotools

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data._
import org.geotools.api.feature.FeatureVisitor
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.filter.expression.{Expression, PropertyName}
import org.geotools.api.filter.sort.SortBy
import org.geotools.api.util.ProgressListener
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.data.store.DataFeatureCollection
import org.geotools.data.util.NullProgressListener
import org.geotools.feature.FeatureCollection
import org.geotools.feature.collection.{DecoratingFeatureCollection, DecoratingSimpleFeatureCollection}
import org.geotools.feature.visitor.GroupByVisitor.GroupByRawResult
import org.geotools.feature.visitor._
import org.geotools.geometry.jts.ReferencedEnvelope
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureCollection.GeoMesaFeatureVisitingCollection
import org.locationtech.geomesa.index.process.GeoMesaProcessVisitor
import org.locationtech.geomesa.index.stats.impl._
import org.locationtech.geomesa.index.stats.{GeoMesaStats, Stat}
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.io.WithClose

import java.util.Collections
import java.util.concurrent.atomic.AtomicLong
import scala.annotation.tailrec

/**
  * Feature collection implementation
  */
<span class="nc" id="L42">class GeoMesaFeatureCollection(source: GeoMesaFeatureSource, query: Query)</span>
<span class="nc" id="L43">    extends GeoMesaFeatureVisitingCollection(source, source.ds.stats, query) {</span>

<span class="nc" id="L45">  private val transaction = source match {</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">    case s: SimpleFeatureStore =&gt; s.getTransaction</span>
<span class="nc" id="L47">    case _ =&gt; Transaction.AUTO_COMMIT</span>
  }

<span class="nc bnc" id="L50" title="All 4 branches missed.">  private lazy val featureReader = source.ds.getFeatureReader(source.sft, transaction, query)</span>

<span class="nc" id="L52">  override def getSchema: SimpleFeatureType = featureReader.schema</span>

<span class="nc" id="L54">  override def reader(): FeatureReader[SimpleFeatureType, SimpleFeature] = featureReader.reader()</span>

  override def subCollection(filter: Filter): SimpleFeatureCollection = {
<span class="nc" id="L57">    val merged = new Query(query)</span>
<span class="nc bnc" id="L58" title="All 6 branches missed.">    val filters = Seq(merged.getFilter, filter).filter(_ != Filter.INCLUDE)</span>
<span class="nc" id="L59">    FilterHelper.filterListAsAnd(filters).foreach(merged.setFilter)</span>
<span class="nc" id="L60">    new GeoMesaFeatureCollection(source, merged)</span>
  }

  override def sort(order: SortBy): SimpleFeatureCollection = {
<span class="nc" id="L64">    val merged = new Query(query)</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (merged.getSortBy == null) {</span>
<span class="nc" id="L66">      merged.setSortBy(order)</span>
    } else {
<span class="nc" id="L68">      merged.setSortBy(merged.getSortBy :+ order: _*)</span>
    }
<span class="nc" id="L70">    new GeoMesaFeatureCollection(source, merged)</span>
  }

<span class="nc" id="L73">  override def getBounds: ReferencedEnvelope = source.getBounds(query)</span>

<span class="nc" id="L75">  override def getCount: Int = source.getCount(query)</span>

  // note: this shouldn't return -1 (as opposed to FeatureSource.getCount), but we still don't return a valid
  // size unless exact counts are enabled
  override def size: Int = {
<span class="nc" id="L80">    val count = getCount</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">    if (count &lt; 0) { 0 } else { count }</span>
  }

  override def contains(o: Any): Boolean = {
<span class="nc" id="L85">    o match {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">      case f: SimpleFeature =&gt;</span>
<span class="nc" id="L87">        val sub = subCollection(FilterHelper.ff.id(f.getIdentifier))</span>
<span class="nc" id="L88">        WithClose(CloseableIterator(sub.features()))(_.nonEmpty)</span>

<span class="nc" id="L90">      case _ =&gt; false</span>
    }
  }

  override def containsAll(collection: java.util.Collection[_]): Boolean = {
<span class="nc" id="L95">    val size = collection.size()</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">    if (size == 0) { true } else {</span>
<span class="nc" id="L97">      val filters = Seq.newBuilder[Filter]</span>
<span class="nc" id="L98">      filters.sizeHint(size)</span>

<span class="nc" id="L100">      val features = collection.iterator()</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">      while (features.hasNext) {</span>
<span class="nc" id="L102">        features.next match {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">          case f: SimpleFeature =&gt; filters += FilterHelper.ff.id(f.getIdentifier)</span>
<span class="nc" id="L104">          case _ =&gt; return false</span>
        }
      }

<span class="nc" id="L108">      val sub = subCollection(org.locationtech.geomesa.filter.orFilters(filters.result))</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      WithClose(CloseableIterator(sub.features()))(_.length) == size</span>
    }
  }
}

<span class="nc bnc" id="L114" title="All 4 branches missed.">object GeoMesaFeatureCollection extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L118">  private val oneUp = new AtomicLong(0)</span>

<span class="nc" id="L120">  def nextId: String = s&quot;GeoMesaFeatureCollection-${oneUp.getAndIncrement()}&quot;</span>

  /**
    * Attempts to visit the feature collection in an optimized manner. This will unwrap any decorating
    * feature collections that may interfere with the `accepts` method.
    *
    * Note that generally this may not be a good idea - collections are presumably wrapped for a reason.
    * However, our visitation functionality keeps being broken by changes in GeoServer, so we're being
    * defensive here.
    *
    * @param collection feature collection
    * @param visitor visitor
    * @param progress progress monitor
    */
  def visit(
      collection: FeatureCollection[SimpleFeatureType, SimpleFeature],
      visitor: FeatureVisitor,
<span class="nc" id="L137">      progress: ProgressListener = new NullProgressListener): Unit = {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    val unwrapped = if (collection.isInstanceOf[GeoMesaFeatureVisitingCollection]) { collection } else {</span>
<span class="nc" id="L139">      try { unwrap(collection) } catch {</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        case e: Throwable =&gt; logger.debug(&quot;Error trying to unwrap feature collection:&quot;, e); collection</span>
      }
    }
<span class="nc" id="L143">    unwrapped.accepts(visitor, progress)</span>
  }

  /**
    * Attempts to remove any decorating feature collections
    *
    * @param collection collection
    * @param level level of collections that have been removed, used to detect potentially infinite looping
    * @return
    */
  @tailrec
  private def unwrap(
      collection: FeatureCollection[SimpleFeatureType, SimpleFeature],
<span class="nc" id="L156">      level: Int = 1): FeatureCollection[SimpleFeatureType, SimpleFeature] = {</span>

    // noinspection TypeCheckCanBeMatch
<span class="nc bnc" id="L159" title="All 2 branches missed.">    val unwrapped = if (collection.isInstanceOf[DecoratingSimpleFeatureCollection]) {</span>
<span class="nc" id="L160">      getDelegate(collection, classOf[DecoratingSimpleFeatureCollection])</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">    } else if (collection.isInstanceOf[DecoratingFeatureCollection[SimpleFeatureType, SimpleFeature]]) {</span>
<span class="nc" id="L162">      getDelegate(collection, classOf[DecoratingFeatureCollection[SimpleFeatureType, SimpleFeature]])</span>
    } else {
<span class="nc bnc" id="L164" title="All 2 branches missed.">      logger.debug(s&quot;Unable to unwrap feature collection $collection of class ${collection.getClass.getName}&quot;)</span>
<span class="nc" id="L165">      return collection</span>
    }

<span class="nc bnc" id="L168" title="All 2 branches missed.">    logger.debug(s&quot;Unwrapped feature collection $collection of class ${collection.getClass.getName} to &quot; +</span>
<span class="nc" id="L169">        s&quot;$unwrapped of class ${unwrapped.getClass.getName}&quot;)</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">    if (unwrapped.isInstanceOf[GeoMesaFeatureVisitingCollection]) {</span>
<span class="nc" id="L172">      unwrapped</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">    } else if (level &gt; 9) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">      logger.debug(&quot;Aborting feature collection unwrapping after 10 iterations&quot;)</span>
<span class="nc" id="L175">      unwrapped</span>
    } else {
<span class="nc" id="L177">      unwrap(unwrapped, level + 1)</span>
    }
  }

  /**
    * Uses reflection to access the protected field 'delegate' in decorating feature collection classes
    *
    * @param collection decorating feature collection
    * @param clas decorating feature base class
    * @return
    */
  private def getDelegate(
      collection: FeatureCollection[SimpleFeatureType, SimpleFeature],
      clas: Class[_]): FeatureCollection[SimpleFeatureType, SimpleFeature] = {
<span class="nc" id="L191">    val m = clas.getDeclaredField(&quot;delegate&quot;)</span>
<span class="nc" id="L192">    m.setAccessible(true)</span>
<span class="nc" id="L193">    m.get(collection).asInstanceOf[FeatureCollection[SimpleFeatureType, SimpleFeature]]</span>
  }

  /**
    * Base class for handling feature visitors
    *
    * @param source feature source
    * @param stats geomesa stat hook
    * @param query query
    */
<span class="nc bnc" id="L203" title="All 4 branches missed.">  abstract class GeoMesaFeatureVisitingCollection(source: SimpleFeatureSource, stats: GeoMesaStats, query: Query)</span>
<span class="nc" id="L204">      extends DataFeatureCollection(nextId) with LazyLogging {</span>

    private def unoptimized(visitor: FeatureVisitor, progress: ProgressListener): Unit = {
<span class="nc bnc" id="L207" title="All 2 branches missed.">      lazy val warning = s&quot;Using unoptimized method for visiting '${visitor.getClass.getName}'&quot;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">      logger.warn(warning)</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">      if (progress != null) {</span>
<span class="nc" id="L210">        progress.warningOccurred(getClass.getName, &quot;accepts()&quot;, warning)</span>
      }
<span class="nc" id="L212">      super.accepts(visitor, progress)</span>
    }

    override def accepts(visitor: FeatureVisitor, progress: ProgressListener): Unit = {
<span class="nc" id="L216">      visitor match {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        case v: GeoMesaProcessVisitor =&gt;</span>
<span class="nc" id="L218">          v.execute(source, query)</span>

<span class="nc bnc" id="L220" title="All 4 branches missed.">        case v: AverageVisitor if v.getExpression.isInstanceOf[PropertyName] =&gt;</span>
<span class="nc" id="L221">          val attribute = v.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L222">          val stat = Stat.DescriptiveStats(Seq(attribute))</span>
<span class="nc" id="L223">          stats.getStat[DescriptiveStats](source.getSchema, stat, query.getFilter, exact = true) match {</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">            case Some(s) if s.count &lt;= Int.MaxValue.toLong =&gt; v.setValue(s.count.toInt, s.sum(0))</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            case Some(s) =&gt; v.setValue(s.mean(0))</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            case None    =&gt; unoptimized(visitor, progress)</span>
          }

<span class="nc bnc" id="L229" title="All 2 branches missed.">        case v: BoundsVisitor =&gt;</span>
<span class="nc" id="L230">          v.getBounds.expandToInclude(stats.getBounds(source.getSchema, query.getFilter))</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">        case v: CountVisitor =&gt;</span>
<span class="nc" id="L233">          v.setValue(source.getCount(query))</span>

<span class="nc bnc" id="L235" title="All 4 branches missed.">        case v: MaxVisitor if v.getExpression.isInstanceOf[PropertyName] =&gt;</span>
<span class="nc" id="L236">          val attribute = v.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L237">          minMax(attribute, exact = false).orElse(minMax(attribute, exact = true)) match {</span>
<span class="nc bnc" id="L238" title="All 4 branches missed.">            case Some((_, max)) =&gt; v.setValue(max)</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            case None           =&gt; unoptimized(visitor, progress)</span>
          }

<span class="nc bnc" id="L242" title="All 4 branches missed.">        case v: GroupByVisitor if v.getExpression.isInstanceOf[PropertyName] =&gt;</span>
<span class="nc" id="L243">          val attribute = v.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L244">          groupBy(attribute, v.getGroupByAttributes.asScala.toSeq, v.getAggregateVisitor) match {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            case Some(result) =&gt; v.setValue(result)</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            case None         =&gt; unoptimized(visitor, progress)</span>
          }

<span class="nc bnc" id="L249" title="All 4 branches missed.">        case v: MinVisitor if v.getExpression.isInstanceOf[PropertyName] =&gt;</span>
<span class="nc" id="L250">          val attribute = v.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L251">          minMax(attribute, exact = false).orElse(minMax(attribute, exact = true)) match {</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">            case Some((min, _)) =&gt; v.setValue(min)</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            case None           =&gt; unoptimized(visitor, progress)</span>
          }

<span class="nc bnc" id="L256" title="All 4 branches missed.">        case v: SumVisitor if v.getExpression.isInstanceOf[PropertyName] =&gt;</span>
<span class="nc" id="L257">          val attribute = v.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L258">          val stat = Stat.DescriptiveStats(Seq(attribute))</span>
<span class="nc" id="L259">          stats.getStat[DescriptiveStats](source.getSchema, stat, query.getFilter, exact = true) match {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            case Some(s) =&gt; v.setValue(s.sum(0))</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            case None    =&gt; unoptimized(visitor, progress)</span>
          }

<span class="nc bnc" id="L264" title="All 4 branches missed.">        case v: UniqueVisitor if v.getExpression.isInstanceOf[PropertyName] =&gt;</span>
<span class="nc" id="L265">          val attribute = v.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L266">          val stat = Stat.Enumeration(attribute)</span>
<span class="nc" id="L267">          stats.getStat[EnumerationStat[Any]](source.getSchema, stat, query.getFilter, exact = true) match {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            case Some(s) =&gt; v.setValue(s.values.toList.asJava)</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            case None    =&gt; unoptimized(visitor, progress)</span>
          }

        case _ =&gt;
<span class="nc" id="L273">          unoptimized(visitor, progress)</span>
      }
    }

    private def minMax(attribute: String, exact: Boolean): Option[(Any, Any)] =
<span class="nc" id="L278">      stats.getMinMax[Any](source.getSchema, attribute, query.getFilter, exact).map(_.bounds)</span>

    private def groupBy(
        attribute: String,
        groupByExpression: Seq[Expression],
        aggregate: FeatureVisitor): Option[java.util.List[GroupByRawResult]] = {
<span class="nc bnc" id="L284" title="All 2 branches missed.">      if (groupByExpression.lengthCompare(1) != 0</span>
<span class="nc bnc" id="L285" title="All 4 branches missed.">          || groupByExpression.exists(e =&gt; !e.isInstanceOf[PropertyName])) { None } else {</span>
<span class="nc" id="L286">        val groupBy = groupByExpression.map(_.asInstanceOf[PropertyName].getPropertyName).head</span>
<span class="nc" id="L287">        val op: Option[(String, Stat =&gt; Any)] = aggregate match {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">          case _: CountVisitor =&gt;</span>
<span class="nc" id="L289">            Some(Stat.Count() -&gt; { (s: Stat) =&gt; math.min( s.asInstanceOf[CountStat].count, Int.MaxValue.toLong).toInt })</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">          case _: MaxVisitor =&gt;</span>
<span class="nc" id="L292">            Some(Stat.MinMax(attribute) -&gt; { (s: Stat) =&gt; s.asInstanceOf[MinMax[Any]].max })</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">          case _: MinVisitor =&gt;</span>
<span class="nc" id="L295">            Some(Stat.MinMax(attribute) -&gt; { (s: Stat) =&gt; s.asInstanceOf[MinMax[Any]].min })</span>

          case _ =&gt;
<span class="nc" id="L298">            None</span>
        }
<span class="nc bnc" id="L300" title="All 2 branches missed.">        op.flatMap { case (nested, unwrap) =&gt;</span>
<span class="nc" id="L301">          val stat = Stat.GroupBy(groupBy, nested)</span>
<span class="nc" id="L302">          stats.getStat[GroupBy[AnyRef]](source.getSchema, stat, query.getFilter, exact = true).map { grouped =&gt;</span>
<span class="nc" id="L303">            val result = new java.util.ArrayList[GroupByRawResult]</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            grouped.iterator.foreach { case (group, stat) =&gt;</span>
<span class="nc" id="L305">              result.add(new GroupByRawResult(Collections.singletonList(group), unwrap(stat)))</span>
            }
<span class="nc" id="L307">            result</span>
          }
        }
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>