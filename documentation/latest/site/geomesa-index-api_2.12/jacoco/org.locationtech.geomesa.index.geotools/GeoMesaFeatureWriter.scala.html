<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaFeatureWriter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.geotools</a> &gt; <span class="el_source">GeoMesaFeatureWriter.scala</span></div><h1>GeoMesaFeatureWriter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.geotools

import com.typesafe.scalalogging.LazyLogging
import io.micrometer.core.instrument.{Metrics, Timer}
import org.geotools.api.data.{Query, Transaction}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.data.DataUtilities
import org.geotools.filter.identity.FeatureIdImpl
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.{FastSettableFeature, ScalaSimpleFeature}
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.api.IndexAdapter.IndexWriter
import org.locationtech.geomesa.index.conf.partition.TablePartition
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureWriter.WriteException
import org.locationtech.geomesa.index.stats.GeoMesaStats.StatUpdater
import org.locationtech.geomesa.security.SecurityUtils
import org.locationtech.geomesa.utils.concurrent.CachedThreadPool
import org.locationtech.geomesa.utils.io.{CloseQuietly, FlushQuietly}
import org.locationtech.geomesa.utils.uuid.{FeatureIdGenerator, Z3FeatureIdGenerator}

import java.io.{Closeable, Flushable}
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong
import scala.util.control.NonFatal

<span class="nc" id="L35">trait GeoMesaFeatureWriter[DS &lt;: GeoMesaDataStore[DS]] extends FastSettableFeatureWriter with Flushable with LazyLogging {</span>

  def ds: DS
  def sft: SimpleFeatureType
  def indices: Seq[GeoMesaFeatureIndex[_, _]]

  // flushables/closeables defined in subclasses, so we can manage them here
  protected def flushables(): Seq[Flushable]
  protected def closeables(): Seq[Closeable]

<span class="nc" id="L45">  private val appendTimer = GeoMesaFeatureWriter.writeTimer(ds, sft, &quot;append&quot;)</span>
<span class="nc" id="L46">  private val updateTimer = GeoMesaFeatureWriter.writeTimer(ds, sft, &quot;update&quot;)</span>
<span class="nc" id="L47">  private val deleteTimer = GeoMesaFeatureWriter.writeTimer(ds, sft, &quot;delete&quot;)</span>
<span class="nc" id="L48">  private val flushTimer = GeoMesaFeatureWriter.writeTimer(ds, sft, &quot;flush&quot;)</span>

<span class="nc" id="L50">  protected val statUpdater: StatUpdater = ds.stats.writer.updater(sft)</span>

<span class="nc" id="L52">  override def getFeatureType: SimpleFeatureType = sft</span>

  override def flush(): Unit = {
<span class="nc" id="L55">    val start = System.nanoTime()</span>
    try {
<span class="nc" id="L57">      val errors = flushables().flatMap(FlushQuietly(_))</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">      if (errors.nonEmpty) {</span>
<span class="nc" id="L59">        propagateExceptions(errors)</span>
      }
    } finally {
<span class="nc" id="L62">      flushTimer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS)</span>
    }
  }

  override def close(): Unit = {
<span class="nc" id="L67">    val start = System.nanoTime()</span>
    try {
<span class="nc" id="L69">      val errors = closeables().flatMap(CloseQuietly(_))</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">      if (errors.nonEmpty) {</span>
<span class="nc" id="L71">        propagateExceptions(errors)</span>
      }
    } finally {
      // we count closes as flushes for timing purposes
<span class="nc" id="L75">      flushTimer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS)</span>
    }
  }

  protected def getWriter(feature: SimpleFeature): IndexWriter

  protected def updateFeature(update: FastSettableFeature, previous: SimpleFeature): Unit = {
<span class="nc" id="L82">    val start = System.nanoTime()</span>
    try {
      // see if there's a suggested ID to use for this feature, else create one based on the feature
<span class="nc" id="L85">      val writable = GeoMesaFeatureWriter.featureWithFid(update)</span>
<span class="nc" id="L86">      try {</span>
<span class="nc" id="L87">        val writer = getWriter(writable)</span>
<span class="nc" id="L88">        val remover = getWriter(previous)</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (writer.eq(remover)) {</span>
          // `update` will calculate all mutations up front in case the feature is not valid, so we don't write partial entries
<span class="nc" id="L91">          writer.update(writable, previous)</span>
        } else {
<span class="nc" id="L93">          remover.delete(previous)</span>
<span class="nc" id="L94">          writer.append(writable)</span>
        }
      } catch {
<span class="nc bnc" id="L97" title="All 2 branches missed.">        case NonFatal(e) =&gt; throwWriteErrors(e, writable)</span>
      }
<span class="nc" id="L99">      statUpdater.add(writable)</span>
    } finally {
<span class="nc" id="L101">      updateTimer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS)</span>
    }
  }

  protected def appendFeature(feature: FastSettableFeature): Unit = {
<span class="nc" id="L106">    val start = System.nanoTime()</span>
    try {
      // see if there's a suggested ID to use for this feature, else create one based on the feature
<span class="nc" id="L109">      val writable = GeoMesaFeatureWriter.featureWithFid(feature)</span>
<span class="nc" id="L110">      try {</span>
        // `append` will calculate all mutations up front in case the feature is not valid, so we don't write partial entries
<span class="nc" id="L112">        getWriter(writable).append(writable)</span>
      } catch {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        case NonFatal(e) =&gt; throwWriteErrors(e, writable)</span>
      }
<span class="nc" id="L116">      statUpdater.add(writable)</span>
    } finally {
<span class="nc" id="L118">      appendTimer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS)</span>
    }
  }

  protected def removeFeature(feature: SimpleFeature): Unit = {
<span class="nc" id="L123">    val start = System.nanoTime()</span>
    try {
      // the feature has come directly from our reader, so it should be valid and already have a FID
<span class="nc" id="L126">      getWriter(feature).delete(feature)</span>
<span class="nc" id="L127">      statUpdater.remove(feature)</span>
    } finally {
<span class="nc" id="L129">      deleteTimer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS)</span>
    }
  }

  // returns a temporary id - we will replace it just before write
<span class="nc" id="L134">  protected def nextFeatureId: String = GeoMesaFeatureWriter.tempFeatureIds.getAndIncrement().toString</span>

  @throws[Exception]
  private def throwWriteErrors(e: Throwable, feature: SimpleFeature): Unit = {
<span class="nc bnc" id="L138" title="All 2 branches missed.">    lazy val msg = s&quot;Error indexing feature '${feature.getID}:${DataUtilities.encodeFeature(feature, false)}'&quot;</span>
<span class="nc" id="L139">    e match {</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">      case _: WriteException =&gt; throw e</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">      case _: IllegalArgumentException =&gt; throw new IllegalArgumentException(msg, e)</span>
<span class="nc" id="L142">      case _ =&gt; throw new RuntimeException(msg, e)</span>
    }
  }

  private def propagateExceptions(errors: Seq[Throwable]): Unit = {
<span class="nc" id="L147">    val all = new RuntimeException(s&quot;Error writing features:&quot;)</span>
<span class="nc" id="L148">    errors.foreach(all.addSuppressed)</span>
<span class="nc" id="L149">    throw all</span>
  }
}

<span class="nc bnc" id="L153" title="All 4 branches missed.">object GeoMesaFeatureWriter extends LazyLogging {</span>

<span class="nc" id="L155">  private val tempFeatureIds = new AtomicLong(0)</span>

<span class="nc" id="L157">  private val idGenerator: FeatureIdGenerator = {</span>
    import org.locationtech.geomesa.index.conf.FeatureProperties.FEATURE_ID_GENERATOR
<span class="nc" id="L159">    try {</span>
      logger.debug(s&quot;Using feature id generator '${FEATURE_ID_GENERATOR.get}'&quot;)
      Class.forName(FEATURE_ID_GENERATOR.get).newInstance().asInstanceOf[FeatureIdGenerator]
    } catch {
      case e: Throwable =&gt;
        logger.error(s&quot;Could not load feature id generator class '${FEATURE_ID_GENERATOR.get}'&quot;, e)
        new Z3FeatureIdGenerator
    }
  }

  /**
   * Create a feature writer
   *
   * @param ds datastore
   * @param sft simple feature type
   * @param indices indices to write
   * @param filter filter for selecting features for updating writes, or None for appending writes
   * @param atomic enforce atomic writes
   * @tparam DS datastore type
   * @return feature writer
   */
  def apply[DS &lt;: GeoMesaDataStore[DS]](
      ds: DS,
      sft: SimpleFeatureType,
      indices: Seq[GeoMesaFeatureIndex[_, _]],
      filter: Option[Filter],
      atomic: Boolean): GeoMesaFeatureWriter[DS] = {
<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (TablePartition.partitioned(sft)) {</span>
<span class="nc" id="L187">      filter match {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        case None =&gt; new PartitionFeatureWriter(ds, sft, indices, atomic) with GeoMesaAppendFeatureWriter[DS]</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        case Some(f) =&gt;</span>
<span class="nc" id="L190">          new PartitionFeatureWriter(ds, sft, indices, atomic) with GeoMesaModifyFeatureWriter[DS] {</span>
<span class="nc" id="L191">            override def filter: Filter = f</span>
          }
      }
    } else {
<span class="nc" id="L195">      filter match {</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        case None =&gt; new TableFeatureWriter(ds, sft, indices, atomic) with GeoMesaAppendFeatureWriter[DS]</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        case Some(f) =&gt;</span>
<span class="nc" id="L198">          new TableFeatureWriter(ds, sft, indices, atomic) with GeoMesaModifyFeatureWriter[DS] {</span>
<span class="nc" id="L199">            override def filter: Filter = f</span>
          }
      }
    }
  }

  /**
   * Sets the feature ID on the feature. If the user has requested a specific ID, that will be used,
   * otherwise one will be generated. If possible, the original feature will be modified and returned.
   */
  def featureWithFid(feature: SimpleFeature): SimpleFeature = {
<span class="nc" id="L210">    val provided = feature.getUserData.get(Hints.PROVIDED_FID)</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">    if (provided != null) {</span>
<span class="nc" id="L212">      withFid(feature, provided.toString)</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">    } else if (feature.getUserData.get(Hints.USE_PROVIDED_FID) != java.lang.Boolean.TRUE) {</span>
<span class="nc" id="L214">      withFid(feature, idGenerator.createId(feature.getFeatureType, feature))</span>
    } else {
<span class="nc" id="L216">      feature</span>
    }
  }

  /**
   * Sets the feature ID on the feature. If the user has requested a specific ID, that will be used,
   * otherwise one will be generated. The original feature will be modified and returned.
   *
   * @param feature feature
   * @return
   */
  def featureWithFid(feature: FastSettableFeature): FastSettableFeature = {
<span class="nc" id="L228">    val provided = feature.getUserData.get(Hints.PROVIDED_FID)</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">    if (provided != null) {</span>
<span class="nc" id="L230">      feature.setId(provided.toString)</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">    } else if (feature.getUserData.get(Hints.USE_PROVIDED_FID) != java.lang.Boolean.TRUE) {</span>
<span class="nc" id="L232">      feature.setId(idGenerator.createId(feature.getFeatureType, feature))</span>
    }
<span class="nc" id="L234">    feature</span>
  }

  private def withFid(feature: SimpleFeature, fid: String): SimpleFeature = {
<span class="nc" id="L238">    feature match {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">      case f: ScalaSimpleFeature =&gt; f.setId(fid); f</span>
      case _ =&gt;
<span class="nc" id="L241">        feature.getIdentifier match {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">          case f: FeatureIdImpl =&gt; f.setID(fid); feature</span>
          case f =&gt;
<span class="nc bnc" id="L244" title="All 2 branches missed.">            logger.warn(s&quot;Unknown FeatureID implementation found, rebuilding feature: $f '${f.getClass.getName}'&quot;)</span>
<span class="nc" id="L245">            val copy = ScalaSimpleFeature.copy(feature)</span>
<span class="nc" id="L246">            copy.setId(fid)</span>
<span class="nc" id="L247">            copy</span>
        }
    }
  }

  /**
   * Gets a timer
   *
   * @param ds datastore
   * @param sft sft
   * @param operation operation tag
   * @tparam DS datastore type
   * @return
   */
  private def writeTimer[DS &lt;: GeoMesaDataStore[DS]](ds: DS, sft: SimpleFeatureType, operation: String): Timer = {
<span class="nc" id="L262">    Timer.builder(&quot;geomesa.write&quot;)</span>
<span class="nc" id="L263">      .tags(ds.tags(sft.getTypeName).and(&quot;op&quot;, operation))</span>
<span class="nc" id="L264">      .description(&quot;Time spent writing features&quot;)</span>
<span class="nc" id="L265">      .register(Metrics.globalRegistry)</span>
  }

  /**
   * Marker class to allow specific exceptions to bubble up
   *
   * @param msg error message
   * @param cause cause (may be null)
   */
<span class="nc" id="L274">  class WriteException(msg: String, cause: Throwable) extends RuntimeException(msg, cause) {</span>
<span class="nc" id="L275">    def this(msg: String) = this(msg, null)</span>
  }

  /**
    * Writes to a single table per index
    */
<span class="nc bnc" id="L281" title="All 4 branches missed.">  private abstract class TableFeatureWriter[DS &lt;: GeoMesaDataStore[DS]](</span>
<span class="nc" id="L282">      val ds: DS,</span>
<span class="nc" id="L283">      val sft: SimpleFeatureType,</span>
<span class="nc" id="L284">      val indices: Seq[GeoMesaFeatureIndex[_, _]],</span>
<span class="nc" id="L285">      val atomic: Boolean</span>
<span class="nc" id="L286">    ) extends GeoMesaFeatureWriter[DS] {</span>

<span class="nc" id="L288">    private val writer = ds.adapter.createWriter(sft, indices, None, atomic)</span>

<span class="nc" id="L290">    override protected def getWriter(feature: SimpleFeature): IndexWriter = writer</span>

<span class="nc" id="L292">    override protected def flushables(): Seq[Flushable] = Seq(writer, statUpdater)</span>
<span class="nc" id="L293">    override protected def closeables(): Seq[Closeable] = Seq(writer, statUpdater)</span>
  }

  /**
    * Support for writing to partitioned tables
    *
    */
<span class="nc bnc" id="L300" title="All 4 branches missed.">  private abstract class PartitionFeatureWriter[DS &lt;: GeoMesaDataStore[DS]](</span>
<span class="nc" id="L301">      val ds: DS,</span>
<span class="nc" id="L302">      val sft: SimpleFeatureType,</span>
<span class="nc" id="L303">      val indices: Seq[GeoMesaFeatureIndex[_, _]],</span>
<span class="nc" id="L304">      val atomic: Boolean</span>
<span class="nc" id="L305">    ) extends GeoMesaFeatureWriter[DS] {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L309">    private val partition = TablePartition(ds, sft).getOrElse {</span>
<span class="nc" id="L310">      throw new IllegalStateException(&quot;Creating a partitioned writer for a non-partitioned schema&quot;)</span>
    }

<span class="nc" id="L313">    private val cache = new java.util.HashMap[String, IndexWriter]()</span>
<span class="nc" id="L314">    private val view = cache.asScala</span>

    override protected def getWriter(feature: SimpleFeature): IndexWriter = {
<span class="nc" id="L317">      val p = partition.partition(feature)</span>
<span class="nc" id="L318">      var writer = cache.get(p)</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">      if (writer == null) {</span>
        // reconfigure the partition each time - this should be idempotent, and block
        // until it is fully created (which may happen in some other thread)
        def createOne(index: GeoMesaFeatureIndex[_, _]): Unit =
<span class="nc" id="L323">          ds.adapter.createTable(index, Some(p), index.getSplits(Some(p)))</span>
<span class="nc" id="L324">        indices.toList.map(i =&gt; CachedThreadPool.submit(() =&gt; createOne(i))).foreach(_.get)</span>
<span class="nc" id="L325">        writer = ds.adapter.createWriter(sft, indices, Some(p), atomic)</span>
<span class="nc" id="L326">        cache.put(p, writer)</span>
      }
<span class="nc" id="L328">      writer</span>
    }

<span class="nc" id="L331">    override protected def flushables(): Seq[Flushable] = view.values.toSeq :+ statUpdater</span>
<span class="nc" id="L332">    override protected def closeables(): Seq[Closeable] = view.values.toSeq :+ statUpdater</span>
  }

  /**
    * Appends new features - can't modify or delete existing features
    */
<span class="nc" id="L338">  private trait GeoMesaAppendFeatureWriter[DS &lt;: GeoMesaDataStore[DS]] extends GeoMesaFeatureWriter[DS] {</span>

    private var currentFeature: ScalaSimpleFeature = _

<span class="nc" id="L342">    override def hasNext: Boolean = false // per geotools spec, always return false</span>

    override def next(): FastSettableFeature = {
<span class="nc" id="L345">      currentFeature = new ScalaSimpleFeature(sft, nextFeatureId)</span>
<span class="nc" id="L346">      currentFeature</span>
    }

    override def write(): Unit = {
<span class="nc bnc" id="L350" title="All 2 branches missed.">      if (currentFeature == null) {</span>
<span class="nc" id="L351">        throw new IllegalStateException(&quot;next() must be called before write()&quot;)</span>
      }
<span class="nc" id="L353">      appendFeature(currentFeature)</span>
<span class="nc" id="L354">      currentFeature = null</span>
    }

    override def remove(): Unit =
<span class="nc" id="L358">      throw new UnsupportedOperationException(&quot;Use getFeatureWriter instead of getFeatureWriterAppend&quot;)</span>
  }

  /**
    * Modifies or deletes existing features. Per the data store api, does not allow appending new features.
    */
<span class="nc" id="L364">  private trait GeoMesaModifyFeatureWriter[DS &lt;: GeoMesaDataStore[DS]] extends GeoMesaFeatureWriter[DS] {</span>

    def filter: Filter

<span class="nc" id="L368">    private val reader = ds.getFeatureReader(new Query(sft.getTypeName, filter), Transaction.AUTO_COMMIT)</span>

    // feature returned from reader
    private var original: SimpleFeature = _

    // feature that caller will modify
    private var live: FastSettableFeature = _

<span class="nc" id="L376">    override def hasNext: Boolean = reader.hasNext</span>

    override def next(): FastSettableFeature = {
<span class="nc" id="L379">      original = reader.next()</span>
      // set the use provided FID hint - allows user to update fid if desired,
      // but if not we'll use the existing one
<span class="nc" id="L382">      original.getUserData.put(Hints.USE_PROVIDED_FID, java.lang.Boolean.TRUE)</span>
<span class="nc" id="L383">      live = ScalaSimpleFeature.copy(sft, original) // this copies user data as well</span>
<span class="nc" id="L384">      live</span>
    }

    override def write(): Unit = {
<span class="nc bnc" id="L388" title="All 2 branches missed.">      if (original == null) {</span>
<span class="nc" id="L389">        throw new IllegalStateException(&quot;next() must be called before write()&quot;)</span>
      }
      // update the feature id based on hints before we compare for changes
<span class="nc" id="L392">      live = GeoMesaFeatureWriter.featureWithFid(live)</span>
      // only write if feature has actually changed...
      // comparison of feature ID and attributes - doesn't consider concrete class used
<span class="nc bnc" id="L395" title="All 2 branches missed.">      if (!ScalaSimpleFeature.equalIdAndAttributes(live, original) ||</span>
<span class="nc bnc" id="L396" title="All 6 branches missed.">            SecurityUtils.getVisibility(live) != SecurityUtils.getVisibility(original)) {</span>
<span class="nc" id="L397">        updateFeature(live, original)</span>
      }
<span class="nc" id="L399">      original = null</span>
<span class="nc" id="L400">      live = null</span>
    }

    override def remove(): Unit = {
<span class="nc bnc" id="L404" title="All 2 branches missed.">      if (original == null) {</span>
<span class="nc" id="L405">        throw new IllegalStateException(&quot;next() must be called before remove()&quot;)</span>
      }
<span class="nc" id="L407">      removeFeature(original)</span>
<span class="nc" id="L408">      original = null</span>
<span class="nc" id="L409">      live = null</span>
    }

<span class="nc" id="L412">    abstract override protected def closeables(): Seq[Closeable] = super.closeables() :+ reader</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>