<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ColumnGroups.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.conf</a> &gt; <span class="el_source">ColumnGroups.scala</span></div><h1>ColumnGroups.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.conf

import com.github.benmanes.caffeine.cache.Caffeine
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.locationtech.geomesa.features.kryo.{KryoFeatureSerializer, ProjectingKryoFeatureSerializer}
import org.locationtech.geomesa.features.{SerializationOption, SimpleFeatureSerializer}
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.index.metadata.TableBasedMetadata
import org.locationtech.geomesa.utils.cache.CacheKeyGenerator
import org.locationtech.geomesa.utils.geotools.Transform.Transforms
import org.locationtech.geomesa.utils.geotools.{SimpleFeatureTypes, Transform}
import org.locationtech.geomesa.utils.index.VisibilityLevel

import java.nio.charset.StandardCharsets
import java.util.concurrent.TimeUnit

<span class="nc" id="L27">class ColumnGroups {</span>

  import org.locationtech.geomesa.filter.RichTransform.RichTransform
  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

  /**
    * Gets the column groups for a simple feature type. The default group will contain all columns
    *
    * @param sft simple feature type
    * @return
    */
  def apply(sft: SimpleFeatureType): Seq[(Array[Byte], SimpleFeatureType)] = {
<span class="nc" id="L42">    val key = CacheKeyGenerator.cacheKey(sft)</span>
<span class="nc" id="L43">    var groups = ColumnGroups.cache.getIfPresent(key)</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">    if (groups == null) {</span>
<span class="nc bnc" id="L45" title="All 6 branches missed.">      if (sft.getVisibilityLevel == VisibilityLevel.Attribute) {</span>
<span class="nc" id="L46">        groups = IndexedSeq((ColumnGroups.Attributes, sft))</span>
      } else {
<span class="nc" id="L48">        val map = scala.collection.mutable.Map.empty[String, SimpleFeatureTypeBuilder]</span>

<span class="nc" id="L50">        sft.getAttributeDescriptors.asScala.foreach { descriptor =&gt;</span>
<span class="nc" id="L51">          descriptor.getColumnGroups().foreach { group =&gt;</span>
<span class="nc" id="L52">            map.getOrElseUpdate(group, new SimpleFeatureTypeBuilder()).add(descriptor)</span>
          }
        }

<span class="nc bnc" id="L56" title="All 2 branches missed.">        val sfts = map.map { case (group, builder) =&gt;</span>
<span class="nc" id="L57">          builder.setName(sft.getTypeName)</span>
<span class="nc" id="L58">          val subset = SimpleFeatureTypes.immutable(builder.buildFeatureType(), sft.getUserData)</span>
<span class="nc" id="L59">          (group.getBytes(StandardCharsets.UTF_8), subset)</span>
<span class="nc" id="L60">        } + (ColumnGroups.Default -&gt; sft)</span>

        // return the smallest groups first, for consistency tiebreaker is string comparison of group
<span class="nc bnc" id="L63" title="All 2 branches missed.">        groups = sfts.toIndexedSeq.sortBy { case (group, subset) =&gt;</span>
<span class="nc" id="L64">          (subset.getAttributeCount, new String(group, StandardCharsets.UTF_8))</span>
        }
      }

<span class="nc" id="L68">      ColumnGroups.cache.put(key, groups)</span>
    }
<span class="nc" id="L70">    groups</span>
  }

  /**
    * Get serializers for each column group
    *
    * @param sft simple feature type
    * @return
    */
  def serializers(sft: SimpleFeatureType): Seq[(Array[Byte], SimpleFeatureSerializer)] = {
<span class="nc bnc" id="L80" title="All 2 branches missed.">    apply(sft).map { case (colFamily, subset) =&gt;</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">      if (colFamily.eq(ColumnGroups.Default) || colFamily.eq(ColumnGroups.Attributes)) {</span>
<span class="nc" id="L82">        (colFamily, KryoFeatureSerializer(subset, SerializationOption.WithoutId))</span>
      } else {
<span class="nc" id="L84">        (colFamily, new ProjectingKryoFeatureSerializer(sft, subset, SerializationOption.WithoutId))</span>
      }
    }
  }

  /**
    * Find a column group that supports the given transform and filter
    *
    * @param sft simple feature type
    * @param transform transform definitions
    * @param ecql filter, if any
    * @return
    */
  def group(sft: SimpleFeatureType, transform: Option[String], ecql: Option[Filter]): (Array[Byte], SimpleFeatureType) = {
<span class="nc" id="L98">    val groups = apply(sft)</span>
<span class="nc" id="L99">    transform.map(Transforms(sft, _)) match {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      case None =&gt; groups.last</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">      case Some(definitions) =&gt;</span>
<span class="nc" id="L102">        val iter = groups.iterator</span>
<span class="nc" id="L103">        var group = iter.next</span>
        // last group has all the columns, so just return the last one if nothing else matches
<span class="nc bnc" id="L105" title="All 4 branches missed.">        while (iter.hasNext &amp;&amp; !supports(group._2, definitions, ecql)) {</span>
<span class="nc" id="L106">          group = iter.next</span>
        }
<span class="nc" id="L108">        group</span>
    }
  }

  /**
    * Validate that the column groups do not overlap with reserved column groups
    *
    * @param sft simple feature type
    */
  def validate(sft: SimpleFeatureType): Unit = {
<span class="nc" id="L118">    val groups = sft.getAttributeDescriptors.asScala.flatMap(_.getColumnGroups()).distinct</span>
<span class="nc" id="L119">    groups.foreach { group =&gt;</span>
<span class="nc bnc" id="L120" title="All 12 branches missed.">      if (group == ColumnGroups.DefaultString || group == ColumnGroups.AttributesString) {</span>
<span class="nc" id="L121">        throw new IllegalArgumentException(s&quot;Column group '$group' is reserved for internal use - &quot; +</span>
<span class="nc" id="L122">            &quot;please choose another name&quot;)</span>
      }
    }
<span class="nc bnc" id="L125" title="All 8 branches missed.">    if (sft.getVisibilityLevel == VisibilityLevel.Attribute &amp;&amp; groups.nonEmpty) {</span>
<span class="nc" id="L126">      throw new IllegalArgumentException(&quot;Column groups are not supported when using attribute-level visibility&quot;)</span>
    }
  }

  /**
   * Does the simple feature type contain the fields required to evaluate the transform and filter
   *
   * @param sft simple feature type
   * @param transforms transform definitions
   * @param filter filter
   * @return
   */
  private def supports(sft: SimpleFeatureType, transforms: Seq[Transform], filter: Option[Filter]): Boolean = {
<span class="nc bnc" id="L139" title="All 4 branches missed.">    filter.forall(FilterHelper.propertyNames(_, sft).forall(sft.indexOf(_) != -1)) &amp;&amp;</span>
<span class="nc bnc" id="L140" title="All 4 branches missed.">        transforms.flatMap(_.properties).forall(sft.indexOf(_) != -1)</span>
  }

}

<span class="nc" id="L145">object ColumnGroups {</span>

<span class="nc" id="L147">  private val DefaultString = &quot;d&quot;</span>
<span class="nc" id="L148">  private val AttributesString = &quot;a&quot;</span>

<span class="nc" id="L150">  val Default: Array[Byte] = DefaultString.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L151">  val Attributes: Array[Byte] = AttributesString.getBytes(StandardCharsets.UTF_8)</span>

<span class="nc" id="L153">  private val cache =</span>
<span class="nc" id="L154">    Caffeine.newBuilder()</span>
<span class="nc" id="L155">        .expireAfterWrite(TableBasedMetadata.Expiry.toDuration.get.toMillis, TimeUnit.MILLISECONDS)</span>
        .build[String, IndexedSeq[(Array[Byte], SimpleFeatureType)]]()
<span class="nc" id="L157">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>