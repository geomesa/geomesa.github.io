<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryHints.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.conf</a> &gt; <span class="el_source">QueryHints.scala</span></div><h1>QueryHints.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.conf

import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.sort.{SortBy, SortOrder}
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.referencing.CRS
import org.geotools.util.factory.Hints
import org.geotools.util.factory.Hints.{ClassKey, IntegerKey}
import org.locationtech.geomesa.index.conf.FilterCompatibility.FilterCompatibility
import org.locationtech.geomesa.index.planning.StrategyDecider.CostEvaluation
import org.locationtech.geomesa.index.planning.StrategyDecider.CostEvaluation.CostEvaluation
import org.locationtech.geomesa.index.utils.Reprojection.QueryReferenceSystems
import org.locationtech.geomesa.utils.text.StringSerialization
import org.locationtech.jts.geom.Envelope

import scala.util.Try

<span class="nc" id="L26">object QueryHints {</span>

<span class="nc" id="L28">  val QUERY_INDEX      = new ClassKey(classOf[String])</span>
<span class="nc" id="L29">  val COST_EVALUATION  = new ClassKey(classOf[CostEvaluation])</span>

<span class="nc" id="L31">  val DENSITY_BBOX     = new ClassKey(classOf[ReferencedEnvelope])</span>
<span class="nc" id="L32">  val DENSITY_GEOM     = new ClassKey(classOf[String])</span>
<span class="nc" id="L33">  val DENSITY_WEIGHT   = new ClassKey(classOf[String])</span>
<span class="nc" id="L34">  val DENSITY_WIDTH    = new IntegerKey(256)</span>
<span class="nc" id="L35">  val DENSITY_HEIGHT   = new IntegerKey(256)</span>

<span class="nc" id="L37">  val STATS_STRING     = new ClassKey(classOf[java.lang.String])</span>
<span class="nc" id="L38">  val ENCODE_STATS     = new ClassKey(classOf[java.lang.Boolean])</span>

<span class="nc" id="L40">  val EXACT_COUNT      = new ClassKey(classOf[java.lang.Boolean])</span>
<span class="nc" id="L41">  val LOOSE_BBOX       = new ClassKey(classOf[java.lang.Boolean])</span>

<span class="nc" id="L43">  val SAMPLING         = new ClassKey(classOf[java.lang.Float])</span>
<span class="nc" id="L44">  val SAMPLE_BY        = new ClassKey(classOf[String])</span>

<span class="nc" id="L46">  val BIN_TRACK        = new ClassKey(classOf[java.lang.String])</span>
<span class="nc" id="L47">  val BIN_GEOM         = new ClassKey(classOf[java.lang.String])</span>
<span class="nc" id="L48">  val BIN_DTG          = new ClassKey(classOf[java.lang.String])</span>
<span class="nc" id="L49">  val BIN_LABEL        = new ClassKey(classOf[java.lang.String])</span>
<span class="nc" id="L50">  val BIN_SORT         = new ClassKey(classOf[java.lang.Boolean])</span>
<span class="nc" id="L51">  val BIN_BATCH_SIZE   = new ClassKey(classOf[java.lang.Integer])</span>

<span class="nc" id="L53">  val ARROW_ENCODE             = new ClassKey(classOf[java.lang.Boolean])</span>
<span class="nc" id="L54">  val ARROW_INCLUDE_FID        = new ClassKey(classOf[java.lang.Boolean])</span>
<span class="nc" id="L55">  val ARROW_PROXY_FID          = new ClassKey(classOf[java.lang.Boolean])</span>
<span class="nc" id="L56">  val ARROW_BATCH_SIZE         = new ClassKey(classOf[java.lang.Integer])</span>
<span class="nc" id="L57">  val ARROW_SORT_FIELD         = new ClassKey(classOf[java.lang.String])</span>
<span class="nc" id="L58">  val ARROW_SORT_REVERSE       = new ClassKey(classOf[java.lang.Boolean])</span>
<span class="nc" id="L59">  val ARROW_FORMAT_VERSION     = new ClassKey(classOf[String])</span>
<span class="nc" id="L60">  val ARROW_DICTIONARY_FIELDS  = new ClassKey(classOf[java.lang.String])</span>
<span class="nc" id="L61">  val ARROW_PROCESS_DELTAS     = new ClassKey(classOf[java.lang.Boolean])</span>
<span class="nc" id="L62">  val ARROW_FLATTEN_STRUCT     = new ClassKey(classOf[java.lang.Boolean])</span>

<span class="nc" id="L64">  val FILTER_COMPAT            = new ClassKey(classOf[java.lang.String])</span>

<span class="nc" id="L66">  val FLIP_AXIS_ORDER          = new ClassKey(classOf[java.lang.Boolean])</span>

  def sortReadableString(sort: Seq[(String, Boolean)]): String =
<span class="nc bnc" id="L69" title="All 4 branches missed.">    sort.map { case (f, r) =&gt; s&quot;$f ${if (r) &quot;DESC&quot; else &quot;ASC&quot; }&quot;}.mkString(&quot;, &quot;)</span>

  // internal hints that shouldn't be set directly by users
<span class="nc" id="L72">  object Internal {</span>
<span class="nc" id="L73">    val RETURN_SFT       = new ClassKey(classOf[SimpleFeatureType])</span>
<span class="nc" id="L74">    val TRANSFORMS       = new ClassKey(classOf[String])</span>
<span class="nc" id="L75">    val TRANSFORM_SCHEMA = new ClassKey(classOf[SimpleFeatureType])</span>
<span class="nc" id="L76">    val SORT_FIELDS      = new ClassKey(classOf[String])</span>
<span class="nc" id="L77">    val REPROJECTION     = new ClassKey(classOf[String])</span>
<span class="nc" id="L78">    val MAX_FEATURES     = new ClassKey(classOf[java.lang.Integer])</span>
<span class="nc" id="L79">    val SKIP_REDUCE      = new ClassKey(classOf[java.lang.Boolean])</span>

    def toSortHint(sortBy: Array[SortBy]): String = {
<span class="nc" id="L82">      val strings = sortBy.flatMap { sb =&gt;</span>
<span class="nc" id="L83">        val prop = sb.getPropertyName</span>
<span class="nc bnc" id="L84" title="All 8 branches missed.">        Seq(if (prop == null) { &quot;&quot; } else { prop.getPropertyName }, s&quot;${sb.getSortOrder == SortOrder.DESCENDING}&quot;)</span>
      }
<span class="nc" id="L86">      StringSerialization.encodeSeq(strings)</span>
    }

    def fromSortHint(hint: String): Seq[(String, Boolean)] =
<span class="nc bnc" id="L90" title="All 6 branches missed.">      StringSerialization.decodeSeq(hint).grouped(2).toSeq.map { case Seq(f, r) =&gt; (f, r.toBoolean) }</span>

    def toProjectionHint(crs: QueryReferenceSystems): String =
<span class="nc" id="L93">      StringSerialization.encodeSeq(Seq(crs.native, crs.user, crs.target).map(CRS.toSRS))</span>

    def fromProjectionHint(hint: String): QueryReferenceSystems = {
<span class="nc bnc" id="L96" title="All 6 branches missed.">      val Seq(native, user, target) = StringSerialization.decodeSeq(hint).map(CRS.decode)</span>
<span class="nc" id="L97">      QueryReferenceSystems(native, user, target)</span>
    }

    def clearTransforms(hints: Hints): Hints = {
<span class="nc" id="L101">      val updated = new Hints(hints)</span>
<span class="nc" id="L102">      updated.remove(QueryHints.Internal.TRANSFORMS)</span>
<span class="nc" id="L103">      updated.remove(QueryHints.Internal.TRANSFORM_SCHEMA)</span>
<span class="nc" id="L104">      updated</span>
    }
  }

<span class="nc" id="L108">  implicit class RichHints(val hints: Hints) extends AnyRef {</span>

<span class="nc" id="L110">    def getReturnSft: SimpleFeatureType = hints.get(Internal.RETURN_SFT).asInstanceOf[SimpleFeatureType]</span>
<span class="nc" id="L111">    def getRequestedIndex: Option[String] = Option(hints.get(QUERY_INDEX).asInstanceOf[String])</span>
    def getCostEvaluation: CostEvaluation = {
<span class="nc" id="L113">      Option(hints.get(COST_EVALUATION).asInstanceOf[CostEvaluation])</span>
<span class="nc" id="L114">          .orElse(QueryProperties.QueryCostType.option.flatMap(t =&gt; CostEvaluation.values.find(_.toString.equalsIgnoreCase(t))))</span>
<span class="nc" id="L115">          .getOrElse(CostEvaluation.Index)</span>
    }
<span class="nc" id="L117">    def isSkipReduce: Boolean = Option(hints.get(Internal.SKIP_REDUCE).asInstanceOf[java.lang.Boolean]).exists(_.booleanValue())</span>
<span class="nc" id="L118">    def isBinQuery: Boolean = hints.containsKey(BIN_TRACK)</span>
<span class="nc" id="L119">    def getBinTrackIdField: String = hints.get(BIN_TRACK).asInstanceOf[String]</span>
<span class="nc" id="L120">    def getBinGeomField: Option[String] = Option(hints.get(BIN_GEOM).asInstanceOf[String])</span>
<span class="nc" id="L121">    def getBinDtgField: Option[String] = Option(hints.get(BIN_DTG).asInstanceOf[String])</span>
<span class="nc" id="L122">    def getBinLabelField: Option[String] = Option(hints.get(BIN_LABEL).asInstanceOf[String])</span>
    def getBinBatchSize: Int =
<span class="nc" id="L124">      Option(hints.get(BIN_BATCH_SIZE).asInstanceOf[Integer]).map(_.intValue).getOrElse(1000)</span>
<span class="nc" id="L125">    def isBinSorting: Boolean = hints.get(BIN_SORT).asInstanceOf[Boolean]</span>
<span class="nc" id="L126">    def getSamplePercent: Option[Float] = Option(hints.get(SAMPLING)).map(_.asInstanceOf[Float])</span>
<span class="nc" id="L127">    def getSampleByField: Option[String] = Option(hints.get(SAMPLE_BY).asInstanceOf[String])</span>
<span class="nc" id="L128">    def getSampling: Option[(Float, Option[String])] = getSamplePercent.map((_, getSampleByField))</span>
<span class="nc" id="L129">    def isDensityQuery: Boolean = hints.containsKey(DENSITY_BBOX)</span>
<span class="nc" id="L130">    def getDensityEnvelope: Option[Envelope] = Option(hints.get(DENSITY_BBOX).asInstanceOf[Envelope])</span>
<span class="nc" id="L131">    def getDensityGeometry: Option[String] = Option(hints.get(DENSITY_GEOM).asInstanceOf[String])</span>
    def getDensityBounds: Option[(Int, Int)] =
<span class="nc" id="L133">      for { w &lt;- Option(hints.get(DENSITY_WIDTH).asInstanceOf[Int])</span>
<span class="nc" id="L134">            h &lt;- Option(hints.get(DENSITY_HEIGHT).asInstanceOf[Int]) } yield (w, h)</span>
<span class="nc" id="L135">    def getDensityWeight: Option[String] = Option(hints.get(DENSITY_WEIGHT).asInstanceOf[String])</span>

<span class="nc" id="L137">    def isArrowQuery: Boolean = Option(hints.get(ARROW_ENCODE).asInstanceOf[java.lang.Boolean]).exists(Boolean.unbox)</span>
<span class="nc" id="L138">    def isArrowIncludeFid: Boolean = Option(hints.get(ARROW_INCLUDE_FID).asInstanceOf[java.lang.Boolean]).forall(Boolean.unbox)</span>
<span class="nc" id="L139">    def isArrowProxyFid: Boolean = Option(hints.get(ARROW_PROXY_FID).asInstanceOf[java.lang.Boolean]).exists(Boolean.unbox)</span>
    def getArrowDictionaryFields: Seq[String] =
<span class="nc" id="L141">      Option(hints.get(ARROW_DICTIONARY_FIELDS).asInstanceOf[String]).toSeq.flatMap(_.split(&quot;,&quot;)).map(_.trim).filter(_.nonEmpty)</span>
<span class="nc" id="L142">    def getArrowBatchSize: Option[Int] = Option(hints.get(ARROW_BATCH_SIZE).asInstanceOf[Integer]).map(_.intValue)</span>
    def getArrowSort: Option[(String, Boolean)] =
<span class="nc" id="L144">      Option(hints.get(ARROW_SORT_FIELD).asInstanceOf[String]).map { field =&gt;</span>
<span class="nc" id="L145">        (field, Option(hints.get(ARROW_SORT_REVERSE)).exists(_.asInstanceOf[Boolean]))</span>
      }
<span class="nc" id="L147">    def getArrowFormatVersion: Option[String] = Option(hints.get(ARROW_FORMAT_VERSION).asInstanceOf[String])</span>
    def isArrowProcessDeltas: Boolean =
<span class="nc" id="L149">      Option(hints.get(ARROW_PROCESS_DELTAS).asInstanceOf[java.lang.Boolean]).forall(Boolean.unbox)</span>
<span class="nc" id="L150">    def isArrowFlatten: Boolean = Option(hints.get(ARROW_FLATTEN_STRUCT).asInstanceOf[java.lang.Boolean]).exists(Boolean.unbox)</span>

<span class="nc" id="L152">    def isStatsQuery: Boolean = hints.containsKey(STATS_STRING)</span>
<span class="nc" id="L153">    def getStatsQuery: String = hints.get(STATS_STRING).asInstanceOf[String]</span>
<span class="nc" id="L154">    def isStatsEncode: Boolean = Option(hints.get(ENCODE_STATS).asInstanceOf[java.lang.Boolean]).exists(Boolean.unbox)</span>
<span class="nc" id="L155">    def getTransformDefinition: Option[String] = Option(hints.get(Internal.TRANSFORMS).asInstanceOf[String])</span>
    def getTransformSchema: Option[SimpleFeatureType] =
<span class="nc" id="L157">      Option(hints.get(Internal.TRANSFORM_SCHEMA).asInstanceOf[SimpleFeatureType])</span>
    def getTransform: Option[(String, SimpleFeatureType)] =
<span class="nc" id="L159">      hints.getTransformDefinition.flatMap(d =&gt; hints.getTransformSchema.map((d, _)))</span>
    def clearTransforms(): Unit = {
<span class="nc" id="L161">      hints.remove(Internal.TRANSFORM_SCHEMA)</span>
<span class="nc" id="L162">      hints.remove(Internal.TRANSFORMS)</span>
    }
    def getSortFields: Option[Seq[(String, Boolean)]] =
<span class="nc" id="L165">      Option(hints.get(Internal.SORT_FIELDS).asInstanceOf[String]).map(Internal.fromSortHint).filterNot(_.isEmpty)</span>
    def getProjection: Option[QueryReferenceSystems] =
<span class="nc" id="L167">      Option(hints.get(Internal.REPROJECTION).asInstanceOf[String]).map(Internal.fromProjectionHint)</span>
<span class="nc" id="L168">    def getMaxFeatures: Option[Int] = Option(hints.get(Internal.MAX_FEATURES).asInstanceOf[Integer]).map(_.intValue())</span>
<span class="nc" id="L169">    def isExactCount: Option[Boolean] = Option(hints.get(EXACT_COUNT)).map(_.asInstanceOf[Boolean])</span>

    def getFilterCompatibility: Option[FilterCompatibility] = {
<span class="nc" id="L172">      Option(hints.get(FILTER_COMPAT).asInstanceOf[String]).map { c =&gt;</span>
<span class="nc" id="L173">        Try(FilterCompatibility.withName(c)).getOrElse {</span>
<span class="nc" id="L174">          val valid = FilterCompatibility.values.map(_.toString).mkString(&quot;'&quot;, &quot;', '&quot;, &quot;'&quot;)</span>
<span class="nc" id="L175">          throw new IllegalArgumentException(s&quot;Invalid hint for filter compatibility: '$c'. Valid values are: $valid'&quot;)</span>
        }
      }
    }

    def isFlipAxisOrder: Boolean =
<span class="nc" id="L181">      Option(hints.get(FLIP_AXIS_ORDER).asInstanceOf[java.lang.Boolean]).exists(Boolean.unbox)</span>
  }
<span class="nc" id="L183">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>