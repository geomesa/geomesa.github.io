<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ThreadManagement.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.utils</a> &gt; <span class="el_source">ThreadManagement.scala</span></div><h1>ThreadManagement.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.utils

import com.typesafe.scalalogging.Logger
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.index.api.QueryPlan
import org.locationtech.geomesa.index.api.QueryPlan.QueryStrategyPlan
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.concurrent.ExitingExecutor
import org.locationtech.geomesa.utils.iterators.ExceptionalIterator
import org.slf4j.LoggerFactory

import java.io.Closeable
import java.util.concurrent.{ScheduledThreadPoolExecutor, TimeUnit}
import scala.concurrent.duration.Duration
import scala.util.control.NonFatal

/**
 * Singleton for registering and managing running queries.
 */
<span class="nc" id="L29">object ThreadManagement {</span>

<span class="nc" id="L31">  private val logger = Logger(LoggerFactory.getLogger(ThreadManagement.getClass.getName.replace(&quot;$&quot;, &quot;&quot;)))</span>

<span class="nc" id="L33">  private val executor = {</span>
<span class="nc" id="L34">    val ex = new ScheduledThreadPoolExecutor(2)</span>
<span class="nc" id="L35">    ex.setRemoveOnCancelPolicy(true)</span>
<span class="nc" id="L36">    ExitingExecutor(ex, force = true)</span>
  }

  /**
   * Class for scans that are managed, i.e. tracked and terminated if they exceed a specified timeout
   *
   * @param underlying low-level scan to be stopped
   * @param timeout scan timeout
   * @param typeName type name, used for log messages
   * @param filter query filter, used for log messages
   * @tparam T type
   */
<span class="nc" id="L48">  class ManagedScan[T](underlying: LowLevelScanner[T], timeout: Timeout, typeName: String, filter: Option[Filter])</span>
<span class="nc" id="L49">      extends CloseableIterator[T] {</span>

    def this(underlying: LowLevelScanner[T], timeout: Timeout, plan: QueryStrategyPlan) =
<span class="nc" id="L52">      this(underlying, timeout, plan.filter.index.sft.getTypeName, plan.filter.filter)</span>

    // we can use a volatile var since we only update the value with a single thread
    @volatile
<span class="nc bnc" id="L56" title="All 2 branches missed.">    private var terminated = timeout.absolute &lt;= System.currentTimeMillis()</span>

<span class="nc bnc" id="L58" title="All 2 branches missed.">    private val iter = ExceptionalIterator(if (terminated) { Iterator.empty } else { underlying.iterator })</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">    private val cancel = if (terminated) { None } else {</span>
<span class="nc" id="L60">      val timeout = math.max(1, this.timeout.absolute - System.currentTimeMillis())</span>
<span class="nc" id="L61">      Some(executor.schedule(new QueryKiller(this), timeout, TimeUnit.MILLISECONDS))</span>
    }

    // note: check iter.hasNext first so we get updated terminated flag
<span class="nc bnc" id="L65" title="All 4 branches missed.">    override def hasNext: Boolean = iter.hasNext || terminated</span>

    override def next(): T = {
<span class="nc bnc" id="L68" title="All 2 branches missed.">      if (terminated) {</span>
<span class="nc" id="L69">        val e = new RuntimeException(s&quot;Scan terminated due to timeout of ${timeout.relative}ms&quot;)</span>
<span class="nc" id="L70">        iter.suppressed.foreach(e.addSuppressed)</span>
<span class="nc" id="L71">        throw e</span>
      } else {
<span class="nc" id="L73">        iter.next()</span>
      }
    }

    /**
     * Forcibly terminate the scan
     */
    def terminate(): Unit = {
<span class="nc" id="L81">      terminated = true</span>
<span class="nc" id="L82">      try {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        logger.warn(</span>
<span class="nc" id="L84">          s&quot;Stopping scan on schema '$typeName' with filter '${filter.fold(&quot;INCLUDE&quot;)(FilterHelper.toString)}' &quot; +</span>
<span class="nc" id="L85">              s&quot;based on timeout of ${timeout.relative}ms&quot;)</span>
<span class="nc" id="L86">        underlying.close()</span>
      } catch {
<span class="nc bnc" id="L88" title="All 4 branches missed.">        case NonFatal(e) =&gt; logger.warn(&quot;Error cancelling scan:&quot;, e)</span>
      }
    }

    /**
     * Was the scan terminated due to timeout
     *
     * @return
     */
<span class="nc" id="L97">    def isTerminated: Boolean = terminated</span>

    override def close(): Unit = {
<span class="nc" id="L100">      cancel.foreach(_.cancel(false))</span>
      // if terminated, we've already closed the iterator
<span class="nc bnc" id="L102" title="All 2 branches missed.">      if (!terminated) {</span>
<span class="nc" id="L103">        underlying.close()</span>
      }
    }
  }

  /**
   * Low level scanner that can be closed to terminate a scan
   *
   * @tparam T type
   */
  trait LowLevelScanner[T] extends Closeable {
    def iterator: Iterator[T]
  }

  /**
   * Timeout holder
   *
   * @param relative relative timeout, in millis
   * @param absolute absolute timeout, in system millis since epoch
   */
<span class="nc bnc" id="L123" title="All 17 branches missed.">  case class Timeout(relative: Long, absolute: Long)</span>

<span class="nc" id="L125">  object Timeout {</span>
<span class="nc" id="L126">    def apply(relative: Long): Timeout = Timeout(relative, System.currentTimeMillis() + relative)</span>
<span class="nc" id="L127">    def apply(relative: Duration): Timeout = apply(relative.toMillis)</span>
<span class="nc" id="L128">    def apply(relative: String): Timeout = apply(Duration(relative))</span>
  }

  /**
   * Runnable to handle terminating a scan
   *
   * @param scan scan to terminate
   */
<span class="nc" id="L136">  private class QueryKiller(val scan: ManagedScan[_]) extends Runnable {</span>
<span class="nc" id="L137">    override def run(): Unit = scan.terminate()</span>
  }
<span class="nc" id="L139">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>