<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractBatchScan.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.utils</a> &gt; <span class="el_source">AbstractBatchScan.scala</span></div><h1>AbstractBatchScan.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.utils

import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.concurrent.CachedThreadPool

import java.util.concurrent._
import scala.util.control.NonFatal

/**
  * Provides parallelism for scanning multiple ranges at a given time, for systems that don't
  * natively support that.
  *
  * Subclasses should generally only expose the `CloseableIterator` interface, and make sure to
  * invoke `start()` before returning to the caller.
  *
  * @param ranges ranges to scan
  * @param threads number of client threads to use for scanning
  * @param buffer max size of the buffer for storing results before they are read by the caller
  * @param sentinel singleton sentinel value used to indicate the completion of scanning threads
  * @tparam T range type
  * @tparam R scan result type
  */
<span class="nc" id="L31">abstract class AbstractBatchScan[T, R &lt;: AnyRef](ranges: Seq[T], threads: Int, buffer: Int, sentinel: R)</span>
<span class="nc" id="L32">    extends CloseableIterator[R] {</span>

  import scala.collection.JavaConverters._

<span class="nc bnc" id="L36" title="All 2 branches missed.">  require(threads &gt; 0, &quot;Thread count must be greater than 0&quot;)</span>

<span class="nc" id="L38">  private val inQueue = new ConcurrentLinkedQueue(ranges.asJava)</span>
<span class="nc" id="L39">  private val outQueue = new LinkedBlockingQueue[R](buffer)</span>

<span class="nc" id="L41">  private val pool = new CachedThreadPool(threads)</span>
<span class="nc" id="L42">  private val latch = new CountDownLatch(threads)</span>
<span class="nc" id="L43">  private val terminator = new Terminator()</span>

<span class="nc" id="L45">  private var retrieved: R = _</span>
<span class="nc" id="L46">  private var error: Throwable = _</span>

  @volatile
<span class="nc" id="L49">  protected var closed: Boolean = false</span>

  /**
    * Scan a single range
    *
    * @param range range to scan
    */
  protected def scan(range: T): CloseableIterator[R]

  /**
    * Start the threaded scans executing
    */
  protected def start(): CloseableIterator[R] = {
<span class="nc" id="L62">    var i = 0</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">    while (i &lt; threads) {</span>
<span class="nc" id="L64">      pool.submit(new SingleThreadScan())</span>
<span class="nc" id="L65">      i += 1</span>
    }
<span class="nc" id="L67">    pool.submit(terminator)</span>
<span class="nc" id="L68">    pool.shutdown()</span>
<span class="nc" id="L69">    this</span>
  }

  override def hasNext: Boolean = {
<span class="nc bnc" id="L73" title="All 2 branches missed.">    if (retrieved != null) {</span>
<span class="nc" id="L74">      true</span>
    } else {
<span class="nc" id="L76">      retrieved = outQueue.take</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      if (!retrieved.eq(sentinel)) {</span>
<span class="nc" id="L78">        true</span>
      } else {
<span class="nc" id="L80">        outQueue.put(sentinel) // re-queue in case hasNext is called again</span>
<span class="nc" id="L81">        retrieved = null.asInstanceOf[R]</span>
<span class="nc" id="L82">        this.synchronized {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">          if (error != null) {</span>
<span class="nc" id="L84">            throw error</span>
          }
        }
<span class="nc" id="L87">        false</span>
      }
    }
  }

  override def next(): R = {
<span class="nc" id="L93">    val n = retrieved</span>
<span class="nc" id="L94">    retrieved = null.asInstanceOf[R]</span>
<span class="nc" id="L95">    n</span>
  }

  override def close(): Unit = {
<span class="nc" id="L99">    closed = true</span>
<span class="nc" id="L100">    inQueue.clear()</span>
<span class="nc" id="L101">    terminator.terminate(true)</span>
  }

  /**
    * Exposed for testing only
    *
    * @param timeout timeout to wait
    * @return true if all threads have terminated, otherwise false
    */
  private [utils] def waitForDone(timeout: Long): Boolean = {
<span class="nc" id="L111">    val start = System.currentTimeMillis()</span>
    while (true) {
<span class="nc bnc" id="L113" title="All 2 branches missed.">      if (pool.isTerminated) {</span>
<span class="nc" id="L114">        return true</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">      } else if (System.currentTimeMillis() - start &gt; timeout) {</span>
<span class="nc" id="L116">        return false</span>
      } else {
<span class="nc" id="L118">        Thread.sleep(10)</span>
      }
    }
    throw new IllegalStateException() // not possible to hit this, but the compiler can't figure that out
  }

  /**
    * Exposed for testing only
    *
    * @param timeout timeout to wait
    * @return true if full, otherwise false
    */
  private [utils] def waitForFull(timeout: Long): Boolean = {
<span class="nc" id="L131">    val start = System.currentTimeMillis()</span>
    while (true) {
<span class="nc bnc" id="L133" title="All 2 branches missed.">      if (outQueue.remainingCapacity() == 0) {</span>
<span class="nc" id="L134">        return true</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      } else if (System.currentTimeMillis() - start &gt; timeout) {</span>
<span class="nc" id="L136">        return false</span>
      } else {
<span class="nc" id="L138">        Thread.sleep(10)</span>
      }
    }
    throw new IllegalStateException() // not possible to hit this, but the compiler can't figure that out
  }

  /**
    * Pulls ranges off the queue and executes them
    */
<span class="nc bnc" id="L147" title="All 2 branches missed.">  private class SingleThreadScan extends Runnable {</span>
    override def run(): Unit = {
<span class="nc" id="L149">      try {</span>
<span class="nc" id="L150">        var range = inQueue.poll()</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        while (range != null) {</span>
<span class="nc" id="L152">          val result = scan(range)</span>
          try {
<span class="nc bnc" id="L154" title="All 2 branches missed.">            while (result.hasNext) {</span>
<span class="nc" id="L155">              val r = result.next</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">              while (!outQueue.offer(r, 100, TimeUnit.MILLISECONDS)) {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">                if (closed) {</span>
<span class="nc" id="L158">                  return</span>
                }
              }
            }
          } finally {
<span class="nc" id="L163">            result.close()</span>
          }
<span class="nc" id="L165">          range = inQueue.poll()</span>
        }
      } catch {
<span class="nc bnc" id="L168" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc" id="L169">          AbstractBatchScan.this.synchronized {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (error == null) { error = e } else { error.addSuppressed(e) }</span>
          }
<span class="nc" id="L172">          close()</span>
      } finally {
<span class="nc" id="L174">        latch.countDown()</span>
      }
    }
  }

  /**
    * Injects the terminal value into the output buffer, once all the scans are complete
    */
<span class="nc bnc" id="L182" title="All 2 branches missed.">  private class Terminator extends Runnable {</span>

    @volatile
<span class="nc" id="L185">    private var done = false</span>

<span class="nc" id="L187">    override def run(): Unit = try { latch.await() } finally { terminate(false) }</span>

    final def terminate(drop: Boolean): Unit = {
      // it's possible that the queue is full, in which case we can't immediately
      // add the sentinel to the queue to indicate to the client that scans are done
      // if the scan has been closed, then the client is done
      // reading and we don't mind dropping some results
      // otherwise we wait and give the client a chance to empty the queue
<span class="nc bnc" id="L195" title="All 8 branches missed.">      if (!done &amp;&amp; (drop || closed || !outQueue.offer(sentinel, 1000, TimeUnit.MILLISECONDS))) {</span>
        // terminate with drops
<span class="nc bnc" id="L197" title="All 2 branches missed.">        while (!outQueue.offer(sentinel)) { outQueue.poll() }</span>
      }
<span class="nc" id="L199">      done = true</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>