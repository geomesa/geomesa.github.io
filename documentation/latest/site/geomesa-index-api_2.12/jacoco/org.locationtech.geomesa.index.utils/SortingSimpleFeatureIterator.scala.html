<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SortingSimpleFeatureIterator.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.utils</a> &gt; <span class="el_source">SortingSimpleFeatureIterator.scala</span></div><h1>SortingSimpleFeatureIterator.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.utils

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.SimpleFeature
import org.locationtech.geomesa.features.kryo.KryoFeatureSerializer
import org.locationtech.geomesa.features.{SerializationOption, SimpleFeatureSerializer}
import org.locationtech.geomesa.index.conf.QueryProperties
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.SimpleFeatureOrdering
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.io.{CloseQuietly, Sizable, WithClose}

import java.io.{File, FileInputStream, FileOutputStream}
import java.nio.file.Files
import java.util.concurrent.atomic.AtomicBoolean
import scala.collection.mutable.ArrayBuffer
import scala.util.Random
import scala.util.control.NonFatal

/**
  * In memory sorting of simple features, with optional spill to disk
  *
  * @param features unsorted feature iterator
  * @param sortBy attributes to sort by, in the form: (name, reverse).
  *               for sort by feature id (e.g. natural sort), use an empty string for name
  */
<span class="nc" id="L35">class SortingSimpleFeatureIterator(features: CloseableIterator[SimpleFeature], sortBy: Seq[(String, Boolean)])</span>
<span class="nc" id="L36">    extends CloseableIterator[SimpleFeature] {</span>

  import SortingSimpleFeatureIterator.{sortInMemory, sortWithSpillover}

<span class="nc" id="L40">  private val closed = new AtomicBoolean(false)</span>

<span class="nc bnc" id="L42" title="All 4 branches missed.">  private lazy val sorted: CloseableIterator[SimpleFeature] = {</span>
<span class="nc bnc" id="L43" title="All 4 branches missed.">    if (closed.get || !features.hasNext) { features } else {</span>
<span class="nc" id="L44">      val head = features.next()</span>
<span class="nc bnc" id="L45" title="All 4 branches missed.">      if (closed.get || !features.hasNext) { CloseableIterator.single(head, features.close()) } else {</span>
<span class="nc" id="L46">        val ordering = SimpleFeatureOrdering(head.getFeatureType, sortBy)</span>
<span class="nc" id="L47">        QueryProperties.SortMemoryThreshold.toBytes match {</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">          case None =&gt; sortInMemory(head, features, ordering, closed)</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">          case Some(threshold) =&gt; sortWithSpillover(head, features, ordering, closed, threshold)</span>
        }
      }
    }
  }

<span class="nc" id="L55">  override def hasNext: Boolean = sorted.hasNext</span>

<span class="nc" id="L57">  override def next(): SimpleFeature = sorted.next()</span>

  override def close(): Unit = {
<span class="nc bnc" id="L60" title="All 2 branches missed.">    if (closed.compareAndSet(false, true)) {</span>
<span class="nc" id="L61">      sorted.close() // also closes original features iterator</span>
    }
  }
}

<span class="nc bnc" id="L66" title="All 4 branches missed.">object SortingSimpleFeatureIterator extends LazyLogging {</span>

  import scala.collection.JavaConverters._

  /**
   * Sorts the iterator in memory
   *
   * @param head head of iterator
   * @param tail tail of iterator
   * @param ordering ordering
   * @param closed checked to determine if we should stop sorting and return early
   * @return
   */
  private def sortInMemory(
      head: SimpleFeature,
      tail: CloseableIterator[SimpleFeature],
      ordering: Ordering[SimpleFeature],
      closed: AtomicBoolean): CloseableIterator[SimpleFeature] = {
    // use ArrayList for sort-in-place of the underlying array
<span class="nc" id="L85">    val list = new java.util.ArrayList[SimpleFeature](100)</span>
<span class="nc" id="L86">    list.add(head)</span>

<span class="nc bnc" id="L88" title="All 4 branches missed.">    while (tail.hasNext &amp;&amp; !closed.get) {</span>
<span class="nc" id="L89">      list.add(tail.next())</span>
    }

<span class="nc bnc" id="L92" title="All 2 branches missed.">    if (closed.get) {</span>
      // don't bother sorting, just return an empty iterator
<span class="nc" id="L94">      CloseableIterator(Iterator.empty, tail.close())</span>
    } else {
<span class="nc" id="L96">      list.sort(ordering)</span>
<span class="nc" id="L97">      CloseableIterator(list.iterator.asScala, tail.close())</span>
    }
  }

  /**
   * Sorts the iterator in memory, but spills over to disk if the size in memory exceeds the specified threshold
   *
   * @param head head of iterator
   * @param tail tail of iterator
   * @param ordering ordering
   * @param closed checked to determine if we should stop sorting and return early
   * @param threshold max memory to use before spilling to disk
   * @return
   */
  private def sortWithSpillover(
      head: SimpleFeature,
      tail: CloseableIterator[SimpleFeature],
      ordering: Ordering[SimpleFeature],
      closed: AtomicBoolean,
      threshold: Long): CloseableIterator[SimpleFeature] = {

    // grouping ID for tmp files, doesn't have to be unique
<span class="nc bnc" id="L119" title="All 2 branches missed.">    lazy val id = {</span>
      val name = head.getFeatureType.getTypeName.replaceAll(&quot;[^A-Za-z0-9_-]&quot;, &quot;&quot;).take(20)
      f&quot;$name-${Random.nextInt(10000)}%04d&quot;
    }

<span class="nc" id="L124">    val sizable: FeatureIsSizable[SimpleFeature] = head match {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      case _: SimpleFeature with Sizable =&gt;</span>
<span class="nc" id="L126">        SizableFeatureIsSizable.asInstanceOf[FeatureIsSizable[SimpleFeature]]</span>
      case _ =&gt;
        // currently, all of our uses of this class pass in Sizable features... this means we missed one
<span class="nc bnc" id="L129" title="All 2 branches missed.">        logger.warn(</span>
<span class="nc" id="L130">          s&quot;Feature class '${head.getClass.getName}' doesn't implement Sizable - &quot; +</span>
<span class="nc" id="L131">              &quot;using estimated size for memory threshold calculations&quot;)</span>
<span class="nc" id="L132">        UnSizableFeatureIsSizable</span>
    }

<span class="nc" id="L135">    val files = ArrayBuffer.empty[File] // tmp files we create when we exceed in-memory threshold</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    lazy val serializer = KryoFeatureSerializer(head.getFeatureType, SerializationOption.WithUserData)</span>
    // use ArrayList for sort-in-place of the underlying array
<span class="nc" id="L138">    val list = new java.util.ArrayList[SimpleFeature](100)</span>
<span class="nc" id="L139">    list.add(head)</span>
<span class="nc" id="L140">    var size = sizable.sizeOf(head)</span>

<span class="nc bnc" id="L142" title="All 4 branches missed.">    while (tail.hasNext &amp;&amp; !closed.get) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      if (size &gt;= threshold) {</span>
        // write out the sorted list to disk
<span class="nc" id="L145">        list.sort(ordering)</span>
<span class="nc" id="L146">        val file = Files.createTempFile(s&quot;gm-sort-$id-&quot;, &quot;.kryo&quot;).toFile</span>
<span class="nc" id="L147">        files += file</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        logger.trace(s&quot;Created temp sort file '${file.getAbsolutePath}'&quot;)</span>
<span class="nc" id="L149">        WithClose(new FileOutputStream(file)) { os =&gt;</span>
<span class="nc" id="L150">          var i = 0</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">          while (i &lt; list.size()) {</span>
<span class="nc" id="L152">            val bytes = serializer.serialize(list.get(i))</span>
<span class="nc" id="L153">            os.write(ByteArrays.toBytes(bytes.length))</span>
<span class="nc" id="L154">            os.write(bytes)</span>
<span class="nc" id="L155">            i += 1</span>
          }
        }
<span class="nc" id="L158">        list.clear()</span>
<span class="nc" id="L159">        size = 0</span>
      }
<span class="nc" id="L161">      val next = tail.next()</span>
<span class="nc" id="L162">      list.add(next)</span>
<span class="nc" id="L163">      size += sizable.sizeOf(next)</span>
    }

<span class="nc bnc" id="L166" title="All 2 branches missed.">    if (closed.get) {</span>
<span class="nc" id="L167">      files.foreach { file =&gt;</span>
<span class="nc" id="L168">        try {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">          if (!file.delete()) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            logger.warn(s&quot;Unable to delete tmp file '${file.getAbsolutePath}''&quot;)</span>
<span class="nc" id="L171">            file.deleteOnExit()</span>
          }
        } catch {
<span class="nc bnc" id="L174" title="All 4 branches missed.">          case NonFatal(e) =&gt; logger.warn(s&quot;Unable to delete tmp file '${file.getAbsolutePath}''&quot;, e)</span>
        }
      }
      // don't bother sorting, just return an empty iterator
<span class="nc" id="L178">      CloseableIterator(Iterator.empty, tail.close())</span>
    } else {
<span class="nc bnc" id="L180" title="All 2 branches missed.">      if (!list.isEmpty) {</span>
<span class="nc" id="L181">        list.sort(ordering)</span>
      }
<span class="nc bnc" id="L183" title="All 2 branches missed.">      if (files.isEmpty) {</span>
<span class="nc" id="L184">        CloseableIterator(list.iterator.asScala, tail.close())</span>
      } else {
<span class="nc" id="L186">        new MergeSortingIterator(files.toIndexedSeq, serializer, list.iterator.asScala, tail, ordering)</span>
      }
    }
  }

  /**
   * Does a merge sort on a group of locally sorted files and a left-over in-memory iterator
   *
   * @param files files to merge
   * @param serializer serializer
   * @param mem left-over in-memory features, already sorted
   * @param closeable link to the original (now-empty) feature iterator, for cleaning up on close
   * @param ordering feature ordering
   */
<span class="nc" id="L200">  private class MergeSortingIterator(</span>
      files: IndexedSeq[File],
<span class="nc" id="L202">      serializer: SimpleFeatureSerializer,</span>
      mem: Iterator[SimpleFeature],
<span class="nc" id="L204">      closeable: CloseableIterator[_],</span>
      ordering: Ordering[SimpleFeature]
<span class="nc" id="L206">    ) extends CloseableIterator[SimpleFeature] {</span>

    // list of feature iterators to merge
<span class="nc" id="L209">    private val merging = IndexedSeq(CloseableIterator(mem)) ++ files.map(new FileIterator(_, serializer))</span>

    // priority queue containing the next feature from each file
<span class="nc" id="L212">    private val heads = {</span>
<span class="nc" id="L213">      val o = Ordering.by[(SimpleFeature, Int), SimpleFeature](_._1)(ordering)</span>
<span class="nc" id="L214">      val q = new java.util.PriorityQueue[(SimpleFeature, Int)](files.size + 1, o)</span>
<span class="nc" id="L215">      var i = 0</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">      while (i &lt; merging.length) {</span>
<span class="nc" id="L217">        val m = merging(i)</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (m.hasNext) {</span>
<span class="nc" id="L219">          q.add(m.next -&gt; i)</span>
        }
<span class="nc" id="L221">        i += 1</span>
      }
<span class="nc" id="L223">      q</span>
    }

<span class="nc bnc" id="L226" title="All 2 branches missed.">    override def hasNext: Boolean = !heads.isEmpty</span>

    override def next(): SimpleFeature = {
<span class="nc bnc" id="L229" title="All 2 branches missed.">      val (f, i) = heads.poll()</span>
<span class="nc" id="L230">      val m = merging(i)</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (m.hasNext) {</span>
<span class="nc" id="L232">        heads.add(m.next -&gt; i)</span>
      }
<span class="nc" id="L234">      f</span>
    }

<span class="nc" id="L237">    override def close(): Unit = CloseQuietly.raise(merging :+ closeable)</span>
  }

  /**
   * Reads a tmp file of serialized simple features
   *
   * @param file file
   * @param serializer serializer
   */
<span class="nc bnc" id="L246" title="All 4 branches missed.">  private class FileIterator(file: File, serializer: SimpleFeatureSerializer)</span>
<span class="nc" id="L247">      extends CloseableIterator[SimpleFeature] with LazyLogging {</span>

<span class="nc" id="L249">    private val is = new FileInputStream(file)</span>
<span class="nc" id="L250">    private var buf = Array.ofDim[Byte](4)</span>

<span class="nc bnc" id="L252" title="All 2 branches missed.">    override def hasNext: Boolean = is.available() &gt; 0</span>

    override def next(): SimpleFeature = {
<span class="nc" id="L255">      is.read(buf, 0, 4)</span>
<span class="nc" id="L256">      val size = ByteArrays.readInt(buf)</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if (buf.length &lt; size) {</span>
<span class="nc" id="L258">        buf = Array.ofDim((size * 1.2).toInt)</span>
      }
<span class="nc" id="L260">      is.read(buf, 0, size)</span>
<span class="nc" id="L261">      serializer.deserialize(buf, 0, size)</span>
    }

    override def close(): Unit = {
<span class="nc" id="L265">      try { is.close() } finally {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (!file.delete()) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">          logger.warn(s&quot;Unable to delete tmp file '${file.getAbsolutePath}''&quot;)</span>
<span class="nc" id="L268">          file.deleteOnExit()</span>
        }
      }
    }
  }

  /**
   * Evidence that a feature is sizable
   *
   * @tparam T type binding
   */
  private trait FeatureIsSizable[T &lt;: SimpleFeature] {
    def sizeOf(feature: T): Long
  }

  /**
   * Evidence that Sizable features are sizable
   */
<span class="nc" id="L286">  private object SizableFeatureIsSizable extends FeatureIsSizable[SimpleFeature with Sizable] {</span>
<span class="nc" id="L287">    override def sizeOf(feature: SimpleFeature with Sizable): Long = feature.calculateSizeOf()</span>
  }

  /**
   * Use a rough estimate based on attributes and user data
   */
<span class="nc" id="L293">  private object UnSizableFeatureIsSizable extends FeatureIsSizable[SimpleFeature] {</span>
    override def sizeOf(feature: SimpleFeature): Long =
<span class="nc" id="L295">      Sizable.sizeOf(feature) + Sizable.deepSizeOf(feature.getAttributes, feature.getUserData)</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>