<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DtgAgeOffFilter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.filters</a> &gt; <span class="el_source">DtgAgeOffFilter.scala</span></div><h1>DtgAgeOffFilter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.filters

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.features.SerializationOption
import org.locationtech.geomesa.features.SerializationOption.SerializationOption
import org.locationtech.geomesa.features.kryo.KryoBufferSimpleFeature
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.iterators.AggregatingScan._
import org.locationtech.geomesa.index.iterators.IteratorCache
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes

import java.util.Date
import scala.util.control.NonFatal

/**
  * Age-off a feature based on an attribute time
  */
<span class="nc" id="L28">trait DtgAgeOffFilter extends AgeOffFilter with LazyLogging {</span>

  protected var sft: SimpleFeatureType = _
  protected var index: GeoMesaFeatureIndex[_, _] = _

  protected var reusableSf: KryoBufferSimpleFeature = _
<span class="nc" id="L34">  protected var dtgIndex: Int = -1</span>

  override def init(options: Map[String, String]): Unit = {
    import DtgAgeOffFilter.Configuration.{DtgOpt, IndexOpt, IndexSftOpt, SftOpt}

<span class="nc" id="L39">    super.init(options)</span>

<span class="nc" id="L41">    val spec = options(SftOpt)</span>
<span class="nc" id="L42">    sft = IteratorCache.sft(spec)</span>
<span class="nc" id="L43">    index = options.get(IndexSftOpt) match {</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">      case None =&gt; IteratorCache.index(sft, spec, options(IndexOpt))</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      case Some(ispec) =&gt; IteratorCache.index(IteratorCache.sft(ispec), ispec, options(IndexOpt))</span>
    }

<span class="nc" id="L48">    reusableSf = IteratorCache.serializer(spec, index.serializedWithId).getReusableFeature</span>
<span class="nc" id="L49">    dtgIndex = options(DtgOpt).toInt // note: keep this last, for back-compatibility with DtgAgeOffIterator</span>
  }

  override def accept(row: Array[Byte],
                      rowOffset: Int,
                      rowLength: Int,
                      value: Array[Byte],
                      valueOffset: Int,
                      valueLength: Int,
                      timestamp: Long): Boolean = {
<span class="nc" id="L59">    try {</span>
<span class="nc" id="L60">      reusableSf.setBuffer(value, valueOffset, valueLength)</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">      reusableSf.getDateAsLong(dtgIndex) &gt; expiry</span>
    } catch {
<span class="nc bnc" id="L63" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        logger.error(s&quot;Error checking age-off for &quot; +</span>
<span class="nc" id="L65">            Option(value).getOrElse(Array.empty).mkString(&quot;[&quot;, &quot;,&quot;, s&quot;], offset: $valueOffset, length: $valueLength&quot;))</span>
<span class="nc" id="L66">        false</span>
    }
  }
}

<span class="nc" id="L71">object DtgAgeOffFilter {</span>

  // configuration keys
<span class="nc" id="L74">  object Configuration {</span>
<span class="nc" id="L75">    val SftOpt      = &quot;sft&quot;</span>
<span class="nc" id="L76">    val IndexOpt    = &quot;index&quot;</span>
<span class="nc" id="L77">    val IndexSftOpt = &quot;index-sft&quot;</span>
<span class="nc" id="L78">    val DtgOpt      = &quot;dtg&quot;</span>
  }

<span class="nc" id="L81">  def configure(sft: SimpleFeatureType,</span>
                index: GeoMesaFeatureIndex[_, _],
                expiry: scala.concurrent.duration.Duration,
                dtgField: Option[String]): Map[String, String] = {
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc bnc" id="L87" title="All 4 branches missed.">    require(!sft.isTableSharing || SystemProperty(&quot;geomesa.age-off.override&quot;).option.exists(_.toBoolean),</span>
      &quot;DtgAgeOff filter should only be applied to features that don't use table sharing. You may override this check&quot; +
          &quot;by setting the system property 'geomesa.age-off.override=true', however please note that age-off&quot; +
<span class="nc" id="L90">          &quot;will affect all shared feature types in the same catalog, and may not work correctly with multiple feature&quot; +</span>
          &quot;types&quot;)

<span class="nc" id="L93">    val dtgIndex = dtgField match {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      case None =&gt;</span>
<span class="nc" id="L95">        sft.getDtgIndex.getOrElse {</span>
<span class="nc" id="L96">          throw new IllegalArgumentException(&quot;Simple feature type does not have a valid date field&quot;)</span>
        }
<span class="nc bnc" id="L98" title="All 2 branches missed.">      case Some(dtg) =&gt;</span>
<span class="nc" id="L99">        val i = sft.indexOf(dtg)</span>
<span class="nc bnc" id="L100" title="All 4 branches missed.">        if (i == -1 || !classOf[Date].isAssignableFrom(sft.getDescriptor(i).getType.getBinding)) {</span>
<span class="nc" id="L101">          throw new IllegalArgumentException(s&quot;Simple feature type does not have a valid date field '$dtg'&quot;)</span>
        }
<span class="nc" id="L103">        i</span>
    }

<span class="nc" id="L106">    val indexSftOpt = Some(index.sft).collect {</span>
<span class="nc bnc" id="L107" title="All 12 branches missed.">      case s if s != sft =&gt; SimpleFeatureTypes.encodeType(s, includeUserData = true)</span>
    }

<span class="nc" id="L110">    AgeOffFilter.configure(sft, expiry) ++ Map (</span>
<span class="nc" id="L111">      Configuration.SftOpt   -&gt; SimpleFeatureTypes.encodeType(sft),</span>
<span class="nc" id="L112">      Configuration.IndexOpt -&gt; index.identifier,</span>
<span class="nc" id="L113">      Configuration.DtgOpt   -&gt; dtgIndex.toString</span>
<span class="nc" id="L114">    ) ++ optionalMap(Configuration.IndexSftOpt -&gt; indexSftOpt)</span>
  }
<span class="nc" id="L116">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>