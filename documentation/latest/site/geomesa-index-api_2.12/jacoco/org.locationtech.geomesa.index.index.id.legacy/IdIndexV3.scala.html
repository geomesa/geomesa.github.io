<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IdIndexV3.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index API</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.index.index.id.legacy</a> &gt; <span class="el_source">IdIndexV3.scala</span></div><h1>IdIndexV3.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.index.index.id.legacy

import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.index.api._
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.index.id.legacy.IdIndexV3.IdIndexKeySpaceV3
import org.locationtech.geomesa.index.index.id.{IdIndex, IdIndexKeySpace}
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.index.IndexMode.IndexMode

// supports table sharing
<span class="nc" id="L20">class IdIndexV3 protected (ds: GeoMesaDataStore[_], sft: SimpleFeatureType, version: Int, mode: IndexMode)</span>
<span class="nc" id="L21">    extends IdIndex(ds, sft, version, mode) {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  def this(ds: GeoMesaDataStore[_], sft: SimpleFeatureType, mode: IndexMode) =
<span class="nc" id="L26">    this(ds, sft, 3, mode)</span>

<span class="nc" id="L28">  override protected val tableNameKey: String = &quot;table.id.v3&quot;</span>

<span class="nc" id="L30">  override val keySpace: IdIndexKeySpace = new IdIndexKeySpaceV3(sft, sft.getTableSharingBytes)</span>
}

<span class="nc" id="L33">object IdIndexV3 {</span>

<span class="nc" id="L35">  private val sharding = Array.empty[Byte]</span>

<span class="nc" id="L37">  class IdIndexKeySpaceV3(sft: SimpleFeatureType, override val sharing: Array[Byte]) extends IdIndexKeySpace(sft) {</span>

<span class="nc bnc" id="L39" title="All 2 branches missed.">    private val rangePrefixes = if (sharing.isEmpty) { Seq.empty } else { Seq(sharing) }</span>

<span class="nc" id="L41">    override val indexKeyByteLength: Right[(Array[Byte], Int, Int) =&gt; Int, Int] = Right(sharing.length)</span>

    override def toIndexKey(writable: WritableFeature,
                            tier: Array[Byte],
                            id: Array[Byte],
                            lenient: Boolean): RowKeyValue[Array[Byte]] = {
      // create the byte array - allocate a single array up front to contain everything
      // ignore tier, not used here
      // note: the row already contains the feature ID, so we don't need to add anything else
<span class="nc bnc" id="L50" title="All 2 branches missed.">      val bytes = if (sharing.isEmpty) { id } else {</span>
<span class="nc" id="L51">        val array = Array.ofDim[Byte](1 + id.length)</span>
<span class="nc" id="L52">        array(0) = sharing.head // sharing is only a single byte</span>
<span class="nc" id="L53">        System.arraycopy(id, 0, array, 1, id.length)</span>
<span class="nc" id="L54">        array</span>
      }

<span class="nc" id="L57">      SingleRowKeyValue(bytes, sharing, IdIndexV3.sharding, id, tier, id, writable.values)</span>
    }

    override def getRangeBytes(ranges: Iterator[ScanRange[Array[Byte]]], tier: Boolean): Iterator[ByteRange] = {
<span class="nc bnc" id="L61" title="All 2 branches missed.">      if (rangePrefixes.isEmpty) {</span>
<span class="nc" id="L62">        ranges.map {</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">          case SingleRowRange(row) =&gt; SingleRowByteRange(row)</span>
<span class="nc" id="L64">          case r =&gt; throw new IllegalArgumentException(s&quot;Unexpected range type $r&quot;)</span>
        }
      } else {
<span class="nc" id="L67">        ranges.flatMap {</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">          case SingleRowRange(row) =&gt; rangePrefixes.map(p =&gt; SingleRowByteRange(ByteArrays.concat(p, row)))</span>
<span class="nc" id="L69">          case r =&gt; throw new IllegalArgumentException(s&quot;Unexpected range type $r&quot;)</span>
        }
      }
    }
  }
<span class="nc" id="L74">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>