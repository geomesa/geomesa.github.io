<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ZN.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index Z3</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.zorder.sfcurve</a> &gt; <span class="el_source">ZN.scala</span></div><h1>ZN.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * Copyright (c) 2015 Azavea.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.zorder.sfcurve

import scala.collection.mutable.ArrayBuffer

/**
  * N-dimensional z-curve base class
  */
<span class="nc" id="L17">abstract class ZN {</span>

  // number of bits used to store each dimension
  def BitsPerDimension: Int

  // number of dimensions
  def Dimensions: Int

  // max value for this z object - can be used to mask another long using &amp;
  def MaxMask: Long

  // total bits used - usually bitsPerDim * dims
  def TotalBits: Int

  // number of quadrants in our quad/oct tree - has to be lazy to instantiate correctly
<span class="nc bnc" id="L32" title="All 4 branches missed.">  private lazy val Quadrants = math.pow(2, Dimensions)</span>

  /**
    * Insert (Dimensions - 1) zeros between each bit to create a zvalue from a single dimension.
    * Only the first BitsPerDimension can be considered.
    *
    * @param value value to split
    * @return
    */
  def split(value: Long): Long

  /**
    * Combine every (Dimensions - 1) bits to re-create a single dimension. Opposite of split.
    *
    * @param z value to combine
    * @return
    */
  def combine(z: Long): Int

  /**
    * Is the value contained in the range. Considers user-space.
    *
    * @param range range
    * @param value value to be tested
    * @return
    */
  def contains(range: ZRange, value: Long): Boolean

  /**
    * Is the value contained in the range. Considers user-space.
    *
    * @param range range
    * @param value value to be tested
    * @return
    */
<span class="nc bnc" id="L67" title="All 4 branches missed.">  def contains(range: ZRange, value: ZRange): Boolean = contains(range, value.min) &amp;&amp; contains(range, value.max)</span>

  /**
    * Does the value overlap with the range. Considers user-space.
    *
    * @param range range
    * @param value value to be tested
    * @return
    */
  def overlaps(range: ZRange, value: ZRange): Boolean

  /**
    * Returns (litmax, bigmin) for the given range and point
    *
    * @param p point
    * @param rmin minimum value
    * @param rmax maximum value
    * @return (litmax, bigmin)
    */
<span class="nc" id="L86">  def zdivide(p: Long, rmin: Long, rmax: Long): (Long, Long) = ZN.zdiv(load, Dimensions)(p, rmin, rmax)</span>

<span class="nc" id="L88">  def zranges(zbounds: ZRange): Seq[IndexRange] = zranges(Array(zbounds))</span>
<span class="nc" id="L89">  def zranges(zbounds: ZRange, precision: Int): Seq[IndexRange] = zranges(Array(zbounds), precision)</span>
  def zranges(zbounds: ZRange, precision: Int, maxRanges: Option[Int]): Seq[IndexRange] =
<span class="nc" id="L91">    zranges(Array(zbounds), precision, maxRanges)</span>

  /**
    * Calculates ranges in index space that match any of the input bounds. Uses breadth-first searching to
    * allow a limit on the number of ranges returned.
    *
    * To improve performance, the following decisions have been made:
    *   uses loops instead of foreach/maps
    *   uses java queues instead of scala queues
    *   allocates initial sequences of decent size
    *   sorts once at the end before merging
    *
    * @param zbounds search space
    * @param precision precision to consider, in bits (max 64)
    * @param maxRanges loose cap on the number of ranges to return. A higher number of ranges will have less
    *                  false positives, but require more processing.
    * @param maxRecurse max levels of recursion to apply before stopping
    * @return ranges covering the search space
    */
  def zranges(zbounds: Array[ZRange],
<span class="nc" id="L111">              precision: Int = 64,</span>
<span class="nc" id="L112">              maxRanges: Option[Int] = None,</span>
<span class="nc" id="L113">              maxRecurse: Option[Int] = Some(ZN.DefaultRecurse)): Seq[IndexRange] = {</span>

    import ZN.LevelTerminator

    // stores our results - initial size of 100 in general saves us some re-allocation
<span class="nc" id="L118">    val ranges = new java.util.ArrayList[IndexRange](100)</span>

    // values remaining to process - initial size of 100 in general saves us some re-allocation
<span class="nc" id="L121">    val remaining = new java.util.ArrayDeque[(Long, Long)](100)</span>

    // calculate the common prefix in the z-values - we start processing with the first diff
<span class="nc bnc" id="L124" title="All 2 branches missed.">    val ZPrefix(commonPrefix, commonBits) = longestCommonPrefix(zbounds.flatMap(b =&gt; Seq(b.min, b.max)): _*)</span>

<span class="nc" id="L126">    var offset = 64 - commonBits</span>

    // checks if a range is contained in the search space
    def isContained(range: ZRange): Boolean = {
<span class="nc" id="L130">      var i = 0</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">      while (i &lt; zbounds.length) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (contains(zbounds(i), range)) {</span>
<span class="nc" id="L133">          return true</span>
        }
<span class="nc" id="L135">        i += 1</span>
      }
<span class="nc" id="L137">      false</span>
    }

    // checks if a range overlaps the search space
    def isOverlapped(range: ZRange): Boolean = {
<span class="nc" id="L142">      var i = 0</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      while (i &lt; zbounds.length) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (overlaps(zbounds(i), range)) {</span>
<span class="nc" id="L145">          return true</span>
        }
<span class="nc" id="L147">        i += 1</span>
      }
<span class="nc" id="L149">      false</span>
    }

    // checks a single value and either:
    //   eliminates it as out of bounds
    //   adds it to our results as fully matching, or
    //   queues up it's children for further processing
    def checkValue(prefix: Long, quadrant: Long): Unit = {
<span class="nc" id="L157">      val min: Long = prefix | (quadrant &lt;&lt; offset) // QR + 000...</span>
<span class="nc" id="L158">      val max: Long = min | (1L &lt;&lt; offset) - 1 // QR + 111...</span>
<span class="nc" id="L159">      val quadrantRange = ZRange(min, max)</span>

<span class="nc bnc" id="L161" title="All 4 branches missed.">      if (isContained(quadrantRange) || offset &lt; 64 - precision) {</span>
        // whole range matches, happy day
<span class="nc" id="L163">        ranges.add(IndexRange(min, max, contained = true))</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      } else if (isOverlapped(quadrantRange)) {</span>
        // some portion of this range is excluded
        // queue up each sub-range for processing
<span class="nc" id="L167">        remaining.add((min, max))</span>
      }
    }

    // bottom out and get all the ranges that partially overlapped but we didn't fully process
    // note: this method is only called when we know there are items remaining in the queue
    def bottomOut(): Unit = {
<span class="nc" id="L174">      while ({{</span>
<span class="nc" id="L175">        val minMax = remaining.poll</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (!minMax.eq(LevelTerminator)) {</span>
<span class="nc" id="L177">          ranges.add(IndexRange(minMax._1, minMax._2, contained = false))</span>
        }
<span class="nc bnc" id="L179" title="All 2 branches missed.">      }; !remaining.isEmpty })()</span>
    }

    // initial level - we just check the single quadrant
<span class="nc" id="L183">    checkValue(commonPrefix, 0)</span>
<span class="nc" id="L184">    remaining.add(LevelTerminator)</span>
<span class="nc" id="L185">    offset -= Dimensions</span>

    // level of recursion
<span class="nc" id="L188">    var level = 0</span>

<span class="nc" id="L190">    val rangeStop = maxRanges.getOrElse(Int.MaxValue)</span>
<span class="nc" id="L191">    val recurseStop = maxRecurse.getOrElse(ZN.DefaultRecurse)</span>

    while ({{
<span class="nc" id="L194">      val next = remaining.poll</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      if (next.eq(LevelTerminator)) {</span>
        // we've fully processed a level, increment our state
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (!remaining.isEmpty) {</span>
<span class="nc" id="L198">          level += 1</span>
<span class="nc" id="L199">          offset -= Dimensions</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">          if (level &gt;= recurseStop || offset &lt; 0) {</span>
<span class="nc" id="L201">            bottomOut()</span>
          } else {
<span class="nc" id="L203">            remaining.add(LevelTerminator)</span>
          }
        }
<span class="nc" id="L206">      } else {</span>
<span class="nc" id="L207">        val prefix = next._1</span>
<span class="nc" id="L208">        var quadrant = 0L</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        while (quadrant &lt; Quadrants) {</span>
<span class="nc" id="L210">          checkValue(prefix, quadrant)</span>
<span class="nc" id="L211">          quadrant += 1</span>
        }
        // subtract one from remaining.size to account for the LevelTerminator
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (ranges.size + remaining.size - 1 &gt;= rangeStop) {</span>
<span class="nc" id="L215">          bottomOut()</span>
        }
      }
<span class="nc bnc" id="L218" title="All 2 branches missed.">    }; !remaining.isEmpty })()</span>

    // we've got all our ranges - now reduce them down by merging overlapping values
<span class="nc" id="L221">    ranges.sort(IndexRange.IndexRangeIsOrdered)</span>

<span class="nc" id="L223">    var current = ranges.get(0) // note: should always be at least one range</span>
<span class="nc" id="L224">    val result = ArrayBuffer.empty[IndexRange]</span>
<span class="nc" id="L225">    var i = 1</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">    while (i &lt; ranges.size()) {</span>
<span class="nc" id="L227">      val range = ranges.get(i)</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">      if (range.lower &lt;= current.upper + 1) {</span>
        // merge the two ranges
<span class="nc bnc" id="L230" title="All 4 branches missed.">        current = IndexRange(current.lower, math.max(current.upper, range.upper), current.contained &amp;&amp; range.contained)</span>
      } else {
        // append the last range and set the current range for future merging
<span class="nc" id="L233">        result.append(current)</span>
<span class="nc" id="L234">        current = range</span>
      }
<span class="nc" id="L236">      i += 1</span>
    }
    // append the last range - there will always be one left that wasn't added
<span class="nc" id="L239">    result.append(current)</span>

<span class="nc" id="L241">    result.toSeq</span>
  }

  /**
   * Cuts Z-Range in two and trims based on user space, can be used to perform augmented binary search
   *
   * @param xd: division point
   * @param inRange: is xd in query range
   */
  def cut(r: ZRange, xd: Long, inRange: Boolean): List[ZRange] = {
<span class="nc bnc" id="L251" title="All 2 branches missed.">    if (r.min == r.max) {</span>
<span class="nc" id="L252">      Nil</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">    } else if (inRange) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (xd == r.min) { // degenerate case, two nodes min has already been counted</span>
<span class="nc" id="L255">        ZRange(r.max, r.max) :: Nil</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      } else if (xd == r.max) { // degenerate case, two nodes max has already been counted</span>
<span class="nc" id="L257">        ZRange(r.min, r.min) :: Nil</span>
      } else {
<span class="nc" id="L259">        ZRange(r.min, xd - 1) :: ZRange(xd + 1, r.max) :: Nil</span>
      }
    } else {
<span class="nc bnc" id="L262" title="All 2 branches missed.">      val (litmax, bigmin) = zdivide(xd, r.min, r.max)</span>
<span class="nc" id="L263">      ZRange(r.min, litmax) :: ZRange(bigmin, r.max) :: Nil</span>
    }
  }

  /**
    * Calculates the longest common binary prefix between two z longs
    *
    * @return (common prefix, number of bits in common)
    */
  def longestCommonPrefix(values: Long*): ZPrefix = {
<span class="nc" id="L273">    var bitShift = TotalBits - Dimensions</span>
<span class="nc" id="L274">    var head = values.head &gt;&gt;&gt; bitShift</span>
<span class="nc bnc" id="L275" title="All 6 branches missed.">    while (values.tail.forall(v =&gt; (v &gt;&gt;&gt; bitShift) == head) &amp;&amp; bitShift &gt; -1) {</span>
<span class="nc" id="L276">      bitShift -= Dimensions</span>
<span class="nc" id="L277">      head = values.head &gt;&gt;&gt; bitShift</span>
    }
<span class="nc" id="L279">    bitShift += Dimensions // increment back to the last valid value</span>
<span class="nc" id="L280">    ZPrefix(values.head &amp; (Long.MaxValue &lt;&lt; bitShift), 64 - bitShift)</span>
  }

  /** Loads either 1000... or 0111... into starting at given bit index of a given dimension */
  private def load(target: Long, p: Long, bits: Int, dim: Int): Long = {
<span class="nc" id="L285">    val mask = ~(split(MaxMask &gt;&gt; (BitsPerDimension - bits)) &lt;&lt; dim)</span>
<span class="nc" id="L286">    val wiped = target &amp; mask</span>
<span class="nc" id="L287">    wiped | (split(p) &lt;&lt; dim)</span>
  }
}

<span class="nc" id="L291">object ZN {</span>

<span class="nc" id="L293">  val DefaultRecurse = 7</span>

  // indicator that we have searched a full level of the quad/oct tree
<span class="nc" id="L296">  private val LevelTerminator = (-1L, -1L)</span>

  /**
    * Implements the the algorithm defined in: Tropf paper to find:
    * LITMAX: maximum z-index in query range smaller than current point, xd
    * BIGMIN: minimum z-index in query range greater than current point, xd
    *
    * @param load: function that knows how to load bits into appropraite dimension of a z-index
    * @param xd: z-index that is outside of the query range
    * @param rmin: minimum z-index of the query range, inclusive
    * @param rmax: maximum z-index of the query range, inclusive
    * @return (LITMAX, BIGMIN)
    */
  private [zorder] def zdiv(load: (Long, Long, Int, Int) =&gt; Long, dims: Int)
                           (xd: Long, rmin: Long, rmax: Long): (Long, Long) = {
<span class="nc bnc" id="L311" title="All 2 branches missed.">    require(rmin &lt; rmax, &quot;min ($rmin) must be less than max $(rmax)&quot;)</span>
<span class="nc" id="L312">    var zmin: Long = rmin</span>
<span class="nc" id="L313">    var zmax: Long = rmax</span>
<span class="nc" id="L314">    var bigmin: Long = 0L</span>
<span class="nc" id="L315">    var litmax: Long = 0L</span>

    def bit(x: Long, idx: Int) = {
<span class="nc" id="L318">      ((x &amp; (1L &lt;&lt; idx)) &gt;&gt; idx).toInt</span>
    }
<span class="nc" id="L320">    def over(bits: Long)  = 1L &lt;&lt; (bits - 1)</span>
<span class="nc" id="L321">    def under(bits: Long) = (1L &lt;&lt; (bits - 1)) - 1</span>

<span class="nc" id="L323">    var i = 64</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">    while (i &gt; 0) {</span>
<span class="nc" id="L325">      i -= 1</span>

<span class="nc" id="L327">      val bits = i/dims+1</span>
<span class="nc" id="L328">      val dim  = i%dims</span>

<span class="nc bnc" id="L330" title="All 16 branches missed.">      ( bit(xd, i), bit(zmin, i), bit(zmax, i) ) match {</span>
<span class="nc bnc" id="L331" title="All 6 branches missed.">        case (0, 0, 0) =&gt;</span>
        // continue

<span class="nc bnc" id="L334" title="All 6 branches missed.">        case (0, 0, 1) =&gt;</span>
<span class="nc" id="L335">          zmax   = load(zmax, under(bits), bits, dim)</span>
<span class="nc" id="L336">          bigmin = load(zmin, over(bits), bits, dim)</span>

<span class="nc bnc" id="L338" title="All 6 branches missed.">        case (0, 1, 0) =&gt;</span>
        // sys.error(s&quot;Not possible, MIN &lt;= MAX, (0, 1, 0)  at index $i&quot;)

<span class="nc bnc" id="L341" title="All 6 branches missed.">        case (0, 1, 1) =&gt;</span>
<span class="nc" id="L342">          bigmin = zmin</span>
<span class="nc" id="L343">          return (litmax, bigmin)</span>

<span class="nc bnc" id="L345" title="All 6 branches missed.">        case (1, 0, 0) =&gt;</span>
<span class="nc" id="L346">          litmax = zmax</span>
<span class="nc" id="L347">          return (litmax, bigmin)</span>

<span class="nc bnc" id="L349" title="All 6 branches missed.">        case (1, 0, 1) =&gt;</span>
<span class="nc" id="L350">          litmax = load(zmax, under(bits), bits, dim)</span>
<span class="nc" id="L351">          zmin = load(zmin, over(bits), bits, dim)</span>

<span class="nc bnc" id="L353" title="All 6 branches missed.">        case (1, 1, 0) =&gt;</span>
        // sys.error(s&quot;Not possible, MIN &lt;= MAX, (1, 1, 0) at index $i&quot;)

<span class="nc bnc" id="L356" title="All 6 branches missed.">        case (1, 1, 1) =&gt;</span>
        // continue
      }
    }
<span class="nc" id="L360">    (litmax, bigmin)</span>
  }
<span class="nc" id="L362">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>