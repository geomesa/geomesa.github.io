<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XZ2SFC.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index Z3</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.curve</a> &gt; <span class="el_source">XZ2SFC.scala</span></div><h1>XZ2SFC.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.curve

import org.locationtech.geomesa.curve.XZ2SFC.{QueryWindow, XElement}
import org.locationtech.geomesa.zorder.sfcurve.IndexRange

import scala.collection.mutable.ArrayBuffer

/**
  * Extended Z-order curve implementation used for efficiently storing polygons.
  *
  * Based on 'XZ-Ordering: A Space-Filling Curve for Objects with Spatial Extension'
  * by Christian BÃ¶hm, Gerald Klump  and Hans-Peter Kriegel
  *
  * @param g resolution level of the curve - i.e. how many times the space will be recursively quartered
  */
<span class="nc" id="L24">class XZ2SFC(g: Short, xBounds: (Double, Double), yBounds: (Double, Double)) {</span>

  // TODO see what the max value of g can be where we can use Ints instead of Longs and possibly refactor to use Ints

<span class="nc" id="L28">  private val xLo = xBounds._1</span>
<span class="nc" id="L29">  private val xHi = xBounds._2</span>
<span class="nc" id="L30">  private val yLo = yBounds._1</span>
<span class="nc" id="L31">  private val yHi = yBounds._2</span>

<span class="nc" id="L33">  private val xSize = xHi - xLo</span>
<span class="nc" id="L34">  private val ySize = yHi - yLo</span>

  /**
    * Index a polygon by it's bounding box
    *
    * @param bounds (xmin, ymin, xmax, ymax)
    * @return z value for the bounding box
    */
<span class="nc" id="L42">  def index(bounds: (Double, Double, Double, Double)): Long = index(bounds._1, bounds._2, bounds._3, bounds._4)</span>

  /**
    * Index a polygon by it's bounding box
    *
    * @param xmin min x value in xBounds
    * @param ymin min y value in yBounds
    * @param xmax max x value in xBounds, must be &gt;= xmin
    * @param ymax max y value in yBounds, must be &gt;= ymin
    * @param lenient standardize boundaries to valid values, or raise an exception
    * @return z value for the bounding box
    */
<span class="nc" id="L54">  def index(xmin: Double, ymin: Double, xmax: Double, ymax: Double, lenient: Boolean = false): Long = {</span>
    // normalize inputs to [0,1]
<span class="nc bnc" id="L56" title="All 2 branches missed.">    val (nxmin, nymin, nxmax, nymax) = normalize(xmin, ymin, xmax, ymax, lenient)</span>

    // calculate the length of the sequence code (section 4.1 of XZ-Ordering paper)

<span class="nc" id="L60">    val maxDim = math.max(nxmax - nxmin, nymax - nymin)</span>

    // l1 (el-one) is a bit confusing to read, but corresponds with the paper's definitions
<span class="nc" id="L63">    val l1 = math.floor(math.log(maxDim) / XZSFC.LogPointFive).toInt</span>

    // the length will either be (l1) or (l1 + 1)
<span class="nc bnc" id="L66" title="All 2 branches missed.">    val length = if (l1 &gt;= g) { g } else {</span>
<span class="nc" id="L67">      val w2 = math.pow(0.5, l1 + 1) // width of an element at resolution l2 (l1 + 1)</span>

      // predicate for checking how many axis the polygon intersects
      // math.floor(min / w2) * w2 == start of cell containing min
<span class="nc bnc" id="L71" title="All 2 branches missed.">      def predicate(min: Double, max: Double): Boolean = max &lt;= (math.floor(min / w2) * w2) + (2 * w2)</span>

<span class="nc bnc" id="L73" title="All 4 branches missed.">      if (predicate(nxmin, nxmax) &amp;&amp; predicate(nymin, nymax)) l1 + 1 else l1</span>
    }

<span class="nc" id="L76">    sequenceCode(nxmin, nymin, length)</span>
  }

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param query a window to cover in the form (xmin, ymin, xmax, ymax) where: all values are in user space
    * @return
    */
<span class="nc" id="L85">  def ranges(query: (Double, Double, Double, Double)): Seq[IndexRange] = ranges(Seq(query))</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param query a window to cover in the form (xmin, ymin, xmax, ymax) where all values are in user space
    * @param maxRanges a rough upper limit on the number of ranges to generate
    * @return
    */
  def ranges(query: (Double, Double, Double, Double), maxRanges: Option[Int]): Seq[IndexRange] =
<span class="nc" id="L95">    ranges(Seq(query), maxRanges)</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param xmin min x value in user space
    * @param ymin min y value in user space
    * @param xmax max x value in user space, must be &gt;= xmin
    * @param ymax max y value in user space, must be &gt;= ymin
    * @return
    */
  def ranges(xmin: Double, ymin: Double, xmax: Double, ymax: Double): Seq[IndexRange] =
<span class="nc" id="L107">    ranges(Seq((xmin, ymin, xmax, ymax)))</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param xmin min x value in user space
    * @param ymin min y value in user space
    * @param xmax max x value in user space, must be &gt;= xmin
    * @param ymax max y value in user space, must be &gt;= ymin
    * @param maxRanges a rough upper limit on the number of ranges to generate
    * @return
    */
  def ranges(xmin: Double, ymin: Double, xmax: Double, ymax: Double, maxRanges: Option[Int]): Seq[IndexRange] =
<span class="nc" id="L120">    ranges(Seq((xmin, ymin, xmax, ymax)), maxRanges)</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param queries a sequence of OR'd windows to cover. Each window is in the form
    *                (xmin, ymin, xmax, ymax) where all values are in user space
    * @param maxRanges a rough upper limit on the number of ranges to generate
    * @return
    */
<span class="nc" id="L130">  def ranges(queries: Seq[(Double, Double, Double, Double)], maxRanges: Option[Int] = None): Seq[IndexRange] = {</span>
    // normalize inputs to [0,1]
<span class="nc bnc" id="L132" title="All 2 branches missed.">    val windows = queries.map { case (xmin, ymin, xmax, ymax) =&gt;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">      val (nxmin, nymin, nxmax, nymax) = normalize(xmin, ymin, xmax, ymax, lenient = false)</span>
<span class="nc" id="L134">      QueryWindow(nxmin, nymin, nxmax, nymax)</span>
    }
<span class="nc" id="L136">    ranges(windows.toArray, maxRanges.getOrElse(Int.MaxValue))</span>
  }

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param query a sequence of OR'd windows to cover, normalized to [0,1]
    * @param rangeStop a rough max value for the number of ranges to return
    * @return
    */
  private def ranges(query: Array[QueryWindow], rangeStop: Int): Seq[IndexRange] = {

    import XZ2SFC.{LevelOneElements, LevelTerminator}

    // stores our results - initial size of 100 in general saves us some re-allocation
<span class="nc" id="L151">    val ranges = new java.util.ArrayList[IndexRange](100)</span>

    // values remaining to process - initial size of 100 in general saves us some re-allocation
<span class="nc" id="L154">    val remaining = new java.util.ArrayDeque[XElement](100)</span>

    // checks if a quad is contained in the search space
    def isContained(quad: XElement): Boolean = {
<span class="nc" id="L158">      var i = 0</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">      while (i &lt; query.length) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (quad.isContained(query(i))) {</span>
<span class="nc" id="L161">          return true</span>
        }
<span class="nc" id="L163">        i += 1</span>
      }
<span class="nc" id="L165">      false</span>
    }

    // checks if a quad overlaps the search space
    def isOverlapped(quad: XElement): Boolean = {
<span class="nc" id="L170">      var i = 0</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      while (i &lt; query.length) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (quad.overlaps(query(i))) {</span>
<span class="nc" id="L173">          return true</span>
        }
<span class="nc" id="L175">        i += 1</span>
      }
<span class="nc" id="L177">      false</span>
    }

    // checks a single value and either:
    //   eliminates it as out of bounds
    //   adds it to our results as fully matching, or
    //   adds it to our results as partial matching and queues up it's children for further processing
    def checkValue(quad: XElement, level: Short): Unit = {
<span class="nc bnc" id="L185" title="All 2 branches missed.">      if (isContained(quad)) {</span>
        // whole range matches, happy day
<span class="nc bnc" id="L187" title="All 2 branches missed.">        val (min, max) = sequenceInterval(quad.xmin, quad.ymin, level, partial = false)</span>
<span class="nc" id="L188">        ranges.add(IndexRange(min, max, contained = true))</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">      } else if (isOverlapped(quad)) {</span>
        // some portion of this range is excluded
        // add the partial match and queue up each sub-range for processing
<span class="nc bnc" id="L192" title="All 2 branches missed.">        val (min, max) = sequenceInterval(quad.xmin, quad.ymin, level, partial = true)</span>
<span class="nc" id="L193">        ranges.add(IndexRange(min, max, contained = false))</span>
<span class="nc" id="L194">        quad.children.foreach(remaining.add)</span>
      }
    }

    // initial level
<span class="nc" id="L199">    LevelOneElements.foreach(remaining.add)</span>
<span class="nc" id="L200">    remaining.add(LevelTerminator)</span>

    // level of recursion
<span class="nc" id="L203">    var level: Short = 1</span>

<span class="nc bnc" id="L205" title="All 6 branches missed.">    while (level &lt; g &amp;&amp; !remaining.isEmpty &amp;&amp; ranges.size &lt; rangeStop) {</span>
<span class="nc" id="L206">      val next = remaining.poll</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">      if (next.eq(LevelTerminator)) {</span>
        // we've fully processed a level, increment our state
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (!remaining.isEmpty) {</span>
<span class="nc" id="L210">          level = (level + 1).toShort</span>
<span class="nc" id="L211">          remaining.add(LevelTerminator)</span>
        }
      } else {
<span class="nc" id="L214">        checkValue(next, level)</span>
      }
    }

    // bottom out and get all the ranges that partially overlapped but we didn't fully process
<span class="nc bnc" id="L219" title="All 2 branches missed.">    while (!remaining.isEmpty) {</span>
<span class="nc" id="L220">      val quad = remaining.poll</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">      if (quad.eq(LevelTerminator)) {</span>
<span class="nc" id="L222">        level = (level + 1).toShort</span>
      } else {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        val (min, max) = sequenceInterval(quad.xmin, quad.ymin, level, partial = false)</span>
<span class="nc" id="L225">        ranges.add(IndexRange(min, max, contained = false))</span>
      }
    }

    // we've got all our ranges - now reduce them down by merging overlapping values
    // note: we don't bother reducing the ranges as in the XZ paper, as accumulo handles lots of ranges fairly well
<span class="nc" id="L231">    ranges.sort(IndexRange.IndexRangeIsOrdered)</span>

<span class="nc" id="L233">    var current = ranges.get(0) // note: should always be at least one range</span>
<span class="nc" id="L234">    val result = ArrayBuffer.empty[IndexRange]</span>
<span class="nc" id="L235">    var i = 1</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">    while (i &lt; ranges.size()) {</span>
<span class="nc" id="L237">      val range = ranges.get(i)</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">      if (range.lower &lt;= current.upper + 1) {</span>
        // merge the two ranges
<span class="nc bnc" id="L240" title="All 4 branches missed.">        current = IndexRange(current.lower, math.max(current.upper, range.upper), current.contained &amp;&amp; range.contained)</span>
      } else {
        // append the last range and set the current range for future merging
<span class="nc" id="L243">        result.append(current)</span>
<span class="nc" id="L244">        current = range</span>
      }
<span class="nc" id="L246">      i += 1</span>
    }
    // append the last range - there will always be one left that wasn't added
<span class="nc" id="L249">    result.append(current)</span>

<span class="nc" id="L251">    result.toSeq</span>
  }

  /**
    * Computes the sequence code for a given point - for polygons this is the lower-left corner.
    *
    * Based on Definition 2 from the XZ-Ordering paper
    *
    * @param x normalized x value [0,1]
    * @param y normalized y value [0,1]
    * @param length length of the sequence code that will be generated
    * @return
    */
  private def sequenceCode(x: Double, y: Double, length: Int): Long = {
<span class="nc" id="L265">    var xmin = 0.0</span>
<span class="nc" id="L266">    var ymin = 0.0</span>
<span class="nc" id="L267">    var xmax = 1.0</span>
<span class="nc" id="L268">    var ymax = 1.0</span>

<span class="nc" id="L270">    var cs = 0L</span>

<span class="nc" id="L272">    var i = 0</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L274">      val xCenter = (xmin + xmax) / 2.0</span>
<span class="nc" id="L275">      val yCenter = (ymin + ymax) / 2.0</span>
<span class="nc bnc" id="L276" title="All 12 branches missed.">      (x &lt; xCenter, y &lt; yCenter) match {</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">        case (true,  true)  =&gt; cs += 1L                                             ; xmax = xCenter; ymax = yCenter</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">        case (false, true)  =&gt; cs += 1L + 1L * (math.pow(4, g - i).toLong - 1L) / 3L; xmin = xCenter; ymax = yCenter</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">        case (true,  false) =&gt; cs += 1L + 2L * (math.pow(4, g - i).toLong - 1L) / 3L; xmax = xCenter; ymin = yCenter</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">        case (false, false) =&gt; cs += 1L + 3L * (math.pow(4, g - i).toLong - 1L) / 3L; xmin = xCenter; ymin = yCenter</span>
      }
<span class="nc" id="L282">      i += 1</span>
    }

<span class="nc" id="L285">    cs</span>
  }

  /**
    * Computes an interval of sequence codes for a given point - for polygons this is the lower-left corner.
    *
    * @param x normalized x value [0,1]
    * @param y normalized y value [0,1]
    * @param length length of the sequence code that will used as the basis for this interval
    * @param partial true if the element partially intersects the query window, false if it is fully contained
    * @return
    */
  private def sequenceInterval(x: Double, y: Double, length: Short, partial: Boolean): (Long, Long) = {
<span class="nc" id="L298">    val min = sequenceCode(x, y, length)</span>
    // if a partial match, we just use the single sequence code as an interval
    // if a full match, we have to match all sequence codes starting with the single sequence code
<span class="nc bnc" id="L301" title="All 2 branches missed.">    val max = if (partial) { min } else {</span>
      // from lemma 3 in the XZ-Ordering paper
<span class="nc" id="L303">      min + (math.pow(4, g - length + 1).toLong - 1L) / 3L</span>
    }
<span class="nc" id="L305">    (min, max)</span>
  }

  /**
    * Normalize user space values to [0,1]
    *
    * @param xmin min x value in user space
    * @param ymin min y value in user space
    * @param xmax max x value in user space, must be &gt;= xmin
    * @param ymax max y value in user space, must be &gt;= ymin
    * @param lenient standardize boundaries to valid values, or raise an exception
    * @return
    */
  private def normalize(xmin: Double,
                        ymin: Double,
                        xmax: Double,
                        ymax: Double,
                        lenient: Boolean): (Double, Double, Double, Double) = {
<span class="nc bnc" id="L323" title="All 4 branches missed.">    require(xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax, s&quot;Bounds must be ordered: [$xmin $xmax] [$ymin $ymax]&quot;)</span>

<span class="nc" id="L325">    try {</span>
<span class="nc bnc" id="L326" title="All 8 branches missed.">      require(xmin &gt;= xLo &amp;&amp; xmax &lt;= xHi &amp;&amp; ymin &gt;= yLo &amp;&amp; ymax &lt;= yHi,</span>
<span class="nc" id="L327">        s&quot;Values out of bounds ([$xLo $xHi] [$yLo $yHi]): [$xmin $xmax] [$ymin $ymax]&quot;)</span>

<span class="nc" id="L329">      val nxmin = (xmin - xLo) / xSize</span>
<span class="nc" id="L330">      val nymin = (ymin - yLo) / ySize</span>
<span class="nc" id="L331">      val nxmax = (xmax - xLo) / xSize</span>
<span class="nc" id="L332">      val nymax = (ymax - yLo) / ySize</span>

<span class="nc" id="L334">      (nxmin, nymin, nxmax, nymax)</span>
    } catch {
<span class="nc bnc" id="L336" title="All 4 branches missed.">      case _: IllegalArgumentException if lenient =&gt;</span>

<span class="nc bnc" id="L338" title="All 4 branches missed.">        val bxmin = if (xmin &lt; xLo) { xLo } else if (xmin &gt; xHi) { xHi } else { xmin }</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">        val bymin = if (ymin &lt; yLo) { yLo } else if (ymin &gt; yHi) { yHi } else { ymin }</span>
<span class="nc bnc" id="L340" title="All 4 branches missed.">        val bxmax = if (xmax &lt; xLo) { xLo } else if (xmax &gt; xHi) { xHi } else { xmax }</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">        val bymax = if (ymax &lt; yLo) { yLo } else if (ymax &gt; yHi) { yHi } else { ymax }</span>

<span class="nc" id="L343">        val nxmin = (bxmin - xLo) / xSize</span>
<span class="nc" id="L344">        val nymin = (bymin - yLo) / ySize</span>
<span class="nc" id="L345">        val nxmax = (bxmax - xLo) / xSize</span>
<span class="nc" id="L346">        val nymax = (bymax - yLo) / ySize</span>

<span class="nc" id="L348">        (nxmin, nymin, nxmax, nymax)</span>
    }
  }
}

<span class="nc" id="L353">object XZ2SFC {</span>

  // the initial level of quads
<span class="nc" id="L356">  private val LevelOneElements = XElement(0.0, 0.0, 1.0, 1.0, 1.0).children</span>

  // indicator that we have searched a full level of the quad/oct tree
<span class="nc" id="L359">  private val LevelTerminator = XElement(-1.0, -1.0, -1.0, -1.0, 0)</span>

<span class="nc" id="L361">  private val cache = new java.util.concurrent.ConcurrentHashMap[Short, XZ2SFC]()</span>

  def apply(g: Short): XZ2SFC = {
<span class="nc" id="L364">    var sfc = cache.get(g)</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">    if (sfc == null) {</span>
<span class="nc" id="L366">      sfc = new XZ2SFC(g, (-180.0, 180.0), (-90.0, 90.0))</span>
<span class="nc" id="L367">      cache.put(g, sfc)</span>
    }
<span class="nc" id="L369">    sfc</span>
  }

  /**
    * Region being queried. Bounds are normalized to [0-1].
    *
    * @param xmin x lower bound in [0-1]
    * @param ymin y lower bound in [0-1]
    * @param xmax x upper bound in [0-1], must be &gt;= xmin
    * @param ymax y upper bound in [0-1], must be &gt;= ymin
    */
<span class="nc bnc" id="L380" title="All 23 branches missed.">  private case class QueryWindow(xmin: Double, ymin: Double, xmax: Double, ymax: Double)</span>

  /**
    * An extended Z curve element. Bounds refer to the non-extended z element for simplicity of calculation.
    *
    * An extended Z element refers to a normal Z curve element that has it's upper bounds expanded by double it's
    * width/height. By convention, an element is always square.
    *
    * @param xmin x lower bound in [0-1]
    * @param ymin y lower bound in [0-1]
    * @param xmax x upper bound in [0-1], must be &gt;= xmin
    * @param ymax y upper bound in [0-1], must be &gt;= ymin
    * @param length length of the non-extended side (note: by convention width should be equal to height)
    */
<span class="nc bnc" id="L394" title="All 26 branches missed.">  private case class XElement(xmin: Double, ymin: Double, xmax: Double, ymax: Double, length: Double) {</span>

    // extended x and y bounds
<span class="nc bnc" id="L397" title="All 4 branches missed.">    lazy val xext = xmax + length</span>
<span class="nc bnc" id="L398" title="All 4 branches missed.">    lazy val yext = ymax + length</span>

    def isContained(window: QueryWindow): Boolean =
<span class="nc bnc" id="L401" title="All 8 branches missed.">      window.xmin &lt;= xmin &amp;&amp; window.ymin &lt;= ymin &amp;&amp; window.xmax &gt;= xext &amp;&amp; window.ymax &gt;= yext</span>

    def overlaps(window: QueryWindow): Boolean =
<span class="nc bnc" id="L404" title="All 8 branches missed.">      window.xmax &gt;= xmin &amp;&amp; window.ymax &gt;= ymin &amp;&amp; window.xmin &lt;= xext &amp;&amp; window.ymin &lt;= yext</span>

    def children: Seq[XElement] = {
<span class="nc" id="L407">      val xCenter = (xmin + xmax) / 2.0</span>
<span class="nc" id="L408">      val yCenter = (ymin + ymax) / 2.0</span>
<span class="nc" id="L409">      val len = length / 2.0</span>
<span class="nc" id="L410">      val c0 = copy(xmax = xCenter, ymax = yCenter, length = len)</span>
<span class="nc" id="L411">      val c1 = copy(xmin = xCenter, ymax = yCenter, length = len)</span>
<span class="nc" id="L412">      val c2 = copy(xmax = xCenter, ymin = yCenter, length = len)</span>
<span class="nc" id="L413">      val c3 = copy(xmin = xCenter, ymin = yCenter, length = len)</span>
<span class="nc" id="L414">      Seq(c0, c1, c2, c3)</span>
    }
  }
<span class="nc" id="L417">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>