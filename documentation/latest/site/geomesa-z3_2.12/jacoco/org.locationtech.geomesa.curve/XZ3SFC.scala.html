<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XZ3SFC.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index Z3</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.curve</a> &gt; <span class="el_source">XZ3SFC.scala</span></div><h1>XZ3SFC.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.curve

import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.curve.XZ3SFC.{QueryWindow, XElement}
import org.locationtech.geomesa.zorder.sfcurve.IndexRange

import scala.collection.mutable.ArrayBuffer

/**
  * Extended Z-order curve implementation used for efficiently storing polygons.
  *
  * Based on 'XZ-Ordering: A Space-Filling Curve for Objects with Spatial Extension'
  * by Christian BÃ¶hm, Gerald Klump  and Hans-Peter Kriegel, expanded to 3 dimensions
  *
  * @param g resolution level of the curve - i.e. how many times the space will be recursively split into eighths

  */
<span class="nc" id="L26">class XZ3SFC(val g: Short, val xBounds: (Double, Double), val yBounds: (Double, Double), val zBounds: (Double, Double)) {</span>

  // TODO see what the max value of g can be where we can use Ints instead of Longs and possibly refactor to use Ints

<span class="nc" id="L30">  private val xLo = xBounds._1</span>
<span class="nc" id="L31">  private val xHi = xBounds._2</span>
<span class="nc" id="L32">  private val yLo = yBounds._1</span>
<span class="nc" id="L33">  private val yHi = yBounds._2</span>
<span class="nc" id="L34">  private val zLo = zBounds._1</span>
<span class="nc" id="L35">  private val zHi = zBounds._2</span>

<span class="nc" id="L37">  private val xSize = xHi - xLo</span>
<span class="nc" id="L38">  private val ySize = yHi - yLo</span>
<span class="nc" id="L39">  private val zSize = zHi - zLo</span>

  /**
    * Index a polygon by it's bounding box
    *
    * @param xmin min x value in xBounds
    * @param ymin min y value in yBounds
    * @param zmin min z value in zBounds
    * @param xmax max x value in xBounds, must be &gt;= xmin
    * @param ymax max y value in yBounds, must be &gt;= ymin
    * @param zmax max z value in zBounds, must be &gt;= tmin
    * @param lenient standardize boundaries to valid values, or raise an exception
    * @return z value for the bounding box
    */
<span class="nc" id="L53">  def index(xmin: Double, ymin: Double, zmin: Double, xmax: Double, ymax: Double, zmax: Double, lenient: Boolean = false): Long = {</span>
    // normalize inputs to [0,1]
<span class="nc bnc" id="L55" title="All 2 branches missed.">    val (nxmin, nymin, nzmin, nxmax, nymax, nzmax) = normalize(xmin, ymin, zmin, xmax, ymax, zmax, lenient)</span>

    // calculate the length of the sequence code (section 4.1 of XZ-Ordering paper)

<span class="nc" id="L59">    val maxDim = math.max(math.max(nxmax - nxmin, nymax - nymin), nzmax - nzmin)</span>

    // l1 (el-one) is a bit confusing to read, but corresponds with the paper's definitions
<span class="nc" id="L62">    val l1 = math.floor(math.log(maxDim) / XZSFC.LogPointFive).toInt</span>

    // the length will either be (l1) or (l1 + 1)
<span class="nc bnc" id="L65" title="All 2 branches missed.">    val length = if (l1 &gt;= g) { g } else {</span>
<span class="nc" id="L66">      val w2 = math.pow(0.5, l1 + 1) // width of an element at resolution l2 (l1 + 1)</span>

      // predicate for checking how many axis the polygon intersects
      // math.floor(min / w2) * w2 == start of cell containing min
<span class="nc bnc" id="L70" title="All 2 branches missed.">      def predicate(min: Double, max: Double): Boolean = max &lt;= (math.floor(min / w2) * w2) + (2 * w2)</span>

<span class="nc bnc" id="L72" title="All 6 branches missed.">      if (predicate(nxmin, nxmax) &amp;&amp; predicate(nymin, nymax) &amp;&amp; predicate(nzmin, nzmax)) l1 + 1 else l1</span>
    }

<span class="nc" id="L75">    sequenceCode(nxmin, nymin, nzmin, length)</span>
  }

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param query a window to cover in the form (xmin, ymin, zmin, xmax, ymax, zmax) where all values are in user space
    * @return
    */
<span class="nc" id="L84">  def ranges(query: (Double, Double, Double, Double, Double, Double)): Seq[IndexRange] = ranges(Seq(query))</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param query a window to cover in the form (xmin, ymin, zmin, xmax, ymax, zmax) where all values are in user space
    * @param maxRanges a rough upper limit on the number of ranges to generate
    * @return
    */
  def ranges(query: (Double, Double, Double, Double, Double, Double), maxRanges: Option[Int]): Seq[IndexRange] =
<span class="nc" id="L94">    ranges(Seq(query), maxRanges)</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param xmin min x value in user space
    * @param ymin min y value in user space
    * @param zmin min z value in user space
    * @param xmax max x value in user space, must be &gt;= xmin
    * @param ymax max y value in user space, must be &gt;= ymin
    * @param zmax max z value in user space, must be &gt;= zmin
    * @return
    */
  def ranges(xmin: Double, ymin: Double, zmin: Double, xmax: Double, ymax: Double, zmax: Double): Seq[IndexRange] =
<span class="nc" id="L108">    ranges(Seq((xmin, ymin, zmin, xmax, ymax, zmax)))</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param xmin min x value in user space
    * @param ymin min y value in user space
    * @param zmin min z value in user space
    * @param xmax max x value in user space, must be &gt;= xmin
    * @param ymax max y value in user space, must be &gt;= ymin
    * @param zmax max z value in user space, must be &gt;= zmin
    * @param maxRanges a rough upper limit on the number of ranges to generate
    * @return
    */
  def ranges(xmin: Double,
             ymin: Double,
             zmin: Double,
             xmax: Double,
             ymax: Double,
             zmax: Double,
             maxRanges: Option[Int]): Seq[IndexRange] =
<span class="nc" id="L129">    ranges(Seq((xmin, ymin, zmin, xmax, ymax, zmax)), maxRanges)</span>

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param queries a sequence of OR'd windows to cover. Each window is in the form
    *                (xmin, ymin, zmin, xmax, ymax, zmax) where all values are in user space
    * @param maxRanges a rough upper limit on the number of ranges to generate
    * @return
    */
  def ranges(queries: Seq[(Double, Double, Double, Double, Double, Double)],
<span class="nc" id="L140">             maxRanges: Option[Int] = None): Seq[IndexRange] = {</span>
    // normalize inputs to [0,1]
<span class="nc bnc" id="L142" title="All 2 branches missed.">    val windows = queries.map { case (xmin, ymin, zmin, xmax, ymax, zmax) =&gt;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      val (nxmin, nymin, nzmin, nxmax, nymax, nzmax) = normalize(xmin, ymin, zmin, xmax, ymax, zmax, lenient = false)</span>
<span class="nc" id="L144">      QueryWindow(nxmin, nymin, nzmin, nxmax, nymax, nzmax)</span>
    }
<span class="nc" id="L146">    ranges(windows.toArray, maxRanges.getOrElse(Int.MaxValue))</span>
  }

  /**
    * Determine XZ-curve ranges that will cover a given query window
    *
    * @param query a sequence of OR'd windows to cover, normalized to [0,1]
    * @param rangeStop a rough max value for the number of ranges to return
    * @return
    */
  private def ranges(query: Array[QueryWindow], rangeStop: Int): Seq[IndexRange] = {

    import XZ3SFC.{LevelOneElements, LevelTerminator}

    // stores our results - initial size of 100 in general saves us some re-allocation
<span class="nc" id="L161">    val ranges = new java.util.ArrayList[IndexRange](100)</span>

    // values remaining to process - initial size of 100 in general saves us some re-allocation
<span class="nc" id="L164">    val remaining = new java.util.ArrayDeque[XElement](100)</span>

    // checks if a quad is contained in the search space
    def isContained(oct: XElement): Boolean = {
<span class="nc" id="L168">      var i = 0</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">      while (i &lt; query.length) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (oct.isContained(query(i))) {</span>
<span class="nc" id="L171">          return true</span>
        }
<span class="nc" id="L173">        i += 1</span>
      }
<span class="nc" id="L175">      false</span>
    }

    // checks if a quad overlaps the search space
    def isOverlapped(oct: XElement): Boolean = {
<span class="nc" id="L180">      var i = 0</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">      while (i &lt; query.length) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (oct.overlaps(query(i))) {</span>
<span class="nc" id="L183">          return true</span>
        }
<span class="nc" id="L185">        i += 1</span>
      }
<span class="nc" id="L187">      false</span>
    }

    // checks a single value and either:
    //   eliminates it as out of bounds
    //   adds it to our results as fully matching, or
    //   adds it to our results as partial matching and queues up it's children for further processing
    def checkValue(oct: XElement, level: Short): Unit = {
<span class="nc bnc" id="L195" title="All 2 branches missed.">      if (isContained(oct)) {</span>
        // whole range matches, happy day
<span class="nc bnc" id="L197" title="All 2 branches missed.">        val (min, max) = sequenceInterval(oct.xmin, oct.ymin, oct.zmin, level, partial = false)</span>
<span class="nc" id="L198">        ranges.add(IndexRange(min, max, contained = true))</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      } else if (isOverlapped(oct)) {</span>
        // some portion of this range is excluded
        // add the partial match and queue up each sub-range for processing
<span class="nc bnc" id="L202" title="All 2 branches missed.">        val (min, max) = sequenceInterval(oct.xmin, oct.ymin, oct.zmin, level, partial = true)</span>
<span class="nc" id="L203">        ranges.add(IndexRange(min, max, contained = false))</span>
<span class="nc" id="L204">        oct.children.foreach(remaining.add)</span>
      }
    }

    // initial level
<span class="nc" id="L209">    LevelOneElements.foreach(remaining.add)</span>
<span class="nc" id="L210">    remaining.add(LevelTerminator)</span>

    // level of recursion
<span class="nc" id="L213">    var level: Short = 1</span>

<span class="nc bnc" id="L215" title="All 6 branches missed.">    while (level &lt; g &amp;&amp; !remaining.isEmpty &amp;&amp; ranges.size &lt; rangeStop) {</span>
<span class="nc" id="L216">      val next = remaining.poll</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">      if (next.eq(LevelTerminator)) {</span>
        // we've fully processed a level, increment our state
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (!remaining.isEmpty) {</span>
<span class="nc" id="L220">          level = (level + 1).toShort</span>
<span class="nc" id="L221">          remaining.add(LevelTerminator)</span>
        }
      } else {
<span class="nc" id="L224">        checkValue(next, level)</span>
      }
    }

    // bottom out and get all the ranges that partially overlapped but we didn't fully process
<span class="nc bnc" id="L229" title="All 2 branches missed.">    while (!remaining.isEmpty) {</span>
<span class="nc" id="L230">      val oct = remaining.poll</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (oct.eq(LevelTerminator)) {</span>
<span class="nc" id="L232">        level = (level + 1).toShort</span>
      } else {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        val (min, max) = sequenceInterval(oct.xmin, oct.ymin, oct.zmin, level, partial = false)</span>
<span class="nc" id="L235">        ranges.add(IndexRange(min, max, contained = false))</span>
      }
    }

    // we've got all our ranges - now reduce them down by merging overlapping values
    // note: we don't bother reducing the ranges as in the XZ paper, as accumulo handles lots of ranges fairly well
<span class="nc" id="L241">    ranges.sort(IndexRange.IndexRangeIsOrdered)</span>

<span class="nc" id="L243">    var current = ranges.get(0) // note: should always be at least one range</span>
<span class="nc" id="L244">    val result = ArrayBuffer.empty[IndexRange]</span>
<span class="nc" id="L245">    var i = 1</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">    while (i &lt; ranges.size()) {</span>
<span class="nc" id="L247">      val range = ranges.get(i)</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if (range.lower &lt;= current.upper + 1) {</span>
        // merge the two ranges
<span class="nc bnc" id="L250" title="All 4 branches missed.">        current = IndexRange(current.lower, math.max(current.upper, range.upper), current.contained &amp;&amp; range.contained)</span>
      } else {
        // append the last range and set the current range for future merging
<span class="nc" id="L253">        result.append(current)</span>
<span class="nc" id="L254">        current = range</span>
      }
<span class="nc" id="L256">      i += 1</span>
    }
    // append the last range - there will always be one left that wasn't added
<span class="nc" id="L259">    result.append(current)</span>

<span class="nc" id="L261">    result.toSeq</span>
  }

  /**
    * Computes the sequence code for a given point - for polygons this is the lower-left corner.
    *
    * Based on Definition 2 from the XZ-Ordering paper
    *
    * @param x normalized x value [0,1]
    * @param y normalized y value [0,1]
    * @param z normalized z value [0,1]
    * @param length length of the sequence code that will be generated
    * @return
    */
  private def sequenceCode(x: Double, y: Double, z: Double, length: Int): Long = {
<span class="nc" id="L276">    var xmin = 0.0</span>
<span class="nc" id="L277">    var ymin = 0.0</span>
<span class="nc" id="L278">    var zmin = 0.0</span>
<span class="nc" id="L279">    var xmax = 1.0</span>
<span class="nc" id="L280">    var ymax = 1.0</span>
<span class="nc" id="L281">    var zmax = 1.0</span>

<span class="nc" id="L283">    var cs = 0L</span>

<span class="nc" id="L285">    var i = 0</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L287">      val xCenter = (xmin + xmax) / 2.0</span>
<span class="nc" id="L288">      val yCenter = (ymin + ymax) / 2.0</span>
<span class="nc" id="L289">      val zCenter = (zmin + zmax) / 2.0</span>
<span class="nc bnc" id="L290" title="All 22 branches missed.">      (x &lt; xCenter, y &lt; yCenter, z &lt; zCenter) match {</span>
<span class="nc bnc" id="L291" title="All 6 branches missed.">        case (true,  true, true)   =&gt; cs += 1L                                             ; xmax = xCenter; ymax = yCenter; zmax = zCenter</span>
<span class="nc bnc" id="L292" title="All 6 branches missed.">        case (false, true, true)   =&gt; cs += 1L + 1L * (math.pow(8, g - i).toLong - 1L) / 7L; xmin = xCenter; ymax = yCenter; zmax = zCenter</span>
<span class="nc bnc" id="L293" title="All 6 branches missed.">        case (true,  false, true)  =&gt; cs += 1L + 2L * (math.pow(8, g - i).toLong - 1L) / 7L; xmax = xCenter; ymin = yCenter; zmax = zCenter</span>
<span class="nc bnc" id="L294" title="All 6 branches missed.">        case (false, false, true)  =&gt; cs += 1L + 3L * (math.pow(8, g - i).toLong - 1L) / 7L; xmin = xCenter; ymin = yCenter; zmax = zCenter</span>
<span class="nc bnc" id="L295" title="All 6 branches missed.">        case (true,  true, false)  =&gt; cs += 1L + 4L * (math.pow(8, g - i).toLong - 1L) / 7L; xmax = xCenter; ymax = yCenter; zmin = zCenter</span>
<span class="nc bnc" id="L296" title="All 6 branches missed.">        case (false, true, false)  =&gt; cs += 1L + 5L * (math.pow(8, g - i).toLong - 1L) / 7L; xmin = xCenter; ymax = yCenter; zmin = zCenter</span>
<span class="nc bnc" id="L297" title="All 6 branches missed.">        case (true,  false, false) =&gt; cs += 1L + 6L * (math.pow(8, g - i).toLong - 1L) / 7L; xmax = xCenter; ymin = yCenter; zmin = zCenter</span>
<span class="nc bnc" id="L298" title="All 6 branches missed.">        case (false, false, false) =&gt; cs += 1L + 7L * (math.pow(8, g - i).toLong - 1L) / 7L; xmin = xCenter; ymin = yCenter; zmin = zCenter</span>
      }
<span class="nc" id="L300">      i += 1</span>
    }

<span class="nc" id="L303">    cs</span>
  }

  /**
    * Computes an interval of sequence codes for a given point - for polygons this is the lower-left corner.
    *
    * @param x normalized x value [0,1]
    * @param y normalized y value [0,1]
    * @param length length of the sequence code that will used as the basis for this interval
    * @param partial true if the element partially intersects the query window, false if it is fully contained
    * @return
    */
  private def sequenceInterval(x: Double, y: Double, z: Double, length: Short, partial: Boolean): (Long, Long) = {
<span class="nc" id="L316">    val min = sequenceCode(x, y, z, length)</span>
    // if a partial match, we just use the single sequence code as an interval
    // if a full match, we have to match all sequence codes starting with the single sequence code
<span class="nc bnc" id="L319" title="All 2 branches missed.">    val max = if (partial) { min } else {</span>
      // from lemma 3 in the XZ-Ordering paper
<span class="nc" id="L321">      min + (math.pow(8, g - length + 1).toLong - 1L) / 7L</span>
    }
<span class="nc" id="L323">    (min, max)</span>
  }

  /**
    * Normalize user space values to [0,1]
    *
    * @param xmin min x value in user space
    * @param ymin min y value in user space
    * @param zmin min z value in user space
    * @param xmax max x value in user space, must be &gt;= xmin
    * @param ymax max y value in user space, must be &gt;= ymin
    * @param zmax max z value in user space, must be &gt;= zmin
    * @param lenient standardize boundaries to valid values, or raise an exception
    * @return
    */
  protected def normalize(
      xmin: Double,
      ymin: Double,
      zmin: Double,
      xmax: Double,
      ymax: Double,
      zmax: Double,
      lenient: Boolean): (Double, Double, Double, Double, Double, Double) = {
<span class="nc bnc" id="L346" title="All 6 branches missed.">    require(xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax &amp;&amp; zmin &lt;= zmax,</span>
<span class="nc" id="L347">      s&quot;Bounds must be ordered: [$xmin $xmax] [$ymin $ymax] [$zmin $zmax]&quot;)</span>

<span class="nc" id="L349">    try {</span>
<span class="nc bnc" id="L350" title="All 12 branches missed.">      require(xmin &gt;= xLo &amp;&amp; xmax &lt;= xHi &amp;&amp; ymin &gt;= yLo &amp;&amp; ymax &lt;= yHi &amp;&amp; zmin &gt;= zLo &amp;&amp; zmax &lt;= zHi,</span>
<span class="nc" id="L351">        s&quot;Values out of bounds ([$xLo $xHi] [$yLo $yHi] [$zLo $zHi]): [$xmin $xmax] [$ymin $ymax] [$zmin $zmax]&quot;)</span>

<span class="nc" id="L353">      val nxmin = (xmin - xLo) / xSize</span>
<span class="nc" id="L354">      val nymin = (ymin - yLo) / ySize</span>
<span class="nc" id="L355">      val nzmin = (zmin - zLo) / zSize</span>
<span class="nc" id="L356">      val nxmax = (xmax - xLo) / xSize</span>
<span class="nc" id="L357">      val nymax = (ymax - yLo) / ySize</span>
<span class="nc" id="L358">      val nzmax = (zmax - zLo) / zSize</span>

<span class="nc" id="L360">      (nxmin, nymin, nzmin, nxmax, nymax, nzmax)</span>
    } catch {
<span class="nc bnc" id="L362" title="All 4 branches missed.">      case _: IllegalArgumentException if lenient =&gt;</span>

<span class="nc bnc" id="L364" title="All 4 branches missed.">        val bxmin = if (xmin &lt; xLo) { xLo } else if (xmin &gt; xHi) { xHi } else { xmin }</span>
<span class="nc bnc" id="L365" title="All 4 branches missed.">        val bymin = if (ymin &lt; yLo) { yLo } else if (ymin &gt; yHi) { yHi } else { ymin }</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">        val bzmin = if (zmin &lt; zLo) { zLo } else if (zmin &gt; zHi) { zHi } else { zmin }</span>
<span class="nc bnc" id="L367" title="All 4 branches missed.">        val bxmax = if (xmax &lt; xLo) { xLo } else if (xmax &gt; xHi) { xHi } else { xmax }</span>
<span class="nc bnc" id="L368" title="All 4 branches missed.">        val bymax = if (ymax &lt; yLo) { yLo } else if (ymax &gt; yHi) { yHi } else { ymax }</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">        val bzmax = if (zmax &lt; zLo) { zLo } else if (zmax &gt; zHi) { zHi } else { zmax }</span>

<span class="nc" id="L371">        val nxmin = (bxmin - xLo) / xSize</span>
<span class="nc" id="L372">        val nymin = (bymin - yLo) / ySize</span>
<span class="nc" id="L373">        val nzmin = (bzmin - zLo) / zSize</span>
<span class="nc" id="L374">        val nxmax = (bxmax - xLo) / xSize</span>
<span class="nc" id="L375">        val nymax = (bymax - yLo) / ySize</span>
<span class="nc" id="L376">        val nzmax = (bzmax - zLo) / zSize</span>

<span class="nc" id="L378">        (nxmin, nymin, nzmin, nxmax, nymax, nzmax)</span>
    }
  }
}

<span class="nc" id="L383">object XZ3SFC {</span>

  // the initial level of octs
<span class="nc" id="L386">  private val LevelOneElements = XElement(0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0).children</span>

  // indicator that we have searched a full level of the oct tree
<span class="nc" id="L389">  private val LevelTerminator = XElement(-1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 0.0)</span>

<span class="nc" id="L391">  private val cache = new java.util.concurrent.ConcurrentHashMap[(Short, TimePeriod), XZ3SFC]()</span>

  def apply(g: Short, period: TimePeriod): XZ3SFC = {
<span class="nc" id="L394">    var sfc = cache.get((g, period))</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">    if (sfc == null) {</span>
<span class="nc" id="L396">      sfc = new XZ3SFC(g, (-180.0, 180.0), (-90.0, 90.0), (0.0, BinnedTime.maxOffset(period).toDouble))</span>
<span class="nc" id="L397">      cache.put((g, period), sfc)</span>
    }
<span class="nc" id="L399">    sfc</span>
  }

  /**
    * Region being queried. Bounds are normalized to [0-1].
    *
    * @param xmin x lower bound in [0-1]
    * @param ymin y lower bound in [0-1]
    * @param zmin z lower bound in [0-1]
    * @param xmax x upper bound in [0-1], must be &gt;= xmin
    * @param ymax y upper bound in [0-1], must be &gt;= ymin
    * @param zmax z upper bound in [0-1], must be &gt;= zmin
    */
<span class="nc bnc" id="L412" title="All 29 branches missed.">  private case class QueryWindow(xmin: Double, ymin: Double, zmin: Double, xmax: Double, ymax: Double, zmax: Double)</span>

  /**
    * An extended Z curve element. Bounds refer to the non-extended z element for simplicity of calculation.
    *
    * An extended Z element refers to a normal Z curve element that has it's upper bounds expanded by double it's
    * width/length/height. By convention, an element is always a cube.
    *
    * @param xmin x lower bound in [0-1]
    * @param ymin y lower bound in [0-1]
    * @param zmin z lower bound in [0-1]
    * @param xmax x upper bound in [0-1], must be &gt;= xmin
    * @param ymax y upper bound in [0-1], must be &gt;= ymin
    * @param zmax z upper bound in [0-1], must be &gt;= zmin
    * @param length length of the non-extended side (note: by convention width should be equal to height and depth)
    */
<span class="nc bnc" id="L428" title="All 32 branches missed.">  private case class XElement(xmin: Double,</span>
<span class="nc" id="L429">                              ymin: Double,</span>
<span class="nc" id="L430">                              zmin: Double,</span>
<span class="nc" id="L431">                              xmax: Double,</span>
<span class="nc" id="L432">                              ymax: Double,</span>
<span class="nc" id="L433">                              zmax: Double,</span>
<span class="nc" id="L434">                              length: Double) {</span>

    // extended x and y bounds
<span class="nc bnc" id="L437" title="All 4 branches missed.">    lazy val xext = xmax + length</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">    lazy val yext = ymax + length</span>
<span class="nc bnc" id="L439" title="All 4 branches missed.">    lazy val zext = zmax + length</span>

    def isContained(window: QueryWindow): Boolean =
<span class="nc bnc" id="L442" title="All 6 branches missed.">      window.xmin &lt;= xmin &amp;&amp; window.ymin &lt;= ymin &amp;&amp; window.zmin &lt;= zmin &amp;&amp;</span>
<span class="nc bnc" id="L443" title="All 6 branches missed.">          window.xmax &gt;= xext &amp;&amp; window.ymax &gt;= yext &amp;&amp; window.zmax &gt;= zext</span>

    def overlaps(window: QueryWindow): Boolean =
<span class="nc bnc" id="L446" title="All 6 branches missed.">      window.xmax &gt;= xmin &amp;&amp; window.ymax &gt;= ymin &amp;&amp; window.zmax &gt;= zmin &amp;&amp;</span>
<span class="nc bnc" id="L447" title="All 6 branches missed.">          window.xmin &lt;= xext &amp;&amp; window.ymin &lt;= yext &amp;&amp; window.zmin &lt;= zext</span>

    def children: Seq[XElement] = {
<span class="nc" id="L450">      val xCenter = (xmin + xmax) / 2.0</span>
<span class="nc" id="L451">      val yCenter = (ymin + ymax) / 2.0</span>
<span class="nc" id="L452">      val zCenter = (zmin + zmax) / 2.0</span>
<span class="nc" id="L453">      val len = length / 2.0</span>
<span class="nc" id="L454">      val c0 = copy(xmax = xCenter, ymax = yCenter, zmax = zCenter, length = len)</span>
<span class="nc" id="L455">      val c1 = copy(xmin = xCenter, ymax = yCenter, zmax = zCenter, length = len)</span>
<span class="nc" id="L456">      val c2 = copy(xmax = xCenter, ymin = yCenter, zmax = zCenter, length = len)</span>
<span class="nc" id="L457">      val c3 = copy(xmin = xCenter, ymin = yCenter, zmax = zCenter, length = len)</span>
<span class="nc" id="L458">      val c4 = copy(xmax = xCenter, ymax = yCenter, zmin = zCenter, length = len)</span>
<span class="nc" id="L459">      val c5 = copy(xmin = xCenter, ymax = yCenter, zmin = zCenter, length = len)</span>
<span class="nc" id="L460">      val c6 = copy(xmax = xCenter, ymin = yCenter, zmin = zCenter, length = len)</span>
<span class="nc" id="L461">      val c7 = copy(xmin = xCenter, ymin = yCenter, zmin = zCenter, length = len)</span>
<span class="nc" id="L462">      Seq(c0, c1, c2, c3, c4, c5, c6, c7)</span>
    }
  }
<span class="nc" id="L465">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>