<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BinnedTime.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Index Z3</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.curve</a> &gt; <span class="el_source">BinnedTime.scala</span></div><h1>BinnedTime.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.curve

import org.locationtech.geomesa.curve.TimePeriod.TimePeriod

import java.time._
import java.time.temporal.ChronoUnit

/**
  * Represents a time by an offset into a binned bucket. The bin represents days, weeks,
  * months or years since the java epoch. The offset represents milliseconds, seconds, or
  * hours into that bin.
  *
  * Times can be partitioned based on four periods:
  *
  *   TimePeriod.Day
  *     bin      =&gt; day
  *     offset   =&gt; milliseconds
  *     max date =&gt; 2059/09/18
  *
  *   TimePeriod.Week
  *     bin      =&gt; week
  *     offset   =&gt; seconds
  *     max date =&gt; 2598/01/04
  *
  *   TimePeriod.Month
  *     bin      =&gt; month
  *     offset   =&gt; seconds
  *     max date =&gt; 4700/08/31
  *
  *   TimePeriod.Year
  *     bin      =&gt; year
  *     offset   =&gt; minutes
  *     max date =&gt; 34737/12/31
  *
  * @param bin number of time periods from the java epoch
  * @param offset precise offset into the specific time period
  */
<span class="nc bnc" id="L46" title="All 17 branches missed.">case class BinnedTime(bin: Short, offset: Long)</span>

<span class="nc" id="L48">object BinnedTime {</span>

  type BinnedTimeToDate = BinnedTime =&gt; ZonedDateTime
  type TimeToBinnedTime = Long =&gt; BinnedTime
  type DateToBinnedTime = ZonedDateTime =&gt; BinnedTime
  type TimeToBin        = Long =&gt; Short
  type DateToBin        = ZonedDateTime =&gt; Short

<span class="nc" id="L56">  val Epoch: ZonedDateTime = ZonedDateTime.ofInstant(Instant.EPOCH, ZoneOffset.UTC)</span>

  // min value (inclusive)
<span class="nc" id="L59">  val ZMinDate: ZonedDateTime = Epoch</span>

  // max values (exclusive)
<span class="nc" id="L62">  val DaysMaxDate  : ZonedDateTime = Epoch.plusDays(Short.MaxValue.toInt + 1)</span>
<span class="nc" id="L63">  val WeeksMaxDate : ZonedDateTime = Epoch.plusWeeks(Short.MaxValue.toInt + 1)</span>
<span class="nc" id="L64">  val MonthsMaxDate: ZonedDateTime = Epoch.plusMonths(Short.MaxValue.toInt + 1)</span>
<span class="nc" id="L65">  val YearsMaxDate : ZonedDateTime = Epoch.plusYears(Short.MaxValue.toInt + 1)</span>

  /**
    * Gets period index (e.g. weeks since the epoch) and offset into that interval (e.g. seconds in week)
    *
    * @param period interval type
    * @return
    */
  def timeToBinnedTime(period: TimePeriod): TimeToBinnedTime = {
<span class="nc" id="L74">    period match {</span>
<span class="nc bnc" id="L75" title="All 6 branches missed.">      case TimePeriod.Day   =&gt; toDayAndMillis</span>
<span class="nc bnc" id="L76" title="All 6 branches missed.">      case TimePeriod.Week  =&gt; toWeekAndSeconds</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">      case TimePeriod.Month =&gt; toMonthAndSeconds</span>
<span class="nc bnc" id="L78" title="All 6 branches missed.">      case TimePeriod.Year  =&gt; toYearAndMinutes</span>
    }
  }

  /**
    * Gets period index (e.g. weeks since the epoch)
    *
    * @param period interval type
    * @return
    */
  def timeToBin(period: TimePeriod): TimeToBin = {
<span class="nc" id="L89">    period match {</span>
<span class="nc bnc" id="L90" title="All 6 branches missed.">      case TimePeriod.Day   =&gt; toDay</span>
<span class="nc bnc" id="L91" title="All 6 branches missed.">      case TimePeriod.Week  =&gt; toWeek</span>
<span class="nc bnc" id="L92" title="All 6 branches missed.">      case TimePeriod.Month =&gt; toMonth</span>
<span class="nc bnc" id="L93" title="All 6 branches missed.">      case TimePeriod.Year  =&gt; toYear</span>
    }
  }

  /**
    * Gets period index (e.g. weeks since the epoch) and offset into that interval (e.g. seconds in week)
    *
    * @param period interval type
    * @return
    */
  def dateToBinnedTime(period: TimePeriod): DateToBinnedTime = {
<span class="nc" id="L104">    period match {</span>
<span class="nc bnc" id="L105" title="All 6 branches missed.">      case TimePeriod.Day   =&gt; toDayAndMillis</span>
<span class="nc bnc" id="L106" title="All 6 branches missed.">      case TimePeriod.Week  =&gt; toWeekAndSeconds</span>
<span class="nc bnc" id="L107" title="All 6 branches missed.">      case TimePeriod.Month =&gt; toMonthAndSeconds</span>
<span class="nc bnc" id="L108" title="All 6 branches missed.">      case TimePeriod.Year  =&gt; toYearAndMinutes</span>
    }
  }

  /**
    * Gets period index (e.g. weeks since the epoch) and offset into that interval (e.g. seconds in week)
    *
    * @param period interval type
    * @return
    */
  def dateToBin(period: TimePeriod): DateToBin = {
<span class="nc" id="L119">    period match {</span>
<span class="nc bnc" id="L120" title="All 6 branches missed.">      case TimePeriod.Day   =&gt; toDay</span>
<span class="nc bnc" id="L121" title="All 6 branches missed.">      case TimePeriod.Week  =&gt; toWeek</span>
<span class="nc bnc" id="L122" title="All 6 branches missed.">      case TimePeriod.Month =&gt; toMonth</span>
<span class="nc bnc" id="L123" title="All 6 branches missed.">      case TimePeriod.Year  =&gt; toYear</span>
    }
  }

  /**
    * Gets a date back from a binned time
    *
    * @param period interval type
    * @return
    */
  def binnedTimeToDate(period: TimePeriod): BinnedTimeToDate = {
<span class="nc" id="L134">    period match {</span>
<span class="nc bnc" id="L135" title="All 6 branches missed.">      case TimePeriod.Day   =&gt; fromDayAndMillis</span>
<span class="nc bnc" id="L136" title="All 6 branches missed.">      case TimePeriod.Week  =&gt; fromWeekAndSeconds</span>
<span class="nc bnc" id="L137" title="All 6 branches missed.">      case TimePeriod.Month =&gt; fromMonthAndSeconds</span>
<span class="nc bnc" id="L138" title="All 6 branches missed.">      case TimePeriod.Year  =&gt; fromYearAndMinutes</span>
    }
  }

  /**
    * Gets the max offset value for a given time period
    *
    * @param period interval type
    * @return
    */
  def maxOffset(period: TimePeriod): Long = {
<span class="nc" id="L149">    period match {</span>
<span class="nc bnc" id="L150" title="All 6 branches missed.">      case TimePeriod.Day   =&gt; ChronoUnit.DAYS.getDuration.toMillis</span>
<span class="nc bnc" id="L151" title="All 6 branches missed.">      case TimePeriod.Week  =&gt; ChronoUnit.WEEKS.getDuration.toMillis / 1000L</span>
<span class="nc bnc" id="L152" title="All 6 branches missed.">      case TimePeriod.Month =&gt; (ChronoUnit.DAYS.getDuration.toMillis / 1000L) * 31L</span>
      // based on 365 days + 1 leap day, with a fudge factor of 10 minutes to account for leap seconds added each year
<span class="nc bnc" id="L154" title="All 6 branches missed.">      case TimePeriod.Year  =&gt; (ChronoUnit.DAYS.getDuration.toMinutes * 366L) + 10L</span>
    }
  }

  /**
    * Max indexable date (exclusive) for a given time period
    *
    * @param period interval type
    * @return
    */
  def maxDate(period: TimePeriod): ZonedDateTime = {
<span class="nc" id="L165">    period match {</span>
<span class="nc bnc" id="L166" title="All 6 branches missed.">      case TimePeriod.Day   =&gt; DaysMaxDate</span>
<span class="nc bnc" id="L167" title="All 6 branches missed.">      case TimePeriod.Week  =&gt; WeeksMaxDate</span>
<span class="nc bnc" id="L168" title="All 6 branches missed.">      case TimePeriod.Month =&gt; MonthsMaxDate</span>
<span class="nc bnc" id="L169" title="All 6 branches missed.">      case TimePeriod.Year  =&gt; YearsMaxDate</span>
    }
  }

  /**
    * Converts values extracted from a filter into valid indexable bounds
    *
    * @param period time period
    * @return
    */
  def boundsToIndexableDates(period: TimePeriod): ((Option[ZonedDateTime], Option[ZonedDateTime])) =&gt; (ZonedDateTime, ZonedDateTime) = {
<span class="nc" id="L180">    val maxDateTime = maxDate(period).minus(1L, ChronoUnit.MILLIS)</span>
<span class="nc" id="L181">    bounds =&gt; {</span>
<span class="nc" id="L182">      val lo = bounds._1 match {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        case None =&gt; ZMinDate</span>
<span class="nc bnc" id="L184" title="All 4 branches missed.">        case Some(dt) if dt.isBefore(ZMinDate) =&gt; ZMinDate</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">        case Some(dt) if dt.isAfter(maxDateTime) =&gt; maxDateTime</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        case Some(dt) =&gt; dt</span>
      }
<span class="nc" id="L188">      val hi = bounds._2 match {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        case None =&gt; maxDateTime</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">        case Some(dt) if dt.isBefore(ZMinDate) =&gt; ZMinDate</span>
<span class="nc bnc" id="L191" title="All 4 branches missed.">        case Some(dt) if dt.isAfter(maxDateTime) =&gt; maxDateTime</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        case Some(dt) =&gt; dt</span>
      }
<span class="nc" id="L194">      (lo, hi)</span>
    }
  }

  private def toDay(time: Long): Short =
<span class="nc" id="L199">    toDay(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toDay(date: ZonedDateTime): Short = {
<span class="nc bnc" id="L202" title="All 2 branches missed.">    require(!date.isBefore(ZMinDate), s&quot;Date exceeds minimum indexable value ($ZMinDate): $date&quot;)</span>
<span class="nc" id="L203">    require(DaysMaxDate.isAfter(date), s&quot;Date exceeds maximum indexable value ($DaysMaxDate): $date&quot;)</span>
<span class="nc" id="L204">    ChronoUnit.DAYS.between(Epoch, date).toShort</span>
  }

  private def toDayAndMillis(time: Long): BinnedTime =
<span class="nc" id="L208">    toDayAndMillis(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toDayAndMillis(date: ZonedDateTime): BinnedTime = {
<span class="nc" id="L211">    val days = toDay(date)</span>
<span class="nc" id="L212">    val millisInDay = date.toInstant.toEpochMilli - Epoch.plus(days, ChronoUnit.DAYS).toInstant.toEpochMilli</span>
<span class="nc" id="L213">    BinnedTime(days, millisInDay)</span>
  }

  private def fromDayAndMillis(date: BinnedTime): ZonedDateTime =
<span class="nc" id="L217">    Epoch.plusDays(date.bin).plus(date.offset, ChronoUnit.MILLIS)</span>

  private def toWeek(time: Long): Short =
<span class="nc" id="L220">    toWeek(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toWeek(date: ZonedDateTime): Short = {
<span class="nc bnc" id="L223" title="All 2 branches missed.">    require(!date.isBefore(ZMinDate), s&quot;Date exceeds minimum indexable value ($ZMinDate): $date&quot;)</span>
<span class="nc" id="L224">    require(WeeksMaxDate.isAfter(date), s&quot;Date exceeds maximum indexable value ($WeeksMaxDate): $date&quot;)</span>
<span class="nc" id="L225">    ChronoUnit.WEEKS.between(Epoch, date).toShort</span>
  }

  private def toWeekAndSeconds(time: Long): BinnedTime =
<span class="nc" id="L229">    toWeekAndSeconds(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toWeekAndSeconds(date: ZonedDateTime): BinnedTime = {
<span class="nc" id="L232">    val weeks = toWeek(date)</span>
<span class="nc" id="L233">    val secondsInWeek = date.toEpochSecond - Epoch.plus(weeks, ChronoUnit.WEEKS).toEpochSecond</span>
<span class="nc" id="L234">    BinnedTime(weeks, secondsInWeek)</span>
  }

  private def fromWeekAndSeconds(date: BinnedTime): ZonedDateTime =
<span class="nc" id="L238">    Epoch.plusWeeks(date.bin).plus(date.offset, ChronoUnit.SECONDS)</span>

  private def toMonth(time: Long): Short =
<span class="nc" id="L241">    toMonth(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toMonth(date: ZonedDateTime): Short = {
<span class="nc bnc" id="L244" title="All 2 branches missed.">    require(!date.isBefore(ZMinDate), s&quot;Date exceeds minimum indexable value ($ZMinDate): $date&quot;)</span>
<span class="nc" id="L245">    require(MonthsMaxDate.isAfter(date), s&quot;Date exceeds maximum indexable value ($MonthsMaxDate): $date&quot;)</span>
<span class="nc" id="L246">    ChronoUnit.MONTHS.between(Epoch, date).toShort</span>
  }

  private def toMonthAndSeconds(time: Long): BinnedTime =
<span class="nc" id="L250">    toMonthAndSeconds(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toMonthAndSeconds(date: ZonedDateTime): BinnedTime = {
<span class="nc" id="L253">    val months = toMonth(date)</span>
<span class="nc" id="L254">    val secondsInMonth = date.toEpochSecond - Epoch.plus(months, ChronoUnit.MONTHS).toEpochSecond</span>
<span class="nc" id="L255">    BinnedTime(months, secondsInMonth)</span>
  }

  private def fromMonthAndSeconds(date: BinnedTime): ZonedDateTime =
<span class="nc" id="L259">    Epoch.plusMonths(date.bin).plus(date.offset, ChronoUnit.SECONDS)</span>

  private def toYear(time: Long): Short =
<span class="nc" id="L262">    toYear(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toYear(date: ZonedDateTime): Short = {
<span class="nc bnc" id="L265" title="All 2 branches missed.">    require(!date.isBefore(ZMinDate), s&quot;Date exceeds minimum indexable value ($ZMinDate): $date&quot;)</span>
<span class="nc" id="L266">    require(YearsMaxDate.isAfter(date), s&quot;Date exceeds maximum indexable value ($YearsMaxDate): $date&quot;)</span>
<span class="nc" id="L267">    ChronoUnit.YEARS.between(Epoch, date).toShort</span>
  }

  private def toYearAndMinutes(time: Long): BinnedTime =
<span class="nc" id="L271">    toYearAndMinutes(ZonedDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneOffset.UTC))</span>

  private def toYearAndMinutes(date: ZonedDateTime): BinnedTime = {
<span class="nc" id="L274">    val years = toYear(date)</span>
<span class="nc" id="L275">    val minutesInYear = (date.toEpochSecond - Epoch.plus(years, ChronoUnit.YEARS).toEpochSecond) / 60L</span>
<span class="nc" id="L276">    BinnedTime(years, minutesInYear)</span>
  }

  private def fromYearAndMinutes(date: BinnedTime): ZonedDateTime =
<span class="nc" id="L280">    Epoch.plusYears(date.bin).plus(date.offset, ChronoUnit.MINUTES)</span>
}

<span class="nc" id="L283">object TimePeriod extends Enumeration {</span>

  type TimePeriod = Value

<span class="nc" id="L287">  val Day:   Value = Value(&quot;day&quot;)</span>
<span class="nc" id="L288">  val Week:  Value = Value(&quot;week&quot;)</span>
<span class="nc" id="L289">  val Month: Value = Value(&quot;month&quot;)</span>
<span class="nc" id="L290">  val Year:  Value = Value(&quot;year&quot;)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>