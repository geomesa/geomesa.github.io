<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlConverter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert XML</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.xml</a> &gt; <span class="el_source">XmlConverter.scala</span></div><h1>XmlConverter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.xml

import com.typesafe.config.Config
import com.typesafe.scalalogging.StrictLogging
import org.apache.commons.io.IOUtils
import org.apache.commons.io.input.BOMInputStream
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.convert.Modes.{ErrorMode, LineMode, ParseMode}
import org.locationtech.geomesa.convert._
import org.locationtech.geomesa.convert.xml.XmlConverter.{XmlConfig, XmlField, XmlHelper, XmlOptions}
import org.locationtech.geomesa.convert2._
import org.locationtech.geomesa.convert2.transforms.Expression
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.io.WithClose
import org.w3c.dom.{Element, NodeList}
import org.xml.sax.{ErrorHandler, InputSource, SAXParseException}

import java.io._
import java.nio.charset.Charset
import javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI
import javax.xml.namespace.NamespaceContext
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamSource
import javax.xml.validation.SchemaFactory
import javax.xml.xpath.{XPath, XPathConstants, XPathExpression, XPathFactory}
import scala.util.control.NonFatal

<span class="nc" id="L37">class XmlConverter(sft: SimpleFeatureType, config: XmlConfig, fields: Seq[XmlField], options: XmlOptions)</span>
<span class="nc" id="L38">    extends AbstractConverter[Element, XmlConfig, XmlField, XmlOptions](sft, config, fields, options) {</span>

<span class="nc bnc" id="L40" title="All 2 branches missed.">  private val helper = new ThreadLocal[XmlHelper]() {</span>
    override def initialValue: XmlHelper =
<span class="nc" id="L42">      new XmlHelper(config.xpathFactory, config.xmlNamespaces, config.xsd, config.featurePath)</span>
  }

<span class="nc" id="L45">  fields.foreach(_.compile(helper))</span>

  // TODO GEOMESA-1039 more efficient InputStream processing for multi mode

  override protected def parse(is: InputStream, ec: EvaluationContext): CloseableIterator[Element] =
<span class="nc" id="L50">    XmlConverter.iterator(helper.get.parser, is, options.encoding, options.lineMode, ec)</span>

  override protected def values(
      parsed: CloseableIterator[Element],
      ec: EvaluationContext): CloseableIterator[Array[Any]] = {

<span class="nc" id="L56">    val array = Array.ofDim[Any](2)</span>

<span class="nc" id="L58">    helper.get.rootPath match {</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">      case None =&gt;</span>
<span class="nc" id="L60">        parsed.map { element =&gt;</span>
<span class="nc" id="L61">          array(0) = element</span>
<span class="nc" id="L62">          array</span>
        }

<span class="nc bnc" id="L65" title="All 2 branches missed.">      case Some(path) =&gt;</span>
<span class="nc" id="L66">        parsed.flatMap { element =&gt;</span>
<span class="nc" id="L67">          array(1) = element</span>
<span class="nc" id="L68">          val nodeList = path.evaluate(element, XPathConstants.NODESET).asInstanceOf[NodeList]</span>
<span class="nc" id="L69">          Iterator.tabulate(nodeList.getLength) { i =&gt;</span>
<span class="nc" id="L70">            array(0) = nodeList.item(i)</span>
<span class="nc" id="L71">            array</span>
          }
        }
    }
  }

}

<span class="nc" id="L79">object XmlConverter extends StrictLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L83">  def createXPath(factory: String, namespaces: Map[String, String] = Map.empty): XPath = {</span>
<span class="nc" id="L84">    val fact = try {</span>
<span class="nc" id="L85">      val res = XPathFactory.newInstance(XPathFactory.DEFAULT_OBJECT_MODEL_URI, factory, getClass.getClassLoader)</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">      logger.info(s&quot;Loaded xpath factory ${res.getClass}&quot;)</span>
<span class="nc" id="L87">      res</span>
    } catch {
<span class="nc bnc" id="L89" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        logger.warn(s&quot;Unable to load xpath provider '$factory': ${e.toString}. &quot; +</span>
<span class="nc" id="L91">            &quot;Xpath queries may be slower - check your classpath&quot;)</span>
<span class="nc" id="L92">        XPathFactory.newInstance(XPathFactory.DEFAULT_OBJECT_MODEL_URI)</span>
    }
<span class="nc" id="L94">    val xpath = fact.newXPath()</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">    if (namespaces.nonEmpty) {</span>
<span class="nc" id="L96">      xpath.setNamespaceContext(new NamespaceContext() {</span>
<span class="nc" id="L97">        override def getPrefix(namespaceURI: String): String = null</span>
<span class="nc" id="L98">        override def getPrefixes(namespaceURI: String): java.util.Iterator[String] = null</span>
<span class="nc" id="L99">        override def getNamespaceURI(prefix: String): String = namespaces.getOrElse(prefix, null)</span>
      })
    }
<span class="nc" id="L102">    xpath</span>
  }

  def iterator(
      parser: DocParser,
      is: InputStream,
      encoding: Charset,
      mode: LineMode,
      ec: EvaluationContext): CloseableIterator[Element] = {

    // detect and exclude the BOM if it exists
<span class="nc" id="L113">    val bis = new BOMInputStream(is)</span>
<span class="nc bnc" id="L114" title="All 6 branches missed.">    if (mode == LineMode.Single) {</span>
<span class="nc" id="L115">      val lines = IOUtils.lineIterator(bis, encoding)</span>
<span class="nc" id="L116">      val elements = lines.asScala.flatMap { line =&gt;</span>
<span class="nc" id="L117">        ec.line += 1</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (line.isBlank) { Iterator.empty } else {</span>
<span class="nc" id="L119">          Iterator.single(parser.parse(new StringReader(line)))</span>
        }
      }
<span class="nc" id="L122">      CloseableIterator(elements, lines.close())</span>
    } else {
<span class="nc" id="L124">      val reader = new InputStreamReader(bis, encoding)</span>
<span class="nc" id="L125">      CloseableIterator.fill(1, reader.close()) { ec.line += 1; parser.parse(reader) }</span>
    }
  }

  // paths can be absolute, or relative to the feature node
  // they can also include xpath functions to manipulate the result
  // feature path can be any xpath that resolves to a node set (or a single node)

<span class="nc bnc" id="L133" title="All 74 branches missed.">  case class XmlConfig(</span>
<span class="nc" id="L134">      `type`: String,</span>
<span class="nc" id="L135">      converterName: Option[String],</span>
<span class="nc" id="L136">      xpathFactory: String,</span>
<span class="nc" id="L137">      xmlNamespaces: Map[String, String],</span>
<span class="nc" id="L138">      xsd: Option[String],</span>
<span class="nc" id="L139">      featurePath: Option[String],</span>
<span class="nc" id="L140">      idField: Option[Expression],</span>
<span class="nc" id="L141">      caches: Map[String, Config],</span>
<span class="nc" id="L142">      userData: Map[String, Expression]</span>
<span class="nc" id="L143">    ) extends ConverterConfig with ConverterName</span>

  sealed trait XmlField extends Field {
    def compile(helper: ThreadLocal[XmlHelper]): Unit
  }

<span class="nc bnc" id="L149" title="All 25 branches missed.">  case class DerivedField(name: String, transforms: Option[Expression]) extends XmlField {</span>
<span class="nc" id="L150">    override def compile(helper: ThreadLocal[XmlHelper]): Unit = {}</span>
<span class="nc" id="L151">    override val fieldArg: Option[Array[AnyRef] =&gt; AnyRef] = None</span>
  }

<span class="nc bnc" id="L154" title="All 32 branches missed.">  case class XmlPathField(name: String, path: String, transforms: Option[Expression]) extends XmlField {</span>

<span class="nc" id="L156">    private var helper: ThreadLocal[XmlHelper] = _</span>

<span class="nc bnc" id="L158" title="All 2 branches missed.">    private val expression = new ThreadLocal[XPathExpression]() {</span>
<span class="nc" id="L159">      override def initialValue(): XPathExpression = helper.get.xpath.compile(path)</span>
    }

<span class="nc" id="L162">    override val fieldArg: Option[Array[AnyRef] =&gt; AnyRef] = Some(values)</span>

<span class="nc" id="L164">    override def compile(helper: ThreadLocal[XmlHelper]): Unit = this.helper = helper</span>

<span class="nc" id="L166">    private def values(args: Array[AnyRef]): AnyRef = expression.get.evaluate(args(0))</span>
  }

<span class="nc bnc" id="L169" title="All 46 branches missed.">  case class XmlOptions(</span>
<span class="nc" id="L170">      validators: Seq[String],</span>
<span class="nc" id="L171">      parseMode: ParseMode,</span>
<span class="nc" id="L172">      errorMode: ErrorMode,</span>
<span class="nc" id="L173">      lineMode: LineMode,</span>
<span class="nc" id="L174">      encoding: Charset</span>
<span class="nc" id="L175">    ) extends ConverterOptions</span>

  /**
   * XML parser helper - holds non-thread-safe classes
   *
   * @param xpathFactory class name to use for creating xpaths
   * @param namespaces xml namespaces
   * @param xsd xsd path to an xsd used to validate parsed documents
   * @param featurePath path to features in the xml doc
   */
<span class="nc" id="L185">  class XmlHelper(</span>
      xpathFactory: String,
      namespaces: Map[String, String],
      xsd: Option[String],
      featurePath: Option[String]) {
<span class="nc" id="L190">    val parser = new DocParser(xsd)</span>
<span class="nc" id="L191">    val xpath: XPath = createXPath(xpathFactory, namespaces)</span>
<span class="nc" id="L192">    val rootPath: Option[XPathExpression] = featurePath.map(xpath.compile)</span>
  }

  /**
   * Document parser helper
   *
   * @param xsd xsd path to an xsd used to validate parsed documents
   */
<span class="nc" id="L200">  class DocParser(xsd: Option[String]) {</span>

<span class="nc" id="L202">    private val builder = {</span>
<span class="nc" id="L203">      val factory = DocumentBuilderFactory.newInstance()</span>
<span class="nc" id="L204">      factory.setNamespaceAware(true)</span>
<span class="nc" id="L205">      val builder = factory.newDocumentBuilder()</span>
      // override default error handler which prints to stdout/stderr
<span class="nc" id="L207">      builder.setErrorHandler(new ErrorHandler() {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        override def warning(e: SAXParseException): Unit = logger.warn(&quot;XML parsing error:&quot;, e)</span>
<span class="nc" id="L209">        override def error(e: SAXParseException): Unit = throw e</span>
<span class="nc" id="L210">        override def fatalError(e: SAXParseException): Unit = throw e</span>
      })
<span class="nc" id="L212">      builder</span>
    }

<span class="nc" id="L215">    private val validator = xsd.map { path =&gt;</span>
<span class="nc" id="L216">      val schemaFactory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI)</span>
<span class="nc" id="L217">      WithClose(getClass.getClassLoader.getResourceAsStream(path)) { xsdStream =&gt;</span>
<span class="nc" id="L218">        schemaFactory.newSchema(new StreamSource(xsdStream)).newValidator()</span>
      }
    }

    def parse(reader: Reader): Element = {
      // parse the document once, then extract each feature node and operate on it
<span class="nc" id="L224">      val document = builder.parse(new InputSource(reader))</span>
      // if a schema is defined, validate it - this will throw an exception on failure
<span class="nc" id="L226">      validator.foreach(_.validate(new DOMSource(document)))</span>
<span class="nc" id="L227">      document.getDocumentElement</span>
    }
  }
<span class="nc" id="L230">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>