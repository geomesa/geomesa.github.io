<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlConverterFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert XML</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.xml</a> &gt; <span class="el_source">XmlConverterFactory.scala</span></div><h1>XmlConverterFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.xml

import com.typesafe.config.{Config, ConfigFactory}
import com.typesafe.scalalogging.StrictLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.convert.EvaluationContext
import org.locationtech.geomesa.convert.Modes.{ErrorMode, LineMode, ParseMode}
import org.locationtech.geomesa.convert.xml.XmlConverter._
import org.locationtech.geomesa.convert.xml.XmlConverterFactory.{XmlConfigConvert, XmlFieldConvert, XmlNamer, XmlOptionsConvert}
import org.locationtech.geomesa.convert2.AbstractConverterFactory.{ConverterConfigConvert, ConverterOptionsConvert, FieldConvert, OptionConvert}
import org.locationtech.geomesa.convert2.TypeInference.{IdentityTransform, Namer, PathWithValues, TypeWithPath}
import org.locationtech.geomesa.convert2.transforms.Expression
import org.locationtech.geomesa.convert2.{AbstractConverterFactory, TypeInference}
import org.locationtech.geomesa.utils.io.WithClose
import org.w3c.dom._
import pureconfig.error.{CannotConvert, ConfigReaderFailures}
import pureconfig.{ConfigObjectCursor, ConfigSource}

import java.io.InputStream
import java.nio.charset.{Charset, StandardCharsets}
import java.util.regex.Pattern
import javax.xml.xpath.XPathConstants
import scala.collection.mutable.ListBuffer
import scala.reflect.classTag
import scala.util.{Failure, Random, Try}

<span class="nc" id="L35">class XmlConverterFactory extends AbstractConverterFactory[XmlConverter, XmlConfig, XmlField, XmlOptions](</span>
<span class="nc" id="L36">  XmlConverterFactory.TypeToProcess, XmlConfigConvert, XmlFieldConvert, XmlOptionsConvert) {</span>

  override protected def withDefaults(conf: Config): Config =
<span class="nc" id="L39">    super.withDefaults(conf).withFallback(ConfigFactory.load(&quot;xml-converter-defaults&quot;))</span>

  /**
   * Infer a configuration and simple feature type from an input stream, if possible
   *
   * Available hints:
   *  - `featurePath` - xpath expression pointing to the feature element
   *
   * @param is input
   * @param sft simple feature type, if known ahead of time
   * @param hints implementation specific hints about the input
   * @return
   */
  override def infer(
      is: InputStream,
      sft: Option[SimpleFeatureType],
      hints: Map[String, AnyRef]): Try[(SimpleFeatureType, Config)] = {
<span class="nc" id="L56">    val tryElements = Try {</span>
<span class="nc" id="L57">      val parser = new DocParser(None)</span>
<span class="nc" id="L58">      WithClose(XmlConverter.iterator(parser, is, StandardCharsets.UTF_8, LineMode.Multi, EvaluationContext.empty)) { iter =&gt;</span>
<span class="nc" id="L59">        iter.take(AbstractConverterFactory.inferSampleSize).toList</span>
      }
    }

<span class="nc" id="L63">    tryElements.flatMap { elements =&gt;</span>
<span class="nc" id="L64">      val featurePath = hints.get(XmlConverterFactory.FeaturePathKey).map(_.toString)</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">      val (defaultNs, namespaces) = elements.headOption match {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        case None =&gt; (None, Map.empty[String, String])</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        case Some(e) =&gt;</span>
<span class="nc" id="L68">          val ns = XmlConverterFactory.getNamespaces(e)</span>
<span class="nc" id="L69">          ns.get(&quot;&quot;) match {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">            case None =&gt; (None, ns)</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">            case Some(default) =&gt;</span>
<span class="nc" id="L72">              val alphas = Random.alphanumeric.filter(_.isLower)</span>
<span class="nc" id="L73">              var key: String = null</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">              while ({ key = alphas.take(4).mkString(&quot;&quot;); ns.contains(key) }) {</span>
                // loop
              }
<span class="nc" id="L77">              (Some(s&quot;$key:&quot;), ns - &quot;&quot; + (key -&gt; default))</span>
          }
      }

      val xpathFactory =
<span class="nc" id="L82">        ConfigSource.fromConfig(withDefaults(XmlConverterFactory.TypeConfig))</span>
<span class="nc" id="L83">            .loadOrThrow[XmlConfig](classTag[XmlConfig], XmlConfigConvert)</span>
            .xpathFactory

<span class="nc" id="L86">      val tryFeatures = Try {</span>
<span class="nc" id="L87">        featurePath match {</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">          case None =&gt; elements</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">          case Some(p) =&gt;</span>
<span class="nc" id="L90">            val xpath = XmlConverter.createXPath(xpathFactory, namespaces).compile(p)</span>
<span class="nc" id="L91">            val features = elements.flatMap { element =&gt;</span>
<span class="nc" id="L92">              val nodeList = xpath.evaluate(element, XPathConstants.NODESET).asInstanceOf[NodeList]</span>
<span class="nc" id="L93">              Seq.tabulate(nodeList.getLength)(i =&gt; nodeList.item(i).asInstanceOf[Element])</span>
            }
<span class="nc" id="L95">            features.take(AbstractConverterFactory.inferSampleSize)</span>
        }
      }

<span class="nc" id="L99">      tryFeatures.flatMap { features =&gt;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (features.isEmpty) {</span>
<span class="nc" id="L101">          Failure(new RuntimeException(&quot;Could not parse input as XML&quot;))</span>
        } else {
<span class="nc" id="L103">          Try {</span>
            // track the properties in each feature
            // use linkedHashMap to retain insertion order
<span class="nc" id="L106">            val props = scala.collection.mutable.LinkedHashMap.empty[String, ListBuffer[Any]]</span>

<span class="nc" id="L108">            val namer = new XmlNamer(defaultNs)</span>
<span class="nc" id="L109">            features.foreach { feature =&gt;</span>
<span class="nc" id="L110">              namer.addRootElement(feature)</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">              XmlConverterFactory.parseNode(feature, &quot;&quot;, defaultNs.getOrElse(&quot;&quot;)).foreach { case (k, v) =&gt;</span>
<span class="nc" id="L112">                props.getOrElseUpdate(k, ListBuffer.empty) += v</span>
              }
            }

<span class="nc bnc" id="L116" title="All 2 branches missed.">            val pathsAndValues = props.toSeq.map { case (path, values) =&gt; PathWithValues(path, values) }</span>
<span class="nc" id="L117">            val inferredTypes = TypeInference.infer(pathsAndValues, sft.toRight(&quot;inferred-xml&quot;), namer)</span>

<span class="nc bnc" id="L119" title="All 2 branches missed.">            val fieldConfig = inferredTypes.types.map { case TypeWithPath(path, inferredType) =&gt;</span>
<span class="nc" id="L120">              val transform = inferredType.transform match {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                case IdentityTransform =&gt; None</span>
                // account for optional nodes by wrapping transform with a try/null
<span class="nc" id="L123">                case t =&gt; Some(Expression(s&quot;try(${t.apply(0)},null)&quot;))</span>
              }
<span class="nc bnc" id="L125" title="All 2 branches missed.">              if (path.isEmpty) {</span>
<span class="nc" id="L126">                DerivedField(inferredType.name, transform)</span>
              } else {
<span class="nc" id="L128">                XmlPathField(inferredType.name, path, transform)</span>
              }
            }

<span class="nc" id="L132">            val idField = Some(Expression(&quot;md5(stringToBytes(toString($0)))&quot;))</span>

            val xmlConfig =
<span class="nc" id="L135">              XmlConfig(typeToProcess, None, xpathFactory, namespaces, None, featurePath, idField, Map.empty, Map.empty)</span>

            val config =
<span class="nc" id="L138">              configConvert.to(xmlConfig)</span>
<span class="nc" id="L139">                  .withFallback(fieldConvert.to(fieldConfig))</span>
                  .toConfig

<span class="nc" id="L142">            (inferredTypes.sft, config)</span>
          }
        }
      }
    }
  }
}

<span class="nc" id="L150">object XmlConverterFactory {</span>

<span class="nc" id="L152">  val TypeToProcess = &quot;xml&quot;</span>

<span class="nc" id="L154">  val FeaturePathKey = &quot;featurePath&quot;</span>

<span class="nc" id="L156">  private val TypeConfig = ConfigFactory.parseString(s&quot;{type = $TypeToProcess}&quot;)</span>

<span class="nc" id="L158">  object XmlConfigConvert extends ConverterConfigConvert[XmlConfig] with OptionConvert with StrictLogging {</span>

    import scala.collection.JavaConverters._

    override protected def decodeConfig(
        cur: ConfigObjectCursor,
        `type`: String,
        idField: Option[Expression],
        caches: Map[String, Config],
        userData: Map[String, Expression]): Either[ConfigReaderFailures, XmlConfig] = {
      for {
<span class="nc" id="L169">        name      &lt;- converterName(cur).right</span>
<span class="nc" id="L170">        provider  &lt;- cur.atKey(&quot;xpath-factory&quot;).right.flatMap(_.asString).right</span>
<span class="nc" id="L171">        namespace &lt;- cur.atKey(&quot;xml-namespaces&quot;).right.flatMap(_.asObjectCursor).right</span>
<span class="nc" id="L172">        path      &lt;- optional(cur, &quot;feature-path&quot;).right</span>
<span class="nc" id="L173">        xsd       &lt;- optional(cur, &quot;xsd&quot;).right</span>
      } yield {
        val namespaces =
<span class="nc" id="L176">          namespace.valueOpt.map(_.unwrapped().asInstanceOf[java.util.Map[String, String]].asScala.toMap)</span>
<span class="nc" id="L177">              .getOrElse(Map.empty)</span>
<span class="nc" id="L178">        XmlConfig(`type`, name, provider, namespaces, xsd, path, idField, caches, userData)</span>
      }
    }

    override protected def encodeConfig(config: XmlConfig, base: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L183">      base.put(&quot;xpath-factory&quot;, config.xpathFactory)</span>
<span class="nc" id="L184">      base.put(&quot;xml-namespaces&quot;, config.xmlNamespaces.asJava)</span>
<span class="nc" id="L185">      config.featurePath.foreach(base.put(&quot;feature-path&quot;, _))</span>
<span class="nc" id="L186">      config.xsd.foreach(base.put(&quot;xsd&quot;, _))</span>
    }
  }

<span class="nc" id="L190">  object XmlFieldConvert extends FieldConvert[XmlField] with OptionConvert {</span>
    override protected def decodeField(cur: ConfigObjectCursor,
                                       name: String,
                                       transform: Option[Expression]): Either[ConfigReaderFailures, XmlField] = {
<span class="nc" id="L194">      for { path &lt;- optional(cur, &quot;path&quot;).right } yield {</span>
<span class="nc" id="L195">        path match {</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">          case None =&gt; DerivedField(name, transform)</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">          case Some(p) =&gt; XmlPathField(name, p, transform)</span>
        }
      }
    }

    override protected def encodeField(field: XmlField, base: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L203">      field match {</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        case f: XmlPathField =&gt; base.put(&quot;path&quot;, f.path)</span>
<span class="nc" id="L205">        case _ =&gt; // no-op</span>
      }
    }
  }

<span class="nc" id="L210">  object XmlOptionsConvert extends ConverterOptionsConvert[XmlOptions] {</span>
    override protected def decodeOptions(
        cur: ConfigObjectCursor,
        validators: Seq[String],
        parseMode: ParseMode,
        errorMode: ErrorMode,
        encoding: Charset): Either[ConfigReaderFailures, XmlOptions] = {
      def parse[T](key: String, values: Iterable[T]): Either[ConfigReaderFailures, T] = {
<span class="nc" id="L218">        cur.atKey(key).right.flatMap { value =&gt;</span>
<span class="nc" id="L219">          value.asString.right.flatMap { string =&gt;</span>
<span class="nc" id="L220">            values.find(_.toString.equalsIgnoreCase(string)) match {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">              case Some(v) =&gt; Right(v)</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">              case None =&gt;</span>
<span class="nc" id="L223">                val msg = s&quot;Must be one of: ${values.mkString(&quot;, &quot;)}&quot;</span>
<span class="nc" id="L224">                value.failed(CannotConvert(value.valueOpt.map(_.toString).orNull, values.head.getClass.getSimpleName, msg))</span>
            }
          }
        }
      }

      for {
<span class="nc" id="L231">        lineMode &lt;- parse(&quot;line-mode&quot;, LineMode.values).right</span>
      } yield {
<span class="nc" id="L233">        XmlOptions(validators, parseMode, errorMode, lineMode, encoding)</span>
      }
    }

    override protected def encodeOptions(options: XmlOptions, base: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L238">      base.put(&quot;line-mode&quot;, options.lineMode.toString)</span>
    }
  }

  /**
   * Attribute namer for xml elements
   */
<span class="nc" id="L245">  private class XmlNamer(defaultPrefix: Option[String]) extends Namer {</span>

<span class="nc" id="L247">    private val rootPrefixes = scala.collection.mutable.HashSet.empty[String]</span>
<span class="nc" id="L248">    private val namespaceMatcher = Pattern.compile(&quot;(/@?)[^:/@]*:&quot;)</span>

    /**
     * Add a root element, whose tag will be removed from any derived attribute names
     *
     * @param elem element
     */
    def addRootElement(elem: Element): Unit = {
<span class="nc" id="L256">      rootPrefixes += {</span>
<span class="nc" id="L257">        defaultPrefix match {</span>
<span class="nc bnc" id="L258" title="All 6 branches missed.">          case Some(p) if elem.getPrefix == null || elem.getPrefix.isEmpty =&gt; s&quot;/$p${elem.getTagName}/&quot;</span>
<span class="nc" id="L259">          case _ =&gt; s&quot;/${elem.getTagName}/&quot;</span>
        }
      }
    }

    override def apply(key: String): String = {
<span class="nc" id="L265">      val withoutRoot = rootPrefixes.find(key.startsWith) match {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        case None    =&gt; key</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        case Some(p) =&gt; key.substring(p.length - 1)</span>
      }
      // remove namespace prefixes from the attribute names
<span class="nc" id="L270">      val withoutPrefixes = namespaceMatcher.matcher(withoutRoot).replaceAll(&quot;$1&quot;)</span>
<span class="nc" id="L271">      super.apply(withoutPrefixes)</span>
    }
  }

  /**
   * Extract xmlns declarations from this element
   *
   * @param doc element
   * @return
   */
  private def getNamespaces(doc: Element): Map[String, String] = {
<span class="nc" id="L282">    val namespaces = Map.newBuilder[String, String]</span>
<span class="nc" id="L283">    val attributes = doc.getAttributes</span>
<span class="nc" id="L284">    var i = 0</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">    while (i &lt; attributes.getLength) {</span>
<span class="nc" id="L286">      val attr = attributes.item(i).asInstanceOf[Attr]</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">      if (attr.getName.startsWith(&quot;xmlns:&quot;)) {</span>
<span class="nc" id="L288">        namespaces += attr.getName.substring(6) -&gt; attr.getValue</span>
<span class="nc bnc" id="L289" title="All 6 branches missed.">      } else if (attr.getName == &quot;xmlns&quot;) {</span>
<span class="nc" id="L290">        namespaces += &quot;&quot; -&gt; attr.getValue</span>
      }
<span class="nc" id="L292">      i += 1</span>
    }
<span class="nc" id="L294">    namespaces.result</span>
  }

  /**
   * Parse an xml node
   *
   * @param node node
   * @param path xpath to the parent of the object
   * @param defaultNamespacePrefix path prefix for elements without an explicit namespace
   * @return map of key is xpath to value, value is a string
   */
  private def parseNode(node: Node, path: String, defaultNamespacePrefix: String): Seq[(String, String)] = {
    // use linkedHashMap to preserve insertion order
<span class="nc" id="L307">    val builder = scala.collection.mutable.LinkedHashMap.empty[String, String]</span>
<span class="nc" id="L308">    node match {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">      case n: Element =&gt;</span>
        val elemPath = {
<span class="nc bnc" id="L311" title="All 4 branches missed.">          val prefix = if (n.getPrefix == null || n.getPrefix.isEmpty) { defaultNamespacePrefix } else { &quot;&quot; }</span>
<span class="nc" id="L312">          s&quot;$path/$prefix${n.getTagName}&quot;</span>
        }
<span class="nc" id="L314">        Seq.tabulate(n.getAttributes.getLength)(n.getAttributes.item(_).asInstanceOf[Attr])</span>
<span class="nc bnc" id="L315" title="All 8 branches missed.">            .filterNot(a =&gt; a.getName.startsWith(&quot;xmlns:&quot;) || a.getName == &quot;xmlns&quot;)</span>
<span class="nc" id="L316">            .sortBy(_.getLocalName)</span>
<span class="nc" id="L317">            .foreach(attr =&gt; builder += s&quot;$elemPath/@${attr.getName}&quot; -&gt; attr.getValue)</span>
<span class="nc" id="L318">        Seq.tabulate(n.getChildNodes.getLength)(n.getChildNodes.item)</span>
<span class="nc" id="L319">            .foreach(child =&gt; builder ++= parseNode(child, elemPath, defaultNamespacePrefix))</span>

<span class="nc bnc" id="L321" title="All 4 branches missed.">      case n: Text if !n.getData.isBlank =&gt;</span>
<span class="nc" id="L322">        builder += path -&gt; n.getData</span>

<span class="nc" id="L324">      case _ =&gt; // no-op</span>
    }
<span class="nc" id="L326">    builder.toSeq</span>
  }
<span class="nc" id="L328">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>