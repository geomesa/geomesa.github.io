<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DelimitedTextConverterFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Text</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.text</a> &gt; <span class="el_source">DelimitedTextConverterFactory.scala</span></div><h1>DelimitedTextConverterFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.text

import com.typesafe.config.Config
import org.apache.commons.csv.CSVFormat
import org.apache.commons.io.IOUtils
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.convert.Modes.{ErrorMode, ParseMode}
import org.locationtech.geomesa.convert.text.DelimitedTextConverter._
import org.locationtech.geomesa.convert.text.DelimitedTextConverterFactory.{DelimitedTextConfigConvert, DelimitedTextOptionsConvert}
import org.locationtech.geomesa.convert2
import org.locationtech.geomesa.convert2.AbstractConverter.BasicField
import org.locationtech.geomesa.convert2.AbstractConverterFactory.{BasicFieldConvert, ConverterConfigConvert, ConverterOptionsConvert, PrimitiveConvert}
import org.locationtech.geomesa.convert2.TypeInference.{FunctionTransform, PathWithValues, TypeWithPath}
import org.locationtech.geomesa.convert2.transforms.Expression
import org.locationtech.geomesa.convert2.transforms.Expression.{LiteralNull, TryExpression}
import org.locationtech.geomesa.convert2.validators.SimpleFeatureValidator
import org.locationtech.geomesa.convert2.{AbstractConverterFactory, TypeInference}
import org.locationtech.geomesa.utils.geotools.{ObjectType, SimpleFeatureTypes}
import org.locationtech.geomesa.utils.io.WithClose
import pureconfig.error.ConfigReaderFailures
import pureconfig.{ConfigObjectCursor, ConfigReader}

import java.io.{InputStream, StringReader}
import java.nio.charset.{Charset, StandardCharsets}
import scala.util.{Failure, Try}

class DelimitedTextConverterFactory
<span class="nc" id="L36">    extends AbstractConverterFactory[DelimitedTextConverter, DelimitedTextConfig, BasicField, DelimitedTextOptions](</span>
<span class="nc" id="L37">      DelimitedTextConverterFactory.TypeToProcess, DelimitedTextConfigConvert, BasicFieldConvert, DelimitedTextOptionsConvert) {</span>

  import scala.collection.JavaConverters._

  override def infer(
      is: InputStream,
      sft: Option[SimpleFeatureType],
      hints: Map[String, AnyRef]): Try[(SimpleFeatureType, Config)] = {
<span class="nc" id="L45">    val tryLines = Try {</span>
<span class="nc" id="L46">      val sampleSize = AbstractConverterFactory.inferSampleSize</span>
<span class="nc" id="L47">      IOUtils.lineIterator(is, StandardCharsets.UTF_8.displayName).asScala.take(sampleSize).toSeq</span>
    }
<span class="nc" id="L49">    tryLines.flatMap { lines =&gt;</span>
      // if only a single line, assume that it isn't actually delimited text
<span class="nc bnc" id="L51" title="All 2 branches missed.">      if (lines.lengthCompare(2) &lt; 0) { Failure(new RuntimeException(&quot;Not enough lines in input data&quot;)) } else {</span>
<span class="nc" id="L52">        val attempts = Iterator.single(magic(lines, sft)) ++</span>
<span class="nc" id="L53">            DelimitedTextConverter.inferences.iterator.map(infer(_, lines, sft))</span>
<span class="nc" id="L54">        convert2.multiTry(attempts, new RuntimeException(&quot;Could not parse input as delimited text&quot;))</span>
      }
    }
  }

  private def infer(
      format: CSVFormat,
      lines: Seq[String],
      sft: Option[SimpleFeatureType]): Try[(SimpleFeatureType, Config)] = {
    // : Seq[List[String]]
<span class="nc" id="L64">    val rows = lines.flatMap { line =&gt;</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">      if (line.isBlank) { None } else {</span>
<span class="nc" id="L66">        Try(format.parse(new StringReader(line)).iterator().next.iterator.asScala.toList).toOption</span>
      }
    }
<span class="nc" id="L69">    val counts = rows.map(_.length).distinct</span>
    // try to verify that we actually have a delimited file
    // ensure that some lines parsed, that there were at most 3 different col counts, and that there were at least 2 cols
<span class="nc bnc" id="L72" title="All 6 branches missed.">    if (counts.isEmpty || counts.lengthCompare(3) &gt; 0 || counts.max &lt; 2) {</span>
<span class="nc bnc" id="L73" title="All 12 branches missed.">      val f = if (format == Formats.Tabs) { &quot;tsv&quot; } else if (format == Formats.Quoted) { &quot;quoted csv&quot; }  else { &quot;csv&quot; }</span>
<span class="nc" id="L74">      return Failure(new RuntimeException(s&quot;Not a valid delimited text file using format: $f&quot;))</span>
    }
<span class="nc" id="L76">    Try {</span>
<span class="nc" id="L77">      val names = sft match {</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        case Some(s) =&gt;</span>
<span class="nc" id="L79">          s.getAttributeDescriptors.asScala.map(_.getLocalName)</span>

<span class="nc bnc" id="L81" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L82">          val values = rows.head.map(v =&gt; PathWithValues(&quot;&quot;, Seq(v)))</span>
<span class="nc bnc" id="L83" title="All 8 branches missed.">          if (TypeInference.infer(values, Left(&quot;&quot;)).types.forall(_.inferredType.typed == ObjectType.STRING)) {</span>
            // assume the first row is headers
<span class="nc" id="L85">            rows.head</span>
          } else {
<span class="nc" id="L87">            Seq.empty</span>
          }
      }
<span class="nc" id="L90">      val nameIter = names.iterator</span>
<span class="nc" id="L91">      val pathsAndValues = Seq.tabulate(counts.max) { col =&gt;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        val values = rows.drop(1).map(vals =&gt; if (vals.lengthCompare(col) &gt; 0) { vals(col) } else { null })</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        PathWithValues(if (nameIter.hasNext) { nameIter.next } else { &quot;&quot; }, values)</span>
      }
      val inferred =
<span class="nc" id="L96">        TypeInference.infer(pathsAndValues,</span>
<span class="nc bnc" id="L97" title="All 6 branches missed.">          sft.toRight(s&quot;inferred-${if (format == Formats.Tabs) { &quot;tsv&quot; } else { &quot;csv&quot; }}&quot;))</span>
<span class="nc bnc" id="L98" title="All 6 branches missed.">      val converterConfig = DelimitedTextConfig(typeToProcess, None, formats.find(_._2 == format).get._1,</span>
<span class="nc" id="L99">        Some(Expression(&quot;md5(string2bytes($0))&quot;)), Map.empty, Map.empty)</span>

      val fields = {
<span class="nc" id="L102">        var i = 0 // 0 is the whole record</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        inferred.types.map { case TypeWithPath(_, inferredType) =&gt;</span>
<span class="nc" id="L104">          i += 1</span>
<span class="nc" id="L105">          BasicField(inferredType.name, Some(Expression(inferredType.transform(i))))</span>
        }
      }

<span class="nc" id="L109">      val options = DelimitedTextOptions(None, CharNotSpecified, CharNotSpecified, None,</span>
<span class="nc" id="L110">        SimpleFeatureValidator.default, ParseMode.Default, ErrorMode(), StandardCharsets.UTF_8)</span>

<span class="nc" id="L112">      val config = configConvert.to(converterConfig)</span>
<span class="nc" id="L113">          .withFallback(fieldConvert.to(fields.toSeq))</span>
<span class="nc" id="L114">          .withFallback(optsConvert.to(options))</span>
          .toConfig

<span class="nc" id="L117">      (inferred.sft, config)</span>
    }
  }

  private def magic(lines: Seq[String], sft: Option[SimpleFeatureType]): Try[(SimpleFeatureType, Config)] = {
<span class="nc bnc" id="L122" title="All 2 branches missed.">    if (!lines.head.startsWith(&quot;id,&quot;)) { Failure(new RuntimeException(&quot;Not a geomesa delimited export&quot;)) } else {</span>
<span class="nc" id="L123">      Try {</span>
<span class="nc" id="L124">        val spec = WithClose(Formats.QuotedMinimal.parse(new StringReader(lines.head.drop(3)))) { result =&gt;</span>
<span class="nc" id="L125">          result.iterator().next.asScala.mkString(&quot;,&quot;)</span>
        }
<span class="nc" id="L127">        val schema = SimpleFeatureTypes.createType(&quot;&quot;, spec)</span>

        val converterConfig =
<span class="nc bnc" id="L130" title="All 6 branches missed.">          DelimitedTextConfig(typeToProcess, None, formats.find(_._2 == Formats.QuotedMinimal).get._1,</span>
<span class="nc" id="L131">            Some(Expression(&quot;$1&quot;)), Map.empty, Map.empty)</span>

<span class="nc" id="L133">        var i = 1 // 0 is the whole record, 1 is the id</span>
<span class="nc" id="L134">        val fields = schema.getAttributeDescriptors.asScala.map { d =&gt;</span>
<span class="nc" id="L135">          val bindings = ObjectType.selectType(d)</span>
<span class="nc" id="L136">          val transform = bindings.head match {</span>
<span class="nc bnc" id="L137" title="All 6 branches missed.">            case ObjectType.STRING   =&gt; TypeInference.IdentityTransform</span>
<span class="nc bnc" id="L138" title="All 6 branches missed.">            case ObjectType.INT      =&gt; TypeInference.CastToInt</span>
<span class="nc bnc" id="L139" title="All 6 branches missed.">            case ObjectType.LONG     =&gt; TypeInference.CastToLong</span>
<span class="nc bnc" id="L140" title="All 6 branches missed.">            case ObjectType.FLOAT    =&gt; TypeInference.CastToFloat</span>
<span class="nc bnc" id="L141" title="All 6 branches missed.">            case ObjectType.DOUBLE   =&gt; TypeInference.CastToDouble</span>
<span class="nc bnc" id="L142" title="All 6 branches missed.">            case ObjectType.BOOLEAN  =&gt; TypeInference.CastToBoolean</span>
<span class="nc bnc" id="L143" title="All 6 branches missed.">            case ObjectType.DATE     =&gt; FunctionTransform(&quot;datetime(&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L144" title="All 6 branches missed.">            case ObjectType.UUID     =&gt; TypeInference.IdentityTransform</span>
<span class="nc bnc" id="L145" title="All 6 branches missed.">            case ObjectType.LIST     =&gt; FunctionTransform(s&quot;parseList('${bindings(1)}',&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L146" title="All 6 branches missed.">            case ObjectType.MAP      =&gt; FunctionTransform(s&quot;parseMap('${bindings(1)}-&gt;${bindings(2)}',&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L147" title="All 6 branches missed.">            case ObjectType.BYTES    =&gt; TypeInference.IdentityTransform</span>
<span class="nc bnc" id="L148" title="All 6 branches missed.">            case ObjectType.GEOMETRY =&gt;</span>
<span class="nc" id="L149">              bindings.drop(1).headOption.getOrElse(ObjectType.GEOMETRY) match {</span>
<span class="nc bnc" id="L150" title="All 6 branches missed.">                case ObjectType.POINT               =&gt; FunctionTransform(&quot;point(&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L151" title="All 6 branches missed.">                case ObjectType.LINESTRING          =&gt; FunctionTransform(&quot;linestring(&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L152" title="All 6 branches missed.">                case ObjectType.POLYGON             =&gt; FunctionTransform(&quot;polygon(&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L153" title="All 6 branches missed.">                case ObjectType.MULTIPOINT          =&gt; FunctionTransform(&quot;multipoint(&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L154" title="All 6 branches missed.">                case ObjectType.MULTILINESTRING     =&gt; FunctionTransform(&quot;multilinestring(&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L155" title="All 6 branches missed.">                case ObjectType.MULTIPOLYGON        =&gt; FunctionTransform(&quot;multipolygon(&quot;, &quot;)&quot;)</span>
<span class="nc bnc" id="L156" title="All 6 branches missed.">                case ObjectType.GEOMETRY_COLLECTION =&gt; FunctionTransform(&quot;geometrycollection(&quot;, &quot;)&quot;)</span>
<span class="nc" id="L157">                case _                              =&gt; FunctionTransform(&quot;geometry(&quot;, &quot;)&quot;)</span>
              }

<span class="nc" id="L160">            case _ =&gt; throw new IllegalStateException(s&quot;Unexpected binding: $bindings&quot;)</span>
          }
<span class="nc" id="L162">          i += 1</span>
<span class="nc" id="L163">          BasicField(d.getLocalName, Some(TryExpression(Expression(transform.apply(i)), LiteralNull)))</span>
        }

<span class="nc" id="L166">        val options = DelimitedTextOptions(Some(1), CharNotSpecified, CharNotSpecified, None,</span>
<span class="nc" id="L167">          SimpleFeatureValidator.default, ParseMode.Default, ErrorMode(), StandardCharsets.UTF_8)</span>

<span class="nc" id="L169">        val config = configConvert.to(converterConfig)</span>
<span class="nc" id="L170">            .withFallback(fieldConvert.to(fields.toSeq))</span>
<span class="nc" id="L171">            .withFallback(optsConvert.to(options))</span>
            .toConfig

<span class="nc" id="L174">        (sft.getOrElse(schema), config)</span>
      }
    }
  }
}

<span class="nc" id="L180">object DelimitedTextConverterFactory {</span>

<span class="nc" id="L182">  val TypeToProcess = &quot;delimited-text&quot;</span>

<span class="nc" id="L184">  object DelimitedTextConfigConvert extends ConverterConfigConvert[DelimitedTextConfig] {</span>

    override protected def decodeConfig(
        cur: ConfigObjectCursor,
        `type`: String,
        idField: Option[Expression],
        caches: Map[String, Config],
        userData: Map[String, Expression]): Either[ConfigReaderFailures, DelimitedTextConfig] = {
      for {
<span class="nc" id="L193">        name   &lt;- converterName(cur).right</span>
<span class="nc" id="L194">        format &lt;- cur.atKey(&quot;format&quot;).right.flatMap(_.asString).right</span>
      } yield {
<span class="nc" id="L196">        DelimitedTextConfig(`type`, name, format, idField, caches, userData)</span>
      }
    }

    override protected def encodeConfig(
        config: DelimitedTextConfig,
        base: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L203">      base.put(&quot;format&quot;, config.format)</span>
    }
  }

<span class="nc" id="L207">  object DelimitedTextOptionsConvert extends ConverterOptionsConvert[DelimitedTextOptions] {</span>
    override protected def decodeOptions(
        cur: ConfigObjectCursor,
        validators: Seq[String],
        parseMode: ParseMode,
        errorMode: ErrorMode,
        encoding: Charset): Either[ConfigReaderFailures, DelimitedTextOptions] = {
      def option[T](key: String, reader: ConfigReader[T]): Either[ConfigReaderFailures, Option[T]] = {
<span class="nc" id="L215">        val value = cur.atKeyOrUndefined(key)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (value.isUndefined) { Right(None) } else { reader.from(value).right.map(Option.apply) }</span>
      }

      def optionalChar(key: String): Either[ConfigReaderFailures, OptionalChar] = {
<span class="nc" id="L220">        val value = cur.atKeyOrUndefined(key)</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (value.isUndefined) { Right(CharNotSpecified) } else {</span>
<span class="nc" id="L222">          PrimitiveConvert.charConfigReader.from(value) match {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            case Right(c) =&gt; Right(CharEnabled(c))</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            case Left(failures) =&gt;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">              if (PrimitiveConvert.stringConfigReader.from(value).right.exists(_.isEmpty)) {</span>
<span class="nc" id="L226">                Right(CharDisabled)</span>
              } else {
<span class="nc" id="L228">                Left(failures)</span>
              }
          }
        }
      }

      for {
<span class="nc" id="L235">        skipLines &lt;- option(&quot;skip-lines&quot;, PrimitiveConvert.intConfigReader).right</span>
<span class="nc" id="L236">        quote     &lt;- optionalChar(&quot;quote&quot;).right</span>
<span class="nc" id="L237">        escape    &lt;- optionalChar(&quot;escape&quot;).right</span>
<span class="nc" id="L238">        delimiter &lt;- option(&quot;delimiter&quot;, PrimitiveConvert.charConfigReader).right</span>
      } yield {
<span class="nc" id="L240">        DelimitedTextOptions(skipLines, quote, escape, delimiter, validators, parseMode, errorMode, encoding)</span>
      }
    }

    override protected def encodeOptions(options: DelimitedTextOptions, base: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L245">      options.skipLines.foreach(o =&gt; base.put(&quot;skip-lines&quot;, Int.box(o)))</span>
<span class="nc" id="L246">      options.quote.foreach(o =&gt; base.put(&quot;quote&quot;, Char.box(o)))</span>
<span class="nc" id="L247">      options.escape.foreach(o =&gt; base.put(&quot;escape&quot;, Char.box(o)))</span>
<span class="nc" id="L248">      options.delimiter.foreach(o =&gt; base.put(&quot;delimiter&quot;, Char.box(o)))</span>
    }
  }
<span class="nc" id="L251">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>