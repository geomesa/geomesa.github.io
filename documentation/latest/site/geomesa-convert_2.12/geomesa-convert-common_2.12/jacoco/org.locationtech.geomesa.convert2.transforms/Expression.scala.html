<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Expression.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2.transforms</a> &gt; <span class="el_source">Expression.scala</span></div><h1>Expression.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2.transforms

import org.locationtech.geomesa.convert.EvaluationContext
import org.locationtech.geomesa.convert.EvaluationContext.{ContextDependent, FieldAccessor, NullFieldAccessor}
import org.locationtech.geomesa.convert2.Field

import scala.util.Try

<span class="nc" id="L17">sealed trait Expression extends ContextDependent[Expression] {</span>

  /**
   * Evaluate the expression against an input row
   *
   * @param args arguments
   * @return
   */
  def apply(args: Array[_ &lt;: AnyRef]): AnyRef

  /**
    * Gets the field dependencies that this expr relies on
    *
    * @param stack current field stack, used to detect circular dependencies
    * @param fieldMap fields lookup
    * @return dependencies
    */
  def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field]

  /**
    * Any nested expressions
    *
    * @return
    */
<span class="nc" id="L41">  def children(): Seq[Expression] = Seq.empty</span>

  /**
   * Visitor pattern for processing an expression tree
   *
   * @param visitor visitor
   * @return
   */
  def accept[T](visitor: ExpressionVisitor[T]): T
}

<span class="nc" id="L52">object Expression {</span>

<span class="nc" id="L54">  def apply(e: String): Expression = ExpressionParser.parse(e)</span>

  /**
    * Returns the list of unique expressions in the input, including any descendants
    *
    * @param expressions expressions
    * @return
    */
  def flatten(expressions: Seq[Expression]): Seq[Expression] = {
<span class="nc" id="L63">    val toCheck = scala.collection.mutable.Queue(expressions: _*)</span>
<span class="nc" id="L64">    val result = scala.collection.mutable.Set.empty[Expression]</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">    while (toCheck.nonEmpty) {</span>
<span class="nc" id="L66">      val next = toCheck.dequeue()</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">      if (result.add(next)) {</span>
<span class="nc" id="L68">        toCheck ++= next.children()</span>
      }
    }
<span class="nc" id="L71">    result.toSeq</span>
  }

<span class="nc" id="L74">  sealed trait Literal[T &lt;: AnyRef] extends Expression {</span>
    def value: T
<span class="nc" id="L76">    override def apply(args: Array[_ &lt;: AnyRef]): AnyRef = value</span>
<span class="nc" id="L77">    override def withContext(ec: EvaluationContext): Expression = this</span>
<span class="nc" id="L78">    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] = Set.empty</span>
<span class="nc" id="L79">    override def toString: String = String.valueOf(value)</span>
<span class="nc" id="L80">    override def accept[V](visitor: ExpressionVisitor[V]): V = visitor.visit(this)</span>
  }

<span class="nc bnc" id="L83" title="All 18 branches missed.">  case class LiteralString(value: String) extends Literal[String] {</span>
<span class="nc" id="L84">    override def toString: String = s&quot;'${String.valueOf(value)}'&quot;</span>
  }

<span class="nc bnc" id="L87" title="All 18 branches missed.">  case class LiteralInt(value: Integer) extends Literal[Integer]</span>

<span class="nc bnc" id="L89" title="All 18 branches missed.">  case class LiteralLong(value: java.lang.Long) extends Literal[java.lang.Long]</span>

<span class="nc bnc" id="L91" title="All 14 branches missed.">  case class LiteralFloat(value: java.lang.Float) extends Literal[java.lang.Float]</span>

<span class="nc bnc" id="L93" title="All 14 branches missed.">  case class LiteralDouble(value: java.lang.Double) extends Literal[java.lang.Double]</span>

<span class="nc bnc" id="L95" title="All 18 branches missed.">  case class LiteralBoolean(value: java.lang.Boolean) extends Literal[java.lang.Boolean]</span>

<span class="nc bnc" id="L97" title="All 14 branches missed.">  case class LiteralAny(value: AnyRef) extends Literal[AnyRef]</span>

<span class="nc" id="L99">  case object LiteralNull extends Literal[AnyRef] { override def value: AnyRef = null }</span>

<span class="nc" id="L101">  abstract class CastExpression(e: Expression, binding: String) extends Expression {</span>
    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] =
<span class="nc" id="L103">      e.dependencies(stack, fieldMap)</span>
<span class="nc" id="L104">    override def children(): Seq[Expression] = Seq(e)</span>
<span class="nc" id="L105">    override def toString: String = s&quot;$e::$binding&quot;</span>
  }

<span class="nc bnc" id="L108" title="All 18 branches missed.">  case class CastToInt(e: Expression) extends CastExpression(e, &quot;int&quot;) {</span>
    override def apply(args: Array[_ &lt;: AnyRef]): Integer = {
<span class="nc" id="L110">      e.apply(args) match {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        case n: Integer          =&gt; n</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        case n: java.lang.Number =&gt; n.intValue()</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        case n: String           =&gt; n.toInt</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        case n: AnyRef           =&gt; n.toString.toInt</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        case null                =&gt; throw new NullPointerException(&quot;Trying to cast 'null' to int&quot;)</span>
      }
    }
    override def withContext(ec: EvaluationContext): Expression = {
<span class="nc" id="L119">      val ewc = e.withContext(ec)</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">      if (e.eq(ewc)) { this } else { CastToInt(ewc) }</span>
    }
<span class="nc" id="L122">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
  }

<span class="nc bnc" id="L125" title="All 18 branches missed.">  case class CastToLong(e: Expression) extends CastExpression(e, &quot;long&quot;) {</span>
    override def apply(args: Array[_ &lt;: AnyRef]): java.lang.Long = {
<span class="nc" id="L127">      e.apply(args) match {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        case n: java.lang.Long   =&gt; n</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        case n: java.lang.Number =&gt; n.longValue()</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        case n: String           =&gt; n.toLong</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        case n: AnyRef           =&gt; n.toString.toLong</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        case null                =&gt; throw new NullPointerException(&quot;Trying to cast 'null' to long&quot;)</span>
      }
    }
    override def withContext(ec: EvaluationContext): Expression = {
<span class="nc" id="L136">      val ewc = e.withContext(ec)</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">      if (e.eq(ewc)) { this } else { CastToLong(ewc) }</span>
    }
<span class="nc" id="L139">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
  }

<span class="nc bnc" id="L142" title="All 18 branches missed.">  case class CastToFloat(e: Expression) extends CastExpression(e, &quot;float&quot;) {</span>
    override def apply(args: Array[_ &lt;: AnyRef]): java.lang.Float = {
<span class="nc" id="L144">      e.apply(args) match {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        case n: java.lang.Float  =&gt; n</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        case n: java.lang.Number =&gt; n.floatValue()</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        case n: String           =&gt; n.toFloat</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        case n: AnyRef           =&gt; n.toString.toFloat</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        case null                =&gt; throw new NullPointerException(&quot;Trying to cast 'null' to float&quot;)</span>
      }
    }
    override def withContext(ec: EvaluationContext): Expression = {
<span class="nc" id="L153">      val ewc = e.withContext(ec)</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      if (e.eq(ewc)) { this } else { CastToFloat(ewc) }</span>
    }
<span class="nc" id="L156">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
  }

<span class="nc bnc" id="L159" title="All 18 branches missed.">  case class CastToDouble(e: Expression) extends CastExpression(e, &quot;double&quot;) {</span>
    override def apply(args: Array[_ &lt;: AnyRef]): java.lang.Double = {
<span class="nc" id="L161">      e.apply(args) match {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        case n: java.lang.Double =&gt; n</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        case n: java.lang.Number =&gt; n.doubleValue()</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        case n: String           =&gt; n.toDouble</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        case n: AnyRef           =&gt; n.toString.toDouble</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        case null                =&gt; throw new NullPointerException(&quot;Trying to cast 'null' to double&quot;)</span>
      }
    }
    override def withContext(ec: EvaluationContext): Expression = {
<span class="nc" id="L170">      val ewc = e.withContext(ec)</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      if (e.eq(ewc)) { this } else { CastToDouble(ewc) }</span>
    }
<span class="nc" id="L173">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
  }

<span class="nc bnc" id="L176" title="All 18 branches missed.">  case class CastToBoolean(e: Expression) extends CastExpression(e, &quot;boolean&quot;) {</span>
    override def apply(args: Array[_ &lt;: AnyRef]): java.lang.Boolean = {
<span class="nc" id="L178">      e.apply(args) match {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        case b: java.lang.Boolean =&gt; b</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        case b: String            =&gt; b.toBoolean</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        case b: AnyRef            =&gt; b.toString.toBoolean</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        case null                 =&gt; throw new NullPointerException(&quot;Trying to cast 'null' to boolean&quot;)</span>
      }
    }
    override def withContext(ec: EvaluationContext): Expression = {
<span class="nc" id="L186">      val ewc = e.withContext(ec)</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">      if (e.eq(ewc)) { this } else { CastToBoolean(ewc) }</span>
    }
<span class="nc" id="L189">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
  }

<span class="nc bnc" id="L192" title="All 18 branches missed.">  case class CastToString(e: Expression) extends CastExpression(e, &quot;string&quot;) {</span>
    override def apply(args: Array[_ &lt;: AnyRef]): String = {
<span class="nc" id="L194">      e.apply(args) match {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        case s: String =&gt; s</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        case s: AnyRef =&gt; s.toString</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        case null      =&gt; throw new NullPointerException(&quot;Trying to cast 'null' to String&quot;)</span>
      }
    }
    override def withContext(ec: EvaluationContext): Expression = {
<span class="nc" id="L201">      val ewc = e.withContext(ec)</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">      if (e.eq(ewc)) { this } else { CastToString(ewc) }</span>
    }
<span class="nc" id="L204">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
  }

<span class="nc bnc" id="L207" title="All 14 branches missed.">  case class Column(i: Int) extends Expression {</span>
<span class="nc" id="L208">    override def apply(args: Array[_ &lt;: AnyRef]): AnyRef = args(i)</span>
<span class="nc" id="L209">    override def withContext(ec: EvaluationContext): Expression = this</span>
<span class="nc" id="L210">    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] = Set.empty</span>
<span class="nc" id="L211">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
<span class="nc" id="L212">    override def toString: String = s&quot;$$$i&quot;</span>
  }

<span class="nc bnc" id="L215" title="All 25 branches missed.">  case class FieldLookup(n: String, accessor: FieldAccessor = NullFieldAccessor) extends Expression {</span>
<span class="nc" id="L216">    override def apply(args: Array[_ &lt;: AnyRef]): AnyRef = accessor.apply()</span>
<span class="nc" id="L217">    override def withContext(ec: EvaluationContext): Expression = FieldLookup(n, ec.accessor(n))</span>
    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] = {
<span class="nc" id="L219">      fieldMap.get(n) match {</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        case None =&gt; Set.empty</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        case Some(field) =&gt;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">          if (stack.contains(field)) {</span>
<span class="nc" id="L223">            throw new IllegalArgumentException(s&quot;Cyclical dependency detected in field $field&quot;)</span>
          } else {
<span class="nc" id="L225">            field.transforms.toSeq.flatMap(_.dependencies(stack + field, fieldMap)).toSet + field</span>
          }
      }
    }
<span class="nc" id="L229">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
<span class="nc" id="L230">    override def toString: String = s&quot;$$$n&quot;</span>
  }

<span class="nc bnc" id="L233" title="All 18 branches missed.">  case class RegexExpression(s: String) extends Expression {</span>
<span class="nc" id="L234">    private val compiled = s.r</span>
<span class="nc" id="L235">    override def apply(args: Array[_ &lt;: AnyRef]): AnyRef = compiled</span>
<span class="nc" id="L236">    override def withContext(ec: EvaluationContext): Expression = this</span>
<span class="nc" id="L237">    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] = Set.empty</span>
<span class="nc" id="L238">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
<span class="nc" id="L239">    override def toString: String = s&quot;$s::r&quot;</span>
  }

<span class="nc bnc" id="L242" title="All 21 branches missed.">  case class FunctionExpression(f: TransformerFunction, arguments: Array[Expression]) extends Expression {</span>

<span class="nc" id="L244">    @volatile private var contextDependent: Int = -1</span>

<span class="nc" id="L246">    private def this(f: TransformerFunction, arguments: Array[Expression], contextDependent: Int) = {</span>
<span class="nc" id="L247">      this(f, arguments)</span>
<span class="nc" id="L248">      this.contextDependent = contextDependent</span>
    }

<span class="nc" id="L251">    override def apply(args: Array[_ &lt;: AnyRef]): AnyRef = f.apply(arguments.map(_.apply(args)))</span>

    override def withContext(ec: EvaluationContext): Expression = {
      // this code is thread-safe, in that it will ensure correctness, but does not guarantee
      // that the dependency check is only performed once
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (contextDependent == 0) { this } else {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        lazy val fwc = f.withContext(ec)</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        lazy val awc = arguments.map(_.withContext(ec))</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (contextDependent == 1) {</span>
<span class="nc" id="L260">          new FunctionExpression(fwc, awc, 1)</span>
        } else {
<span class="nc bnc" id="L262" title="All 2 branches missed.">          if (!fwc.eq(f)) {</span>
<span class="nc" id="L263">            contextDependent = 1</span>
          } else {
<span class="nc" id="L265">            var i = 0</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            while (i &lt; arguments.length) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">              if (!awc(i).eq(arguments(i))) {</span>
<span class="nc" id="L268">                contextDependent = 1</span>
<span class="nc" id="L269">                i = Int.MaxValue</span>
              } else {
<span class="nc" id="L271">                i += 1</span>
              }
            }
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (i == arguments.length) {</span>
<span class="nc" id="L275">              contextDependent = 0</span>
            }
          }
<span class="nc bnc" id="L278" title="All 2 branches missed.">          if (contextDependent == 0) { this } else { new FunctionExpression(fwc, awc, 1) }</span>
        }
      }
    }

    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] =
<span class="nc" id="L284">      arguments.flatMap(_.dependencies(stack, fieldMap)).toSet</span>
<span class="nc" id="L285">    override def children(): Seq[Expression] = arguments</span>
<span class="nc" id="L286">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
<span class="nc" id="L287">    override def toString: String = s&quot;${f.names.head}${arguments.mkString(&quot;(&quot;, &quot;,&quot;, &quot;)&quot;)}&quot;</span>
  }

<span class="nc bnc" id="L290" title="All 25 branches missed.">  case class TryExpression(toTry: Expression, fallback: Expression) extends Expression {</span>

<span class="nc" id="L292">    @volatile private var contextDependent: Int = -1</span>

<span class="nc" id="L294">    private def this(toTry: Expression, fallback: Expression, contextDependent: Int) = {</span>
<span class="nc" id="L295">      this(toTry, fallback)</span>
<span class="nc" id="L296">      this.contextDependent = contextDependent</span>
    }

<span class="nc" id="L299">    override def apply(args: Array[_ &lt;: AnyRef]): AnyRef = Try(toTry.apply(args)).getOrElse(fallback.apply(args))</span>

    override def withContext(ec: EvaluationContext): Expression = {
      // this code is thread-safe, in that it will ensure correctness, but does not guarantee
      // that the dependency check is only performed once
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (contextDependent == 0) { this } else {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        lazy val twc = toTry.withContext(ec)</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        lazy val fwc = fallback.withContext(ec)</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (contextDependent == 1) {</span>
<span class="nc" id="L308">          new TryExpression(twc, fwc, 1)</span>
        } else {
<span class="nc bnc" id="L310" title="All 4 branches missed.">          contextDependent = if (twc.eq(toTry) &amp;&amp; fwc.eq(fallback)) { 0 } else { 1 }</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">          if (contextDependent == 0) { this } else { new TryExpression(twc, fwc, 1) }</span>
        }
      }
    }

    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] =
<span class="nc" id="L317">      toTry.dependencies(stack, fieldMap) ++ fallback.dependencies(stack, fieldMap)</span>
<span class="nc" id="L318">    override def children(): Seq[Expression] = Seq(toTry, fallback)</span>
<span class="nc" id="L319">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
<span class="nc" id="L320">    override def toString: String = s&quot;try($toTry,$fallback)&quot;</span>
  }

<span class="nc bnc" id="L323" title="All 18 branches missed.">  case class WithDefaultExpression(expressions: Seq[Expression]) extends Expression {</span>

<span class="nc bnc" id="L325" title="All 2 branches missed.">    require(expressions.lengthCompare(1) &gt; 0)</span>

<span class="nc" id="L327">    @volatile private var contextDependent: Int = -1</span>

<span class="nc" id="L329">    private def this(expressions: Seq[Expression], contextDependent: Int) = {</span>
<span class="nc" id="L330">      this(expressions)</span>
<span class="nc" id="L331">      this.contextDependent = contextDependent</span>
    }

<span class="nc bnc" id="L334" title="All 2 branches missed.">    override def apply(args: Array[_ &lt;: AnyRef]): AnyRef = {</span>
<span class="nc" id="L335">      expressions.foreach { e =&gt;</span>
<span class="nc" id="L336">        val result = e.apply(args)</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L338">          return result</span>
        }
      }
<span class="nc" id="L341">      null</span>
    }

    override def withContext(ec: EvaluationContext): Expression = {
      // this code is thread-safe, in that it will ensure correctness, but does not guarantee
      // that the dependency check is only performed once
<span class="nc bnc" id="L347" title="All 2 branches missed.">      if (contextDependent == 0) { this } else {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        lazy val ewc = expressions.map(_.withContext(ec))</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (contextDependent == 1) {</span>
<span class="nc" id="L350">          new WithDefaultExpression(ewc, 1)</span>
        } else {
<span class="nc bnc" id="L352" title="All 6 branches missed.">          contextDependent = if (ewc.zip(expressions).forall { case (e1, e2) =&gt; e1.eq(e2) }) { 0 } else { 1 }</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">          if (contextDependent == 0) { this } else { new WithDefaultExpression(ewc, 1) }</span>
        }
      }
    }

    override def dependencies(stack: Set[Field], fieldMap: Map[String, Field]): Set[Field] =
<span class="nc" id="L359">      expressions.flatMap(_.dependencies(stack, fieldMap)).toSet</span>
<span class="nc" id="L360">    override def children(): Seq[Expression] = expressions</span>
<span class="nc" id="L361">    override def accept[T](visitor: ExpressionVisitor[T]): T = visitor.visit(this)</span>
<span class="nc" id="L362">    override def toString: String = s&quot;withDefault(${expressions.mkString(&quot;,&quot;)})&quot;</span>
  }
<span class="nc" id="L364">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>