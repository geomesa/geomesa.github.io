<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScriptingFunctionFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2.transforms</a> &gt; <span class="el_source">ScriptingFunctionFactory.scala</span></div><h1>ScriptingFunctionFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2.transforms

import com.typesafe.scalalogging.LazyLogging
import org.apache.commons.io.filefilter.TrueFileFilter
import org.apache.commons.io.{FileUtils, FilenameUtils, IOUtils}
import org.locationtech.geomesa.convert2.transforms.TransformerFunction.NamedTransformerFunction
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty

import java.io.File
import java.net.URI
import java.nio.file.FileSystems
import java.util.Collections
import javax.script.{Invocable, ScriptContext, ScriptEngine, ScriptEngineManager}
import scala.collection.JavaConverters._

/**
  * Provides TransformerFunctions that execute javax.scripts compatible functions defined
  * on the classpath or in external directories.  Scripting languages are determined by
  * the extension of the file.  For instance, 'name.js' will be interpreted as a javascript file.
  */
<span class="nc bnc" id="L29" title="All 4 branches missed.">class ScriptingFunctionFactory extends TransformerFunctionFactory with LazyLogging {</span>

  import ScriptingFunctionFactory._

<span class="nc bnc" id="L33" title="All 4 branches missed.">  override lazy val functions: Seq[TransformerFunction] = {</span>
<span class="nc" id="L34">    val curClassLoader = Thread.currentThread().getContextClassLoader</span>
<span class="nc" id="L35">    val scriptURIs = loadScriptsFromEnvironment ++ loadScripts(curClassLoader)</span>

<span class="nc bnc" id="L37" title="All 2 branches missed.">    logger.debug(s&quot;Script URIs found: ${scriptURIs.map(_.toString).mkString(&quot;,&quot;)}&quot;)</span>
<span class="nc" id="L38">    val mgr = new ScriptEngineManager()</span>
<span class="nc" id="L39">    scriptURIs</span>
<span class="nc" id="L40">      .map { f =&gt;</span>
        // Always use the scheme specific part for URIs
<span class="nc" id="L42">        val ext = FilenameUtils.getExtension(f.getSchemeSpecificPart)</span>
<span class="nc" id="L43">        (f, ext)</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">      }.groupBy { case (_, ext) =&gt; ext }</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      .flatMap { case (ext, files) =&gt;</span>
<span class="nc" id="L46">        val engine = Option(mgr.getEngineByExtension(ext))</span>
<span class="nc" id="L47">        engine.map { e =&gt; evaluateScriptsForEngine(curClassLoader, files, e, ext) }.getOrElse(Seq())</span>
      }.toList
  }

  private def evaluateScriptsForEngine(loader: ClassLoader, files: Seq[(URI, String)], e: ScriptEngine, ext: String) = {
<span class="nc bnc" id="L52" title="All 2 branches missed.">    files.foreach { case (f, _) =&gt; evalScriptFile(loader, e, f) }</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">    e.getBindings(ScriptContext.ENGINE_SCOPE).asScala.map { case (k, v) =&gt;</span>
<span class="nc" id="L54">      new ScriptTransformerFn(ext, k, e.asInstanceOf[Invocable])</span>
    }
  }

  def evalScriptFile(loader: ClassLoader, e: ScriptEngine, f: URI): AnyRef =
<span class="nc" id="L59">    e.eval(IOUtils.toString(f, &quot;UTF-8&quot;))</span>
}

<span class="nc bnc" id="L62" title="All 4 branches missed.">object ScriptingFunctionFactory extends LazyLogging {</span>

<span class="nc" id="L64">  val ConvertScriptsPathProperty = &quot;geomesa.convert.scripts.path&quot;</span>
<span class="nc" id="L65">  val ConvertScriptsClassPath    = &quot;geomesa-convert-scripts&quot;</span>

<span class="nc" id="L67">  val ConvertScriptsPath: SystemProperty = SystemProperty(ConvertScriptsPathProperty)</span>

  /**
    * &lt;p&gt;Load scripts from the environment using the property &quot;geomesa.convert.scripts.path&quot;
    * Entries are colon (:) separated. Entries can be files or directories. Directories will
    * be recursively searched for script files. The extension of script files defines what
    * kind of script they are (e.g. js = javascript)&lt;/p&gt;
    */
  def loadScriptsFromEnvironment: Seq[URI] = {
<span class="nc" id="L76">    ConvertScriptsPath.option.toSeq.flatMap(_.split(&quot;:&quot;)).flatMap { path =&gt;</span>
<span class="nc" id="L77">      val f = new File(path)</span>
<span class="nc bnc" id="L78" title="All 4 branches missed.">      if (!f.exists() || !f.canRead) {</span>
<span class="nc" id="L79">        Seq.empty</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">      } else if (f.isDirectory) {</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (!f.canExecute) { Seq.empty } else {</span>
<span class="nc" id="L82">          FileUtils.listFiles(f, TrueFileFilter.TRUE, TrueFileFilter.TRUE).asScala.map(_.toURI)</span>
        }
      } else {
<span class="nc" id="L85">        Seq(f.toURI)</span>
      }
    }
  }

  /**
    * Load scripts from the resource geomesa-convert-scripts from a classloader. To use this
    * create a folder in the jar named &quot;geomesa-convert-scripts&quot; and place script files
    * within that directory.
    *
    * @param loader
    * @return
    */
  def loadScripts(loader: ClassLoader): Seq[URI] = {
<span class="nc" id="L99">    Option(loader.getResources(ConvertScriptsClassPath + &quot;/&quot;).asScala).toSeq.flatten.flatMap { url =&gt;</span>
<span class="nc" id="L100">      val uri = url.toURI</span>
<span class="nc" id="L101">      uri.getScheme match {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        case &quot;jar&quot; =&gt;</span>
<span class="nc" id="L103">          val fs = FileSystems.newFileSystem(uri, Collections.emptyMap[String, AnyRef](), loader)</span>
<span class="nc" id="L104">          val p = fs.getPath(ConvertScriptsClassPath + &quot;/&quot;)</span>
<span class="nc" id="L105">          val uris = java.nio.file.Files.walk(p).iterator().asScala.toSeq</span>
<span class="nc" id="L106">          val files = uris.filterNot(java.nio.file.Files.isDirectory(_)).map(_.toUri)</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">          logger.debug(s&quot;Loaded scripts ${files.mkString(&quot;,&quot;)} from jar ${uri.toString}&quot;)</span>
<span class="nc" id="L108">          files</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        case &quot;file&quot; =&gt;</span>
<span class="nc" id="L110">          IOUtils.readLines(url.openStream(), &quot;UTF-8&quot;)</span>
<span class="nc" id="L111">            .asScala.map { s =&gt; loader.getResource(s&quot;$ConvertScriptsClassPath/$s&quot;).toURI }</span>
      }
    }
  }

<span class="nc" id="L116">  class ScriptTransformerFn(ext: String, name: String, engine: Invocable)</span>
<span class="nc" id="L117">      extends NamedTransformerFunction(Seq(s&quot;$ext:$name&quot;)) {</span>
    override def apply(args: Array[AnyRef]): AnyRef =
<span class="nc" id="L119">      engine.asInstanceOf[Invocable].invokeFunction(name, args: _*)</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>