<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateFunctionFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2.transforms</a> &gt; <span class="el_source">DateFunctionFactory.scala</span></div><h1>DateFunctionFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2.transforms

import org.locationtech.geomesa.convert2.transforms.DateFunctionFactory.{CustomFormatDateParser, DateToString, StandardDateParser}
import org.locationtech.geomesa.convert2.transforms.Expression.LiteralString
import org.locationtech.geomesa.convert2.transforms.TransformerFunction.NamedTransformerFunction
import org.locationtech.geomesa.utils.text.DateParsing

import java.time.ZoneOffset
import java.time.format.DateTimeFormatter
import java.util.{Date, Locale}

<span class="nc" id="L20">class DateFunctionFactory extends TransformerFunctionFactory {</span>

  import java.time.format.{DateTimeFormatter, DateTimeFormatterBuilder}
  import java.time.temporal.ChronoField
  import java.time.{ZoneOffset, ZonedDateTime}

  override def functions: Seq[TransformerFunction] =
<span class="nc" id="L27">    Seq(now, customFormatDateParser, datetime, basicDateTimeNoMillis, basicIsoDate, basicDateTime, isoDate,</span>
<span class="nc" id="L28">      isoLocalDate, isoLocalDateTime, isoOffsetDateTime, isoDateTime, dateHourMinuteSecondMillis,</span>
<span class="nc" id="L29">      millisToDate, secsToDate, dateToString, dateToMillis)</span>

<span class="nc" id="L31">  private val now = TransformerFunction(&quot;now&quot;) { _ =&gt;</span>
<span class="nc" id="L32">    Date.from(ZonedDateTime.now(ZoneOffset.UTC).toInstant)</span>
  }

<span class="nc" id="L35">  private val millisToDate = TransformerFunction.pure(&quot;millisToDate&quot;) { args =&gt;</span>
<span class="nc" id="L36">    args(0) match {</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">      case null =&gt; null</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">      case d: Number =&gt; new Date(d.longValue)</span>
<span class="nc" id="L39">      case d =&gt; throw new IllegalArgumentException(s&quot;Invalid millisecond: $d&quot;)</span>
    }
  }

<span class="nc" id="L43">  private val secsToDate = TransformerFunction.pure(&quot;secsToDate&quot;) { args =&gt;</span>
<span class="nc" id="L44">    args(0) match {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      case null =&gt; null</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">      case d: Number =&gt; new Date(d.longValue * 1000L)</span>
<span class="nc" id="L47">      case d =&gt; throw new IllegalArgumentException(s&quot;Invalid second: $d&quot;)</span>
    }
  }

  // yyyy-MM-dd'T'HH:mm:ss.SSSZZ (ZZ is time zone with colon)
<span class="nc" id="L52">  private val datetime = new StandardDateParser(Seq(&quot;dateTime&quot;, &quot;datetime&quot;)) {</span>
<span class="nc" id="L53">    override val format: DateTimeFormatter =</span>
<span class="nc" id="L54">      new DateTimeFormatterBuilder()</span>
          .parseCaseInsensitive()
<span class="nc" id="L56">          .append(DateTimeFormatter.ISO_LOCAL_DATE)</span>
          .parseLenient()
<span class="nc" id="L58">          .appendLiteral('T')</span>
<span class="nc" id="L59">          .appendValue(ChronoField.HOUR_OF_DAY, 2)</span>
<span class="nc" id="L60">          .appendLiteral(':')</span>
<span class="nc" id="L61">          .appendValue(ChronoField.MINUTE_OF_HOUR, 2)</span>
<span class="nc" id="L62">          .appendLiteral(':')</span>
<span class="nc" id="L63">          .appendValue(ChronoField.SECOND_OF_MINUTE, 2)</span>
<span class="nc" id="L64">          .appendFraction(ChronoField.MILLI_OF_SECOND, 3, 3, true)</span>
          .optionalStart()
          .appendOffsetId()
<span class="nc" id="L67">          .toFormatter(Locale.US)</span>
<span class="nc" id="L68">          .withZone(ZoneOffset.UTC)</span>
  }

  // yyyyMMdd
<span class="nc" id="L72">  private val basicIsoDate = new StandardDateParser(Seq(&quot;basicIsoDate&quot;, &quot;basicDate&quot;)) {</span>
<span class="nc" id="L73">    override val format: DateTimeFormatter = DateTimeFormatter.BASIC_ISO_DATE.withZone(ZoneOffset.UTC)</span>
  }

  // yyyy-MM-dd
<span class="nc" id="L77">  private val isoDate = new StandardDateParser(Seq(&quot;isoDate&quot;)) {</span>
<span class="nc" id="L78">    override val format: DateTimeFormatter = DateTimeFormatter.ISO_DATE.withZone(ZoneOffset.UTC)</span>
  }

  // yyyy-MM-dd
<span class="nc" id="L82">  private val isoLocalDate = new StandardDateParser(Seq(&quot;isoLocalDate&quot;)) {</span>
<span class="nc" id="L83">    override val format: DateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE.withZone(ZoneOffset.UTC)</span>
  }

  // yyyy-MM-dd'T'HH:mm:ss
<span class="nc" id="L87">  private val isoLocalDateTime = new StandardDateParser(Seq(&quot;isoLocalDateTime&quot;)) {</span>
<span class="nc" id="L88">    override val format: DateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME.withZone(ZoneOffset.UTC)</span>
  }

  // yyyy-MM-dd'T'HH:mm:ssZ
<span class="nc" id="L92">  private val isoOffsetDateTime = new StandardDateParser(Seq(&quot;isoOffsetDateTime&quot;)) {</span>
<span class="nc" id="L93">    override val format: DateTimeFormatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME.withZone(ZoneOffset.UTC)</span>
  }

  // yyyy-MM-dd'T'HH:mm:ss
<span class="nc" id="L97">  private val isoDateTime = new StandardDateParser(Seq(&quot;isoDateTime&quot;)) {</span>
<span class="nc" id="L98">    override val format: DateTimeFormatter = DateTimeFormatter.ISO_DATE_TIME.withZone(ZoneOffset.UTC)</span>
  }

  // yyyyMMdd'T'HHmmss.SSSZ
<span class="nc" id="L102">  private val basicDateTime = new StandardDateParser(Seq(&quot;basicDateTime&quot;)) {</span>
<span class="nc" id="L103">    override val format: DateTimeFormatter =</span>
<span class="nc" id="L104">      new DateTimeFormatterBuilder()</span>
          .parseCaseInsensitive()
<span class="nc" id="L106">          .appendValue(ChronoField.YEAR, 4)</span>
<span class="nc" id="L107">          .appendValue(ChronoField.MONTH_OF_YEAR, 2)</span>
<span class="nc" id="L108">          .appendValue(ChronoField.DAY_OF_MONTH, 2)</span>
<span class="nc" id="L109">          .appendLiteral('T')</span>
<span class="nc" id="L110">          .appendValue(ChronoField.HOUR_OF_DAY, 2)</span>
<span class="nc" id="L111">          .appendValue(ChronoField.MINUTE_OF_HOUR, 2)</span>
<span class="nc" id="L112">          .appendValue(ChronoField.SECOND_OF_MINUTE, 2)</span>
<span class="nc" id="L113">          .appendFraction(ChronoField.MILLI_OF_SECOND, 3, 3, true)</span>
          .optionalStart()
          .appendOffsetId()
<span class="nc" id="L116">          .toFormatter(Locale.US)</span>
<span class="nc" id="L117">          .withZone(ZoneOffset.UTC)</span>
  }

  // yyyyMMdd'T'HHmmssZ
<span class="nc" id="L121">  private val basicDateTimeNoMillis = new StandardDateParser(Seq(&quot;basicDateTimeNoMillis&quot;)) {</span>
<span class="nc" id="L122">    override val format: DateTimeFormatter =</span>
<span class="nc" id="L123">      new DateTimeFormatterBuilder()</span>
          .parseCaseInsensitive()
<span class="nc" id="L125">          .appendValue(ChronoField.YEAR, 4)</span>
<span class="nc" id="L126">          .appendValue(ChronoField.MONTH_OF_YEAR, 2)</span>
<span class="nc" id="L127">          .appendValue(ChronoField.DAY_OF_MONTH, 2)</span>
<span class="nc" id="L128">          .appendLiteral('T')</span>
<span class="nc" id="L129">          .appendValue(ChronoField.HOUR_OF_DAY, 2)</span>
<span class="nc" id="L130">          .appendValue(ChronoField.MINUTE_OF_HOUR, 2)</span>
<span class="nc" id="L131">          .appendValue(ChronoField.SECOND_OF_MINUTE, 2)</span>
          .optionalStart()
          .appendOffsetId()
<span class="nc" id="L134">          .toFormatter(Locale.US)</span>
<span class="nc" id="L135">          .withZone(ZoneOffset.UTC)</span>
  }

  // yyyy-MM-dd'T'HH:mm:ss.SSS
<span class="nc" id="L139">  private val dateHourMinuteSecondMillis =</span>
<span class="nc" id="L140">    new StandardDateParser(Seq(&quot;dateHourMinuteSecondMillis&quot;)) {</span>
<span class="nc" id="L141">      override val format: DateTimeFormatter =</span>
<span class="nc" id="L142">        new DateTimeFormatterBuilder()</span>
            .parseCaseInsensitive()
<span class="nc" id="L144">            .append(DateTimeFormatter.ISO_LOCAL_DATE)</span>
            .parseLenient()
<span class="nc" id="L146">            .appendLiteral('T')</span>
<span class="nc" id="L147">            .appendValue(ChronoField.HOUR_OF_DAY, 2)</span>
<span class="nc" id="L148">            .appendLiteral(':')</span>
<span class="nc" id="L149">            .appendValue(ChronoField.MINUTE_OF_HOUR, 2)</span>
<span class="nc" id="L150">            .appendLiteral(':')</span>
<span class="nc" id="L151">            .appendValue(ChronoField.SECOND_OF_MINUTE, 2)</span>
<span class="nc" id="L152">            .appendFraction(ChronoField.MILLI_OF_SECOND, 3, 3, true)</span>
<span class="nc" id="L153">            .toFormatter(Locale.US)</span>
<span class="nc" id="L154">            .withZone(ZoneOffset.UTC)</span>
    }

<span class="nc" id="L157">  private val customFormatDateParser = new CustomFormatDateParser(null)</span>

<span class="nc" id="L159">  private val dateToString = new DateToString(null)</span>

<span class="nc" id="L161">  private val dateToMillis = TransformerFunction.pure(&quot;dateToMillis&quot;) { args =&gt;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (args(0) == null) { null } else { args(0).asInstanceOf[Date].getTime }</span>
  }
}

<span class="nc" id="L166">object DateFunctionFactory {</span>

<span class="nc" id="L168">  abstract class StandardDateParser(names: Seq[String]) extends NamedTransformerFunction(names, pure = true) {</span>
    val format: DateTimeFormatter // note: formats are thread safe
    override def apply(args: Array[AnyRef]): AnyRef = {
<span class="nc" id="L171">      args(0) match {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        case null =&gt; null</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        case d: String =&gt; DateParsing.parseDate(d, format)</span>
<span class="nc" id="L174">        case d =&gt; DateParsing.parseDate(d.toString, format)</span>
      }
    }
  }

<span class="nc" id="L179">  class CustomFormatDateParser(format: DateTimeFormatter) extends NamedTransformerFunction(Seq(&quot;date&quot;), pure = true) {</span>

    override def getInstance(args: List[Expression]): CustomFormatDateParser = {
<span class="nc" id="L182">      val format = args match {</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">        case LiteralString(s) :: _ =&gt; DateTimeFormatter.ofPattern(s).withZone(ZoneOffset.UTC)</span>
<span class="nc" id="L184">        case _ =&gt; throw new IllegalArgumentException(s&quot;Expected date pattern but got: ${args.headOption.orNull}&quot;)</span>
      }
<span class="nc" id="L186">      new CustomFormatDateParser(format)</span>
    }

    override def apply(args: Array[AnyRef]): AnyRef = {
<span class="nc" id="L190">      args(1) match {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        case null =&gt; null</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        case d: String =&gt; DateParsing.parseDate(d, format)</span>
<span class="nc" id="L193">        case d =&gt; DateParsing.parseDate(d.toString, format)</span>
      }
    }
  }

<span class="nc" id="L198">  class DateToString(format: DateTimeFormatter) extends NamedTransformerFunction(Seq(&quot;dateToString&quot;), pure = true) {</span>

    override def getInstance(args: List[Expression]): DateToString = {
<span class="nc" id="L201">      val format = args match {</span>
<span class="nc bnc" id="L202" title="All 4 branches missed.">        case LiteralString(s) :: _ =&gt; DateTimeFormatter.ofPattern(s).withZone(ZoneOffset.UTC)</span>
<span class="nc" id="L203">        case _ =&gt; throw new IllegalArgumentException(s&quot;Expected date pattern but got: ${args.headOption.orNull}&quot;)</span>
      }
<span class="nc" id="L205">      new DateToString(format)</span>
    }

    override def apply(args: Array[AnyRef]): AnyRef =
<span class="nc" id="L209">      DateParsing.formatDate(args(1).asInstanceOf[java.util.Date], format)</span>
  }
<span class="nc" id="L211">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>