<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionParser.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2.transforms</a> &gt; <span class="el_source">ExpressionParser.scala</span></div><h1>ExpressionParser.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2.transforms

import com.typesafe.scalalogging.StrictLogging
import org.locationtech.geomesa.convert2.transforms.Expression._
import org.locationtech.geomesa.utils.text.BasicParser
import org.parboiled.errors.{ErrorUtils, ParsingException}
import org.parboiled.scala.parserunners.{BasicParseRunner, ReportingParseRunner}

/**
  * Parser for converter transforms
  */
<span class="nc" id="L20">object ExpressionParser extends StrictLogging {</span>

<span class="nc" id="L22">  private val Parser = new ExpressionParser()</span>

  @throws(classOf[ParsingException])
<span class="nc" id="L25">  def parse(expression: String, report: Boolean = true): Expression = {</span>
<span class="nc bnc" id="L26" title="All 2 branches missed.">    logger.trace(s&quot;Parsing expression: $expression&quot;)</span>
<span class="nc bnc" id="L27" title="All 2 branches missed.">    if (expression == null) {</span>
<span class="nc" id="L28">      throw new IllegalArgumentException(&quot;Invalid expression: null&quot;)</span>
    }
<span class="nc bnc" id="L30" title="All 2 branches missed.">    val runner = if (report) { ReportingParseRunner(Parser.expression) } else { BasicParseRunner(Parser.expression) }</span>
<span class="nc" id="L31">    val parsing = runner.run(expression)</span>
<span class="nc" id="L32">    parsing.result.getOrElse {</span>
<span class="nc" id="L33">      throw new ParsingException(s&quot;Invalid expression: ${ErrorUtils.printParseErrors(parsing)}&quot;)</span>
    }
  }
}

<span class="nc" id="L38">private [transforms] class ExpressionParser extends BasicParser {</span>

  import org.parboiled.scala._

  // full expression
<span class="nc" id="L43">  def expression: Rule1[Expression] = rule(&quot;expression&quot;) { expr ~ EOI }</span>

<span class="nc" id="L45">  protected def expr: Rule1[Expression] = rule(&quot;expr&quot;) {</span>
<span class="nc" id="L46">    whitespace ~ (cast | nonCast) ~ whitespace</span>
  }

<span class="nc" id="L49">  private def cast: Rule1[Expression] = rule(&quot;cast&quot;) {</span>
<span class="nc" id="L50">    castToInt | castToLong | castToFloat | castToDouble | castToString | castToBoolean | castToRegex</span>
  }

<span class="nc" id="L53">  private def nonCast: Rule1[Expression] = rule {</span>
<span class="nc" id="L54">    tryFunction | withDefaultFunction | function | column | field | literal</span>
  }

<span class="nc" id="L57">  private def literal: Rule1[Expression] = rule(&quot;literal&quot;) {</span>
    // order is important - most to least specific
<span class="nc" id="L59">    litFloat | litDouble | litLong | litInt | litBoolean | litString | litNull</span>
  }

<span class="nc" id="L62">  private def column: Rule1[Expression] = rule(&quot;$col&quot;) {</span>
<span class="nc" id="L63">    &quot;$&quot; ~ int ~~&gt; { i =&gt; Column(i) }</span>
  }

<span class="nc" id="L66">  private def field: Rule1[Expression] = rule(&quot;$field&quot;) {</span>
<span class="nc" id="L67">    &quot;$&quot; ~ (unquotedString | &quot;{&quot; ~ oneOrMore(char | &quot;.&quot; | &quot; &quot;) ~&gt; { c =&gt; c } ~ &quot;}&quot;) ~~&gt; { name =&gt; FieldLookup(name) }</span>
  }

<span class="nc" id="L70">  private def tryFunction: Rule1[Expression] = rule(&quot;try&quot;) {</span>
<span class="nc" id="L71">    (&quot;try&quot; ~ whitespace ~ &quot;(&quot; ~ expr ~ &quot;,&quot; ~ expr ~ &quot;)&quot;) ~~&gt; { (primary, fallback) =&gt; TryExpression(primary, fallback) }</span>
  }

<span class="nc" id="L74">  private def withDefaultFunction: Rule1[Expression] = rule(&quot;withDefault&quot;) {</span>
<span class="nc" id="L75">    (&quot;withDefault&quot; ~ whitespace ~ &quot;(&quot; ~ expr ~ &quot;,&quot; ~ oneOrMore(expr, &quot;,&quot;) ~ &quot;)&quot;) ~~&gt; {</span>
<span class="nc" id="L76">      (primary, fallback) =&gt; WithDefaultExpression(Seq(primary) ++ fallback)</span>
    }
  }

<span class="nc" id="L80">  private def function: Rule1[Expression] = rule(&quot;function&quot;) {</span>
<span class="nc" id="L81">    (optional(unquotedString ~ &quot;:&quot;) ~ unquotedString ~ whitespace ~ &quot;(&quot; ~ zeroOrMore(expr, &quot;,&quot;) ~ &quot;)&quot;) ~~&gt; {</span>
<span class="nc" id="L82">      (ns, fn, args) =&gt; {</span>
<span class="nc" id="L83">        val name = ns.map(_ + &quot;:&quot; + fn).getOrElse(fn)</span>
<span class="nc" id="L84">        val function = TransformerFunction.functions.getOrElse(name,</span>
<span class="nc" id="L85">          throw new ParsingException(s&quot;Invalid function name: $name&quot;))</span>
<span class="nc" id="L86">        val expr = FunctionExpression(function.getInstance(args), args.toArray)</span>
<span class="nc bnc" id="L87" title="All 4 branches missed.">        if (function.pure &amp;&amp; args.forall(a =&gt; a.isInstanceOf[Literal[_]])) {</span>
<span class="nc" id="L88">          LiteralAny(expr.apply(Array.empty))</span>
        } else {
<span class="nc" id="L90">          expr</span>
        }
      }
    }
  }

<span class="nc" id="L96">  private def litInt: Rule1[Expression] = rule(&quot;int&quot;) {</span>
<span class="nc" id="L97">    int ~~&gt; { e =&gt; LiteralInt(e) }</span>
  }

<span class="nc" id="L100">  private def litLong: Rule1[Expression] = rule(&quot;long&quot;) {</span>
<span class="nc" id="L101">    long ~~&gt; { e =&gt; LiteralLong(e) }</span>
  }

<span class="nc" id="L104">  private def litFloat: Rule1[Expression] = rule(&quot;float&quot;) {</span>
<span class="nc" id="L105">    float ~~&gt; { e =&gt; LiteralFloat(e) }</span>
  }

<span class="nc" id="L108">  private def litDouble: Rule1[Expression] = rule(&quot;double&quot;) {</span>
<span class="nc" id="L109">    double ~~&gt; { e =&gt; LiteralDouble(e) }</span>
  }

<span class="nc" id="L112">  private def litBoolean: Rule1[Expression] = rule(&quot;boolean&quot;) {</span>
<span class="nc" id="L113">    boolean ~~&gt; { e =&gt; LiteralBoolean(e) }</span>
  }

<span class="nc" id="L116">  private def litString: Rule1[Expression] = rule(&quot;string&quot;) {</span>
<span class="nc" id="L117">    (quotedString | singleQuotedString) ~~&gt; { e =&gt; LiteralString(e) }</span>
  }

<span class="nc" id="L120">  private def litNull: Rule1[Expression] = rule(&quot;null&quot;) {</span>
<span class="nc" id="L121">    &quot;null&quot; ~&gt; { _ =&gt; LiteralNull }</span>
  }

<span class="nc" id="L124">  private def castToInt: Rule1[Expression] = rule(&quot;::int&quot;) {</span>
<span class="nc" id="L125">    (nonCast ~ (&quot;::integer&quot; | &quot;::int&quot;)) ~~&gt; {</span>
<span class="nc" id="L126">      e =&gt; {</span>
<span class="nc" id="L127">        val expr = CastToInt(e)</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (e.isInstanceOf[Literal[_]]) { LiteralInt(expr.apply(Array.empty)) } else { expr }</span>
      }
    }
  }

<span class="nc" id="L133">  private def castToLong: Rule1[Expression] = rule(&quot;::long&quot;) {</span>
<span class="nc" id="L134">    (nonCast ~ &quot;::long&quot;) ~~&gt; {</span>
<span class="nc" id="L135">      e =&gt; {</span>
<span class="nc" id="L136">        val expr = CastToLong(e)</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (e.isInstanceOf[Literal[_]]) { LiteralLong(expr.apply(Array.empty)) } else { expr }</span>
      }
    }
  }

<span class="nc" id="L142">  private def castToFloat: Rule1[Expression] = rule(&quot;::float&quot;) {</span>
<span class="nc" id="L143">    (nonCast ~ &quot;::float&quot;) ~~&gt; {</span>
<span class="nc" id="L144">      e =&gt; {</span>
<span class="nc" id="L145">        val expr = CastToFloat(e)</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (e.isInstanceOf[Literal[_]]) { LiteralFloat(expr.apply(Array.empty)) } else { expr }</span>
      }
    }
  }

<span class="nc" id="L151">  private def castToDouble: Rule1[Expression] = rule(&quot;::double&quot;) {</span>
<span class="nc" id="L152">    (nonCast ~ &quot;::double&quot;) ~~&gt; {</span>
<span class="nc" id="L153">      e =&gt; {</span>
<span class="nc" id="L154">        val expr = CastToDouble(e)</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (e.isInstanceOf[Literal[_]]) { LiteralDouble(expr.apply(Array.empty)) } else { expr }</span>
      }
    }
  }

<span class="nc" id="L160">  private def castToString: Rule1[Expression] = rule(&quot;::string&quot;) {</span>
<span class="nc" id="L161">    (nonCast ~ &quot;::string&quot;) ~~&gt; {</span>
<span class="nc" id="L162">      e =&gt; {</span>
<span class="nc" id="L163">        val expr = CastToString(e)</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (e.isInstanceOf[Literal[_]]) { LiteralString(expr.apply(Array.empty)) } else { expr }</span>
      }
    }
  }

<span class="nc" id="L169">  private def castToBoolean: Rule1[Expression] = rule(&quot;::boolean&quot;) {</span>
<span class="nc" id="L170">    (nonCast ~ &quot;::&quot; ~ (&quot;boolean&quot; | &quot;bool&quot;)) ~~&gt; {</span>
<span class="nc" id="L171">      e =&gt; {</span>
<span class="nc" id="L172">        val expr = CastToBoolean(e)</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (e.isInstanceOf[Literal[_]]) { LiteralBoolean(expr.apply(Array.empty)) } else { expr }</span>
      }
    }
  }

<span class="nc" id="L178">  private def castToRegex: Rule1[Expression] = rule(&quot;::r&quot;) {</span>
<span class="nc" id="L179">    (quotedString | singleQuotedString) ~ &quot;::r&quot; ~~&gt; { e =&gt; RegexExpression(e) }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>