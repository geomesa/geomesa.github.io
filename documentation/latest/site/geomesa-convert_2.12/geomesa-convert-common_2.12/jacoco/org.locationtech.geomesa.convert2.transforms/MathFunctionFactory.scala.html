<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathFunctionFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2.transforms</a> &gt; <span class="el_source">MathFunctionFactory.scala</span></div><h1>MathFunctionFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2.transforms

<span class="nc" id="L11">class MathFunctionFactory extends TransformerFunctionFactory {</span>

  import scala.collection.JavaConverters._

  override def functions: Seq[TransformerFunction] =
<span class="nc" id="L16">    Seq(add, subtract, multiply, divide, mean, min, max, sin, asin, cos, acos, tan, atan, ln, exp, sqrt, modulo)</span>

<span class="nc" id="L18">  private val add = TransformerFunction.pure(&quot;add&quot;) { args =&gt;</span>
<span class="nc" id="L19">    var s: Double = 0.0</span>
<span class="nc bnc" id="L20" title="All 2 branches missed.">    if (args.length != 0) {</span>
<span class="nc" id="L21">      val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L22" title="All 2 branches missed.">        case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L23">        case _ =&gt; args</span>
      }
<span class="nc" id="L25">      numbers.foreach(s += parseDouble(_))</span>
    }
<span class="nc" id="L27">    s</span>
  }

<span class="nc" id="L30">  private val multiply = TransformerFunction.pure(&quot;multiply&quot;) { args =&gt;</span>
<span class="nc" id="L31">    var s: Double = 1.0</span>
<span class="nc bnc" id="L32" title="All 2 branches missed.">    if (args.length != 0) {</span>
<span class="nc" id="L33">      val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L34" title="All 2 branches missed.">        case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L35">        case _ =&gt; args</span>
      }
<span class="nc" id="L37">      numbers.foreach(s *= parseDouble(_))</span>
    }
<span class="nc" id="L39">    s</span>
  }

<span class="nc" id="L42">  private val subtract = TransformerFunction.pure(&quot;subtract&quot;) { args =&gt;</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L44">      throw new IllegalArgumentException(&quot;Subtract called without any arguments&quot;)</span>
    }
<span class="nc" id="L46">    val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">      case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L48">      case _ =&gt; args</span>
    }
<span class="nc" id="L50">    var s: Double = parseDouble(numbers.head)</span>
<span class="nc" id="L51">    numbers.drop(1).foreach(s -= parseDouble(_))</span>
<span class="nc" id="L52">    s</span>
  }

<span class="nc" id="L55">  private val divide = TransformerFunction.pure(&quot;divide&quot;) { args =&gt;</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L57">      throw new IllegalArgumentException(&quot;Divide called without any arguments&quot;)</span>
    }
<span class="nc" id="L59">    val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L61">      case _ =&gt; args</span>
    }
<span class="nc" id="L63">    var s: Double = parseDouble(numbers.head)</span>
<span class="nc" id="L64">    numbers.drop(1).foreach(s /= parseDouble(_))</span>
<span class="nc" id="L65">    s</span>
  }

<span class="nc" id="L68">  private val mean = TransformerFunction.pure(&quot;mean&quot;) { args =&gt;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">    if (args.length == 0) { 0d } else {</span>
<span class="nc" id="L70">      var count = 0d</span>
<span class="nc" id="L71">      val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L73">        case _ =&gt; args</span>
      }
<span class="nc" id="L75">      numbers.foreach(n =&gt; count += parseDouble(n))</span>
<span class="nc" id="L76">      count / numbers.length</span>
    }
  }

<span class="nc" id="L80">  private val min = TransformerFunction.pure(&quot;min&quot;) { args =&gt;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L82">      throw new IllegalArgumentException(&quot;Min called without any arguments&quot;)</span>
    }
<span class="nc" id="L84">    val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">      case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L86">      case _ =&gt; args</span>
    }
<span class="nc" id="L88">    var min = numbers.head.asInstanceOf[Comparable[Any]]</span>
<span class="nc" id="L89">    numbers.drop(1).foreach { n =&gt;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">      if (min.compareTo(n) &gt; 0) {</span>
<span class="nc" id="L91">        min = n.asInstanceOf[Comparable[Any]]</span>
      }
    }
<span class="nc" id="L94">    min</span>
  }

<span class="nc" id="L97">  private val max = TransformerFunction.pure(&quot;max&quot;) { args =&gt;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L99">      throw new IllegalArgumentException(&quot;Max called without any arguments&quot;)</span>
    }
<span class="nc" id="L101">    val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">      case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L103">      case _ =&gt; args</span>
    }
<span class="nc" id="L105">    var max = numbers.head.asInstanceOf[Comparable[Any]]</span>
<span class="nc" id="L106">    numbers.drop(1).foreach { n =&gt;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">      if (max.compareTo(n) &lt; 0) {</span>
<span class="nc" id="L108">        max = n.asInstanceOf[Comparable[Any]]</span>
      }
    }
<span class="nc" id="L111">    max</span>
  }

<span class="nc" id="L114">  private val sin = TransformerFunction.pure(&quot;sin&quot;) { args =&gt; Math.sin(parseSingleDouble(args, &quot;sin&quot;)) }</span>

<span class="nc" id="L116">  private val cos = TransformerFunction.pure(&quot;cos&quot;) { args =&gt; Math.cos(parseSingleDouble(args, &quot;cos&quot;)) }</span>

<span class="nc" id="L118">  private val tan = TransformerFunction.pure(&quot;tan&quot;) { args =&gt; Math.tan(parseSingleDouble(args, &quot;tan&quot;)) }</span>

<span class="nc" id="L120">  private val asin = TransformerFunction.pure(&quot;asin&quot;) { args =&gt; Math.asin(parseSingleDouble(args, &quot;asin&quot;)) }</span>

<span class="nc" id="L122">  private val acos = TransformerFunction.pure(&quot;acos&quot;) { args =&gt; Math.acos(parseSingleDouble(args, &quot;acos&quot;)) }</span>

<span class="nc" id="L124">  private val atan = TransformerFunction.pure(&quot;atan&quot;) { args =&gt; Math.atan(parseSingleDouble(args, &quot;atan&quot;)) }</span>

<span class="nc" id="L126">  private val ln = TransformerFunction.pure(&quot;ln&quot;) { args =&gt; Math.log(parseSingleDouble(args, &quot;ln&quot;)) }</span>

<span class="nc" id="L128">  private val exp = TransformerFunction.pure(&quot;exp&quot;) { args =&gt; Math.exp(parseSingleDouble(args, &quot;exp&quot;)) }</span>

<span class="nc" id="L130">  private val sqrt = TransformerFunction.pure(&quot;sqrt&quot;) { args =&gt; Math.sqrt(parseSingleDouble(args, &quot;sqrt&quot;)) }</span>

<span class="nc" id="L132">  private val modulo = TransformerFunction.pure(&quot;modulo&quot;) { args =&gt;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L134">      throw new IllegalArgumentException(&quot;modulo called without any arguments&quot;)</span>
    }
<span class="nc" id="L136">    val numbers: scala.collection.Seq[Any] = args(0) match {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">      case list: java.util.List[_] =&gt; list.asScala</span>
<span class="nc" id="L138">      case _ =&gt; args</span>
    }
<span class="nc bnc" id="L140" title="All 2 branches missed.">    if (numbers.length != 2) {</span>
<span class="nc" id="L141">      throw new IllegalArgumentException(s&quot;modulo called with an invalid number of arguments: expected 2 but got ${args.length}&quot;)</span>
    }
<span class="nc" id="L143">    parseInt(args(0)) % parseInt(args(1))</span>
  }

  private def parseSingleDouble(args: Array[Any], fn: String): Double = {
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if (args.length != 1) {</span>
<span class="nc" id="L148">      throw new IllegalArgumentException(s&quot;$fn called with an invalid number of arguments: expected 1 but got ${args.length}&quot;)</span>
    }
<span class="nc" id="L150">    parseDouble(args(0))</span>
  }

  private def parseDouble(v: Any): Double = {
<span class="nc" id="L154">    v match {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">      case n: Int    =&gt; n.toDouble</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">      case n: Double =&gt; n</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      case n: Float  =&gt; n.toDouble</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      case n: Long   =&gt; n.toDouble</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">      case n: String =&gt; n.toDouble</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      case n: Any    =&gt; n.toString.toDouble</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">      case null      =&gt; throw new NullPointerException()</span>
    }
  }

  private def parseInt(v: Any): Int = {
<span class="nc" id="L166">    v match {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">      case n: Int    =&gt; n</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      case n: Double =&gt; n.toInt</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">      case n: Float  =&gt; n.toInt</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">      case n: Long   =&gt; n.toInt</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      case n: String =&gt; n.toInt</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">      case n: Any    =&gt; n.toString.toInt</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">      case null      =&gt; throw new NullPointerException()</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>