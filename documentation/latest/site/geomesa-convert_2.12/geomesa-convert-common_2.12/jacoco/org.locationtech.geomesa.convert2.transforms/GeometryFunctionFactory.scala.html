<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeometryFunctionFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2.transforms</a> &gt; <span class="el_source">GeometryFunctionFactory.scala</span></div><h1>GeometryFunctionFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0 
 ***********************************************************************/

package org.locationtech.geomesa.convert2.transforms

import org.geotools.api.referencing.operation.MathTransform
import org.geotools.geometry.jts.{JTS, JTSFactoryFinder}
import org.geotools.referencing.CRS
import org.locationtech.geomesa.convert2.transforms.TransformerFunction.NamedTransformerFunction
import org.locationtech.geomesa.utils.text.{WKBUtils, WKTUtils}
import org.locationtech.jts.geom._

import java.util.concurrent.ConcurrentHashMap

<span class="nc" id="L20">class GeometryFunctionFactory extends TransformerFunctionFactory {</span>

  import GeometryFunctionFactory.{coord, coordM, coordZ, coordZM}

  override def functions: Seq[TransformerFunction] =
<span class="nc" id="L25">    Seq(pointParserFn, pointMParserFn, multiPointParserFn, lineStringParserFn, multiLineStringParserFn,</span>
<span class="nc" id="L26">      polygonParserFn, multiPolygonParserFn, geometryCollectionParserFn, geometryParserFn, projectFromParserFn)</span>

<span class="nc" id="L28">  private val gf = JTSFactoryFinder.getGeometryFactory</span>

<span class="nc" id="L30">  private val pointParserFn = TransformerFunction.pure(&quot;point&quot;) {</span>
<span class="nc bnc" id="L31" title="All 8 branches missed.">    case Array(g: Point) =&gt; g</span>
<span class="nc bnc" id="L32" title="All 10 branches missed.">    case Array(x: Number, y: Number) =&gt; gf.createPoint(coord(x, y))</span>
<span class="nc bnc" id="L33" title="All 12 branches missed.">    case Array(x: Number, y: Number, z: Number) =&gt; gf.createPoint(coordZ(x, y, z))</span>
<span class="nc bnc" id="L34" title="All 14 branches missed.">    case Array(x: Number, y: Number, z: Number, m: Number) =&gt; gf.createPoint(coordZM(x, y, z, m))</span>
<span class="nc bnc" id="L35" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g).asInstanceOf[Point]</span>
<span class="nc bnc" id="L36" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g).asInstanceOf[Point]</span>
<span class="nc bnc" id="L37" title="All 8 branches missed.">    case args if args.nonEmpty &amp;&amp; args.lengthCompare(4) &lt;= 0 &amp;&amp; args.forall(_ == null) =&gt; null</span>
<span class="nc" id="L38">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid point conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L41">  private val pointMParserFn = TransformerFunction.pure(&quot;pointM&quot;) {</span>
<span class="nc bnc" id="L42" title="All 12 branches missed.">    case Array(x: Number, y: Number, m: Number) =&gt; gf.createPoint(coordM(x, y, m))</span>
<span class="nc bnc" id="L43" title="All 12 branches missed.">    case Array(null, null, null) =&gt; null</span>
<span class="nc" id="L44">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid pointM conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L47">  private val multiPointParserFn = TransformerFunction.pure(&quot;multipoint&quot;) {</span>
<span class="nc bnc" id="L48" title="All 8 branches missed.">    case Array(g: MultiPoint) =&gt; g</span>
<span class="nc bnc" id="L49" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g).asInstanceOf[MultiPoint]</span>
<span class="nc bnc" id="L50" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g).asInstanceOf[MultiPoint]</span>
<span class="nc bnc" id="L51" title="All 10 branches missed.">    case Array(x: java.util.List[_], y: java.util.List[_]) =&gt;</span>
<span class="nc" id="L52">      val coords = Array.ofDim[Coordinate](x.size)</span>
<span class="nc" id="L53">      var i = 0</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">      while (i &lt; coords.length) {</span>
<span class="nc" id="L55">        coords(i) = new Coordinate(x.get(i).asInstanceOf[Number].doubleValue, y.get(i).asInstanceOf[Number].doubleValue)</span>
<span class="nc" id="L56">        i += 1</span>
      }
<span class="nc" id="L58">      gf.createMultiPointFromCoords(coords)</span>
<span class="nc bnc" id="L59" title="All 8 branches missed.">    case Array(null) =&gt; null</span>
<span class="nc" id="L60">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid multipoint conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L63">  private val lineStringParserFn = TransformerFunction.pure(&quot;linestring&quot;) {</span>
<span class="nc bnc" id="L64" title="All 8 branches missed.">    case Array(g: LineString) =&gt; g</span>
<span class="nc bnc" id="L65" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g).asInstanceOf[LineString]</span>
<span class="nc bnc" id="L66" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g).asInstanceOf[LineString]</span>
<span class="nc bnc" id="L67" title="All 10 branches missed.">    case Array(x: java.util.List[_], y: java.util.List[_]) =&gt;</span>
<span class="nc" id="L68">      val coords = Array.ofDim[Coordinate](x.size)</span>
<span class="nc" id="L69">      var i = 0</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">      while (i &lt; coords.length) {</span>
<span class="nc" id="L71">        coords(i) = new Coordinate(x.get(i).asInstanceOf[Number].doubleValue, y.get(i).asInstanceOf[Number].doubleValue)</span>
<span class="nc" id="L72">        i += 1</span>
      }
<span class="nc" id="L74">      gf.createLineString(coords)</span>
<span class="nc bnc" id="L75" title="All 8 branches missed.">    case Array(null) =&gt; null</span>
<span class="nc" id="L76">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid linestring conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L79">  private val multiLineStringParserFn = TransformerFunction.pure(&quot;multilinestring&quot;) {</span>
<span class="nc bnc" id="L80" title="All 8 branches missed.">    case Array(g: MultiLineString) =&gt; g</span>
<span class="nc bnc" id="L81" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g).asInstanceOf[MultiLineString]</span>
<span class="nc bnc" id="L82" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g).asInstanceOf[MultiLineString]</span>
<span class="nc bnc" id="L83" title="All 8 branches missed.">    case Array(null) =&gt; null</span>
<span class="nc" id="L84">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid multilinestring conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L87">  private val polygonParserFn = TransformerFunction.pure(&quot;polygon&quot;) {</span>
<span class="nc bnc" id="L88" title="All 8 branches missed.">    case Array(g: Polygon) =&gt; g</span>
<span class="nc bnc" id="L89" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g).asInstanceOf[Polygon]</span>
<span class="nc bnc" id="L90" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g).asInstanceOf[Polygon]</span>
<span class="nc bnc" id="L91" title="All 8 branches missed.">    case Array(null) =&gt; null</span>
<span class="nc" id="L92">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid polygon conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L95">  private val multiPolygonParserFn = TransformerFunction.pure(&quot;multipolygon&quot;) {</span>
<span class="nc bnc" id="L96" title="All 8 branches missed.">    case Array(g: MultiPolygon) =&gt; g</span>
<span class="nc bnc" id="L97" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g).asInstanceOf[MultiPolygon]</span>
<span class="nc bnc" id="L98" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g).asInstanceOf[MultiPolygon]</span>
<span class="nc bnc" id="L99" title="All 8 branches missed.">    case Array(null) =&gt; null</span>
<span class="nc" id="L100">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid multipolygon conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L103">  private val geometryCollectionParserFn = TransformerFunction.pure(&quot;geometrycollection&quot;) {</span>
<span class="nc bnc" id="L104" title="All 8 branches missed.">    case Array(g: GeometryCollection) =&gt; g</span>
<span class="nc bnc" id="L105" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g).asInstanceOf[GeometryCollection]</span>
<span class="nc bnc" id="L106" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g).asInstanceOf[GeometryCollection]</span>
<span class="nc bnc" id="L107" title="All 8 branches missed.">    case Array(null) =&gt; null</span>
<span class="nc" id="L108">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid geometrycollection conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L111">  private val geometryParserFn = TransformerFunction.pure(&quot;geometry&quot;) {</span>
<span class="nc bnc" id="L112" title="All 8 branches missed.">    case Array(g: Geometry) =&gt; g</span>
<span class="nc bnc" id="L113" title="All 8 branches missed.">    case Array(g: String) =&gt; WKTUtils.read(g)</span>
<span class="nc bnc" id="L114" title="All 8 branches missed.">    case Array(g: Array[Byte]) =&gt; WKBUtils.read(g)</span>
<span class="nc bnc" id="L115" title="All 8 branches missed.">    case Array(null) =&gt; null</span>
<span class="nc" id="L116">    case args =&gt; throw new IllegalArgumentException(s&quot;Invalid geometry conversion argument: ${args.mkString(&quot;,&quot;)}&quot;)</span>
  }

<span class="nc" id="L119">  private val projectFromParserFn: TransformerFunction = new NamedTransformerFunction(Seq(&quot;projectFrom&quot;), pure = true) {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L123">    private val cache = new ConcurrentHashMap[String, MathTransform].asScala</span>

    override def apply(args: Array[AnyRef]): AnyRef = {
      import org.locationtech.geomesa.utils.geotools.CRS_EPSG_4326

<span class="nc" id="L128">      val geom = args(1).asInstanceOf[Geometry]</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      if (geom == null) { null } else {</span>
<span class="nc" id="L130">        val epsg = args(0).asInstanceOf[String]</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        val lenient = if (args.length &gt; 2) { java.lang.Boolean.parseBoolean(args(2).toString) } else { true }</span>
        // transforms should be thread safe according to https://sourceforge.net/p/geotools/mailman/message/32123017/
<span class="nc" id="L133">        val transform = cache.getOrElseUpdate(s&quot;$epsg:$lenient&quot;,</span>
<span class="nc" id="L134">          CRS.findMathTransform(CRS.decode(epsg), CRS_EPSG_4326, lenient))</span>
<span class="nc" id="L135">        JTS.transform(geom, transform)</span>
      }
    }
  }
}

<span class="nc" id="L141">object GeometryFunctionFactory {</span>

<span class="nc" id="L143">  private def coord(x: Number, y: Number): Coordinate = new CoordinateXY(x.doubleValue, y.doubleValue)</span>

  private def coordZ(x: Number, y: Number, z: Number): Coordinate =
<span class="nc" id="L146">    new Coordinate(x.doubleValue, y.doubleValue, z.doubleValue)</span>

  private def coordM(x: Number, y: Number, m: Number): Coordinate =
<span class="nc" id="L149">    new CoordinateXYM(x.doubleValue, y.doubleValue, m.doubleValue)</span>

  private def coordZM(x: Number, y: Number, z: Number, m: Number): Coordinate =
<span class="nc" id="L152">    new CoordinateXYZM(x.doubleValue, y.doubleValue, z.doubleValue, m.doubleValue)</span>
<span class="nc" id="L153">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>