<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PredicateParser.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2.transforms</a> &gt; <span class="el_source">PredicateParser.scala</span></div><h1>PredicateParser.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2.transforms

import com.typesafe.scalalogging.StrictLogging
import org.locationtech.geomesa.convert2.transforms.Predicate._
import org.locationtech.geomesa.convert2.transforms.PredicateParser.Comparisons
import org.parboiled.errors.{ErrorUtils, ParsingException}
import org.parboiled.scala.parserunners.{BasicParseRunner, ReportingParseRunner}

<span class="nc" id="L17">object PredicateParser extends StrictLogging {</span>

<span class="nc" id="L19">  private val Parser = new PredicateParser()</span>

  @throws(classOf[ParsingException])
<span class="nc" id="L22">  def parse(predicate: String, report: Boolean = true): Predicate = {</span>
<span class="nc bnc" id="L23" title="All 2 branches missed.">    logger.trace(s&quot;Parsing predicate: $predicate&quot;)</span>
<span class="nc bnc" id="L24" title="All 2 branches missed.">    if (predicate == null) {</span>
<span class="nc" id="L25">      throw new IllegalArgumentException(&quot;Invalid predicate: null&quot;)</span>
    }
<span class="nc bnc" id="L27" title="All 2 branches missed.">    val runner = if (report) { ReportingParseRunner(Parser.predicate) } else { BasicParseRunner(Parser.predicate) }</span>
<span class="nc" id="L28">    val parsing = runner.run(predicate)</span>
<span class="nc" id="L29">    parsing.result.getOrElse(throw new ParsingException(s&quot;Invalid predicate: ${ErrorUtils.printParseErrors(parsing)}&quot;))</span>
  }

<span class="nc" id="L32">  private object Comparisons extends Enumeration {</span>
    type Comparisons = Value
<span class="nc" id="L34">    val Eq, LT, GT, LTEq, GTEq, NEq  = Value</span>
  }
}

<span class="nc" id="L38">private class PredicateParser extends ExpressionParser {</span>

  import PredicateParser.Comparisons._
  import org.parboiled.scala._

  // full predicate
<span class="nc" id="L44">  def predicate: Rule1[Predicate] = rule(&quot;predicate&quot;) { pred ~ EOI }</span>

<span class="nc" id="L46">  private def pred: Rule1[Predicate] = rule(&quot;pred&quot;) {</span>
<span class="nc" id="L47">    whitespace ~ (and | or | grouped) ~ whitespace</span>
  }

<span class="nc" id="L50">  private def grouped: Rule1[Predicate] = rule(&quot;simple&quot;) {</span>
<span class="nc" id="L51">    whitespace ~ (andFn | orFn | not | comparison | (&quot;(&quot; ~ and ~ &quot;)&quot;) | (&quot;(&quot; ~ or ~ &quot;)&quot;)) ~ whitespace</span>
  }

<span class="nc" id="L54">  private def andFn: Rule1[Predicate] = rule(&quot;andFn&quot;) {</span>
<span class="nc" id="L55">    (&quot;and(&quot; ~ pred ~ &quot;,&quot; ~ oneOrMore(pred, &quot;,&quot;) ~ &quot;)&quot;) ~~&gt; { (head, tail) =&gt; And(head, tail) }</span>
  }

<span class="nc" id="L58">  private def and: Rule1[Predicate] = rule(&quot;and&quot;) {</span>
<span class="nc" id="L59">    (grouped ~ &quot;&amp;&amp;&quot; ~ oneOrMore(grouped, &quot;&amp;&amp;&quot;)) ~~&gt; { (head, tail) =&gt; And(head, tail) }</span>
  }

<span class="nc" id="L62">  private def orFn: Rule1[Predicate] = rule(&quot;orFn&quot;) {</span>
<span class="nc" id="L63">    (&quot;or(&quot; ~ pred ~ &quot;,&quot; ~ oneOrMore(pred, &quot;,&quot;) ~ &quot;)&quot;) ~~&gt; { (head, tail) =&gt; Or(head, tail) }</span>
  }

<span class="nc" id="L66">  private def or: Rule1[Predicate] = rule(&quot;or&quot;) {</span>
<span class="nc" id="L67">    (grouped ~ &quot;||&quot; ~ oneOrMore(grouped, &quot;||&quot;)) ~~&gt; { (head, tail) =&gt; Or(head, tail) }</span>
  }

<span class="nc" id="L70">  private def not: Rule1[Predicate] = rule(&quot;not&quot;) {</span>
<span class="nc" id="L71">    ((&quot;not(&quot; | &quot;!(&quot;) ~ pred ~ &quot;)&quot;) ~~&gt; { p =&gt; Not(p) }</span>
  }

<span class="nc" id="L74">  private def comparison: Rule1[Predicate] = rule {</span>
<span class="nc" id="L75">    compareFn | booleanCompare | compare</span>
  }

<span class="nc" id="L78">  private def compare: Rule1[Predicate] = rule {</span>
<span class="nc" id="L79">    (expr ~ whitespace ~ op ~ whitespace ~ expr) ~~&gt; {</span>
<span class="nc" id="L80">      (left, comp, right) =&gt; comp match {</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        case &quot;==&quot; =&gt; BinaryEquals(left, right)</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        case &quot;!=&quot; =&gt; BinaryNotEquals(left, right)</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        case &quot;&lt;&quot;  =&gt; BinaryLessThan(left, right)</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        case &quot;&lt;=&quot; =&gt; BinaryLessThanOrEquals(left, right)</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        case &quot;&gt;&quot;  =&gt; BinaryGreaterThan(left, right)</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        case &quot;&gt;=&quot; =&gt; BinaryGreaterThanOrEquals(left, right)</span>
      }
    }
  }

<span class="nc" id="L91">  private def op: Rule1[String] = rule {</span>
<span class="nc" id="L92">    (&quot;==&quot; | &quot;!=&quot; | &quot;&lt;=&quot; | &quot;&lt;&quot;  | &quot;&gt;=&quot; | &quot;&gt;&quot;) ~&gt; { s =&gt; s}</span>
  }

<span class="nc" id="L95">  private def compareFn: Rule1[Predicate] = rule {</span>
<span class="nc" id="L96">    (compareFnName ~ comparisonType ~ &quot;(&quot; ~ expr ~ &quot;,&quot; ~ whitespace ~ expr ~ &quot;)&quot;) ~~&gt; {</span>
<span class="nc" id="L97">      (comp, left, right) =&gt; comp match {</span>
<span class="nc bnc" id="L98" title="All 6 branches missed.">        case Eq   =&gt; BinaryEquals(left, right)</span>
<span class="nc bnc" id="L99" title="All 6 branches missed.">        case LT   =&gt; BinaryLessThan(left, right)</span>
<span class="nc bnc" id="L100" title="All 6 branches missed.">        case GT   =&gt; BinaryGreaterThan(left, right)</span>
<span class="nc bnc" id="L101" title="All 6 branches missed.">        case LTEq =&gt; BinaryLessThanOrEquals(left, right)</span>
<span class="nc bnc" id="L102" title="All 6 branches missed.">        case GTEq =&gt; BinaryGreaterThanOrEquals(left, right)</span>
<span class="nc bnc" id="L103" title="All 6 branches missed.">        case NEq  =&gt; BinaryNotEquals(left, right)</span>
      }
    }
  }

<span class="nc" id="L108">  private def compareFnName: Rule0 = rule {</span>
<span class="nc" id="L109">    &quot;str&quot; | &quot;integer&quot; | &quot;int&quot; | &quot;long&quot; | &quot;float&quot; | &quot;double&quot;</span>
  }

<span class="nc" id="L112">  private def booleanCompare: Rule1[Predicate] = rule {</span>
<span class="nc" id="L113">    ((&quot;boolean&quot; | &quot;bool&quot;) ~ comparisonType ~ &quot;(&quot; ~ expr ~ &quot;,&quot; ~ whitespace ~ expr ~ &quot;)&quot;) ~~&gt; {</span>
<span class="nc" id="L114">      (comp, left, right) =&gt; comp match {</span>
<span class="nc bnc" id="L115" title="All 6 branches missed.">        case Eq  =&gt; BinaryEquals(left, right)</span>
<span class="nc bnc" id="L116" title="All 6 branches missed.">        case NEq =&gt; BinaryNotEquals(left, right)</span>
<span class="nc" id="L117">        case _ =&gt; throw new ParsingException(s&quot;Invalid boolean comparison operator: $comp&quot;)</span>
      }
    }
  }

<span class="nc" id="L122">  private def comparisonType: Rule1[Comparisons] = rule {</span>
<span class="nc" id="L123">    (Eq.toString | LTEq.toString | GTEq.toString | LT.toString | GT.toString | NEq.toString) ~&gt; {</span>
<span class="nc" id="L124">      s =&gt; Comparisons.withName(s)</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>