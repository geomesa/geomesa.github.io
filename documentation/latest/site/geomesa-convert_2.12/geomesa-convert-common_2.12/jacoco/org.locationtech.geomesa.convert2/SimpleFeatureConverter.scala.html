<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleFeatureConverter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2</a> &gt; <span class="el_source">SimpleFeatureConverter.scala</span></div><h1>SimpleFeatureConverter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2

import com.typesafe.config.Config
import com.typesafe.scalalogging.{LazyLogging, StrictLogging}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.convert._
import org.locationtech.geomesa.utils.classpath.ServiceLoader
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypeLoader
import org.locationtech.geomesa.utils.io.WithClose

import java.io.{Closeable, InputStream}
import scala.util.{Failure, Try}

/**
 * Converts input streams into simple features. SimpleFeatureConverters should be thread-safe. However,
 * a given EvaluationContext should only be used in a single thread at once.
 */
<span class="nc" id="L27">trait SimpleFeatureConverter extends Closeable with LazyLogging {</span>

  import scala.collection.JavaConverters._

  /**
    * Result feature type
    */
  def targetSft: SimpleFeatureType

  /**
   * Process an input stream into simple features.
   *
   * This method should be thread-safe, as long as different evaluation contexts are used for each request.
   *
   * @param is input
   * @param ec evaluation context
   * @return
   */
<span class="nc" id="L45">  def process(is: InputStream, ec: EvaluationContext = createEvaluationContext()): CloseableIterator[SimpleFeature]</span>

  /**
   * Create a context used for local state while processing. A context object is not thread-safe, and should
   * only be used in one thread at a time.
   *
   * @param globalParams global key-values to make accessible through the evaluation context
   * @return
   */
<span class="nc" id="L54">  def createEvaluationContext(globalParams: Map[String, Any] = Map.empty): EvaluationContext</span>

  /**
   * Java API for `createEvaluationContext`
   *
   * @param globalParams global key-values to make accessible through the evaluation context
   * @return
   */
  final def createEvaluationContext(globalParams: java.util.Map[String, Any]): EvaluationContext =
<span class="nc" id="L63">    createEvaluationContext(globalParams.asScala.toMap)</span>
}

<span class="nc" id="L66">object SimpleFeatureConverter extends StrictLogging {</span>

<span class="nc" id="L68">  val factories: List[SimpleFeatureConverterFactory] = ServiceLoader.load[SimpleFeatureConverterFactory]()</span>

<span class="nc bnc" id="L70" title="All 2 branches missed.">  logger.debug(s&quot;Found ${factories.size} factories: ${factories.map(_.getClass.getName).mkString(&quot;, &quot;)}&quot;)</span>

  /**
    * Create a converter
    *
    * @param sft simple feature type
    * @param config converter configuration
    * @return
    */
  def apply(sft: SimpleFeatureType, config: Config): SimpleFeatureConverter = {
<span class="nc" id="L80">    factories.toStream.flatMap(_.apply(sft, config)).headOption.getOrElse {</span>
<span class="nc" id="L81">      throw new IllegalArgumentException(s&quot;Cannot find converter factory for ${sft.getTypeName}&quot;)</span>
    }
  }

  /**
    * Create a converter by name
    *
    * @param typeName simple feature type name
    * @param converterName converter name
    * @return
    */
  def apply(typeName: String, converterName: String): SimpleFeatureConverter = {
<span class="nc" id="L93">    val sft = SimpleFeatureTypeLoader.sftForName(typeName).getOrElse {</span>
<span class="nc" id="L94">      throw new IllegalArgumentException(s&quot;Unable to load SimpleFeatureType for typeName '$typeName'&quot;)</span>
    }
<span class="nc" id="L96">    apply(sft, converterName)</span>
  }

  /**
    * Create a converter by name
    *
    * @param sft simple feature type
    * @param converterName converter name
    * @return
    */
  def apply(sft: SimpleFeatureType, converterName: String): SimpleFeatureConverter = {
<span class="nc" id="L107">    val converter = ConverterConfigLoader.configForName(converterName).getOrElse {</span>
<span class="nc" id="L108">      throw new IllegalArgumentException(s&quot;Unable to load converter config for converter named '$converterName'&quot;)</span>
    }
<span class="nc" id="L110">    apply(sft, converter)</span>
  }

  /**
    * Infer a converter based on a data sample
    *
    * @param is input stream to convert
    * @param sft simple feature type, if known
    * @return
    */
  @deprecated(&quot;replaced with `infer(() =&gt; InputStream, Option[SimpleFeatureType], Map[String, Any])`&quot;)
  def infer(
      is: () =&gt; InputStream,
      sft: Option[SimpleFeatureType],
<span class="nc" id="L124">      path: Option[String] = None): Option[(SimpleFeatureType, Config)] = {</span>
<span class="nc" id="L125">    val hints = path match {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">      case None    =&gt; Map.empty[String, AnyRef]</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      case Some(p) =&gt; Map(EvaluationContext.InputFilePathKey -&gt; p)</span>
    }
<span class="nc" id="L129">    infer(is, sft, hints).toOption</span>
  }

  /**
   * Infer a converter based on a data sample
   *
   * @param is input stream to convert
   * @param sft simple feature type, if known
   * @param hints implementation specific hints
   * @return
   */
  def infer(
      is: () =&gt; InputStream,
      sft: Option[SimpleFeatureType],
<span class="nc" id="L143">      hints: Map[String, AnyRef]): Try[(SimpleFeatureType, Config)] = infer(is, sft, hints, None)</span>

  /**
   * Infer a converter based on a data sample
   *
   * @param is input stream to convert
   * @param sft simple feature type, if known
   * @param hints implementation specific hints
   * @param priority priority order for trying factories
   * @return
   */
  def infer(
      is: () =&gt; InputStream,
      sft: Option[SimpleFeatureType],
      hints: Map[String, AnyRef],
      priority: Option[Ordering[SimpleFeatureConverterFactory]]): Try[(SimpleFeatureType, Config)] = {
<span class="nc bnc" id="L159" title="All 2 branches missed.">    if (factories.isEmpty) {</span>
<span class="nc" id="L160">      Failure(new RuntimeException(&quot;There are no converters available on the classpath&quot;))</span>
    } else {
<span class="nc" id="L162">      val sorted = priority.fold(factories)(factories.sorted(_))</span>
<span class="nc" id="L163">      val attempts = sorted.iterator.map { factory =&gt;</span>
<span class="nc" id="L164">        WithClose(is()) { is =&gt;</span>
<span class="nc" id="L165">          val res = try { factory.infer(is, sft, hints) } catch {</span>
            // in case a particular converter's dependencies aren't on the classpath
<span class="nc" id="L167">            case e: NoClassDefFoundError =&gt; Failure(e)</span>
          }
<span class="nc bnc" id="L169" title="All 2 branches missed.">          if (res.isSuccess) { res } else {</span>
<span class="nc" id="L170">            val msg = s&quot;${factory.getClass.getSimpleName}: could not infer a converter:&quot;</span>
<span class="nc" id="L171">            Failure(new RuntimeException(msg, res.failed.get))</span>
          }
        }
      }
<span class="nc" id="L175">      multiTry(attempts, new RuntimeException(&quot;Unable to infer a converter&quot;))</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>