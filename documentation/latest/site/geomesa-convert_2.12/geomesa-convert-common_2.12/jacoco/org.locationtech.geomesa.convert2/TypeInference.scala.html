<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeInference.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2</a> &gt; <span class="el_source">TypeInference.scala</span></div><h1>TypeInference.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2

import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.convert2.transforms.DateFunctionFactory.StandardDateParser
import org.locationtech.geomesa.convert2.transforms.TransformerFunction
import org.locationtech.geomesa.utils.geotools.{FeatureUtils, ObjectType, SimpleFeatureTypes}
import org.locationtech.geomesa.utils.text.{DateParsing, WKTUtils}
import org.locationtech.jts.geom._

import java.lang.{Boolean =&gt; jBoolean, Double =&gt; jDouble, Float =&gt; jFloat, Long =&gt; jLong}
import java.util.{Date, Locale}
import scala.util.Try

<span class="nc" id="L22">object TypeInference {</span>

  import ObjectType._

  import scala.collection.JavaConverters._

  // fields to match for lat/lon - in priority order, from most to least specific
<span class="nc" id="L29">  private val latitudeNames = Seq(&quot;latitude&quot;, &quot;lat&quot;)</span>
<span class="nc" id="L30">  private val longitudeNames = Seq(&quot;longitude&quot;, &quot;lon&quot;, &quot;long&quot;)</span>

  // map of priorities and transforms for merging different number types
<span class="nc" id="L33">  private val mergeUpNumbers = Map(</span>
<span class="nc" id="L34">    DOUBLE -&gt; (0, CastToDouble),</span>
<span class="nc" id="L35">    FLOAT  -&gt; (1, CastToFloat),</span>
<span class="nc" id="L36">    LONG   -&gt; (2, CastToLong),</span>
<span class="nc" id="L37">    INT    -&gt; (3, CastToInt),</span>
  )

  /**
   * Infer types
   *
   * @param pathsAndValues paths (xpath, jsonpath, etc) to values
   * @param sft simple feature type, or name for inferred type
   * @param namer naming for inferred attributes
   * @param failureRate allowed failure rate for conversion to a given type
   * @return
   */
  def infer(
      pathsAndValues: Seq[PathWithValues],
      sft: Either[String, SimpleFeatureType],
<span class="nc" id="L52">      namer: String =&gt; String = new Namer(),</span>
<span class="nc" id="L53">      failureRate: Float = 0.1f): InferredTypesWithPaths = {</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">    val inferred = pathsAndValues.map { case PathWithValues(path, values) =&gt;</span>
<span class="nc" id="L55">      val rawTypes = values.map(InferredType.infer)</span>
      // merge the types for this column from each row
<span class="nc" id="L57">      val typed = merge(rawTypes.toSeq, failureRate)</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">      val baseName = if (path.nonEmpty) { path } else { String.valueOf(typed.typed).toLowerCase(Locale.US) }</span>
<span class="nc" id="L59">      TypeWithPath(path, typed.copy(name = namer(baseName)))</span>
    }
<span class="nc" id="L61">    val geom = deriveGeometry(inferred.map(_.inferredType), namer).map(TypeWithPath(&quot;&quot;, _))</span>

<span class="nc" id="L63">    val typesWithPaths = inferred ++ geom</span>

<span class="nc" id="L65">    sft match {</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">      case Left(name) =&gt;</span>
<span class="nc" id="L67">        val schema = TypeInference.schema(name, typesWithPaths.map(_.inferredType))</span>
<span class="nc" id="L68">        InferredTypesWithPaths(schema, typesWithPaths)</span>

<span class="nc bnc" id="L70" title="All 2 branches missed.">      case Right(sft) =&gt;</span>
        // validate the existing schema
<span class="nc" id="L72">        AbstractConverterFactory.validateInferredType(sft, typesWithPaths.map(_.inferredType.typed))</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        val renamed = typesWithPaths.zip(sft.getAttributeDescriptors.asScala.map(_.getLocalName)).map {</span>
<span class="nc" id="L74">          case (inferred, name) =&gt; inferred.copy(inferredType = inferred.inferredType.copy(name = name))</span>
        }
<span class="nc" id="L76">        InferredTypesWithPaths(sft, renamed)</span>
    }
  }

  /**
    * Try to derive a geometry field, if one does not already exist
    *
    * @param types known types
    * @return
    */
  def deriveGeometry(types: Seq[InferredType], namer: String =&gt; String): Option[InferredType] = {
    // if there is no geometry field, see if we can derive one
<span class="nc bnc" id="L88" title="All 2 branches missed.">    if (types.map(_.typed).exists(ObjectType.GeometrySubtypes.contains)) { None } else {</span>
<span class="nc bnc" id="L89" title="All 12 branches missed.">      val nums = types.filter(t =&gt; t.typed == ObjectType.DOUBLE || t.typed == ObjectType.FLOAT)</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">      if (nums.lengthCompare(2) &lt; 0) { None } else {</span>
        def findBestMatch(names: Seq[String]): Option[InferredType] = {
          // determine priority order
<span class="nc" id="L93">          val potentials = nums.flatMap { t =&gt;</span>
<span class="nc" id="L94">            val name = t.name.toLowerCase(Locale.US)</span>
<span class="nc" id="L95">            val i = names.indexOf(name)</span>
<span class="nc" id="L96">            val j = names.indexWhere(n =&gt; name.endsWith(s&quot;_$n&quot;))</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="nc" id="L98">              Some(i -&gt; t)</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">            } else if (j != -1) {</span>
<span class="nc" id="L100">              Some(j + names.length -&gt; t) // add names.length to make exact matches sort first</span>
            } else {
<span class="nc" id="L102">              None</span>
            }
          }
<span class="nc bnc" id="L105" title="All 4 branches missed.">          potentials.sortBy(_._1).collectFirst { case (_, t) =&gt; t }</span>
        }
        for {
<span class="nc" id="L108">          lat &lt;- findBestMatch(latitudeNames)</span>
<span class="nc" id="L109">          lon &lt;- findBestMatch(longitudeNames)</span>
        } yield {
<span class="nc" id="L111">          InferredType(namer(&quot;geom&quot;), POINT, DerivedTransform(&quot;point&quot;, lon.name, lat.name))</span>
        }
      }
    }
  }

  /**
    * Create a simple feature type from inferred types
    *
    * @param name sft name
    * @param types types
    * @return
    */
  def schema(name: String, types: Seq[InferredType]): SimpleFeatureType = {
<span class="nc" id="L125">    val spec = new StringBuilder()</span>
<span class="nc" id="L126">    types.foreach { typ =&gt;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      if (spec.nonEmpty) {</span>
<span class="nc" id="L128">        spec.append(&quot;,&quot;)</span>
      }
<span class="nc" id="L130">      spec.append(typ.name).append(':').append(typ.binding)</span>
    }
<span class="nc bnc" id="L132" title="All 8 branches missed.">    if (types.exists(_.typed == ObjectType.GEOMETRY)) {</span>
<span class="nc" id="L133">      spec.append(s&quot;;${SimpleFeatureTypes.Configs.MixedGeometries}=true&quot;)</span>
    }
<span class="nc" id="L135">    SimpleFeatureTypes.createType(name, spec.toString())</span>
  }

  /**
    * Merge the values from a given column into a single type
    *
    * @param types types extracted from the column
    * @param failureRate max percentage of values that can fail a conversion to a particular type,
    *                    and still consider the column to be that type
    * @return
    */
  private def merge(types: Seq[InferredType], failureRate: Float): InferredType = {

<span class="nc" id="L148">    val typeCounts = scala.collection.mutable.Map.empty[InferredType, Int].withDefaultValue(0)</span>
<span class="nc" id="L149">    types.foreach(t =&gt; typeCounts(t) += 1)</span>

<span class="nc bnc" id="L151" title="All 2 branches missed.">    if (typeCounts.size == 1) {</span>
      // if only one type, we're good
<span class="nc" id="L153">      return types.head</span>
    }

<span class="nc bnc" id="L156" title="All 2 branches missed.">    var (mostFrequentType, mostFrequentTypeCount) = typeCounts.maxBy(_._2)</span>

<span class="nc bnc" id="L158" title="All 2 branches missed.">    if (1f - mostFrequentTypeCount.toFloat / types.length &lt; failureRate) {</span>
      // if the most frequent type passes the error threshold, use it
<span class="nc" id="L160">      return mostFrequentType</span>
    }

    // try to combine types up into more general ones
<span class="nc bnc" id="L164" title="All 4 branches missed.">    val mergedTypeCounts = typeCounts.foldLeft(Map.empty[InferredType, Int]) { case (counts, (typ, count)) =&gt;</span>
<span class="nc" id="L165">      val merged = scala.collection.mutable.Map.empty[InferredType, (InferredType, Int)] // from -&gt; to</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">      counts.foreach { case (mergedType, mergedCount) =&gt;</span>
<span class="nc" id="L167">        merge(typ, mergedType).foreach(t =&gt; merged += mergedType -&gt; (t, mergedCount + count))</span>
      }
<span class="nc bnc" id="L169" title="All 2 branches missed.">      if (merged.isEmpty) {</span>
<span class="nc" id="L170">        counts + (typ -&gt; count)</span>
      } else {
<span class="nc" id="L172">        (counts -- merged.keys) ++ merged.values</span>
      }
    }

<span class="nc bnc" id="L176" title="All 2 branches missed.">    mergedTypeCounts.maxBy(_._2) match {</span>
<span class="nc" id="L177">      case (t, c) =&gt; mostFrequentType = t; mostFrequentTypeCount = c</span>
    }

<span class="nc bnc" id="L180" title="All 2 branches missed.">    if (1f - mostFrequentTypeCount.toFloat / types.length &lt; failureRate) {</span>
      // if the most frequent merged type passes the error threshold, use it
<span class="nc" id="L182">      return mostFrequentType</span>
    }

    // if nothing else, fall back to string
<span class="nc" id="L186">    InferredType(&quot;&quot;, STRING, CastToString)</span>
  }

  /**
    * Merge two types into a single super-type, if one exists
    *
    * for example:
    *
    *   merge(float, double) == double
    *   merge(point, linestring) == geometry
    *
    * @param left first type
    * @param right second type
    * @return
    */
  private def merge(left: InferredType, right: InferredType): Option[InferredType] = {
    // string + foo =&gt; string, null + foo =&gt; foo
<span class="nc bnc" id="L203" title="All 14 branches missed.">    if (left == right || left.typed == STRING || right.typed == null) {</span>
<span class="nc" id="L204">      Some(left)</span>
<span class="nc bnc" id="L205" title="All 8 branches missed.">    } else if (left.typed == null || right.typed == STRING) {</span>
<span class="nc" id="L206">      Some(right)</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">    } else if (ObjectType.GeometrySubtypes.contains(left.typed) &amp;&amp; ObjectType.GeometrySubtypes.contains(right.typed)) {</span>
<span class="nc" id="L208">      Some(InferredType(&quot;&quot;, GEOMETRY, IdentityTransform))</span>
    } else {
      for {
<span class="nc bnc" id="L211" title="All 4 branches missed.">        (leftPriority, leftTransform) &lt;- mergeUpNumbers.get(left.typed)</span>
<span class="nc bnc" id="L212" title="All 4 branches missed.">        (rightPriority, rightTransform) &lt;- mergeUpNumbers.get(right.typed)</span>
      } yield {
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (leftPriority &lt;= rightPriority) {</span>
<span class="nc" id="L215">          left.copy(transform = leftTransform)</span>
        } else {
<span class="nc" id="L217">          right.copy(transform = rightTransform)</span>
        }
      }
    }
  }

  /**
    * Get the simple feature type spec binding for a type
    *
    * @param typed object type
    * @return
    */
<span class="nc" id="L229">  private def binding(typed: ObjectType): String = typed match {</span>
<span class="nc bnc" id="L230" title="All 10 branches missed.">    case STRING | null       =&gt; &quot;String&quot;</span>
<span class="nc bnc" id="L231" title="All 6 branches missed.">    case INT                 =&gt; &quot;Int&quot;</span>
<span class="nc bnc" id="L232" title="All 6 branches missed.">    case LONG                =&gt; &quot;Long&quot;</span>
<span class="nc bnc" id="L233" title="All 6 branches missed.">    case FLOAT               =&gt; &quot;Float&quot;</span>
<span class="nc bnc" id="L234" title="All 6 branches missed.">    case DOUBLE              =&gt; &quot;Double&quot;</span>
<span class="nc bnc" id="L235" title="All 6 branches missed.">    case BOOLEAN             =&gt; &quot;Boolean&quot;</span>
<span class="nc bnc" id="L236" title="All 6 branches missed.">    case DATE                =&gt; &quot;Date&quot;</span>
<span class="nc bnc" id="L237" title="All 6 branches missed.">    case UUID                =&gt; &quot;UUID&quot;</span>
<span class="nc bnc" id="L238" title="All 6 branches missed.">    case LIST                =&gt; &quot;List&quot;</span>
<span class="nc bnc" id="L239" title="All 6 branches missed.">    case MAP                 =&gt; &quot;Map&quot;</span>
<span class="nc bnc" id="L240" title="All 6 branches missed.">    case BYTES               =&gt; &quot;Bytes&quot;</span>
<span class="nc bnc" id="L241" title="All 6 branches missed.">    case JSON                =&gt; &quot;String:json=true&quot;</span>
<span class="nc bnc" id="L242" title="All 6 branches missed.">    case POINT               =&gt; &quot;Point:srid=4326&quot;</span>
<span class="nc bnc" id="L243" title="All 6 branches missed.">    case LINESTRING          =&gt; &quot;LineString:srid=4326&quot;</span>
<span class="nc bnc" id="L244" title="All 6 branches missed.">    case POLYGON             =&gt; &quot;Polygon:srid=4326&quot;</span>
<span class="nc bnc" id="L245" title="All 6 branches missed.">    case MULTIPOINT          =&gt; &quot;MultiPoint:srid=4326&quot;</span>
<span class="nc bnc" id="L246" title="All 6 branches missed.">    case MULTILINESTRING     =&gt; &quot;MultiLineString:srid=4326&quot;</span>
<span class="nc bnc" id="L247" title="All 6 branches missed.">    case MULTIPOLYGON        =&gt; &quot;MultiPolygon:srid=4326&quot;</span>
<span class="nc bnc" id="L248" title="All 6 branches missed.">    case GEOMETRY_COLLECTION =&gt; &quot;GeometryCollection:srid=4326&quot;</span>
<span class="nc bnc" id="L249" title="All 6 branches missed.">    case GEOMETRY            =&gt; &quot;Geometry:srid=4326&quot;</span>
  }

  /**
   * Helper for naming attributes during type inference
   */
<span class="nc" id="L255">  class Namer(existing: Seq[String] = Seq.empty) extends (String =&gt; String) {</span>

    // track the names we use for each column to ensure no duplicates
<span class="nc" id="L258">    private val uniqueNames = scala.collection.mutable.HashSet[String](existing: _*)</span>

    /**
     * Get a valid attribute name based on the element name
     *
     * @param key json key
     * @return
     */
    override def apply(key: String): String = {
<span class="nc" id="L267">      val base = key.replaceAll(&quot;[^A-Za-z0-9]+&quot;, &quot;_&quot;).replaceAll(&quot;^_|_$&quot;, &quot;&quot;)</span>
<span class="nc" id="L268">      var candidate = base</span>
<span class="nc" id="L269">      var i = 0</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">      while (FeatureUtils.ReservedWords.contains(candidate.toUpperCase(Locale.US)) || !uniqueNames.add(candidate)) {</span>
<span class="nc" id="L271">        candidate = s&quot;${base}_$i&quot;</span>
<span class="nc" id="L272">        i += 1</span>
      }
<span class="nc" id="L274">      candidate</span>
    }
  }

  /**
   * Path to an attribute (xpath, json path, column number) and the values of that attribute
   *
   * @param path path
   * @param values sample values
   */
<span class="nc bnc" id="L284" title="All 25 branches missed.">  case class PathWithValues(path: String, values: Iterable[Any])</span>

  /**
   * Inferred feature type
   *
   * @param sft simple feature type
   * @param types types and paths to the attributes
   */
<span class="nc bnc" id="L292" title="All 25 branches missed.">  case class InferredTypesWithPaths(sft: SimpleFeatureType, types: Seq[TypeWithPath])</span>

  /**
   * An attribute type with a path to the attribute (xpath, json path, column number, etc)
   *
   * @param path path
   * @param inferredType type
   */
<span class="nc bnc" id="L300" title="All 25 branches missed.">  case class TypeWithPath(path: String, inferredType: InferredType)</span>

  /**
    * Inferred type of a converter field
    *
    * @param name name of the field
    * @param typed type of the field
    * @param transform converter transform
    */
<span class="nc bnc" id="L309" title="All 32 branches missed.">  case class InferredType(name: String, typed: ObjectType, transform: InferredTransform) {</span>
<span class="nc" id="L310">    def binding: String = TypeInference.binding(typed)</span>
  }

  /**
    * Inferred converter transform
    */
  sealed trait InferredTransform {

    /**
      * Get the converter transform as a string, suitable for the 'transform' field of a converter field definition
      *
      * @param i the index of the raw value in the transform arguments array.
      *          for delimited text, this would generally be the column number.
      *          for json, it would generally be '0', since the json-path result is placed at index 0
      * @return
      */
    def apply(i: Int): String
  }

<span class="nc" id="L329">  case object IdentityTransform extends InferredTransform {</span>
<span class="nc" id="L330">    def apply(i: Int): String = s&quot;$$$i&quot;</span>
  }

<span class="nc" id="L333">  sealed class CastTransform(to: String) extends InferredTransform {</span>
<span class="nc" id="L334">    def apply(i: Int): String = s&quot;$to($$$i)&quot;</span>
  }

<span class="nc" id="L337">  case object CastToInt extends CastTransform(&quot;toInt&quot;)</span>
<span class="nc" id="L338">  case object CastToLong extends CastTransform(&quot;toLong&quot;)</span>
<span class="nc" id="L339">  case object CastToFloat extends CastTransform(&quot;toFloat&quot;)</span>
<span class="nc" id="L340">  case object CastToDouble extends CastTransform(&quot;toDouble&quot;)</span>
<span class="nc" id="L341">  case object CastToBoolean extends CastTransform(&quot;toBoolean&quot;)</span>
<span class="nc" id="L342">  case object CastToString extends CastTransform(&quot;toString&quot;)</span>

<span class="nc bnc" id="L344" title="All 25 branches missed.">  case class FunctionTransform(prefix: String, suffix: String) extends InferredTransform {</span>
<span class="nc" id="L345">    def apply(i: Int): String = s&quot;$prefix$$$i$suffix&quot;</span>
  }

  // function transform that only operates on derived fields and not $i
<span class="nc bnc" id="L349" title="All 25 branches missed.">  case class DerivedTransform(name: String, fields: String*) extends InferredTransform {</span>
<span class="nc" id="L350">    def apply(i: Int): String = s&quot;$name${fields.mkString(&quot;($&quot;, &quot;,$&quot;, &quot;)&quot;)}&quot;</span>
  }

<span class="nc" id="L353">  object InferredType {</span>

<span class="nc bnc" id="L355" title="All 4 branches missed.">    private val dateParsers = TransformerFunction.functions.values.collect { case f: StandardDateParser =&gt; f }.toArray</span>

    /**
      * Infer a type from a value. Returned type will have an empty name
      *
      * @param value value
      * @return
      */
    def infer(value: Any): InferredType = {
<span class="nc" id="L364">      value match {</span>
<span class="nc bnc" id="L365" title="All 6 branches missed.">        case null | &quot;&quot;                =&gt; InferredType(&quot;&quot;, null, IdentityTransform)</span>
<span class="nc bnc" id="L366" title="All 6 branches missed.">        case _: Int | _: Integer      =&gt; InferredType(&quot;&quot;, INT, IdentityTransform)</span>
<span class="nc bnc" id="L367" title="All 6 branches missed.">        case _: Long | _: jLong       =&gt; InferredType(&quot;&quot;, LONG, IdentityTransform)</span>
<span class="nc bnc" id="L368" title="All 6 branches missed.">        case _: Float | _: jFloat     =&gt; InferredType(&quot;&quot;, FLOAT, IdentityTransform)</span>
<span class="nc bnc" id="L369" title="All 6 branches missed.">        case _: Double | _: jDouble   =&gt; InferredType(&quot;&quot;, DOUBLE, IdentityTransform)</span>
<span class="nc bnc" id="L370" title="All 6 branches missed.">        case _: Boolean | _: jBoolean =&gt; InferredType(&quot;&quot;, BOOLEAN, IdentityTransform)</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        case _: Date                  =&gt; InferredType(&quot;&quot;, DATE, IdentityTransform)</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">        case _: Array[Byte]           =&gt; InferredType(&quot;&quot;, BYTES, IdentityTransform)</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        case _: java.util.UUID        =&gt; InferredType(&quot;&quot;, UUID, IdentityTransform)</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        case _: Point                 =&gt; InferredType(&quot;&quot;, POINT, IdentityTransform)</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        case _: LineString            =&gt; InferredType(&quot;&quot;, LINESTRING, IdentityTransform)</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        case _: Polygon               =&gt; InferredType(&quot;&quot;, POLYGON, IdentityTransform)</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        case _: MultiPoint            =&gt; InferredType(&quot;&quot;, MULTIPOINT, IdentityTransform)</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        case _: MultiLineString       =&gt; InferredType(&quot;&quot;, MULTILINESTRING, IdentityTransform)</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        case _: MultiPolygon          =&gt; InferredType(&quot;&quot;, MULTIPOLYGON, IdentityTransform)</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        case _: GeometryCollection    =&gt; InferredType(&quot;&quot;, GEOMETRY_COLLECTION, IdentityTransform)</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        case _: java.util.List[_]     =&gt; InferredType(&quot;&quot;, LIST, IdentityTransform)</span>

<span class="nc bnc" id="L383" title="All 2 branches missed.">        case s: String =&gt;</span>
<span class="nc" id="L384">          val trimmed = s.trim</span>
<span class="nc" id="L385">          tryNumberParsing(trimmed)</span>
<span class="nc" id="L386">              .orElse(tryDateParsing(trimmed))</span>
<span class="nc" id="L387">              .orElse(tryGeometryParsing(trimmed))</span>
<span class="nc" id="L388">              .orElse(tryBooleanParsing(trimmed))</span>
<span class="nc" id="L389">              .orElse(tryUuidParsing(trimmed))</span>
<span class="nc" id="L390">              .getOrElse(InferredType(&quot;&quot;, STRING, IdentityTransform))</span>

<span class="nc" id="L392">        case _ =&gt; InferredType(&quot;&quot;, STRING, CastToString)</span>
      }
    }

<span class="nc" id="L396">    private def tryNumberParsing(s: String): Option[InferredType] = {</span>
<span class="nc" id="L397">      Try(BigDecimal(s)).toOption.collect {</span>
<span class="nc bnc" id="L398" title="All 8 branches missed.">        case n if s.indexOf('.') == -1 &amp;&amp; n.isValidInt  =&gt; InferredType(&quot;&quot;, INT, CastToInt)</span>
<span class="nc bnc" id="L399" title="All 8 branches missed.">        case n if s.indexOf('.') == -1 &amp;&amp; n.isValidLong =&gt; InferredType(&quot;&quot;, LONG, CastToLong)</span>
        // don't consider floats - even valid floats cause rounding changes when using as doubles in geometries
<span class="nc bnc" id="L401" title="All 4 branches missed.">        case n if n.isDecimalDouble                     =&gt; InferredType(&quot;&quot;, DOUBLE, CastToDouble)</span>
      }
    }

    private def tryDateParsing(s: String): Option[InferredType] = {
<span class="nc" id="L406">      var i = 0</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">      while (i &lt; dateParsers.length) {</span>
<span class="nc" id="L408">        val p = dateParsers(i)</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (Try(DateParsing.parseDate(s, p.format)).isSuccess) {</span>
<span class="nc" id="L410">          return Some(InferredType(&quot;&quot;, DATE, FunctionTransform(s&quot;${p.names.head}(&quot;, &quot;)&quot;)))</span>
        }
<span class="nc" id="L412">        i += 1</span>
      }
<span class="nc" id="L414">      None</span>
    }

    private def tryGeometryParsing(s: String): Option[InferredType] = {
<span class="nc" id="L418">      Try(WKTUtils.read(s)).toOption.map {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        case _: Point              =&gt; InferredType(&quot;&quot;, POINT, FunctionTransform(&quot;point(&quot;, &quot;)&quot;))</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        case _: LineString         =&gt; InferredType(&quot;&quot;, LINESTRING, FunctionTransform(&quot;linestring(&quot;, &quot;)&quot;))</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        case _: Polygon            =&gt; InferredType(&quot;&quot;, POLYGON, FunctionTransform(&quot;polygon(&quot;, &quot;)&quot;))</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">        case _: MultiPoint         =&gt; InferredType(&quot;&quot;, MULTIPOINT, FunctionTransform(&quot;multipoint(&quot;, &quot;)&quot;))</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        case _: MultiLineString    =&gt; InferredType(&quot;&quot;, MULTILINESTRING, FunctionTransform(&quot;multilinestring(&quot;, &quot;)&quot;))</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        case _: MultiPolygon       =&gt; InferredType(&quot;&quot;, MULTIPOLYGON, FunctionTransform(&quot;multipolygon(&quot;, &quot;)&quot;))</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        case _: GeometryCollection =&gt; InferredType(&quot;&quot;, GEOMETRY_COLLECTION, FunctionTransform(&quot;geometrycollection(&quot;, &quot;)&quot;))</span>
<span class="nc" id="L426">        case _                     =&gt; InferredType(&quot;&quot;, GEOMETRY, FunctionTransform(&quot;geometry(&quot;, &quot;)&quot;))</span>
      }
    }

    private def tryBooleanParsing(s: String): Option[InferredType] =
<span class="nc" id="L431">      Try(s.toBoolean).toOption.map(_ =&gt; InferredType(&quot;&quot;, BOOLEAN, CastToBoolean))</span>

    private def tryUuidParsing(s: String): Option[InferredType] =
<span class="nc" id="L434">      Try(java.util.UUID.fromString(s)).toOption.map(_ =&gt; InferredType(&quot;&quot;, UUID, IdentityTransform))</span>
  }
<span class="nc" id="L436">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>