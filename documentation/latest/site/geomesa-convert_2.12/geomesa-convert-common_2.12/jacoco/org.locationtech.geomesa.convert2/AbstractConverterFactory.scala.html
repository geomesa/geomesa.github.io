<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractConverterFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert2</a> &gt; <span class="el_source">AbstractConverterFactory.scala</span></div><h1>AbstractConverterFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert2

import com.typesafe.config._
import com.typesafe.scalalogging.{LazyLogging, Logger}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.convert.ConverterConfigLoader
import org.locationtech.geomesa.convert.Modes.{ErrorMode, ParseMode}
import org.locationtech.geomesa.convert2.AbstractConverter.{BasicConfig, BasicField, BasicOptions}
import org.locationtech.geomesa.convert2.AbstractConverterFactory.{ConverterConfigConvert, ConverterOptionsConvert, FieldConvert}
import org.locationtech.geomesa.convert2.transforms.Expression
import org.locationtech.geomesa.convert2.validators.{HasDtgValidatorFactory, HasGeoValidatorFactory}
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import pureconfig._
import pureconfig.error.{CannotConvert, ConfigReaderFailures}

import java.lang.reflect.InvocationTargetException
import java.nio.charset.Charset
import java.util.Collections
import scala.collection.mutable.ArrayBuffer
import scala.reflect.{ClassTag, classTag}
import scala.util.control.NonFatal

/**
  * Abstract converter factory implementation. Subclasses need to implement `typeToProcess` and make available
  * pureconfig readers for the converter configuration
 *
 *  The converter to use is identified by the 'type' field in the config, e.g. 'xml' or 'json'
  */
<span class="nc bnc" id="L39" title="All 4 branches missed.">abstract class AbstractConverterFactory[S &lt;: AbstractConverter[_, C, F, O] : ClassTag, C &lt;: ConverterConfig : ClassTag, F &lt;: Field : ClassTag, O &lt;: ConverterOptions : ClassTag](</span>
<span class="nc" id="L40">    val typeToProcess: String,</span>
<span class="nc" id="L41">    protected val configConvert: ConverterConfigConvert[C],</span>
<span class="nc" id="L42">    protected val fieldConvert: FieldConvert[F],</span>
<span class="nc" id="L43">    protected val optsConvert: ConverterOptionsConvert[O]</span>
<span class="nc" id="L44">  ) extends SimpleFeatureConverterFactory {</span>

<span class="nc" id="L46">  private def loadConfig(config: ConfigObjectSource): C = config.loadOrThrow[C](classTag[C], configConvert)</span>
<span class="nc" id="L47">  private def loadFields(config: ConfigObjectSource): Seq[F] = config.loadOrThrow[Seq[F]](classTag[Seq[F]], fieldConvert)</span>
<span class="nc" id="L48">  private def loadOptions(config: ConfigObjectSource): O = config.loadOrThrow[O](classTag[O], optsConvert)</span>

  override def apply(sft: SimpleFeatureType, conf: Config): Option[SimpleFeatureConverter] = {
<span class="nc bnc" id="L51" title="All 4 branches missed.">    if (!conf.hasPath(&quot;type&quot;) || !conf.getString(&quot;type&quot;).equalsIgnoreCase(typeToProcess)) { None } else {</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">      val (config, fields, opts) = try {</span>
        val c = ConfigSource.fromConfig(withDefaults(conf))
        (loadConfig(c), loadFields(c), loadOptions(c))
      } catch {
        case NonFatal(e) =&gt; throw new IllegalArgumentException(s&quot;Invalid configuration: ${e.getMessage}&quot;)
      }
<span class="nc" id="L58">      val args = Array(classOf[SimpleFeatureType], implicitly[ClassTag[C]].runtimeClass,</span>
<span class="nc" id="L59">        classOf[Seq[F]], implicitly[ClassTag[O]].runtimeClass)</span>
<span class="nc" id="L60">      val constructor = implicitly[ClassTag[S]].runtimeClass.getConstructor(args: _*)</span>
      try {
<span class="nc" id="L62">        Some(constructor.newInstance(sft, config, fields, opts).asInstanceOf[SimpleFeatureConverter])</span>
      } catch {
<span class="nc" id="L64">        case e: InvocationTargetException =&gt; throw e.getCause</span>
      }
    }
  }

  /**
    * Add default paths to the config, and handle deprecated options
    *
    * @param conf config
    * @return
    */
<span class="nc" id="L75">  protected def withDefaults(conf: Config): Config = AbstractConverterFactory.standardDefaults(conf, logger)</span>
}

<span class="nc bnc" id="L78" title="All 4 branches missed.">object AbstractConverterFactory extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L82">  val InferSampleSize: SystemProperty = SystemProperty(&quot;geomesa.convert.infer.sample&quot;, &quot;100&quot;)</span>

<span class="nc" id="L84">  def inferSampleSize: Int = InferSampleSize.toInt.getOrElse {</span>
    // shouldn't ever happen since the default is a valid int
<span class="nc" id="L86">    throw new IllegalStateException(&quot;Could not determine sample size from system property&quot;)</span>
  }

  /**
    * Validate an inferred type matches an existing type
    *
    * @param sft existing type
    * @param types inferred type
    * @return true if types match, otherwise false
    */
<span class="nc" id="L96">  def validateInferredType(sft: SimpleFeatureType, types: Seq[ObjectType], raiseError: Boolean = true): Boolean = {</span>
<span class="nc" id="L97">    val existing = sft.getAttributeDescriptors.asScala.map(ObjectType.selectType).collect {</span>
<span class="nc bnc" id="L98" title="All 24 branches missed.">      case Seq(ObjectType.GEOMETRY, subtype) =&gt; subtype</span>
<span class="nc" id="L99">      case t =&gt; t.head</span>
    }
<span class="nc bnc" id="L101" title="All 8 branches missed.">    if (existing == types) { true } else if (!raiseError) { false } else {</span>
<span class="nc" id="L102">      throw new IllegalArgumentException(s&quot;Simple feature type does not match inferred schema: &quot; +</span>
<span class="nc" id="L103">          s&quot;\n\tExisting types: ${existing.mkString(&quot;, &quot;)}&quot; +</span>
<span class="nc" id="L104">          s&quot;\n\tInferred types: ${types.mkString(&quot;, &quot;)}&quot;)</span>
    }
  }

  /**
    * Handles common deprecated values and quoting of user data keys
    *
    * @param conf conf
    * @return
    */
  def standardDefaults(conf: Config, logger: =&gt; Logger): Config = {
    import scala.collection.JavaConverters._

<span class="nc" id="L117">    val updates = ArrayBuffer.empty[Config =&gt; Config]</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">    if (conf.hasPath(&quot;options.validation-mode&quot;)) {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">      logger.warn(s&quot;Using deprecated option 'validation-mode' - use 'error-mode' instead&quot;)</span>
<span class="nc" id="L120">      updates.append(c =&gt; c.withValue(&quot;options.error-mode&quot;, conf.getValue(&quot;options.validation-mode&quot;)))</span>
    }
<span class="nc bnc" id="L122" title="All 2 branches missed.">    if (conf.hasPath(&quot;options.validating&quot;)) {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">      logger.warn(s&quot;Using deprecated option 'validating' - use 'error-mode' instead&quot;)</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">      val validators = if (conf.getBoolean(&quot;options.validating&quot;)) {</span>
<span class="nc" id="L125">        ConfigValueFactory.fromIterable(Seq(HasGeoValidatorFactory.Name, HasDtgValidatorFactory.Name).asJava)</span>
      } else {
<span class="nc" id="L127">        ConfigValueFactory.fromIterable(Collections.emptyList())</span>
      }
<span class="nc" id="L129">      updates.append(c =&gt; c.withValue(&quot;options.validators&quot;, validators))</span>
    }

<span class="nc" id="L132">    updates.foldLeft(conf)((c, mod) =&gt; mod.apply(c)).withFallback(ConfigFactory.load(&quot;base-converter-defaults&quot;))</span>
  }

  /**
    * Default pureconfig convert for a basic configuration, for converters that don't have
    * any additional config options
    */
<span class="nc" id="L139">  implicit object BasicConfigConvert extends ConverterConfigConvert[BasicConfig] {</span>

    override protected def decodeConfig(
        cur: ConfigObjectCursor,
        `type`: String,
        idField: Option[Expression],
        caches: Map[String, Config],
        userData: Map[String, Expression]): Either[ConfigReaderFailures, BasicConfig] = {
<span class="nc" id="L147">      for { name &lt;- converterName(cur).right } yield {</span>
<span class="nc" id="L148">        BasicConfig(`type`, name, idField, caches, userData)</span>
      }
    }

<span class="nc" id="L152">    override protected def encodeConfig(config: BasicConfig, base: java.util.Map[String, AnyRef]): Unit = {}</span>
  }

  /**
    * Default pureconfig convert for a basic field, for converters that don't have
    * any additional field options
    */
<span class="nc" id="L159">  implicit object BasicFieldConvert extends FieldConvert[BasicField] {</span>

    override protected def decodeField(cur: ConfigObjectCursor,
                                       name: String,
                                       transform: Option[Expression]): Either[ConfigReaderFailures, BasicField] = {
<span class="nc" id="L164">      Right(BasicField(name, transform))</span>
    }

<span class="nc" id="L167">    override protected def encodeField(field: BasicField, base: java.util.Map[String, AnyRef]): Unit = {}</span>
  }

  /**
    * Default pureconfig convert for basic options, for converters that don't have
    * any additional options
    */
<span class="nc" id="L174">  implicit object BasicOptionsConvert extends ConverterOptionsConvert[BasicOptions] {</span>

    override protected def decodeOptions(
        cur: ConfigObjectCursor,
        validators: Seq[String],
        parseMode: ParseMode,
        errorMode: ErrorMode,
        encoding: Charset): Either[ConfigReaderFailures, BasicOptions] = {
<span class="nc" id="L182">      Right(BasicOptions(validators, parseMode, errorMode, encoding))</span>
    }

<span class="nc" id="L185">    override protected def encodeOptions(options: BasicOptions, base: java.util.Map[String, AnyRef]): Unit = {}</span>
  }

  /**
    * Pureconfig convert that parses out basic config. Subclasses must implement `decodeConfig` and `encodeConfig`
    * to read/write any custom config
    *
    * @tparam C config class
    */
<span class="nc" id="L194">  abstract class ConverterConfigConvert[C &lt;: ConverterConfig]</span>
<span class="nc" id="L195">      extends ConfigConvert[C] with ExpressionConvert with ConfigMapConvert {</span>

    protected def decodeConfig(
        cur: ConfigObjectCursor,
        `type`: String,
        idField: Option[Expression],
        caches: Map[String, Config],
        userData: Map[String, Expression]): Either[ConfigReaderFailures, C]

    protected def encodeConfig(config: C, base: java.util.Map[String, AnyRef]): Unit

    override def from(cur: ConfigCursor): Either[ConfigReaderFailures, C] = {
      for {
<span class="nc" id="L208">        obj      &lt;- cur.asObjectCursor.right</span>
<span class="nc" id="L209">        typ      &lt;- obj.atKey(&quot;type&quot;).right.flatMap(_.asString).right</span>
<span class="nc" id="L210">        idField  &lt;- idFieldFrom(obj.atKeyOrUndefined(&quot;id-field&quot;)).right</span>
<span class="nc" id="L211">        userData &lt;- userDataFrom(obj.atKeyOrUndefined(&quot;user-data&quot;)).right</span>
<span class="nc" id="L212">        caches   &lt;- configMapFrom(obj.atKeyOrUndefined(&quot;caches&quot;)).right</span>
<span class="nc" id="L213">        config   &lt;- decodeConfig(obj, typ, idField, caches, userData).right</span>
      } yield {
<span class="nc" id="L215">        config</span>
      }
    }

<span class="nc" id="L219">    override def to(obj: C): ConfigObject = ConfigValueFactory.fromMap(configTo(obj))</span>

    protected def converterName(cur: ConfigObjectCursor): Either[ConfigReaderFailures, Option[String]] =
<span class="nc" id="L222">      optionalStringFrom(cur.atKeyOrUndefined(ConverterConfigLoader.ConverterNameKey))</span>

    private def configTo(config: C): java.util.Map[String, AnyRef] = {
<span class="nc" id="L225">      val map = new java.util.HashMap[String, AnyRef]</span>
<span class="nc" id="L226">      map.put(&quot;type&quot;, config.`type`)</span>
<span class="nc" id="L227">      config.idField.foreach(f =&gt; map.put(&quot;id-field&quot;, f.toString))</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">      if (config.userData.nonEmpty) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        map.put(&quot;user-data&quot;, config.userData.map { case (k, v) =&gt; (k, v.toString.asInstanceOf[AnyRef]) }.asJava)</span>
      }
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (config.caches.nonEmpty) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        map.put(&quot;caches&quot;, config.caches.map { case (k, v) =&gt; (k, v.root().unwrapped()) })</span>
      }
<span class="nc" id="L234">      encodeConfig(config, map)</span>
<span class="nc" id="L235">      map</span>
    }

    private def optionalStringFrom(cur: ConfigCursor): Either[ConfigReaderFailures, Option[String]] =
<span class="nc bnc" id="L239" title="All 2 branches missed.">      if (cur.isUndefined) { Right(None) } else { cur.asString.right.map(s =&gt; Option(s)) }</span>

    private def idFieldFrom(cur: ConfigCursor): Either[ConfigReaderFailures, Option[Expression]] = {
<span class="nc bnc" id="L242" title="All 2 branches missed.">      if (cur.isUndefined) { Right(None) } else {</span>
<span class="nc" id="L243">        for { expr &lt;- exprFrom(cur).right } yield { Some(expr) }</span>
      }
    }

    private def userDataFrom(cur: ConfigCursor): Either[ConfigReaderFailures, Map[String, Expression]] = {
      import org.locationtech.geomesa.utils.conf.ConfConversions.RichConfig

<span class="nc bnc" id="L250" title="All 2 branches missed.">      if (cur.isUndefined) { Right(Map.empty) } else {</span>
        def merge(cur: ConfigObjectCursor): Either[ConfigReaderFailures, Map[String, Expression]] = {
<span class="nc" id="L252">          val map = cur.valueOpt.get.toConfig.toStringMap() // handles quoting keys</span>
<span class="nc bnc" id="L253" title="All 4 branches missed.">          map.foldLeft[Either[ConfigReaderFailures, Map[String, Expression]]](Right(Map.empty)) {</span>
<span class="nc" id="L254">            case (map, (k, v)) =&gt;</span>
              // convert back to a cursor for parsing the expression
<span class="nc" id="L256">              val path = cur.pathElems ++ ConfigUtil.splitPath(k).asScala</span>
<span class="nc" id="L257">              val valueCursor = ConfigCursor(ConfigValueFactory.fromAnyRef(v), path)</span>
<span class="nc" id="L258">              for { m &lt;- map.right; d &lt;- exprFrom(valueCursor).right } yield { m + (k -&gt; d) }</span>
          }
        }
<span class="nc" id="L261">        for { obj &lt;- cur.asObjectCursor.right; data &lt;- merge(obj).right } yield { data }</span>
      }
    }
  }

  /**
    * Pureconfig convert that parses out basic fields. Subclasses must implement `decodeField` and `encodeField`
    * to read/write any custom field values
    *
    * @tparam F field type
    */
<span class="nc" id="L272">  abstract class FieldConvert[F &lt;: Field] extends ConfigConvert[Seq[F]] with ExpressionConvert {</span>

    protected def decodeField(cur: ConfigObjectCursor,
                              name: String,
                              transform: Option[Expression]): Either[ConfigReaderFailures, F]

    protected def encodeField(field: F, base: java.util.Map[String, AnyRef]): Unit

    override def from(cur: ConfigCursor): Either[ConfigReaderFailures, Seq[F]] = {
      for {
<span class="nc" id="L282">        obj    &lt;- cur.asObjectCursor.right</span>
<span class="nc" id="L283">        fields &lt;- obj.atKey(&quot;fields&quot;).right.flatMap(_.asListCursor).right.flatMap(fieldsFrom).right</span>
      } yield {
<span class="nc" id="L285">        fields</span>
      }
    }

    override def to(obj: Seq[F]): ConfigObject = {
<span class="nc" id="L290">      val map = new java.util.HashMap[String, AnyRef]</span>
<span class="nc" id="L291">      map.put(&quot;fields&quot;, obj.map(fieldTo).asJava)</span>
<span class="nc" id="L292">      ConfigValueFactory.fromMap(map)</span>
    }

    private def fieldsFrom(cur: ConfigListCursor): Either[ConfigReaderFailures, Seq[F]] = {
<span class="nc" id="L296">      cur.list.foldLeft[Either[ConfigReaderFailures, Seq[F]]](Right(Seq.empty)) {</span>
<span class="nc" id="L297">        (list, field) =&gt; for { li &lt;- list.right; f &lt;- fieldFrom(field).right } yield { li :+ f }</span>
      }
    }

    private def fieldFrom(cur: ConfigCursor): Either[ConfigReaderFailures, F] = {
      def transformFrom(cur: ConfigCursor): Either[ConfigReaderFailures, Option[Expression]] = {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (cur.isUndefined) { Right(None) } else {</span>
<span class="nc" id="L304">          exprFrom(cur).right.map(t =&gt; Some(t))</span>
        }
      }

      for {
<span class="nc" id="L309">        obj       &lt;- cur.asObjectCursor.right</span>
<span class="nc" id="L310">        name      &lt;- obj.atKey(&quot;name&quot;).right.flatMap(_.asString).right</span>
<span class="nc" id="L311">        transform &lt;- transformFrom(obj.atKeyOrUndefined(&quot;transform&quot;)).right</span>
<span class="nc" id="L312">        field     &lt;- decodeField(obj, name, transform).right</span>
      } yield {
<span class="nc" id="L314">        field</span>
      }
    }

    private def fieldTo(field: F): java.util.Map[String, AnyRef] = {
<span class="nc" id="L319">      val map = new java.util.HashMap[String, AnyRef]</span>
<span class="nc" id="L320">      map.put(&quot;name&quot;, field.name)</span>
<span class="nc" id="L321">      field.transforms.foreach(t =&gt; map.put(&quot;transform&quot;, t.toString))</span>
<span class="nc" id="L322">      encodeField(field, map)</span>
<span class="nc" id="L323">      map</span>
    }
  }

  /**
    * Pureconfig convert that parses out basic options. Subclasses must implement `decodeOptions` and `encodeOptions`
    * to read/write any custom converter options
    *
    * @tparam O options class
    */
<span class="nc" id="L333">  abstract class ConverterOptionsConvert[O &lt;: ConverterOptions] extends ConfigConvert[O] with ConfigMapConvert {</span>

    protected def decodeOptions(
        cur: ConfigObjectCursor,
        validators: Seq[String],
        parseMode: ParseMode,
        errorMode: ErrorMode,
        encoding: Charset): Either[ConfigReaderFailures, O]

    protected def encodeOptions(options: O, base: java.util.Map[String, AnyRef]): Unit

    override def from(cur: ConfigCursor): Either[ConfigReaderFailures, O] = {
      for {
<span class="nc" id="L346">        obj     &lt;- cur.asObjectCursor.right</span>
<span class="nc" id="L347">        options &lt;- obj.atKey(&quot;options&quot;).right.flatMap(_.asObjectCursor).right.flatMap(optionsFrom).right</span>
      } yield {
<span class="nc" id="L349">        options</span>
      }
    }

    override def to(obj: O): ConfigObject = {
<span class="nc" id="L354">      val map = new java.util.HashMap[String, AnyRef]</span>
<span class="nc" id="L355">      map.put(&quot;options&quot;, optionsTo(obj))</span>
<span class="nc" id="L356">      ConfigValueFactory.fromMap(map)</span>
    }

    private def optionsFrom(cur: ConfigObjectCursor): Either[ConfigReaderFailures, O] = {

      def mergeValidators(cur: ConfigListCursor): Either[ConfigReaderFailures, Seq[String]] = {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        cur.list.foldLeft[Either[ConfigReaderFailures, Seq[String]]](Right(Seq.empty)) {</span>
<span class="nc" id="L363">          case (seq, v) =&gt; for { s &lt;- seq.right; string &lt;- v.asString.right } yield { s :+ string }</span>
        }
      }

<span class="nc" id="L367">      def parse[T](key: String, values: Iterable[T], fallback: Map[String, T] = Map.empty[String, T]): Either[ConfigReaderFailures, T] = {</span>
<span class="nc" id="L368">        cur.atKey(key).right.flatMap { value =&gt;</span>
<span class="nc" id="L369">          value.asString.right.flatMap { string =&gt;</span>
<span class="nc bnc" id="L370" title="All 8 branches missed.">            val fb = fallback.collectFirst { case (k, v) if k.equalsIgnoreCase(string) =&gt; v }</span>
<span class="nc" id="L371">            values.find(_.toString.equalsIgnoreCase(string)).orElse(fb) match {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">              case Some(v) =&gt; Right(v)</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">              case None =&gt; value.failed(CannotConvert(value.valueOpt.map(_.toString).orNull, values.head.getClass.getSimpleName, s&quot;Must be one of: ${values.mkString(&quot;, &quot;)}&quot;))</span>
            }
          }
        }
      }

<span class="nc bnc" id="L379" title="All 2 branches missed.">      if (cur.atKey(&quot;verbose&quot;).isRight) {</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        logger.warn(&quot;Using deprecated option 'verbose' - use logging levels instead&quot;)</span>
      }
<span class="nc bnc" id="L382" title="All 2 branches missed.">      if (cur.atKey(&quot;reporters&quot;).isRight) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        logger.warn(</span>
<span class="nc" id="L384">          &quot;Using deprecated option 'reporters' - see https://www.geomesa.org/documentation/stable/user/appendix/metrics.html &quot; +</span>
            &quot;for configuring metrics&quot;)
      }

      for {
<span class="nc" id="L389">        validators &lt;- cur.atKey(&quot;validators&quot;).right.flatMap(_.asListCursor).right.flatMap(mergeValidators).right</span>
<span class="nc" id="L390">        parseMode  &lt;- parse(&quot;parse-mode&quot;, ParseMode.values).right</span>
<span class="nc" id="L391">        errorMode  &lt;- parse(&quot;error-mode&quot;, ErrorMode.values, Map(&quot;skip-bad-records&quot; -&gt; ErrorMode.LogErrors)).right</span>
<span class="nc" id="L392">        encoding   &lt;- cur.atKey(&quot;encoding&quot;).right.flatMap(_.asString).right.map(Charset.forName).right</span>
<span class="nc" id="L393">        options    &lt;- decodeOptions(cur, validators, parseMode, errorMode, encoding).right</span>
      } yield {
<span class="nc" id="L395">        options</span>
      }
    }

    private def optionsTo(options: O): java.util.Map[String, AnyRef] = {
<span class="nc" id="L400">      val map = new java.util.HashMap[String, AnyRef]</span>
<span class="nc" id="L401">      map.put(&quot;parse-mode&quot;, options.parseMode.toString)</span>
<span class="nc" id="L402">      map.put(&quot;error-mode&quot;, options.errorMode.toString)</span>
<span class="nc" id="L403">      map.put(&quot;encoding&quot;, options.encoding.name)</span>
<span class="nc" id="L404">      map.put(&quot;validators&quot;, options.validators.asJava)</span>
<span class="nc" id="L405">      encodeOptions(options, map)</span>
<span class="nc" id="L406">      map</span>
    }
  }

  /**
    * Convert a transformer expression
    */
<span class="nc" id="L413">  trait ExpressionConvert {</span>
    protected def exprFrom(cur: ConfigCursor): Either[ConfigReaderFailures, Expression] = {
      def parse(expr: String): Either[ConfigReaderFailures, Expression] =
<span class="nc" id="L416">        try { Right(Expression(expr)) } catch {</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">          case NonFatal(e) =&gt; cur.failed(CannotConvert(cur.valueOpt.map(_.toString).orNull, &quot;Expression&quot;, e.getMessage))</span>
        }
<span class="nc" id="L419">      for { raw  &lt;- cur.asString.right; expr &lt;- parse(raw).right } yield { expr }</span>
    }
  }

  /**
    * Convert an optional path, as a string
    */
<span class="nc" id="L426">  trait OptionConvert {</span>
    protected def optional(cur: ConfigObjectCursor, key: String): Either[ConfigReaderFailures, Option[String]] = {
<span class="nc" id="L428">      val optCur = cur.atKeyOrUndefined(key)</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">      if (optCur.isUndefined) { Right(None) } else {</span>
<span class="nc" id="L430">        optCur.asString.right.map(Option.apply)</span>
      }
    }
  }

  /**
    * Convert named configs
    */
<span class="nc" id="L438">  trait ConfigMapConvert {</span>
    protected def configMapFrom(cur: ConfigCursor): Either[ConfigReaderFailures, Map[String, Config]] = {
<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (cur.isUndefined) { Right(Map.empty) } else {</span>
        def merge(cur: ConfigObjectCursor): Either[ConfigReaderFailures, Map[String, Config]] = {
<span class="nc bnc" id="L442" title="All 4 branches missed.">          cur.map.foldLeft[Either[ConfigReaderFailures, Map[String, Config]]](Right(Map.empty)) {</span>
<span class="nc" id="L443">            case (map, (k, v)) =&gt;</span>
<span class="nc" id="L444">              for { m &lt;- map.right; c &lt;- v.asObjectCursor.right } yield {</span>
<span class="nc" id="L445">                m + (k -&gt; c.valueOpt.map(_.toConfig).getOrElse(ConfigFactory.empty))</span>
              }
          }
        }
<span class="nc" id="L449">        for { obj &lt;- cur.asObjectCursor.right; configs &lt;- merge(obj).right } yield { configs }</span>
      }
    }
  }

  /**
    * Access to primitive converts
    */
<span class="nc" id="L457">  object PrimitiveConvert extends PrimitiveReaders with PrimitiveWriters</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>