<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EvaluationContext.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert</a> &gt; <span class="el_source">EvaluationContext.scala</span></div><h1>EvaluationContext.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert

import com.typesafe.scalalogging.LazyLogging
import io.micrometer.core.instrument.{Counter, Metrics, Tags}
import org.locationtech.geomesa.convert.EvaluationContext.{ContextListener, EvaluationError, FieldAccessor}
import org.locationtech.geomesa.convert2.Field
import org.locationtech.geomesa.convert2.metrics.ConverterMetrics

import java.util.concurrent.atomic.AtomicLong
import scala.util.control.NonFatal

/**
 * Holds the state associated with a conversion attempt. Evaluation contexts are not thread safe.
 */
<span class="nc" id="L23">trait EvaluationContext {</span>

  /**
    * The current line being processed.
    *
    * This may be an actual line (e.g. a csv row), or a logical line (e.g. an avro record)
    *
    * @return
    */
<span class="nc" id="L32">  var line: Long = 0</span>

  /**
    * Enrichment caches
    *
    * @return
    */
  def cache: Map[String, EnrichmentCache]

  /**
    * Counter for tracking successes
    *
    * @return
    */
  @deprecated(&quot;Replaced with `stats`&quot;)
  def success: com.codahale.metrics.Counter

  /**
    * Counter for tracking failures
    *
    * @return
    */
  @deprecated(&quot;Replaced with `stats`&quot;)
  def failure: com.codahale.metrics.Counter

  /**
   * Result stats
   *
   * @return
   */
  def stats: EvaluationContext.Stats

  /**
   * Access to any errors that have occurred - note that errors will generally only be kept if the converter
   * error mode is set to `ReturnErrors`
   *
   * @return
   */
  def errors: java.util.Queue[EvaluationError]

  /**
   * Gets a references to a field's value
   *
   * @param name field name
   * @return
   */
  def accessor(name: String): FieldAccessor

  /**
   * Evaluate all values using the given arguments. The returned array may be mutated on subsequent calls to
   * `evaluate`, so shouldn't be kept long-term
   *
   * @param args single row of input
   */
  def evaluate(args: Array[AnyRef]): Either[EvaluationError, Array[AnyRef]]

  /**
   * Returns a new context with a listener attached
   */
  def withListener(listener: ContextListener): EvaluationContext
}

<span class="nc bnc" id="L94" title="All 4 branches missed.">object EvaluationContext extends LazyLogging {</span>

<span class="nc" id="L96">  val InputFilePathKey = &quot;inputFilePath&quot;</span>
<span class="nc" id="L97">  val FilterKey = &quot;filter&quot;</span>

  /**
    * Creates a new, empty evaluation context
    *
    * @return
    */
  def empty: EvaluationContext =
<span class="nc" id="L105">    new StatefulEvaluationContext(Array.empty, Map.empty, Map.empty, Stats())</span>

  /**
    * Gets a global parameter map containing the input file path
    *
    * @param file input file path
    * @return
    */
<span class="nc" id="L113">  def inputFileParam(file: String): Map[String, AnyRef] = Map(InputFilePathKey -&gt; file)</span>

  /**
   * Trait for reading a field from an evaluation context
   */
  sealed trait FieldAccessor {
    def apply(): AnyRef
  }

<span class="nc" id="L122">  case object NullFieldAccessor extends FieldAccessor {</span>
<span class="nc" id="L123">    override def apply(): AnyRef = null</span>
  }

<span class="nc" id="L126">  class FieldValueAccessor(values: Array[AnyRef], i: Int) extends FieldAccessor {</span>
<span class="nc" id="L127">    override def apply(): AnyRef = values(i)</span>
  }

<span class="nc" id="L130">  class GlobalFieldAccessor(value: AnyRef) extends FieldAccessor {</span>
<span class="nc" id="L131">    override def apply(): AnyRef = value</span>
  }

  /**
   * Marker trait for resources that are dependent on the evaluation context state
   *
   * @tparam T type
   */
  trait ContextDependent[T &lt;: ContextDependent[T]] {

    /**
     * Return a copy of the instance tied to the given evaluation context.
     *
     * If the instance does not use the evaluation context, it should return itself instead of a copy
     *
     * @param ec evaluation context
     * @return
     */
    def withContext(ec: EvaluationContext): T
  }

  /**
   * Tracks success and failures in the conversion process
   */
  trait Stats {

    /**
     * Increment and retrieve success counts
     *
     * @param i amount to increment (may be zero to just retrieve current value)
     * @return
     */
<span class="nc" id="L163">    def success(i: Int = 1): Long</span>

    /**
     * Increment and retrieve failure counts
     *
     * @param i amount to increment (may be zero to just retrieve current value)
     * @return
     */
<span class="nc" id="L171">    def failure(i: Int = 1): Long</span>
  }

<span class="nc" id="L174">  object Stats {</span>

    /**
     * Create a new stats instance
     *
     * @param tags tags to apply to any metrics
     * @return
     */
<span class="nc" id="L182">    def apply(tags: Tags = Tags.empty()): Stats = {</span>
<span class="nc" id="L183">      val name = ConverterMetrics.name(&quot;count&quot;)</span>
<span class="nc" id="L184">      MicrometerStats(Metrics.counter(name, tags.and(&quot;result&quot;, &quot;success&quot;)), Metrics.counter(name, tags.and(&quot;result&quot;, &quot;failure&quot;)))</span>
    }

    /**
     * Wraps dropwizard counters, for back-compatibility
     *
     * @param dwSuccess success
     * @param dwFailure failure
     * @param tags tags
     * @return
     */
<span class="nc" id="L195">    private[geomesa] def wrap(dwSuccess: com.codahale.metrics.Counter, dwFailure: com.codahale.metrics.Counter, tags: Tags): Stats = {</span>
<span class="nc" id="L196">      new Stats {</span>
<span class="nc" id="L197">        private val delegate = Stats(tags) // sets up the micrometer metrics</span>
<span class="nc" id="L198">        override def success(i: Int): Long = { delegate.success(i); dwSuccess.inc(i); dwSuccess.getCount }</span>
<span class="nc" id="L199">        override def failure(i: Int): Long = { delegate.failure(i); dwFailure.inc(i); dwFailure.getCount }</span>
      }
    }

    /**
     * Tracks success and failures in the conversion process. Counters are globally shared, so
     * we track counts locally, while updating the global counters at the same time.
     *
     * Note that micrometer meters (including counters) will not actually store anything unless a registry has been configured.
     *
     * @param success success counter
     * @param failure failure counter
     */
<span class="nc bnc" id="L212" title="All 25 branches missed.">    private case class MicrometerStats(success: Counter, failure: Counter) extends Stats {</span>

<span class="nc" id="L214">      private val localSuccessCount = new AtomicLong(0)</span>
<span class="nc" id="L215">      private val localFailureCount = new AtomicLong(0)</span>

<span class="nc" id="L217">      override def success(i: Int = 1): Long = {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (i &gt; 0) {</span>
<span class="nc" id="L219">          success.increment(i)</span>
<span class="nc" id="L220">          localSuccessCount.addAndGet(i)</span>
        } else {
<span class="nc" id="L222">          localSuccessCount.get()</span>
        }
      }

<span class="nc" id="L226">      override def failure(i: Int = 1): Long = {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (i &gt; 0) {</span>
<span class="nc" id="L228">          failure.increment(i)</span>
<span class="nc" id="L229">          localFailureCount.addAndGet(i)</span>
        } else {
<span class="nc" id="L231">          localFailureCount.get()</span>
        }
      }
    }
  }

  /**
   * Evaluation error
   *
   * @param field field name that had an error
   * @param line line number of the input being evaluated
   * @param e error
   */
<span class="nc bnc" id="L244" title="All 28 branches missed.">  case class EvaluationError(field: String, line: Long, e: Throwable)</span>

  /**
   * Listener callback trait
   */
  trait ContextListener {

    /**
     * Invoked when success counts change
     *
     * @param i amount of change
     */
    def onSuccess(i: Int): Unit

    /**
     * Invoked when failure counts change
     *
     * @param i amount of change
     */
    def onFailure(i: Int): Unit
  }

  /**
    * Evaluation context accessors
    *
    * @param ec context
    */
<span class="nc bnc" id="L271" title="All 12 branches missed.">  implicit class RichEvaluationContext(val ec: EvaluationContext) extends AnyVal {</span>
<span class="nc" id="L272">    def getInputFilePath: Option[String] = Option(ec.accessor(InputFilePathKey).apply().asInstanceOf[String])</span>
  }

  /**
   * Evaluation context implementation
   *
   * @param fields fields to evaluate, in topological dependency order
   * @param globalValues global variable name/values
   * @param cache enrichment caches
   * @param stats metrics
   * @param errors error tracker
   */
<span class="nc" id="L284">  class StatefulEvaluationContext(</span>
<span class="nc" id="L285">      fields: Array[Field],</span>
<span class="nc" id="L286">      globalValues: Map[String, _ &lt;: AnyRef],</span>
<span class="nc" id="L287">      val cache: Map[String, EnrichmentCache],</span>
<span class="nc" id="L288">      val stats: Stats,</span>
<span class="nc" id="L289">      val errors: java.util.Queue[EvaluationError] = new java.util.ArrayDeque[EvaluationError]()</span>
<span class="nc" id="L290">    ) extends EvaluationContext {</span>

    // holder for results from evaluating each row
<span class="nc" id="L293">    private val values = Array.ofDim[AnyRef](fields.length)</span>
    // temp array for holding the arguments for a field
<span class="nc" id="L295">    private val fieldArray = Array.ofDim[AnyRef](1)</span>
    // copy the transforms and tie them to the context
    // note: the class isn't fully instantiated yet, but this statement is last in the initialization
<span class="nc" id="L298">    private val transforms = fields.map(_.transforms.map(_.withContext(this)))</span>

<span class="nc bnc" id="L300" title="All 6 branches missed.">    override lazy val success: com.codahale.metrics.Counter = new com.codahale.metrics.Counter() {</span>
<span class="nc" id="L301">      override def inc(n: Long): Unit = stats.success(n.toInt)</span>
<span class="nc" id="L302">      override def getCount: Long = stats.success(0)</span>
    }
<span class="nc bnc" id="L304" title="All 6 branches missed.">    override lazy val failure: com.codahale.metrics.Counter = new com.codahale.metrics.Counter() {</span>
<span class="nc" id="L305">      override def inc(n: Long): Unit = stats.failure(n.toInt)</span>
<span class="nc" id="L306">      override def getCount: Long = stats.failure(0)</span>
    }

    override def accessor(name: String): FieldAccessor = {
<span class="nc bnc" id="L310" title="All 6 branches missed.">      val i = fields.indexWhere(_.name == name)</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">      if (i &gt;= 0) { new FieldValueAccessor(values, i) } else {</span>
<span class="nc" id="L312">        globalValues.get(name) match {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">          case Some(value) =&gt; new GlobalFieldAccessor(value)</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">          case None =&gt; NullFieldAccessor</span>
        }
      }
    }

<span class="nc bnc" id="L319" title="All 2 branches missed.">    override def evaluate(args: Array[AnyRef]): Either[EvaluationError, Array[AnyRef]] = {</span>
<span class="nc" id="L320">      var i = 0</span>
      // note: since fields are in topological order we don't need to clear them
<span class="nc bnc" id="L322" title="All 2 branches missed.">      while (i &lt; values.length) {</span>
<span class="nc" id="L323">        values(i) = try {</span>
          val fieldArgs = fields(i).fieldArg match {
            case None =&gt; args
            case Some(f) =&gt; fieldArray(0) = f.apply(args); fieldArray
          }
          transforms(i) match {
            case Some(t) =&gt; t.apply(fieldArgs)
            case None    =&gt; fieldArgs(0)
          }
        } catch {
          case NonFatal(e) =&gt; return Left(EvaluationError(fields(i).name, line, e))
        }
<span class="nc" id="L335">        i += 1</span>
      }
<span class="nc" id="L337">      Right(values)</span>
    }

    override def withListener(listener: ContextListener): EvaluationContext =
<span class="nc" id="L341">      new StatefulEvaluationContext(fields, globalValues, cache, StatListener(stats, listener))</span>
  }

  /**
   * Stats implementation that adds a listener.
   *
   * Note that this implementation can chain additional listeners, but it's not very efficient doing so. The
   * typical usage of listeners is reporting out counts, so usually there will only be one.
   *
   * @param delegate delegate stats
   * @param listener listener
   */
<span class="nc bnc" id="L353" title="All 25 branches missed.">  case class StatListener(delegate: Stats, listener: ContextListener) extends Stats {</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">    override def success(i: Int): Long = { if (i &gt; 0) { listener.onSuccess(i) }; delegate.success(i) }</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">    override def failure(i: Int): Long = { if (i &gt; 0) { listener.onFailure(i) }; delegate.failure(i) }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>