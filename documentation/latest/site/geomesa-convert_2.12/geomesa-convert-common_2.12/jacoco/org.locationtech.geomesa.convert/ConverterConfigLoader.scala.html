<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConverterConfigLoader.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert</a> &gt; <span class="el_source">ConverterConfigLoader.scala</span></div><h1>ConverterConfigLoader.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert

import com.typesafe.config.{Config, ConfigFactory, ConfigValueFactory}
import com.typesafe.scalalogging.LazyLogging
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty

import java.net.URL
import java.util.{ServiceLoader, List =&gt; JList}
import scala.collection.JavaConverters._

<span class="nc bnc" id="L19" title="All 4 branches missed.">object ConverterConfigLoader extends LazyLogging {</span>

<span class="nc" id="L21">  val ConfigPathProperty: SystemProperty = SystemProperty(&quot;org.locationtech.geomesa.converter.config.path&quot;, &quot;geomesa.converters&quot;)</span>

<span class="nc" id="L23">  val ConverterNameKey = &quot;converter-name&quot;</span>

<span class="nc" id="L25">  private val configProviders = {</span>
<span class="nc" id="L26">    val pList = ServiceLoader.load(classOf[ConverterConfigProvider]).asScala.toList</span>
<span class="nc bnc" id="L27" title="All 2 branches missed.">    logger.debug(s&quot;Found ${pList.size} SPI providers for ${classOf[ConverterConfigProvider].getName}&quot; +</span>
<span class="nc" id="L28">      s&quot;: ${pList.map(_.getClass.getName).mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L29">    pList</span>
  }

<span class="nc" id="L32">  def path: String = ConfigPathProperty.get</span>

  // this is intentionally a method to allow reloading by the providers
  def confs: Map[String, Config] =
<span class="nc bnc" id="L36" title="All 2 branches missed.">    configProviders.map(_.loadConfigs.asScala).reduce( _ ++ _).toMap.map { case (k, v) =&gt;</span>
      // add the key used to identify the converter (used for metrics)
<span class="nc bnc" id="L38" title="All 2 branches missed.">      k -&gt; (if (v.hasPath(ConverterNameKey)) { v } else { v.withValue(ConverterNameKey, ConfigValueFactory.fromAnyRef(k)) })</span>
    }

  // Public API
<span class="nc" id="L42">  def listConverterNames: List[String] = confs.keys.toList</span>
<span class="nc" id="L43">  def getAllConfigs: Map[String, Config] = confs</span>
<span class="nc" id="L44">  def configForName(name: String): Option[Config] = confs.get(name)</span>
}

<span class="nc" id="L47">trait GeoMesaConvertParser extends LazyLogging {</span>
  def parseConf(config: Config): Map[String, Config] = {
<span class="nc bnc" id="L49" title="All 2 branches missed.">    logger.trace(s&quot;Attempting to load Converters from path ${ConverterConfigLoader.path}&quot;)</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">    if (!config.hasPath(ConverterConfigLoader.path)) {</span>
<span class="nc" id="L51">      Map.empty[String, Config]</span>
    } else {
<span class="nc" id="L53">      val confs = config.getConfig(ConverterConfigLoader.path)</span>
<span class="nc" id="L54">      confs.root.keySet.asScala.map { k =&gt;</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">        logger.trace(s&quot;Found conf block $k&quot;)</span>
<span class="nc" id="L56">        k -&gt; confs.getConfig(k)</span>
<span class="nc" id="L57">      }.toMap[String, Config]</span>
    }
  }
}

<span class="nc" id="L62">object GeoMesaConvertParser {</span>
  def isConvertConfig(conf: Config): Boolean = {
<span class="nc" id="L64">    conf.hasPath(&quot;type&quot;)</span>
  }
}
/**
  * Provides access converter configs on the classpath
  */
<span class="nc bnc" id="L70" title="All 4 branches missed.">class ClassPathConfigProvider extends ConverterConfigProvider with GeoMesaConvertParser {</span>
  // intentionally keep as a method so we can reload dynamically
<span class="nc" id="L72">  override def loadConfigs(): java.util.Map[String, Config] = parseConf(ConfigFactory.load).asJava</span>
}

/** Load Config from URLs */
<span class="nc bnc" id="L76" title="All 4 branches missed.">class URLConfigProvider extends ConverterConfigProvider with GeoMesaConvertParser {</span>
  import URLConfigProvider._

  override def loadConfigs(): java.util.Map[String, Config] = {
<span class="nc" id="L80">    val confs = configURLs.flatMap { url =&gt;</span>
      try {
<span class="nc" id="L82">        Some(ConfigFactory.parseURL(url).resolve())</span>
      } catch {
        case e: Throwable =&gt;
<span class="nc bnc" id="L85" title="All 2 branches missed.">          logger.warn(s&quot;Unable to load converter config from url $url&quot;)</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">          logger.trace(s&quot;Unable to load converter config from url $url&quot;, e)</span>
<span class="nc" id="L87">          None</span>
      }
    }
<span class="nc" id="L90">    confs.reduceLeftOption(_.withFallback(_)).map(parseConf).getOrElse(Map.empty[String, Config]).asJava</span>
  }

  // Will also pick things up from the SystemProperties
  def configURLs: Seq[URL] = {
<span class="nc" id="L95">    val config = ConfigFactory.load()</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">    if (config.hasPath(ConverterConfigURLs)) {</span>
<span class="nc" id="L97">      config.getAnyRef(ConverterConfigURLs) match {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        case s: String          =&gt; s.split(',').map(_.trim).map(new URL(_))</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        case lst: JList[String] =&gt; lst.asScala.map(new URL(_)).toSeq</span>
      }
    } else {
<span class="nc" id="L102">      Seq.empty[URL]</span>
    }
  }

}

<span class="nc" id="L108">object URLConfigProvider {</span>
<span class="nc" id="L109">  val ConverterConfigURLs = &quot;geomesa.convert.config.urls&quot;</span>
}

<span class="nc bnc" id="L112" title="All 4 branches missed.">object SimpleConverterConfigParser extends GeoMesaConvertParser</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>