<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoJsonParsing.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Json</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.json</a> &gt; <span class="el_source">GeoJsonParsing.scala</span></div><h1>GeoJsonParsing.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.json

import com.google.gson._
import org.locationtech.geomesa.utils.text.WKTUtils
import org.locationtech.jts.geom._
import org.locationtech.jts.geom.impl.CoordinateArraySequence

import java.util.{Collections, Locale}
import scala.util.{Failure, Success, Try}


<span class="nc" id="L20">trait GeoJsonParsing {</span>

  import GeoJsonParsing._

  import scala.collection.JavaConverters._

<span class="nc" id="L26">  private val factory = new GeometryFactory</span>

  /**
    * Determines if the element is a geojson feature collection
    *
    * @param el element
    * @return
    */
<span class="nc" id="L34">  def isFeatureCollection(el: JsonElement): Boolean = isType(el, FeatureCollectionType)</span>

  /**
    * Determines if the element is a geojson feature
    *
    * @param el element
    * @return
    */
<span class="nc" id="L42">  def isFeature(el: JsonElement): Boolean = isType(el, FeatureType)</span>

  /**
    * Parse a geojson feature collection element
    *
    * @see `isFeatureCollection` to determine if this is likely to succeed
    *
    * @param el element
    * @return
    */
  def parseFeatureCollection(el: JsonElement): Seq[GeoJsonFeature] = {
<span class="nc" id="L53">    val features = el.getAsJsonObject.get(FeaturesKey).getAsJsonArray</span>
<span class="nc" id="L54">    Seq.tabulate(features.size)(i =&gt; parseFeature(features.get(i)))</span>
  }

  /**
    * Parse a geojson feature element
    *
    * @see `isFeature` to determine if this is likely to succeed
    *
    * @param el element
    * @return
    */
  def parseFeature(el: JsonElement): GeoJsonFeature = {
<span class="nc" id="L66">    val obj = el.getAsJsonObject</span>
<span class="nc" id="L67">    val id = obj.get(IdKey) match {</span>
<span class="nc bnc" id="L68" title="All 4 branches missed.">      case s: JsonPrimitive if s.isString =&gt; Some(s.getAsString)</span>
<span class="nc" id="L69">      case _ =&gt; None</span>
    }
<span class="nc" id="L71">    val geometry = parseGeometry(obj.get(GeometryKey))</span>
<span class="nc" id="L72">    val props: Map[String, Any] = obj.get(PropertiesKey) match {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">      case o: JsonObject =&gt; parseElement(o, s&quot;$$['$PropertiesKey']&quot;).toMap</span>
<span class="nc" id="L74">      case _ =&gt; Map.empty</span>
    }
<span class="nc" id="L76">    GeoJsonFeature(id, geometry, props)</span>
  }

  /**
    * Parse a geometry element
    *
    * @param el element
    * @return
    */
<span class="nc" id="L85">  def parseGeometry(el: JsonElement): Geometry = el match {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    case o: JsonObject    =&gt; parseGeometryObject(o).get</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">    case o: JsonPrimitive =&gt; WKTUtils.read(o.getAsString)</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">    case _: JsonNull      =&gt; null.asInstanceOf[Geometry]</span>
<span class="nc" id="L89">    case _ =&gt; throw new IllegalArgumentException(s&quot;Unknown geometry type: $el&quot;)</span>
  }


  /**
   * Parse a json element
   *
   * @param elem element
   * @param path json path to the object
   * @return map of key is json path to value, value is a string, boolean or list[string]
   */
  def parseElement(elem: JsonElement, path: String): Seq[(String, Any)] = {
<span class="nc" id="L101">    elem match {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">      case e: JsonPrimitive =&gt;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (e.isBoolean) {</span>
<span class="nc" id="L104">          Seq(path -&gt; e.getAsBoolean)</span>
        } else {
          // note: gson numbers don't have a defined type so type checking doesn't work
<span class="nc" id="L107">          Seq(path -&gt; e.getAsString)</span>
        }

<span class="nc bnc" id="L110" title="All 2 branches missed.">      case e: JsonObject =&gt;</span>
<span class="nc" id="L111">        parseGeometryObject(e) match {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">          case Success(geom) =&gt; Seq(path -&gt; geom)</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">          case Failure(_) =&gt;</span>
<span class="nc" id="L114">            val builder = Seq.newBuilder[(String, Any)]</span>
<span class="nc" id="L115">            e.entrySet().asScala.foreach { entry =&gt;</span>
<span class="nc" id="L116">              builder ++= parseElement(entry.getValue, s&quot;$path['${entry.getKey}']&quot;)</span>
            }
<span class="nc" id="L118">            builder.result</span>
        }

<span class="nc bnc" id="L121" title="All 2 branches missed.">      case e: JsonArray =&gt;</span>
<span class="nc" id="L122">        val list = new java.util.ArrayList[String](e.size())</span>
<span class="nc" id="L123">        var i = 0</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        while (i &lt; e.size()) {</span>
<span class="nc" id="L125">          list.add(e.get(i).toString)</span>
<span class="nc" id="L126">          i += 1</span>
        }
<span class="nc" id="L128">        Seq(path -&gt; Collections.unmodifiableList(list))</span>

      case _ =&gt;
<span class="nc" id="L131">        Seq.empty // no-op</span>
    }
  }

  /**
    * Parse a geometry object
    *
    * @param obj object
    * @return
    */
  private def parseGeometryObject(obj: JsonObject): Try[Geometry] = {
<span class="nc" id="L142">    val geomType = obj.get(TypeKey)</span>

<span class="nc bnc" id="L144" title="All 4 branches missed.">    if (geomType == null || !geomType.isJsonPrimitive) {</span>
<span class="nc" id="L145">      return Failure(new RuntimeException(&quot;Not a Geometry object&quot;))</span>
    }

<span class="nc" id="L148">    geomType.getAsString.toLowerCase(Locale.US) match {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">      case &quot;point&quot; =&gt;</span>
<span class="nc" id="L150">        Try(factory.createPoint(toPointCoords(obj.get(CoordinatesKey))))</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">      case &quot;linestring&quot; =&gt;</span>
<span class="nc" id="L153">        Try(factory.createLineString(toCoordSeq(obj.get(CoordinatesKey))))</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">      case &quot;polygon&quot; =&gt;</span>
<span class="nc" id="L156">        Try(toPolygon(obj.get(CoordinatesKey)))</span>

<span class="nc bnc" id="L158" title="All 2 branches missed.">      case &quot;multipoint&quot; =&gt;</span>
<span class="nc" id="L159">        Try(factory.createMultiPoint(toCoordSeq(obj.get(CoordinatesKey))))</span>

<span class="nc bnc" id="L161" title="All 2 branches missed.">      case &quot;multilinestring&quot; =&gt;</span>
<span class="nc" id="L162">        Try {</span>
          val coords =
<span class="nc" id="L164">            obj.get(CoordinatesKey).getAsJsonArray.asScala</span>
<span class="nc" id="L165">              .map(c =&gt; factory.createLineString(toCoordSeq(c))).toArray</span>
<span class="nc" id="L166">          factory.createMultiLineString(coords)</span>
        }

<span class="nc bnc" id="L169" title="All 2 branches missed.">      case &quot;multipolygon&quot; =&gt;</span>
<span class="nc" id="L170">        Try(factory.createMultiPolygon(obj.get(CoordinatesKey).getAsJsonArray.asScala.map(toPolygon).toArray))</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">      case &quot;geometrycollection&quot; =&gt;</span>
<span class="nc" id="L173">        Try(factory.createGeometryCollection(obj.get(GeometriesKey).getAsJsonArray.asScala.map(parseGeometry).toArray))</span>

      case unknown =&gt;
<span class="nc" id="L176">        Failure(new UnsupportedOperationException(s&quot;Can't parse geometry type of $unknown&quot;))</span>
    }
  }

  private def toPointCoords(el: JsonElement): Coordinate = {
<span class="nc" id="L181">    el.getAsJsonArray.asScala.map(_.getAsDouble).toSeq match {</span>
<span class="nc bnc" id="L182" title="All 6 branches missed.">      case Seq(x, y)    =&gt; new Coordinate(x, y)</span>
<span class="nc bnc" id="L183" title="All 6 branches missed.">      case Seq(x, y, z) =&gt; new Coordinate(x, y, z)</span>
<span class="nc" id="L184">      case s =&gt; throw new IllegalArgumentException(s&quot;Invalid point - expected 2 or 3 values, got ${s.mkString(&quot;, &quot;)}&quot;)</span>
    }
  }

  private def toCoordSeq(el: JsonElement): CoordinateSequence =
<span class="nc" id="L189">    new CoordinateArraySequence(el.getAsJsonArray.asScala.map(_.getAsJsonArray).map(toPointCoords).toArray)</span>

  private def toPolygon(el: JsonElement): Polygon = {
<span class="nc" id="L192">    val rings = el.getAsJsonArray.iterator.asScala.map(c =&gt; factory.createLinearRing(toCoordSeq(c)))</span>
<span class="nc" id="L193">    val shell = rings.next</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">    if (rings.hasNext) {</span>
<span class="nc" id="L195">      factory.createPolygon(shell, rings.toArray)</span>
    } else {
<span class="nc" id="L197">      factory.createPolygon(shell)</span>
    }
  }

<span class="nc" id="L201">  private def isType(el: JsonElement, t: String): Boolean = el match {</span>
<span class="nc bnc" id="L202" title="All 10 branches missed.">    case o: JsonObject =&gt; Option(o.get(TypeKey)).exists(e =&gt; e.isJsonPrimitive &amp;&amp; e.getAsString == t)</span>
<span class="nc" id="L203">    case _ =&gt; false</span>
  }
}

<span class="nc" id="L207">object GeoJsonParsing extends GeoJsonParsing {</span>

  /**
   * Parsed geojson feature element
   *
   * @param id id, if present
   * @param geom geometry
   * @param properties 'properties' values - key is json path to value, value is a string, boolean or list[string].
   *                   nested elements will be flattened out, with a path pointing into the element
   */
<span class="nc bnc" id="L217" title="All 32 branches missed.">  case class GeoJsonFeature(id: Option[String], geom: Geometry, properties: Map[String, Any])</span>

<span class="nc" id="L219">  private val FeatureType = &quot;Feature&quot;</span>
<span class="nc" id="L220">  private val FeatureCollectionType = &quot;FeatureCollection&quot;</span>

<span class="nc" id="L222">  private val TypeKey = &quot;type&quot;</span>
<span class="nc" id="L223">  private val FeaturesKey = &quot;features&quot;</span>
<span class="nc" id="L224">  private val CoordinatesKey = &quot;coordinates&quot;</span>
<span class="nc" id="L225">  private val PropertiesKey = &quot;properties&quot;</span>
<span class="nc" id="L226">  private val GeometryKey = &quot;geometry&quot;</span>
<span class="nc" id="L227">  private val GeometriesKey = &quot;geometries&quot;</span>
<span class="nc" id="L228">  private val IdKey = &quot;id&quot;</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>