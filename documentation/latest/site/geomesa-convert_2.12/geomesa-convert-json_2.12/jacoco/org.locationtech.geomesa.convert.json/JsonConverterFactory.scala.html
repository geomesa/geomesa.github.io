<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonConverterFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Json</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.json</a> &gt; <span class="el_source">JsonConverterFactory.scala</span></div><h1>JsonConverterFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.json

import com.google.gson.stream.{JsonReader, JsonToken}
import com.google.gson.{JsonElement, JsonNull, JsonParser}
import com.jayway.jsonpath.{JsonPath, PathNotFoundException}
import com.typesafe.config.Config
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.convert.json.GeoJsonParsing.GeoJsonFeature
import org.locationtech.geomesa.convert.json.JsonConverter._
import org.locationtech.geomesa.convert.json.JsonConverterFactory.{JsonConfigConvert, JsonFieldConvert, PropNamer}
import org.locationtech.geomesa.convert2.AbstractConverter.BasicOptions
import org.locationtech.geomesa.convert2.AbstractConverterFactory.{BasicOptionsConvert, ConverterConfigConvert, FieldConvert, OptionConvert}
import org.locationtech.geomesa.convert2.TypeInference.{IdentityTransform, Namer, PathWithValues, TypeWithPath}
import org.locationtech.geomesa.convert2.transforms.Expression
import org.locationtech.geomesa.convert2.{AbstractConverterFactory, TypeInference}
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.io.{CloseWithLogging, WithClose}
import pureconfig.ConfigObjectCursor
import pureconfig.error.{CannotConvert, ConfigReaderFailures}

import java.io.{InputStream, InputStreamReader}
import java.nio.charset.StandardCharsets
import java.util.Locale
import scala.collection.mutable.ListBuffer
import scala.util.{Failure, Try}

<span class="nc" id="L35">class JsonConverterFactory extends AbstractConverterFactory[JsonConverter, JsonConfig, JsonField, BasicOptions](</span>
<span class="nc" id="L36">  JsonConverterFactory.TypeToProcess, JsonConfigConvert, JsonFieldConvert, BasicOptionsConvert) {</span>

  import scala.collection.JavaConverters._

  override def apply(sft: SimpleFeatureType, conf: Config): Option[JsonConverter] = {
<span class="nc" id="L41">    val option = super.apply(sft, conf).asInstanceOf[Option[JsonConverter]]</span>
<span class="nc" id="L42">    option.foreach { converter =&gt;</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">      if (converter.config.featurePath.isEmpty) {</span>
<span class="nc" id="L44">        val hasRootPath = converter.fields.exists {</span>
<span class="nc bnc" id="L45" title="All 4 branches missed.">          case f: TypedJsonField if f.pathIsRoot =&gt; true</span>
<span class="nc" id="L46">          case _ =&gt; false</span>
        }
<span class="nc bnc" id="L48" title="All 2 branches missed.">        if (hasRootPath) {</span>
<span class="nc" id="L49">          CloseWithLogging(converter)</span>
<span class="nc" id="L50">          throw new IllegalArgumentException(&quot;Invalid configuration - root paths can not be used without defining a feature path&quot;)</span>
        }
      }
    }
<span class="nc" id="L54">    option</span>
  }

  /**
   * Infer a configuration and simple feature type from an input stream, if possible
   *
   * Available hints:
   *  - `featurePath` - json path expression pointing to the feature element
   *
   * @param is input
   * @param sft simple feature type, if known ahead of time
   * @param hints implementation specific hints about the input
   * @return
   */
  override def infer(
      is: InputStream,
      sft: Option[SimpleFeatureType],
      hints: Map[String, AnyRef]): Try[(SimpleFeatureType, Config)] = {

<span class="nc" id="L73">    val tryElements = Try {</span>
<span class="nc" id="L74">      WithClose(new JsonReader(new InputStreamReader(is, StandardCharsets.UTF_8))) { reader =&gt;</span>
<span class="nc" id="L75">        reader.setLenient(true)</span>
<span class="nc" id="L76">        val iter: Iterator[JsonElement] = new Iterator[JsonElement] {</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">          override def hasNext: Boolean = reader.peek() != JsonToken.END_DOCUMENT</span>
<span class="nc" id="L78">          override def next(): JsonElement = JsonParser.parseReader(reader)</span>
        }
<span class="nc" id="L80">        iter.take(AbstractConverterFactory.inferSampleSize).toList</span>
      }
    }
<span class="nc" id="L83">    tryElements.flatMap { elements =&gt;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      lazy val featurePath = hints.get(JsonConverterFactory.FeaturePathKey).map(_.toString)</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">      if (elements.isEmpty) {</span>
<span class="nc" id="L86">        Failure(new RuntimeException(&quot;Could not parse the input as JSON&quot;))</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">      } else if (JsonConverter.isFeature(elements.head)) {</span>
<span class="nc" id="L88">        Try(elements.map(JsonConverter.parseFeature))</span>
<span class="nc" id="L89">            .flatMap(inferGeoJson(_, None, sft))</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">      } else if (JsonConverter.isFeatureCollection(elements.head)) {</span>
<span class="nc" id="L91">        Try(elements.flatMap(JsonConverter.parseFeatureCollection))</span>
<span class="nc" id="L92">            .flatMap(inferGeoJson(_, Some(&quot;$.features[*]&quot;), sft))</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">      } else if (elements.head.isJsonObject) {</span>
<span class="nc" id="L94">        inferJson(elements, featurePath, sft)</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">      } else if (elements.head.isJsonArray) {</span>
<span class="nc" id="L96">        inferJson(elements, featurePath.orElse(Some(&quot;$.[*]&quot;)), sft)</span>
      } else {
<span class="nc" id="L98">        Failure(new RuntimeException(&quot;Could not parse the input as a JSON object or array&quot;))</span>
      }
    }
  }

  private def inferGeoJson(
      features: Seq[GeoJsonFeature],
      featurePath: Option[String],
<span class="nc" id="L106">      sft: Option[SimpleFeatureType]): Try[(SimpleFeatureType, Config)] = Try {</span>
    // track the 'properties', geometry type and 'id' in each feature
    // use linkedHashMap to retain insertion order
<span class="nc" id="L109">    val props = scala.collection.mutable.LinkedHashMap.empty[String, ListBuffer[Any]]</span>
<span class="nc" id="L110">    val geoms = ListBuffer.empty[Any]</span>
<span class="nc" id="L111">    var hasId = true</span>

<span class="nc" id="L113">    features.take(AbstractConverterFactory.inferSampleSize).foreach { feature =&gt;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">      feature.properties.foreach { case (k, v) =&gt; props.getOrElseUpdate(k, ListBuffer.empty) += v }</span>
<span class="nc" id="L115">      geoms += feature.geom</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">      hasId = hasId &amp;&amp; feature.id.isDefined</span>
    }

    val pathsAndValues =
<span class="nc bnc" id="L120" title="All 2 branches missed.">      props.toSeq.map { case (path, values) =&gt; PathWithValues(path, values) } :+</span>
<span class="nc" id="L121">          PathWithValues(JsonConverterFactory.GeoJsonGeometryPath, geoms)</span>
<span class="nc" id="L122">    val inferredTypes = TypeInference.infer(pathsAndValues, sft.toRight(&quot;inferred-json&quot;), new PropNamer())</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">    val idJsonField = if (hasId) { Some(StringJsonField(&quot;id&quot;, &quot;$.id&quot;, pathIsRoot = false, None)) } else { None }</span>
<span class="nc" id="L125">    val idField = idJsonField match {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">      case None    =&gt; Some(Expression(&quot;md5(stringToBytes(toString($0)))&quot;))</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      case Some(f) =&gt; Some(Expression(s&quot;$$${f.name}&quot;))</span>
    }
<span class="nc" id="L129">    val fieldConfig = idJsonField.toSeq ++ inferredTypes.types.map(createFieldConfig)</span>

<span class="nc" id="L131">    val jsonConfig = JsonConfig(typeToProcess, None, featurePath, idField, Map.empty, Map.empty)</span>

<span class="nc" id="L133">    val config = configConvert.to(jsonConfig)</span>
<span class="nc" id="L134">        .withFallback(fieldConvert.to(fieldConfig))</span>
<span class="nc" id="L135">        .withFallback(optsConvert.to(BasicOptions.default))</span>
        .toConfig

<span class="nc" id="L138">    (inferredTypes.sft, config)</span>
  }

  private def inferJson(
      elements: Seq[JsonElement],
      featurePath: Option[String],
      sft: Option[SimpleFeatureType]): Try[(SimpleFeatureType, Config)] = {
<span class="nc" id="L145">    val tryFeatures = Try {</span>
<span class="nc" id="L146">      val features = featurePath match {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        case None =&gt; elements</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        case Some(p) =&gt;</span>
<span class="nc" id="L149">          val path = JsonPath.compile(p)</span>
<span class="nc" id="L150">          elements.flatMap { el =&gt;</span>
<span class="nc" id="L151">            val res = try { path.read[JsonElement](el, JsonConverter.JsonConfiguration) } catch {</span>
<span class="nc" id="L152">              case _: PathNotFoundException =&gt; JsonNull.INSTANCE</span>
            }
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (res.isJsonArray) {</span>
<span class="nc" id="L155">              res.getAsJsonArray.asList().asScala</span>
            } else {
<span class="nc" id="L157">              Seq(res)</span>
            }
          }
      }
<span class="nc bnc" id="L161" title="All 4 branches missed.">      features.collect { case r if r.isJsonObject =&gt; r.getAsJsonObject }</span>
    }

<span class="nc" id="L164">    tryFeatures.flatMap { features =&gt;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">      if (features.isEmpty) {</span>
<span class="nc" id="L166">        Failure(new RuntimeException(&quot;Could not parse input as JSON&quot;))</span>
      } else {
<span class="nc" id="L168">        Try {</span>
          // track the properties in each feature
          // use linkedHashMap to retain insertion order
<span class="nc" id="L171">          val props = scala.collection.mutable.LinkedHashMap.empty[String, ListBuffer[Any]]</span>

<span class="nc" id="L173">          features.take(AbstractConverterFactory.inferSampleSize).foreach { feature =&gt;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            GeoJsonParsing.parseElement(feature, &quot;&quot;).foreach { case (k, v) =&gt;</span>
<span class="nc" id="L175">              props.getOrElseUpdate(k, ListBuffer.empty) += v</span>
            }
          }

<span class="nc bnc" id="L179" title="All 2 branches missed.">          val pathsAndValues = props.toSeq.map { case (path, values) =&gt; PathWithValues(path, values) }</span>
<span class="nc" id="L180">          val inferredTypes = TypeInference.infer(pathsAndValues, sft.toRight(&quot;inferred-json&quot;))</span>

<span class="nc" id="L182">          val idField = Some(Expression(&quot;md5(stringToBytes(toString($0)))&quot;))</span>
<span class="nc" id="L183">          val fieldConfig = inferredTypes.types.map(createFieldConfig)</span>

<span class="nc" id="L185">          val jsonConfig = JsonConfig(typeToProcess, None, featurePath, idField, Map.empty, Map.empty)</span>

          val config =
<span class="nc" id="L188">            configConvert.to(jsonConfig)</span>
<span class="nc" id="L189">                .withFallback(fieldConvert.to(fieldConfig))</span>
<span class="nc" id="L190">                .withFallback(optsConvert.to(BasicOptions.default))</span>
                .toConfig

<span class="nc" id="L193">          (inferredTypes.sft, config)</span>
        }
      }
    }
  }

  private def createFieldConfig(typed: TypeWithPath): JsonField = {
<span class="nc bnc" id="L200" title="All 2 branches missed.">    val TypeWithPath(path, inferredType) = typed</span>
<span class="nc" id="L201">    val transform = inferredType.transform match {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">      case IdentityTransform =&gt; None</span>
      // account for optional nodes by wrapping transform with a try/null
<span class="nc" id="L204">      case t =&gt; Some(Expression(s&quot;try(${t.apply(0)},null)&quot;))</span>
    }
<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (path.isEmpty) {</span>
<span class="nc" id="L207">      DerivedField(inferredType.name, transform)</span>
    } else {
<span class="nc" id="L209">      inferredType.typed match {</span>
<span class="nc bnc" id="L210" title="All 6 branches missed.">        case ObjectType.BOOLEAN =&gt;</span>
<span class="nc" id="L211">          BooleanJsonField(inferredType.name, path, pathIsRoot = false, transform)</span>
<span class="nc bnc" id="L212" title="All 6 branches missed.">        case ObjectType.LIST =&gt;</span>
          // if type is list, that means the transform is 'identity', but we need to replace it with jsonList.
          // this is due to GeoJsonParsing decoding the json array for us, above
<span class="nc" id="L215">          ArrayJsonField(inferredType.name, path, pathIsRoot = false, Some(Expression(&quot;try(jsonList('string',$0),null)&quot;)))</span>
<span class="nc bnc" id="L216" title="All 4 branches missed.">        case t if transform.isEmpty &amp;&amp; ObjectType.GeometrySubtypes.contains(t) =&gt;</span>
<span class="nc" id="L217">          GeometryJsonField(inferredType.name, path, pathIsRoot = false, None)</span>
        case _ =&gt;
          // all other types will be parsed as strings with appropriate transforms
<span class="nc" id="L220">          StringJsonField(inferredType.name, path, pathIsRoot = false, transform)</span>
      }
    }
  }
}

<span class="nc" id="L226">object JsonConverterFactory {</span>

<span class="nc" id="L228">  val TypeToProcess = &quot;json&quot;</span>

<span class="nc" id="L230">  val FeaturePathKey = &quot;featurePath&quot;</span>

<span class="nc" id="L232">  private val GeoJsonGeometryPath = &quot;$.geometry&quot;</span>

<span class="nc" id="L234">  object JsonConfigConvert extends ConverterConfigConvert[JsonConfig] with OptionConvert {</span>

    override protected def decodeConfig(
        cur: ConfigObjectCursor,
        `type`: String,
        idField: Option[Expression],
        caches: Map[String, Config],
        userData: Map[String, Expression]): Either[ConfigReaderFailures, JsonConfig] = {
      for {
<span class="nc" id="L243">        name &lt;- converterName(cur).right</span>
<span class="nc" id="L244">        path &lt;- optional(cur, &quot;feature-path&quot;).right</span>
      } yield {
<span class="nc" id="L246">        JsonConfig(`type`, name, path, idField, caches, userData)</span>
      }
    }

    override protected def encodeConfig(config: JsonConfig, base: java.util.Map[String, AnyRef]): Unit =
<span class="nc" id="L251">      config.featurePath.foreach(p =&gt; base.put(&quot;feature-path&quot;, p))</span>

  }

<span class="nc" id="L255">  object JsonFieldConvert extends FieldConvert[JsonField] with OptionConvert {</span>
    override protected def decodeField(cur: ConfigObjectCursor,
                                       name: String,
                                       transform: Option[Expression]): Either[ConfigReaderFailures, JsonField] = {
<span class="nc" id="L259">      val jsonTypeCur =  cur.atKeyOrUndefined(&quot;json-type&quot;)</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      val jsonType = if (jsonTypeCur.isUndefined) { Right(None) } else { jsonTypeCur.asString.right.map(Option.apply) }</span>

      val config = for {
<span class="nc" id="L263">        jType    &lt;- jsonType.right</span>
<span class="nc" id="L264">        path     &lt;- optional(cur, &quot;path&quot;).right</span>
<span class="nc" id="L265">        rootPath &lt;- optional(cur, &quot;root-path&quot;).right</span>
      } yield {
<span class="nc" id="L267">        (jType, path, rootPath)</span>
      }
<span class="nc bnc" id="L269" title="All 2 branches missed.">      config.right.flatMap { case (jType, path, rootPath) =&gt;</span>
<span class="nc bnc" id="L270" title="All 4 branches missed.">        if (path.isDefined &amp;&amp; rootPath.isDefined) {</span>
<span class="nc" id="L271">          cur.failed(CannotConvert(cur.toString, &quot;JsonField&quot;, &quot;Json fields must define only one of 'path' or 'root-path'&quot;))</span>
<span class="nc bnc" id="L272" title="All 6 branches missed.">        } else if (jType.isDefined &amp;&amp; path.isEmpty &amp;&amp; rootPath.isEmpty) {</span>
<span class="nc" id="L273">          cur.failed(CannotConvert(cur.toString, &quot;JsonField&quot;, &quot;Json fields must define a 'path' or 'root-path'&quot;))</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        } else if (jType.isEmpty) {</span>
<span class="nc" id="L275">          Right(DerivedField(name, transform))</span>
        } else {
<span class="nc bnc" id="L277" title="All 6 branches missed.">          val (jsonPath, pathIsRoot) = (path, rootPath) match {</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">            case (Some(p), None) =&gt; (p, false)</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">            case (None, Some(p)) =&gt; (p, true)</span>
          }
<span class="nc" id="L281">          jType.get.toLowerCase(Locale.US) match {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            case &quot;string&quot;           =&gt; Right(StringJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            case &quot;float&quot;            =&gt; Right(FloatJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            case &quot;double&quot;           =&gt; Right(DoubleJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L285" title="All 6 branches missed.">            case &quot;integer&quot; | &quot;int&quot;  =&gt; Right(IntJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L286" title="All 6 branches missed.">            case &quot;boolean&quot; | &quot;bool&quot; =&gt; Right(BooleanJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            case &quot;long&quot;             =&gt; Right(LongJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            case &quot;geometry&quot;         =&gt; Right(GeometryJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L289" title="All 6 branches missed.">            case &quot;array&quot; | &quot;list&quot;   =&gt; Right(ArrayJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc bnc" id="L290" title="All 6 branches missed.">            case &quot;object&quot; | &quot;map&quot;   =&gt; Right(ObjectJsonField(name, jsonPath, pathIsRoot, transform))</span>
<span class="nc" id="L291">            case t =&gt; cur.failed(CannotConvert(cur.toString, &quot;JsonField&quot;, s&quot;Invalid json-type '$t'&quot;))</span>
          }
        }
      }
    }

    override protected def encodeField(field: JsonField, base: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L298">      field match {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        case f: TypedJsonField =&gt;</span>
<span class="nc" id="L300">          base.put(&quot;json-type&quot;, f.jsonType)</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">          base.put(if (f.pathIsRoot) { &quot;root-path&quot; } else { &quot;path&quot; }, f.path)</span>

<span class="nc" id="L303">        case _ =&gt; // no-op</span>
      }
    }
  }

<span class="nc" id="L308">  private class PropNamer extends Namer {</span>
    override def apply(key: String): String =
<span class="nc bnc" id="L310" title="All 6 branches missed.">      super.apply(if (key == GeoJsonGeometryPath) { &quot;geom&quot; } else { key.replaceFirst(&quot;properties&quot;, &quot;&quot;) })</span>
  }
<span class="nc" id="L312">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>