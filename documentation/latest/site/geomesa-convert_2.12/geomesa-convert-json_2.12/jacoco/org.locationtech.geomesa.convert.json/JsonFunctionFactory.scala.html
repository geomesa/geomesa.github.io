<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonFunctionFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Json</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.json</a> &gt; <span class="el_source">JsonFunctionFactory.scala</span></div><h1>JsonFunctionFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.json

import com.fasterxml.jackson.databind.{ObjectMapper, SerializationFeature}
import com.google.gson._
import com.jayway.jsonpath.JsonPath
import com.typesafe.scalalogging.LazyLogging
import org.locationtech.geomesa.convert.EvaluationContext
import org.locationtech.geomesa.convert2.transforms.CollectionFunctionFactory.CollectionParsing
import org.locationtech.geomesa.convert2.transforms.TransformerFunction.NamedTransformerFunction
import org.locationtech.geomesa.convert2.transforms.{TransformerFunction, TransformerFunctionFactory}
import org.locationtech.geomesa.utils.text.DateParsing

import java.util.Date
import java.util.concurrent.ConcurrentHashMap

<span class="nc bnc" id="L24" title="All 4 branches missed.">class JsonFunctionFactory extends TransformerFunctionFactory with CollectionParsing with LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L28">  private val gson = new Gson()</span>
<span class="nc" id="L29">  private val mapper = new ObjectMapper().configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)</span>

  // noinspection ScalaDeprecation
  override def functions: Seq[TransformerFunction] =
<span class="nc" id="L33">    Seq(jsonToString, jsonListParser, jsonMapParser, mapToJson, jsonPath, jsonArrayToObject, newJsonObject, emptyToNull)</span>

  @deprecated(&quot;use toString&quot;)
<span class="nc bnc" id="L36" title="All 2 branches missed.">  private val jsonToString = new NamedTransformerFunction(Seq(&quot;jsonToString&quot;, &quot;json2string&quot;), pure = true) {</span>
<span class="nc" id="L37">    override def apply(args: Array[AnyRef]): AnyRef = args(0).toString</span>
    override def withContext(ec: EvaluationContext): TransformerFunction = {
<span class="nc bnc" id="L39" title="All 2 branches missed.">      logger.warn(&quot;Using deprecated function 'jsonToString' - use 'toString' instead&quot;)</span>
<span class="nc" id="L40">      super.withContext(ec)</span>
    }
  }

<span class="nc" id="L44">  private val jsonPath: TransformerFunction = new NamedTransformerFunction(Array(&quot;jsonPath&quot;), pure = true) {</span>
<span class="nc" id="L45">    private val cache = new ConcurrentHashMap[Any, JsonPath]()</span>
    override def apply(args: Array[AnyRef]): AnyRef = {
<span class="nc" id="L47">      var path = cache.get(args(0))</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">      if (path == null) {</span>
<span class="nc" id="L49">        path = JsonPath.compile(args(0).asInstanceOf[String])</span>
<span class="nc" id="L50">        cache.put(args(0), path)</span>
      }
<span class="nc" id="L52">      val elem = path.read[JsonElement](args(1), JsonConverter.JsonConfiguration)</span>
      // unwrap primitive and null elements
<span class="nc bnc" id="L54" title="All 2 branches missed.">      if (elem.isJsonNull) {</span>
<span class="nc" id="L55">        null</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">      } else if (elem.isJsonPrimitive) {</span>
<span class="nc" id="L57">        val p = elem.getAsJsonPrimitive</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (p.isString) {</span>
<span class="nc" id="L59">          p.getAsString</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        } else if (p.isNumber) {</span>
<span class="nc" id="L61">          p.getAsNumber</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        } else if (p.isBoolean) {</span>
<span class="nc" id="L63">          Boolean.box(p.getAsBoolean)</span>
        } else {
<span class="nc" id="L65">          p.getAsString // this shouldn't really ever happen...</span>
        }
      } else {
<span class="nc" id="L68">        elem</span>
      }
    }
  }

<span class="nc" id="L73">  private val jsonListParser = TransformerFunction.pure(&quot;jsonList&quot;) { args =&gt;</span>
<span class="nc" id="L74">    val array = args(1).asInstanceOf[JsonArray]</span>
<span class="nc bnc" id="L75" title="All 4 branches missed.">    if (array == null || array.isJsonNull) { null } else {</span>
<span class="nc" id="L76">      val clazz = determineClazz(args(0).asInstanceOf[String])</span>
<span class="nc" id="L77">      val result = new java.util.ArrayList[Any](array.size())</span>
<span class="nc" id="L78">      val iter = array.iterator()</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">      while (iter.hasNext) {</span>
<span class="nc" id="L80">        val e = iter.next</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        if (!e.isJsonNull) {</span>
<span class="nc" id="L82">          result.add(convert(getPrimitive(e.getAsJsonPrimitive), clazz))</span>
        }
      }
<span class="nc" id="L85">      result</span>
    }
  }

<span class="nc" id="L89">  private val jsonMapParser = TransformerFunction.pure(&quot;jsonMap&quot;) { args =&gt;</span>
<span class="nc" id="L90">    val kClass = determineClazz(args(0).asInstanceOf[String])</span>
<span class="nc" id="L91">    val vClass = determineClazz(args(1).asInstanceOf[String])</span>
<span class="nc" id="L92">    val map = args(2).asInstanceOf[JsonObject]</span>

<span class="nc bnc" id="L94" title="All 4 branches missed.">    if (map == null || map.isJsonNull) { null } else {</span>
<span class="nc" id="L95">      val result = new java.util.HashMap[Any, Any](map.size())</span>
<span class="nc" id="L96">      val iter = map.entrySet().iterator()</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      while (iter.hasNext) {</span>
<span class="nc" id="L98">        val e = iter.next</span>
<span class="nc" id="L99">        result.put(convert(e.getKey, kClass), convert(getPrimitive(e.getValue.getAsJsonPrimitive), vClass))</span>
      }
<span class="nc" id="L101">      result</span>
    }
  }

<span class="nc" id="L105">  private val mapToJson = TransformerFunction.pure(&quot;map2Json&quot;, &quot;mapToJson&quot;) { args =&gt;</span>
<span class="nc" id="L106">    mapper.writeValueAsString(args(0).asInstanceOf[java.util.Map[String, _]])</span>
  }

<span class="nc" id="L109">  private val jsonArrayToObject = TransformerFunction.pure(&quot;jsonArrayToObject&quot;) { args =&gt;</span>
<span class="nc" id="L110">    val array = args(0).asInstanceOf[JsonArray]</span>
<span class="nc bnc" id="L111" title="All 4 branches missed.">    if (array == null || array.isJsonNull) { null } else {</span>
<span class="nc" id="L112">      val obj = new JsonObject()</span>
<span class="nc" id="L113">      var i = 0</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">      while (i &lt; array.size()) {</span>
<span class="nc" id="L115">        obj.add(Integer.toString(i), array.get(i))</span>
<span class="nc" id="L116">        i += 1</span>
      }
<span class="nc" id="L118">      obj</span>
    }
  }

<span class="nc" id="L122">  private val newJsonObject = TransformerFunction.pure(&quot;newJsonObject&quot;) { args =&gt;</span>
<span class="nc" id="L123">    val obj = new JsonObject()</span>
<span class="nc" id="L124">    var i = 1</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">    while (i &lt; args.length) {</span>
<span class="nc" id="L126">      val key = args(i -1).toString</span>
<span class="nc" id="L127">      args(i) match {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        case null =&gt; // skip nulls</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        case j: JsonElement =&gt; obj.add(key, j)</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        case j: String  =&gt; obj.add(key, new JsonPrimitive(j))</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        case j: Number  =&gt; obj.add(key, new JsonPrimitive(j))</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        case j: Boolean =&gt; obj.add(key, new JsonPrimitive(j))</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        case j: Date    =&gt; obj.add(key, new JsonPrimitive(DateParsing.formatDate(j)))</span>
<span class="nc" id="L134">        case j          =&gt; obj.add(key, gson.toJsonTree(j))</span>
      }

<span class="nc" id="L137">      i += 2</span>
    }
<span class="nc" id="L139">    obj</span>
  }

<span class="nc" id="L142">  private val emptyToNull = TransformerFunction.pure(&quot;emptyJsonToNull&quot;) { args =&gt;</span>
<span class="nc" id="L143">    args(0) match {</span>
<span class="nc bnc" id="L144" title="All 6 branches missed.">      case JsonNull.INSTANCE =&gt; null</span>
<span class="nc bnc" id="L145" title="All 4 branches missed.">      case j: JsonObject if j.size() == 0 =&gt; null</span>
<span class="nc bnc" id="L146" title="All 10 branches missed.">      case j: JsonObject if j.entrySet().asScala.forall(_.getValue == JsonNull.INSTANCE) =&gt; null</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">      case j: JsonArray if j.size() == 0 =&gt; null</span>
<span class="nc" id="L148">      case j =&gt; j</span>
    }
  }

<span class="nc bnc" id="L152" title="All 2 branches missed.">  private def getPrimitive(p: JsonPrimitive): Any = if (p.isBoolean) { p.getAsBoolean } else { p.getAsString }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>