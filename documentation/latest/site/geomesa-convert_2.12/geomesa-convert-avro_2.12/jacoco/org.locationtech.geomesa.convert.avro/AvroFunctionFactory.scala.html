<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AvroFunctionFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Avro</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.avro</a> &gt; <span class="el_source">AvroFunctionFactory.scala</span></div><h1>AvroFunctionFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.avro

import com.google.gson.{GsonBuilder, JsonArray, JsonElement, JsonNull, JsonObject, JsonPrimitive}
import org.apache.avro.generic.GenericRecord
import org.locationtech.geomesa.convert2.transforms.Expression.LiteralString
import org.locationtech.geomesa.convert2.transforms.TransformerFunction.NamedTransformerFunction
import org.locationtech.geomesa.convert2.transforms.{Expression, TransformerFunction, TransformerFunctionFactory}
import org.locationtech.geomesa.features.avro.serialization.AvroField.UuidBinaryField
import org.locationtech.geomesa.features.avro.serialization.CollectionSerialization

import java.nio.ByteBuffer
import java.util.UUID

<span class="nc" id="L22">class AvroFunctionFactory extends TransformerFunctionFactory {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L26">  override def functions: Seq[TransformerFunction] = Seq(avroPath, binaryList, binaryMap, binaryUuid, avroToJson)</span>

<span class="nc" id="L28">  private val gson = new GsonBuilder().disableHtmlEscaping().create()</span>

<span class="nc" id="L30">  private val avroPath = new AvroPathFn(null)</span>

  // parses a list encoded by the geomesa avro writer
<span class="nc" id="L33">  private val binaryList = TransformerFunction.pure(&quot;avroBinaryList&quot;) { args =&gt;</span>
<span class="nc" id="L34">    args(0) match {</span>
<span class="nc bnc" id="L35" title="All 2 branches missed.">      case bytes: Array[Byte] =&gt; CollectionSerialization.decodeList(ByteBuffer.wrap(bytes))</span>
<span class="nc bnc" id="L36" title="All 2 branches missed.">      case null =&gt; null</span>
<span class="nc" id="L37">      case arg =&gt; throw new IllegalArgumentException(s&quot;Expected byte array but got: $arg&quot;)</span>
    }
  }

  // parses a map encoded by the geomesa avro writer
<span class="nc" id="L42">  private val binaryMap = TransformerFunction.pure(&quot;avroBinaryMap&quot;) { args =&gt;</span>
<span class="nc" id="L43">    args(0) match {</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">      case bytes: Array[Byte] =&gt; CollectionSerialization.decodeMap(ByteBuffer.wrap(bytes))</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      case null =&gt; null</span>
<span class="nc" id="L46">      case arg =&gt; throw new IllegalArgumentException(s&quot;Expected byte array but got: $arg&quot;)</span>
    }
  }

  // parses a uuid encoded by the geomesa avro writer
<span class="nc" id="L51">  private val binaryUuid = TransformerFunction.pure(&quot;avroBinaryUuid&quot;) { args =&gt;</span>
<span class="nc" id="L52">    args(0) match {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">      case bytes: Array[Byte] =&gt; UuidBinaryField.decode(ByteBuffer.wrap(bytes))</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">      case uuid: UUID =&gt; uuid</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">      case null =&gt; null</span>
<span class="nc" id="L56">      case arg =&gt; throw new IllegalArgumentException(s&quot;Expected byte array but got: $arg&quot;)</span>
    }
  }

<span class="nc" id="L60">  private val avroToJson = TransformerFunction.pure(&quot;avroToJson&quot;) { args =&gt;</span>
<span class="nc" id="L61">    args(0) match {</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">      case null =&gt; null</span>
<span class="nc" id="L63">      case a =&gt; gson.toJson(toJson(a))</span>
    }
  }

<span class="nc bnc" id="L67" title="All 2 branches missed.">  class AvroPathFn(path: AvroPath) extends NamedTransformerFunction(Seq(&quot;avroPath&quot;), pure = true) {</span>

    override def getInstance(args: List[Expression]): AvroPathFn = {
<span class="nc" id="L70">      val path = args match {</span>
<span class="nc bnc" id="L71" title="All 6 branches missed.">        case _ :: LiteralString(s) :: _ =&gt; AvroPath(s)</span>
<span class="nc" id="L72">        case _ =&gt; throw new IllegalArgumentException(s&quot;Expected Avro path but got: ${args.headOption.orNull}&quot;)</span>
      }
<span class="nc" id="L74">      new AvroPathFn(path)</span>
    }

    override def apply(args: Array[AnyRef]): AnyRef =
<span class="nc" id="L78">      path.eval(args(0).asInstanceOf[GenericRecord]).orNull.asInstanceOf[AnyRef]</span>
  }

  private def toJson(arg: Any): JsonElement = {
<span class="nc" id="L82">    arg match {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      case s: String =&gt; new JsonPrimitive(s)</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      case n: Number =&gt; new JsonPrimitive(n)</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">      case b: Boolean =&gt; new JsonPrimitive(b)</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">      case r: GenericRecord =&gt;</span>
<span class="nc" id="L87">        val obj = new JsonObject()</span>
<span class="nc" id="L88">        var i = 0</span>
<span class="nc" id="L89">        r.getSchema.getFields.asScala.foreach { field =&gt;</span>
<span class="nc" id="L90">          val value = toJson(r.get(i))</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">          if (!value.isJsonNull) {</span>
<span class="nc" id="L92">            obj.add(field.name(), value)</span>
          }
<span class="nc" id="L94">          i += 1</span>
        }
<span class="nc" id="L96">        obj</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      case list: java.util.List[_] =&gt;</span>
<span class="nc" id="L98">        val array = new JsonArray(list.size())</span>
<span class="nc" id="L99">        list.asScala.foreach { elem =&gt;</span>
<span class="nc" id="L100">          val json = toJson(elem)</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">          if (!json.isJsonNull) {</span>
<span class="nc" id="L102">            array.add(json)</span>
          }
        }
<span class="nc" id="L105">        array</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">      case m: java.util.Map[_, _] =&gt;</span>
<span class="nc" id="L107">        val obj = new JsonObject()</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        m.asScala.foreach { case (k, v) =&gt;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">          if (k != null) {</span>
<span class="nc" id="L110">            val value = toJson(v)</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">            if (!value.isJsonNull) {</span>
<span class="nc" id="L112">              obj.add(k.toString, value)</span>
            }
          }
        }
<span class="nc" id="L116">        obj</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">      case null =&gt; JsonNull.INSTANCE</span>
<span class="nc" id="L118">      case _ =&gt; new JsonPrimitive(arg.toString)</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>