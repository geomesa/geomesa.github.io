<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AvroConverterFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Avro</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.avro</a> &gt; <span class="el_source">AvroConverterFactory.scala</span></div><h1>AvroConverterFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.avro

import com.typesafe.config.Config
import org.apache.avro.Schema
import org.apache.avro.file.DataFileStream
import org.apache.avro.generic.{GenericDatumReader, GenericRecord}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.convert.avro.AvroConverter._
import org.locationtech.geomesa.convert.avro.AvroConverterFactory.AvroConfigConvert
import org.locationtech.geomesa.convert2.AbstractConverter.{BasicField, BasicOptions}
import org.locationtech.geomesa.convert2.AbstractConverterFactory.{BasicFieldConvert, BasicOptionsConvert, ConverterConfigConvert, OptionConvert}
import org.locationtech.geomesa.convert2.TypeInference.{FunctionTransform, InferredType, Namer}
import org.locationtech.geomesa.convert2.transforms.Expression
import org.locationtech.geomesa.convert2.{AbstractConverterFactory, TypeInference}
import org.locationtech.geomesa.features.avro.io.AvroDataFile
import org.locationtech.geomesa.features.avro.serialization.AvroField.{FidField, UserDataField, VersionField}
import org.locationtech.geomesa.features.avro.serialization.AvroSerialization
import org.locationtech.geomesa.features.avro.{FieldNameEncoder, SerializationVersions}
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.io.WithClose
import pureconfig.ConfigObjectCursor
import pureconfig.error.{ConfigReaderFailures, FailureReason}

import java.io.InputStream
import scala.util.Try

<span class="nc" id="L35">class AvroConverterFactory extends AbstractConverterFactory[AvroConverter, AvroConfig, BasicField, BasicOptions](</span>
<span class="nc" id="L36">  &quot;avro&quot;, AvroConfigConvert, BasicFieldConvert, BasicOptionsConvert) {</span>

  import scala.collection.JavaConverters._

  /**
    * Note: only works on Avro files with embedded schemas
    *
    * @param is input
    * @param sft simple feature type, if known ahead of time
    * @param hints hints
    * @return
    */
  override def infer(
      is: InputStream,
      sft: Option[SimpleFeatureType],
      hints: Map[String, AnyRef]): Try[(SimpleFeatureType, Config)] = {
<span class="nc" id="L52">    Try {</span>
<span class="nc" id="L53">      WithClose(new DataFileStream[GenericRecord](is, new GenericDatumReader[GenericRecord]())) { dfs =&gt;</span>
<span class="nc bnc" id="L54" title="All 4 branches missed.">        val (schema, id, fields, userData) = if (AvroDataFile.canParse(dfs)) {</span>
          // this is a file written in the geomesa avro format
<span class="nc" id="L56">          val records = dfs.iterator.asScala.take(AbstractConverterFactory.inferSampleSize)</span>
          // get the version from the first record
<span class="nc bnc" id="L58" title="All 4 branches missed.">          val version = records.flatMap(r =&gt; Option(r.get(VersionField.name))).collectFirst { case i: Integer =&gt; i.intValue() }</span>
<span class="nc" id="L59">          val nameEncoder = new FieldNameEncoder(version.getOrElse(SerializationVersions.DefaultVersion))</span>
<span class="nc" id="L60">          val dataSft = AvroDataFile.getSft(dfs)</span>
<span class="nc" id="L61">          val native = AvroSerialization.usesNativeCollections(dfs.getSchema)</span>

<span class="nc" id="L63">          val fields = dataSft.getAttributeDescriptors.asScala.map { descriptor =&gt;</span>
            // some types need a function applied to the underlying avro value
<span class="nc" id="L65">            val fn = ObjectType.selectType(descriptor).head match {</span>
<span class="nc bnc" id="L66" title="All 6 branches missed.">              case ObjectType.DATE            =&gt; Some(&quot;millisToDate&quot;)</span>
<span class="nc bnc" id="L67" title="All 6 branches missed.">              case ObjectType.UUID            =&gt; Some(&quot;avroBinaryUuid&quot;)</span>
<span class="nc bnc" id="L68" title="All 6 branches missed.">              case ObjectType.GEOMETRY        =&gt; Some(&quot;geometry&quot;) // note: handles both wkt (v1) and wkb (v2)</span>
<span class="nc bnc" id="L69" title="All 8 branches missed.">              case ObjectType.LIST if !native =&gt; Some(&quot;avroBinaryList&quot;)</span>
<span class="nc bnc" id="L70" title="All 8 branches missed.">              case ObjectType.MAP if !native  =&gt; Some(&quot;avroBinaryMap&quot;)</span>
<span class="nc" id="L71">              case _ =&gt; None</span>
            }

<span class="nc" id="L74">            val path = s&quot;avroPath($$1, '/${nameEncoder.encode(descriptor.getLocalName)}')&quot;</span>
<span class="nc" id="L75">            val expression = fn.map(f =&gt; s&quot;$f($path)&quot;).getOrElse(path)</span>
<span class="nc" id="L76">            BasicField(descriptor.getLocalName, Some(Expression(expression)))</span>
          }

<span class="nc" id="L79">          val id = Expression(s&quot;avroPath($$1, '/${FidField.name}')&quot;)</span>
          val userData: Map[String, Expression] =
<span class="nc bnc" id="L81" title="All 2 branches missed.">            if (dfs.getSchema.getField(UserDataField.name) == null) { Map.empty } else {</span>
              // avro user data is stored as an array of 'key', 'keyClass', 'value', and 'valueClass'
              // our converters require global key-&gt;expression, so pull out the unique keys
<span class="nc" id="L84">              val kvs = scala.collection.mutable.Map.empty[String, Expression]</span>
<span class="nc" id="L85">              records.foreach { record =&gt;</span>
<span class="nc" id="L86">                val ud = record.get(UserDataField.name).asInstanceOf[java.util.Collection[GenericRecord]]</span>
<span class="nc" id="L87">                ud.asScala.foreach { rec =&gt;</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">                  if (rec.getSchema.getField(&quot;key&quot;) != null) {</span>
<span class="nc" id="L89">                    Option(rec.get(&quot;key&quot;)).map(_.toString).foreach { key =&gt;</span>
<span class="nc" id="L90">                      kvs.getOrElseUpdate(key, {</span>
<span class="nc" id="L91">                        var expression = s&quot;avroPath($$1, '/${UserDataField.name}[$$key=$key]/value')&quot;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                        if (rec.getSchema.getField(&quot;valueClass&quot;) != null &amp;&amp;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                            Option(rec.get(&quot;valueClass&quot;)).map(_.toString).contains(&quot;java.util.Date&quot;)) {</span>
                          // dates have to be converted from millis
<span class="nc" id="L95">                          expression = s&quot;millisToDate($expression)&quot;</span>
                        }
<span class="nc" id="L97">                        Expression(expression)</span>
                      })
                    }
                  }
                }
              }
<span class="nc" id="L103">              kvs.toMap</span>
            }

<span class="nc" id="L106">          (dataSft, id, fields, userData)</span>
        } else {
          // this is an arbitrary avro file, create fields based on the schema
<span class="nc" id="L109">          val types = AvroConverterFactory.schemaTypes(dfs.getSchema)</span>
<span class="nc" id="L110">          val dataSft = TypeInference.schema(&quot;inferred-avro&quot;, types)</span>
          // note: avro values are always stored at index 1
<span class="nc" id="L112">          val id = Expression(&quot;md5(string2bytes($1::string))&quot;)</span>
<span class="nc" id="L113">          val fields = types.map(t =&gt; BasicField(t.name, Some(Expression(t.transform.apply(1)))))</span>

<span class="nc" id="L115">          (dataSft, id, fields, Map.empty[String, Expression])</span>
        }

        // validate the existing schema, if any
<span class="nc" id="L119">        sft.foreach { existing =&gt;</span>
<span class="nc" id="L120">          val inferred = schema.getAttributeDescriptors.asScala</span>
<span class="nc" id="L121">          val matched = existing.getAttributeDescriptors.asScala.count { d =&gt;</span>
<span class="nc" id="L122">            inferred.exists { i =&gt;</span>
<span class="nc bnc" id="L123" title="All 8 branches missed.">              i.getLocalName == d.getLocalName &amp;&amp; d.getType.getBinding.isAssignableFrom(i.getType.getBinding)</span>
            }
          }
<span class="nc bnc" id="L126" title="All 2 branches missed.">          if (matched == 0) {</span>
<span class="nc" id="L127">            throw new IllegalArgumentException(&quot;Inferred schema does not match existing schema&quot;)</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">          } else if (matched &lt; existing.getAttributeCount) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            logger.warn(s&quot;Inferred schema only matched $matched out of ${existing.getAttributeCount} attributes&quot;)</span>
          }
        }

<span class="nc" id="L133">        val converterConfig = AvroConfig(typeToProcess, None, SchemaEmbedded, Some(id), Map.empty, userData)</span>

<span class="nc" id="L135">        val config = configConvert.to(converterConfig)</span>
<span class="nc" id="L136">            .withFallback(fieldConvert.to(fields.toSeq))</span>
<span class="nc" id="L137">            .withFallback(optsConvert.to(BasicOptions.default))</span>
            .toConfig

<span class="nc" id="L140">        (schema, config)</span>
      }
    }
  }
}

<span class="nc" id="L146">object AvroConverterFactory {</span>

  import scala.collection.JavaConverters._

  /**
    * Take an avro schema and return the simple feature type bindings for it
    *
    * @param schema avro schema
    * @return
    */
  def schemaTypes(schema: Schema): Seq[InferredType] = {
<span class="nc" id="L157">    val namer = new Namer()</span>
<span class="nc" id="L158">    val types = scala.collection.mutable.ArrayBuffer.empty[InferredType]</span>

<span class="nc" id="L160">    def mapField(field: Schema.Field, path: String = &quot;&quot;): Unit = {</span>
      // get a valid attribute name
<span class="nc" id="L162">      val name = namer(field.name())</span>

      // checks for nested array/map types we can handle
<span class="nc" id="L165">      def isSimpleArray: Boolean = isSimple(field.schema().getElementType)</span>
<span class="nc" id="L166">      def isSimpleMap: Boolean = isSimple(field.schema().getValueType)</span>

<span class="nc" id="L168">      val transform = FunctionTransform(&quot;avroPath(&quot;, s&quot;,'$path/${field.name}')&quot;)</span>
<span class="nc" id="L169">      field.schema().getType match {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        case Schema.Type.STRING  =&gt; types += InferredType(name, ObjectType.STRING, transform)</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        case Schema.Type.BYTES   =&gt; types += InferredType(name, ObjectType.BYTES, transform)</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        case Schema.Type.INT     =&gt; types += InferredType(name, ObjectType.INT, transform)</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        case Schema.Type.LONG    =&gt; types += InferredType(name, ObjectType.LONG, transform)</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        case Schema.Type.FLOAT   =&gt; types += InferredType(name, ObjectType.FLOAT, transform)</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        case Schema.Type.DOUBLE  =&gt; types += InferredType(name, ObjectType.DOUBLE, transform)</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        case Schema.Type.BOOLEAN =&gt; types += InferredType(name, ObjectType.BOOLEAN, transform)</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">        case Schema.Type.ARRAY   =&gt; if (isSimpleArray) { types += InferredType(name, ObjectType.LIST, transform) }</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">        case Schema.Type.MAP     =&gt; if (isSimpleMap) { types += InferredType(name, ObjectType.MAP, transform) }</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        case Schema.Type.FIXED   =&gt; types += InferredType(name, ObjectType.BYTES, transform)</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        case Schema.Type.ENUM    =&gt; types += InferredType(name, ObjectType.STRING, transform.copy(suffix = transform.suffix + &quot;::string&quot;))</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        case Schema.Type.UNION   =&gt; types += InferredType(name, ObjectType.STRING, transform.copy(suffix = transform.suffix + &quot;::string&quot;))</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        case Schema.Type.RECORD  =&gt; field.schema().getFields.asScala.foreach(mapField(_, s&quot;$path/${field.name}&quot;))</span>
<span class="nc" id="L183">        case _ =&gt; // no-op</span>
      }
    }

<span class="nc" id="L187">    schema.getFields.asScala.foreach(mapField(_))</span>

    // check if we can derive a geometry field
<span class="nc" id="L190">    TypeInference.deriveGeometry(types.toSeq, namer).foreach(g =&gt; types += g)</span>

<span class="nc" id="L192">    types.toSeq</span>
  }

<span class="nc" id="L195">  private def isSimple(s: Schema): Boolean = s.getType match {</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">    case Schema.Type.STRING  =&gt; true</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">    case Schema.Type.INT     =&gt; true</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">    case Schema.Type.LONG    =&gt; true</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    case Schema.Type.FLOAT   =&gt; true</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">    case Schema.Type.DOUBLE  =&gt; true</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">    case Schema.Type.BOOLEAN =&gt; true</span>
<span class="nc" id="L202">    case _ =&gt; false</span>
  }

<span class="nc" id="L205">  object AvroConfigConvert extends ConverterConfigConvert[AvroConfig] with OptionConvert {</span>

    override protected def decodeConfig(
        cur: ConfigObjectCursor,
        `type`: String,
        idField: Option[Expression],
        caches: Map[String, Config],
        userData: Map[String, Expression]): Either[ConfigReaderFailures, AvroConfig] = {

      def schemaOrFile(
          schema: Option[String],
          schemaFile: Option[String]): Either[ConfigReaderFailures, SchemaConfig] = {
<span class="nc bnc" id="L217" title="All 6 branches missed.">        (schema, schemaFile) match {</span>
<span class="nc bnc" id="L218" title="All 6 branches missed.">          case (Some(s), None) if s.equalsIgnoreCase(SchemaEmbedded.name) =&gt; Right(SchemaEmbedded)</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">          case (Some(s), None) =&gt; Right(SchemaString(s))</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">          case (None, Some(s)) =&gt; Right(SchemaFile(s))</span>
          case _ =&gt;
<span class="nc" id="L222">            val reason: FailureReason = new FailureReason {</span>
<span class="nc" id="L223">              override val description: String = &quot;Exactly one of 'schema' or 'schema-file' must be defined&quot;</span>
            }
<span class="nc" id="L225">            cur.failed(reason)</span>
        }
      }

      for {
<span class="nc" id="L230">        name       &lt;- converterName(cur).right</span>
<span class="nc" id="L231">        schema     &lt;- optional(cur, &quot;schema&quot;).right</span>
<span class="nc" id="L232">        schemaFile &lt;- optional(cur, &quot;schema-file&quot;).right</span>
<span class="nc" id="L233">        either     &lt;- schemaOrFile(schema, schemaFile).right</span>
      } yield {
<span class="nc" id="L235">        AvroConfig(`type`, name, either, idField, caches, userData)</span>
      }
    }

    override protected def encodeConfig(config: AvroConfig, base: java.util.Map[String, AnyRef]): Unit = {
<span class="nc" id="L240">      config.schema match {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        case SchemaEmbedded  =&gt; base.put(&quot;schema&quot;, SchemaEmbedded.name)</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        case SchemaString(s) =&gt; base.put(&quot;schema&quot;, s)</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        case SchemaFile(s)   =&gt; base.put(&quot;schema-file&quot;, s)</span>
      }
    }
  }
<span class="nc" id="L247">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>