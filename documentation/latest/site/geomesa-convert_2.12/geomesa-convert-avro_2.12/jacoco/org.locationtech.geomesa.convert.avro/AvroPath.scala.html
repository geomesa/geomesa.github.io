<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AvroPath.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Avro</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.avro</a> &gt; <span class="el_source">AvroPath.scala</span></div><h1>AvroPath.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.avro

import org.apache.avro.generic.{GenericArray, GenericEnumSymbol, GenericFixed, GenericRecord}
import org.apache.avro.util.Utf8
import org.locationtech.geomesa.utils.text.BasicParser
import org.parboiled.errors.ParsingException
import org.parboiled.scala.parserunners.{BasicParseRunner, ReportingParseRunner}

import java.nio.ByteBuffer

sealed trait AvroPath {
  def eval(record: Any): Option[Any]
}

<span class="nc" id="L23">object AvroPath extends BasicParser {</span>

  type AvroPredicate = GenericRecord =&gt; Boolean

<span class="nc" id="L27">  private val Parser = new AvroPathParser()</span>

<span class="nc" id="L29">  def apply(path: String): AvroPath = parse(path)</span>

  @throws(classOf[ParsingException])
<span class="nc" id="L32">  def parse(path: String, report: Boolean = true): AvroPath = {</span>
<span class="nc bnc" id="L33" title="All 2 branches missed.">    if (path == null) {</span>
<span class="nc" id="L34">      throw new IllegalArgumentException(&quot;Invalid path string: null&quot;)</span>
    }
<span class="nc bnc" id="L36" title="All 2 branches missed.">    val runner = if (report) { ReportingParseRunner(Parser.path) } else { BasicParseRunner(Parser.path) }</span>
<span class="nc" id="L37">    val parsing = runner.run(path)</span>
<span class="nc" id="L38">    parsing.result.getOrElse(throw new ParsingException(s&quot;Error parsing avro path: $path&quot;))</span>
  }

  private def convert(record: Any): Any = {
<span class="nc" id="L42">    record match {</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">      case x: Utf8                       =&gt; x.toString</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">      case x: ByteBuffer                 =&gt; convertBytes(x)</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      case x: GenericFixed               =&gt; x.bytes()</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">      case x: GenericEnumSymbol[_]       =&gt; x.toString</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">      case x: GenericArray[Any]          =&gt; convertList(x)</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">      case x: java.util.Map[String, Any] =&gt; convertMap(x)</span>
<span class="nc" id="L49">      case x                             =&gt; x</span>
    }
  }

  private def convertBytes(x: ByteBuffer): Array[Byte] = {
<span class="nc" id="L54">    val start = x.position()</span>
<span class="nc" id="L55">    val length = x.limit() - start</span>
<span class="nc" id="L56">    val bytes = Array.ofDim[Byte](length)</span>
<span class="nc" id="L57">    x.get(bytes, 0, length)</span>
<span class="nc" id="L58">    x.position(start)</span>
<span class="nc" id="L59">    bytes</span>
  }

  private def convertList(list: java.util.List[Any]): java.util.List[Any] = {
<span class="nc" id="L63">    val result = new java.util.ArrayList[Any](list.size())</span>
<span class="nc" id="L64">    val iter = list.iterator()</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">    while (iter.hasNext) {</span>
<span class="nc" id="L66">      result.add(convert(iter.next()))</span>
    }
<span class="nc" id="L68">    result</span>
  }

  // note: maps get re-used, so we need to copy to a new structure
  private def convertMap(map: java.util.Map[String, Any]): java.util.Map[String, Any] = {
<span class="nc" id="L73">    val result = new java.util.HashMap[String, Any](map.size())</span>
<span class="nc" id="L74">    val iter = map.entrySet().iterator()</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">    while (iter.hasNext) {</span>
<span class="nc" id="L76">      val entry = iter.next</span>
<span class="nc" id="L77">      result.put(convert(entry.getKey).asInstanceOf[String], convert(entry.getValue))</span>
    }
<span class="nc" id="L79">    result</span>
  }

<span class="nc bnc" id="L82" title="All 25 branches missed.">  case class PathExpr(field: String, predicate: AvroPredicate) extends AvroPath {</span>
    override def eval(record: Any): Option[Any] = {
<span class="nc" id="L84">      record match {</span>
        // schema null check supports our parquet support
<span class="nc bnc" id="L86" title="All 6 branches missed.">        case gr: GenericRecord if gr.getSchema == null || gr.getSchema.getField(field) != null =&gt;</span>
<span class="nc" id="L87">          gr.get(field) match {</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            case x: GenericRecord =&gt; Some(x).filter(predicate)</span>
<span class="nc" id="L89">            case x                =&gt; Option(convert(x))</span>
          }

<span class="nc" id="L92">        case _ =&gt; None</span>
      }
    }
  }

<span class="nc bnc" id="L97" title="All 25 branches missed.">  case class ArrayRecordExpr(field: String, matched: String) extends AvroPath {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L101">    override def eval(r: Any): Option[Any] = r match {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">      case a: java.util.List[GenericRecord] =&gt; a.asScala.find(predicate)</span>
<span class="nc" id="L103">      case _ =&gt; None</span>
    }

    private def predicate(record: GenericRecord): Boolean = {
<span class="nc" id="L107">      record.get(field) match {</span>
<span class="nc bnc" id="L108" title="All 8 branches missed.">        case x: Utf8 =&gt; x.toString == matched</span>
<span class="nc bnc" id="L109" title="All 6 branches missed.">        case x       =&gt; x == matched</span>
      }
    }
  }

<span class="nc bnc" id="L114" title="All 18 branches missed.">  case class CompositeExpr(se: Seq[AvroPath]) extends AvroPath {</span>
<span class="nc" id="L115">    override def eval(r: Any): Option[Any] = r match {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">      case gr: GenericRecord =&gt; se.foldLeft[Option[Any]](Some(gr))((result, current) =&gt; result.flatMap(current.eval))</span>
<span class="nc" id="L117">      case _ =&gt; None</span>
    }
  }

<span class="nc bnc" id="L121" title="All 18 branches missed.">  case class UnionTypeFilter(n: String) extends AvroPredicate {</span>
<span class="nc bnc" id="L122" title="All 6 branches missed.">    override def apply(v1: GenericRecord): Boolean = v1.getSchema.getName == n</span>
  }

<span class="nc" id="L125">  class AvroPathParser extends BasicParser {</span>

    import org.parboiled.scala._

    // full simple feature spec
<span class="nc" id="L130">    def path: Rule1[AvroPath] = rule(&quot;Path&quot;) {</span>
<span class="nc" id="L131">      oneOrMore(pathExpression | arrayRecord) ~ EOI ~~&gt; {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        paths =&gt; if (paths.lengthCompare(1) == 0) { paths.head } else { CompositeExpr(paths) }</span>
      }
    }

<span class="nc" id="L136">    private def pathExpression: Rule1[PathExpr] = rule(&quot;PathExpression&quot;) {</span>
<span class="nc" id="L137">      &quot;/&quot; ~ identifier ~ optional(&quot;$type=&quot; ~ identifier) ~~&gt; {</span>
<span class="nc" id="L138">        (field, typed) =&gt; PathExpr(field, typed.map(UnionTypeFilter.apply).getOrElse(_ =&gt; true))</span>
      }
    }

<span class="nc" id="L142">    private def arrayRecord: Rule1[ArrayRecordExpr] = rule(&quot;ArrayRecord&quot;) {</span>
<span class="nc" id="L143">      (&quot;[$&quot; ~ identifier ~ &quot;=&quot; ~ identifier ~ &quot;]&quot;) ~~&gt; {</span>
<span class="nc" id="L144">        (field, matched) =&gt; ArrayRecordExpr(field, matched)</span>
      }
    }

<span class="nc" id="L148">    private def identifier: Rule1[String] = rule(&quot;Identifier&quot;) {</span>
<span class="nc" id="L149">      oneOrMore(char | anyOf(&quot;.-&quot;)) ~&gt; { s =&gt; s }</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>