<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AvroReadSupport.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Convert Parquet</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.convert.parquet</a> &gt; <span class="el_source">AvroReadSupport.scala</span></div><h1>AvroReadSupport.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.convert.parquet

import org.apache.avro.generic.{GenericData, GenericRecord}
import org.apache.hadoop.conf.Configuration
import org.apache.parquet.avro.AvroSchemaConverter
import org.apache.parquet.conf.ParquetConfiguration
import org.apache.parquet.hadoop.api.ReadSupport.ReadContext
import org.apache.parquet.hadoop.api.{InitContext, ReadSupport}
import org.apache.parquet.io.api._
import org.apache.parquet.schema.LogicalTypeAnnotation._
import org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName
import org.apache.parquet.schema.Type.Repetition
import org.apache.parquet.schema._
import org.locationtech.geomesa.convert.parquet.AvroReadSupport.AvroRecordMaterializer
import org.locationtech.geomesa.curve.BinnedTime
import org.locationtech.geomesa.fs.storage.parquet.io.SimpleFeatureReadSupport._
import org.locationtech.geomesa.fs.storage.parquet.io.{SimpleFeatureParquetSchema, SimpleFeatureReadSupport}
import org.locationtech.geomesa.utils.geotools.ObjectType

import java.util.{Collections, Date}

/**
  * Read support for parsing an arbitrary parquet file into avro records.
  *
  * The official parquet-avro reader doesn't support 'repeated' columns, and requires avro 1.8,
  * so we roll our own
  */
<span class="nc" id="L36">class AvroReadSupport extends ReadSupport[GenericRecord] {</span>

<span class="nc" id="L38">  private var schema: Option[SimpleFeatureParquetSchema] = None</span>

  override def init(context: InitContext): ReadContext = {
<span class="nc" id="L41">    schema = SimpleFeatureParquetSchema.read(context)</span>
<span class="nc" id="L42">    new ReadContext(context.getFileSchema, schema.map(_.metadata).getOrElse(Collections.emptyMap()))</span>
  }

  override def prepareForRead(
      configuration: Configuration,
      keyValueMetaData: java.util.Map[String, String],
      fileSchema: MessageType,
      readContext: ReadContext): RecordMaterializer[GenericRecord] =
<span class="nc" id="L50">    new AvroRecordMaterializer(fileSchema, schema)</span>

  override def prepareForRead(
    configuration: ParquetConfiguration,
    keyValueMetaData: java.util.Map[String, String],
    fileSchema: MessageType,
    readContext: ReadContext): RecordMaterializer[GenericRecord] =
<span class="nc" id="L57">    new AvroRecordMaterializer(fileSchema, schema)</span>
}

<span class="nc" id="L60">object AvroReadSupport {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L64">  class AvroRecordMaterializer(fileSchema: MessageType, schema: Option[SimpleFeatureParquetSchema])</span>
<span class="nc" id="L65">      extends RecordMaterializer[GenericRecord] {</span>
<span class="nc" id="L66">    private val root = new GenericGroupConverter(fileSchema, schema)</span>
<span class="nc" id="L67">    override def getCurrentRecord: GenericRecord = root.materialize()</span>
<span class="nc" id="L68">    override def getRootConverter: GroupConverter = root</span>
  }

  /**
   * Group converter for a record
   *
   * @param fileSchema parquet schema
   * @param schema geomesa schema encodings, if it's a geomesa file
   */
<span class="nc" id="L77">  private class GenericGroupConverter(fileSchema: MessageType, schema: Option[SimpleFeatureParquetSchema])</span>
<span class="nc" id="L78">      extends GroupConverter with ValueMaterializer[GenericRecord] {</span>

<span class="nc" id="L80">    private val avroSchema = new AvroSchemaConverter().convert(fileSchema)</span>
<span class="nc" id="L81">    private val fields = fileSchema.getFields.asScala.toSeq</span>
<span class="nc" id="L82">    private val converters = schema match {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      case None =&gt; Array.tabulate(fields.length)(i =&gt; converter(fields(i)))</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      case Some(s) =&gt;</span>
        // for attributes, we re-use our parquet read support so that they get parsed into standard simple feature attribute
        // types (including geometries) instead of generic avro types
        val attributes =
<span class="nc" id="L88">          s.sft.getAttributeDescriptors.asScala.map(d =&gt; SimpleFeatureReadSupport.attribute(ObjectType.selectType(d), s.encodings))</span>
        // the remaining non-attribute fields are added as generic types (currently fid, vis, and bboxes)
<span class="nc" id="L90">        val remaining = fields.drop(s.sft.getAttributeCount).map(converter).toArray</span>
<span class="nc" id="L91">        attributes.toArray ++ remaining</span>
    }

<span class="nc" id="L94">    private var rec: GenericRecord = _</span>

<span class="nc" id="L96">    override def getConverter(fieldIndex: Int): Converter = converters(fieldIndex)</span>
    override def start(): Unit = {
<span class="nc" id="L98">      rec = new GenericData.Record(avroSchema)</span>
<span class="nc" id="L99">      converters.foreach(_.reset())</span>
    }
    override def end(): Unit = {
<span class="nc" id="L102">      var i = 0</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">      while (i &lt; fields.length) {</span>
<span class="nc" id="L104">        rec.put(i, converters(i).materialize())</span>
<span class="nc" id="L105">        i += 1</span>
      }
    }
<span class="nc" id="L108">    override def reset(): Unit = rec = null</span>
<span class="nc" id="L109">    override def materialize(): GenericRecord = rec</span>
  }

  /**
    * Get a converter for a field type
    *
    * @param field field
    * @return
    */
  private def converter(field: Type): ValueMaterializer[_ &lt;: AnyRef] = {
<span class="nc" id="L119">    val logical = field.getLogicalTypeAnnotation</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">    if (field.isPrimitive) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">      lazy val logicalConverter = logical match {</span>
        case _: StringLogicalTypeAnnotation =&gt; Some(new StringConverter())
        case _: DateLogicalTypeAnnotation =&gt; Some(new DaysConverter())
        case t: TimestampLogicalTypeAnnotation if t.getUnit == LogicalTypeAnnotation.TimeUnit.MILLIS =&gt; Some(new DateMillisConverter())
        case t: TimestampLogicalTypeAnnotation if t.getUnit == LogicalTypeAnnotation.TimeUnit.MICROS =&gt; Some(new DateMicrosConverter())
        case t: TimestampLogicalTypeAnnotation if t.getUnit == LogicalTypeAnnotation.TimeUnit.NANOS =&gt; Some(new NanosConverter())
        case _: UUIDLogicalTypeAnnotation =&gt; Some(new UuidConverter())
        case _ =&gt; None
      }
<span class="nc" id="L130">      val convert = field.asPrimitiveType().getPrimitiveTypeName match {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        case PrimitiveTypeName.BINARY               =&gt; logicalConverter.getOrElse(new GeneralPrimitiveConverter())</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        case PrimitiveTypeName.INT32                =&gt; logicalConverter.getOrElse(new GeneralPrimitiveConverter())</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        case PrimitiveTypeName.INT64                =&gt; logicalConverter.getOrElse(new GeneralPrimitiveConverter())</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        case PrimitiveTypeName.DOUBLE               =&gt; new GeneralPrimitiveConverter()</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        case PrimitiveTypeName.FLOAT                =&gt; new GeneralPrimitiveConverter()</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        case PrimitiveTypeName.BOOLEAN              =&gt; new GeneralPrimitiveConverter()</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        case PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY =&gt; logicalConverter.getOrElse(new GeneralPrimitiveConverter())</span>
<span class="nc" id="L138">        case _                                      =&gt; NullPrimitiveConverter</span>
      }
<span class="nc bnc" id="L140" title="All 2 branches missed.">      if (field.isRepetition(Repetition.REPEATED)) {</span>
<span class="nc" id="L141">        new RepeatedPrimitiveConverter(convert)</span>
      } else {
<span class="nc" id="L143">        convert</span>
      }
    } else {
<span class="nc" id="L146">      val group = field.asGroupType()</span>
      def genericGroupConverter(): GenericGroupConverter =
<span class="nc" id="L148">        new GenericGroupConverter(new MessageType(group.getName, group.getFields), None)</span>
<span class="nc" id="L149">      logical match {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        case _: ListLogicalTypeAnnotation =&gt;</span>
<span class="nc" id="L151">          ParquetConverterFactory.getListElementType(group) match {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            case Some(items) =&gt; new ListConverter(converter(items))</span>
<span class="nc" id="L153">            case _ =&gt; genericGroupConverter()</span>
          }

<span class="nc bnc" id="L156" title="All 2 branches missed.">        case _: MapLogicalTypeAnnotation =&gt;</span>
<span class="nc" id="L157">          ParquetConverterFactory.getMapKeyValueTypes(group) match {</span>
<span class="nc bnc" id="L158" title="All 4 branches missed.">            case Some((k, v)) =&gt; new MapConverter(converter(k), converter(v))</span>
<span class="nc" id="L159">            case _ =&gt; genericGroupConverter()</span>
          }

        case _ =&gt;
<span class="nc" id="L163">          genericGroupConverter()</span>
      }
    }
  }

  /**
   * Converter for primitive fields with repetition of 'repeated'
   *
   * @param delegate single value converter
   */
<span class="nc" id="L173">  private class RepeatedPrimitiveConverter(delegate: PrimitiveConverter with ValueMaterializer[_ &lt;: AnyRef])</span>
<span class="nc" id="L174">    extends PrimitiveConverter with ValueMaterializer[java.util.List[AnyRef]] {</span>

<span class="nc" id="L176">    private var list: java.util.List[AnyRef] = _</span>

<span class="nc" id="L178">    override def addBinary(value: Binary): Unit = { delegate.addBinary(value); addElement() }</span>
<span class="nc" id="L179">    override def addBoolean(value: Boolean): Unit = { delegate.addBoolean(value); addElement() }</span>
<span class="nc" id="L180">    override def addInt(value: Int): Unit = { delegate.addInt(value); addElement() }</span>
<span class="nc" id="L181">    override def addFloat(value: Float): Unit = { delegate.addFloat(value); addElement() }</span>
<span class="nc" id="L182">    override def addLong(value: Long): Unit = { delegate.addLong(value); addElement() }</span>
<span class="nc" id="L183">    override def addDouble(value: Double): Unit = { delegate.addDouble(value); addElement() }</span>

    private def addElement(): Unit = {
<span class="nc bnc" id="L186" title="All 2 branches missed.">      if (list == null) {</span>
<span class="nc" id="L187">        list = new java.util.ArrayList[AnyRef]()</span>
      }
<span class="nc" id="L189">      list.add(delegate.materialize())</span>
<span class="nc" id="L190">      delegate.reset()</span>
    }
<span class="nc" id="L192">    override def reset(): Unit = list = null</span>
<span class="nc" id="L193">    override def materialize(): java.util.List[AnyRef] = list</span>
  }

  /**
    * Converter for a DAYS encoded INT32 field
    */
<span class="nc" id="L199">  private class DaysConverter extends PrimitiveConverter with ValueMaterializer[Date] {</span>
<span class="nc" id="L200">    private var value: Int = -1</span>
<span class="nc" id="L201">    private var set = false</span>

    override def addInt(value: Int): Unit = {
<span class="nc" id="L204">      this.value = value</span>
<span class="nc" id="L205">      set = true</span>
    }
<span class="nc" id="L207">    override def reset(): Unit = set = false</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">    override def materialize(): Date = if (set) { Date.from(BinnedTime.Epoch.plusDays(value).toInstant) } else { null }</span>
  }

  /**
   * Converter for a MICROS encoded INT64 field
   */
<span class="nc" id="L214">  private class NanosConverter extends PrimitiveConverter with ValueMaterializer[Date] {</span>
<span class="nc" id="L215">    private var value: Long = -1</span>
<span class="nc" id="L216">    private var set = false</span>

    override def addLong(value: Long): Unit = {
<span class="nc" id="L219">      this.value = value</span>
<span class="nc" id="L220">      set = true</span>
    }
<span class="nc" id="L222">    override def reset(): Unit = set = false</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">    override def materialize(): Date = if (set) { new Date(value / 1000000L) } else { null }</span>
  }

<span class="nc" id="L226">  private case object NullPrimitiveConverter extends PrimitiveConverter with ValueMaterializer[AnyRef] {</span>
<span class="nc" id="L227">    override def addBinary(value: Binary): Unit = {}</span>
<span class="nc" id="L228">    override def addBoolean(value: Boolean): Unit = {}</span>
<span class="nc" id="L229">    override def addDouble(value: Double): Unit = {}</span>
<span class="nc" id="L230">    override def addFloat(value: Float): Unit = {}</span>
<span class="nc" id="L231">    override def addInt(value: Int): Unit = {}</span>
<span class="nc" id="L232">    override def addLong(value: Long): Unit = {}</span>
<span class="nc" id="L233">    override def reset(): Unit = {}</span>
<span class="nc" id="L234">    override def materialize(): AnyRef = null</span>
  }

  /**
   * Converter for any primitive type
   */
<span class="nc" id="L240">  private class GeneralPrimitiveConverter extends PrimitiveConverter with ValueMaterializer[AnyRef] {</span>
<span class="nc" id="L241">    private var value: Any = -1</span>
<span class="nc" id="L242">    private var set = false</span>

    override def addBinary(value: Binary): Unit = {
<span class="nc bnc" id="L245" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L246">        this.value = value.getBytes</span>
<span class="nc" id="L247">        set = true</span>
      }
    }
    override def addBoolean(value: Boolean): Unit = {
<span class="nc" id="L251">      this.value = value</span>
<span class="nc" id="L252">      set = true</span>
    }
    override def addDouble(value: Double): Unit = {
<span class="nc" id="L255">      this.value = value</span>
<span class="nc" id="L256">      set = true</span>
    }
    override def addFloat(value: Float): Unit = {
<span class="nc" id="L259">      this.value = value</span>
<span class="nc" id="L260">      set = true</span>
    }
    override def addInt(value: Int): Unit = {
<span class="nc" id="L263">      this.value = value</span>
<span class="nc" id="L264">      set = true</span>
    }
    override def addLong(value: Long): Unit = {
<span class="nc" id="L267">      this.value = value</span>
<span class="nc" id="L268">      set = true</span>
    }
<span class="nc" id="L270">    override def reset(): Unit = set = false</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">    override def materialize(): AnyRef = if (set) { value.asInstanceOf[AnyRef] } else { null }</span>
  }
<span class="nc" id="L273">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>