<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeometryProcessing.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Filters and Functions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.filter</a> &gt; <span class="el_source">GeometryProcessing.scala</span></div><h1>GeometryProcessing.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.filter

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.spatial._
import org.geotools.api.filter.{Filter, FilterFactory}
import org.geotools.filter.spatial.BBOXImpl
import org.locationtech.geomesa.filter.FilterHelper.trimToWorld
import org.locationtech.geomesa.utils.geohash.GeohashUtils
import org.locationtech.geomesa.utils.geotools.GeometryUtils.distanceDegrees
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.jts.geom.{Geometry, GeometryCollection}

import java.util.Locale
import scala.util.{Failure, Success}

/**
  * Process a geometry for querying
  */
trait GeometryProcessing {

  /**
    * Process a spatial filter
    *
    * @param op filter operation
    * @param sft simple feature type
    * @param factory filter factory
    * @return
    */
  def process(op: BinarySpatialOperator, sft: SimpleFeatureType, factory: FilterFactory): Filter

  /**
    * Extract geometries from a filter, to use for querying
    *
    * @param op filter
    * @param attribute name of geometry attribute to extract
    * @return
    */
  def extract(op: BinarySpatialOperator, attribute: String): Seq[Geometry]
}

<span class="nc bnc" id="L50" title="All 4 branches missed.">object GeometryProcessing extends GeometryProcessing with LazyLogging {</span>

<span class="nc" id="L52">  private val SafeGeomString = &quot;gm-safe&quot;</span>

<span class="nc" id="L54">  private val processor = FilterProperties.GeometryProcessing.get match {</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">    case p if p.equalsIgnoreCase(&quot;spatial4j&quot;)  =&gt; Spatial4jStrategy</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    case p if p.equalsIgnoreCase(&quot;none&quot;) =&gt; NoneStrategy</span>
    case p =&gt;
<span class="nc bnc" id="L58" title="All 2 branches missed.">      logger.warn(s&quot;Invalid value for '${FilterProperties.GeometryProcessing.property}', using default (spatial4j): $p&quot;)</span>
<span class="nc" id="L59">      Spatial4jStrategy</span>
  }

  override def process(op: BinarySpatialOperator, sft: SimpleFeatureType, factory: FilterFactory): Filter =
<span class="nc" id="L63">    processor.process(op, sft, factory)</span>

  override def extract(op: BinarySpatialOperator, attribute: String): Seq[Geometry] =
<span class="nc" id="L66">    processor.extract(op, attribute)</span>

  /**
    * Multiplier to convert to meters from a dwithin unit
    *
    * @param units units defined in a dwithin filter
    * @return
    */
  def metersMultiplier(units: String): Double = {
<span class="nc bnc" id="L75" title="All 2 branches missed.">    if (units == null) { 1d } else {</span>
<span class="nc" id="L76">      units.trim.toLowerCase(Locale.US) match {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        case &quot;meters&quot;         =&gt; 1d</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        case &quot;kilometers&quot;     =&gt; 1000d</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        case &quot;feet&quot;           =&gt; 0.3048</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        case &quot;statute miles&quot;  =&gt; 1609.347</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        case &quot;nautical miles&quot; =&gt; 1852d</span>
<span class="nc" id="L82">        case _                =&gt; 1d // not part of ECQL spec...</span>
      }
    }
  }

  /**
    * Expand a geometry collection into a seq of geometries
    *
    * @param geometry geometry
    * @return
    */
<span class="nc" id="L93">  private def flatten(geometry: Geometry): Seq[Geometry] = geometry match {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">    case g: GeometryCollection =&gt; Seq.tabulate(g.getNumGeometries)(g.getGeometryN).flatMap(flatten)</span>
<span class="nc" id="L95">    case _ =&gt; Seq(geometry)</span>
  }

<span class="nc" id="L98">  private trait AbstractGeometryProcessing extends GeometryProcessing {</span>

    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

    protected def split(geom: Geometry, op: BinarySpatialOperator): Geometry

    override def process(op: BinarySpatialOperator, sft: SimpleFeatureType, factory: FilterFactory): Filter = {
<span class="nc" id="L105">      val prop = org.locationtech.geomesa.filter.checkOrderUnsafe(op.getExpression1, op.getExpression2)</span>
<span class="nc" id="L106">      val geom = FastConverter.evaluate(prop.literal, classOf[Geometry])</span>
<span class="nc bnc" id="L107" title="All 6 branches missed.">      if (geom.getUserData == SafeGeomString) {</span>
<span class="nc" id="L108">        op // we've already visited this geom once</span>
      } else {
        // check for null or empty attribute and replace with default geometry name
<span class="nc" id="L111">        val attribute = Option(prop.name).filterNot(_.isEmpty).orElse(Option(sft).map(_.getGeomField)).orNull</span>
        // trim to world boundaries
<span class="nc" id="L113">        val trimmedGeom = trimToWorld(geom)</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (trimmedGeom.isEmpty) {</span>
<span class="nc" id="L115">          Filter.EXCLUDE</span>
        } else {
<span class="nc" id="L117">          val property = factory.property(attribute)</span>
<span class="nc" id="L118">          val filters = flatten(split(trimmedGeom, op)).map { geom =&gt;</span>
            // mark it as being visited
<span class="nc" id="L120">            geom.setUserData(SafeGeomString) // note: side effect</span>
<span class="nc" id="L121">            val literal = factory.literal(geom)</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">            val (e1, e2) = if (prop.flipped) { (literal, property) } else { (property, literal) }</span>
<span class="nc" id="L123">            op match {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">              case _: Within     =&gt; factory.within(e1, e2)</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">              case _: Intersects =&gt; factory.intersects(e1, e2)</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">              case _: Overlaps   =&gt; factory.overlaps(e1, e2)</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">              case d: DWithin    =&gt; factory.dwithin(e1, e2, d.getDistance, d.getDistanceUnits)</span>
              // use the direct constructor so that we preserve our geom user data
<span class="nc bnc" id="L129" title="All 2 branches missed.">              case _: BBOX       =&gt; new BBOXImpl(e1, e2)</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">              case _: Contains   =&gt; factory.contains(e1, e2)</span>
            }
          }
<span class="nc" id="L133">          orFilters(filters)(factory)</span>
        }
      }
    }

    override def extract(op: BinarySpatialOperator, attribute: String): Seq[Geometry] = {
      val geometry = for {
<span class="nc" id="L140">        prop &lt;- checkOrder(op.getExpression1, op.getExpression2)</span>
<span class="nc bnc" id="L141" title="All 8 branches missed.">        if prop.name == null || prop.name == attribute</span>
<span class="nc" id="L142">        geom &lt;- Option(FastConverter.evaluate(prop.literal, classOf[Geometry]))</span>
      } yield {
<span class="nc" id="L144">        val buffered = op match {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">          case f: DWithin =&gt; geom.buffer(distanceDegrees(geom, f.getDistance * metersMultiplier(f.getDistanceUnits))._2)</span>
<span class="nc" id="L146">          case _          =&gt; geom</span>
        }
<span class="nc" id="L148">        split(trimToWorld(buffered), op)</span>
      }
<span class="nc" id="L150">      geometry.map(flatten).getOrElse(Seq.empty)</span>
    }
  }

<span class="nc" id="L154">  private object Spatial4jStrategy extends AbstractGeometryProcessing {</span>
    override protected def split(geom: Geometry, op: BinarySpatialOperator): Geometry = {
      // add waypoints if needed so that IDL is handled correctly
<span class="nc bnc" id="L157" title="All 2 branches missed.">      val waypoints = if (op.isInstanceOf[BBOX]) { FilterHelper.addWayPointsToBBOX(geom) } else { geom }</span>
<span class="nc" id="L158">      GeohashUtils.getInternationalDateLineSafeGeometry(waypoints) match {</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        case Success(g) =&gt; g</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">        case Failure(e) =&gt; logger.warn(s&quot;Error splitting geometry on AM for $waypoints&quot;, e); waypoints</span>
      }
    }
  }

<span class="nc" id="L165">  private object NoneStrategy extends AbstractGeometryProcessing {</span>
<span class="nc" id="L166">    override protected def split(geom: Geometry, op: BinarySpatialOperator): Geometry = geom</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>