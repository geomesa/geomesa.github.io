<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Bounds.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Filters and Functions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.filter</a> &gt; <span class="el_source">Bounds.scala</span></div><h1>Bounds.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.filter

import org.locationtech.geomesa.filter.Bounds.Bound

/**
  * Single typed bound. If filter is unbounded on one or both sides, the associated bound will be None.
  *
  * For example, bounds for 'foo &lt; 5' would be (None, Some(5))
  * Special case for 'foo NOT NULL' will have both bounds be None
  *
  * @param lower lower bound, if any
  * @param upper upper bound, if any
  * @tparam T binding of the attribute type
  */
<span class="nc bnc" id="L23" title="All 25 branches missed.">case class Bounds[T](lower: Bound[T], upper: Bound[T]) {</span>

<span class="nc" id="L25">  def bounds: (Option[T], Option[T]) = (lower.value, upper.value)</span>

  /**
    * Bounded on at least one side
    *
    * @return
    */
<span class="nc bnc" id="L32" title="All 4 branches missed.">  def isBounded: Boolean = lower.value.nonEmpty || upper.value.nonEmpty</span>

  /**
    * Bounded on both sides
    *
    * @return
    */
<span class="nc bnc" id="L39" title="All 4 branches missed.">  def isBoundedBothSides: Boolean = lower.value.nonEmpty &amp;&amp; upper.value.nonEmpty</span>

  /**
    * Covers multiple values
    *
    * @return
    */
<span class="nc bnc" id="L46" title="All 8 branches missed.">  def isRange: Boolean = lower.value.isEmpty || lower.value != upper.value</span>

  /**
    * Covers a single value
    *
    * @return
    */
<span class="nc bnc" id="L53" title="All 2 branches missed.">  def isEquals: Boolean = !isRange</span>

  /**
    * Does this bounds cover the other bounds?
    *
    * @param other other bounds
    * @return
    */
  def covers(other: Bounds[T]): Boolean = {
    // if the end is unbounded, it will always cover, so use .forall
    // if the end is bounded and other.end is unbounded, then it will never cover, so use .exists on the inner check
    // if both end and other.end are bounded, then compare them
<span class="nc bnc" id="L65" title="All 2 branches missed.">    upper.value.forall { up =&gt;</span>
<span class="nc" id="L66">      other.upper.value.exists { oup =&gt;</span>
<span class="nc" id="L67">        val c = oup.asInstanceOf[Comparable[Any]].compareTo(up)</span>
<span class="nc bnc" id="L68" title="All 8 branches missed.">        c &lt; 0 || (c == 0 &amp;&amp; (upper.inclusive || other.upper.exclusive))</span>
      }
<span class="nc bnc" id="L70" title="All 2 branches missed.">    } &amp;&amp; lower.value.forall { lo =&gt;</span>
<span class="nc" id="L71">      other.lower.value.exists { olo =&gt;</span>
<span class="nc" id="L72">        val c = olo.asInstanceOf[Comparable[Any]].compareTo(lo)</span>
<span class="nc bnc" id="L73" title="All 8 branches missed.">        c &gt; 0 || (c == 0 &amp;&amp; (lower.inclusive || other.lower.exclusive))</span>
      }
    }
  }

  /**
    * Does this bounds intersect the other bounds?
    *
    * @param other other bounds
    * @return
    */
  def intersects(other: Bounds[T]): Boolean = {
    // if `largerLowerBound` or `smallerUpperBound` return None, then both this and other are unbounded
    // on the same end, so they by definition overlap - so use .forall
<span class="nc" id="L87">    val largerLowerBound = Bounds.largerLowerBound(lower, other.lower)</span>
<span class="nc" id="L88">    largerLowerBound.value.forall { lo =&gt;</span>
<span class="nc" id="L89">      val smallerUpperBound = Bounds.smallerUpperBound(upper, other.upper)</span>
<span class="nc" id="L90">      smallerUpperBound.value.forall { up =&gt;</span>
        // if largerLowerBound bound is smaller than smallerUpperBound, then they overlap
<span class="nc" id="L92">        val c = lo.asInstanceOf[Comparable[Any]].compareTo(up)</span>
<span class="nc bnc" id="L93" title="All 8 branches missed.">        c &lt; 0 || (c == 0 &amp;&amp; largerLowerBound.inclusive &amp;&amp; smallerUpperBound.inclusive)</span>
      }
    }
  }

  override def toString: String = {
<span class="nc bnc" id="L99" title="All 2 branches missed.">    (if (lower.inclusive) { &quot;[&quot; } else { &quot;(&quot; }) + lower.value.getOrElse(&quot;-\u221E&quot;) + &quot;,&quot; +</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      upper.value.getOrElse(&quot;+\u221E&quot;) + (if (upper.inclusive) { &quot;]&quot; } else { &quot;)&quot; })</span>
  }
}

<span class="nc" id="L104">object Bounds {</span>

  /**
    * Single bound (lower or upper).
    *
    * Bound may be unbounded, in which case value is None. Note by convention unbounded bounds are exclusive
    *
    * @param value value of this bound, if bounded
    * @param inclusive whether the bound is inclusive or exclusive.
    *                  for example, 'foo &lt; 5' is exclusive, 'foo &lt;= 5' is inclusive
    */
<span class="nc bnc" id="L115" title="All 23 branches missed.">  case class Bound[T](value: Option[T], inclusive: Boolean) {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">    def exclusive: Boolean = !inclusive</span>
  }

<span class="nc" id="L119">  object Bound {</span>
<span class="nc" id="L120">    private val unboundedBound = Bound[Any](None, inclusive = false)</span>
<span class="nc" id="L121">    def unbounded[T]: Bound[T] = unboundedBound.asInstanceOf[Bound[T]]</span>
<span class="nc" id="L122">    def inclusive[T](value: T): Bound[T] = Bound(Option(value), inclusive = true)</span>
  }

<span class="nc" id="L125">  private val allValues = Bounds(Bound.unbounded, Bound.unbounded)</span>

<span class="nc" id="L127">  def everything[T]: Bounds[T] = allValues.asInstanceOf[Bounds[T]]</span>

  /**
    * Gets the smaller value between two lower bounds, taking into account exclusivity.
    * If the bounds are equal, the first bound will always be returned
    *
    * @param bound1 first bound
    * @param bound2 second bound
    * @return smaller bound
    */
  def smallerLowerBound[T](bound1: Bound[T], bound2: Bound[T]): Bound[T] = {
<span class="nc bnc" id="L138" title="All 2 branches missed.">    if (bound1.value.isEmpty) {</span>
<span class="nc" id="L139">      bound1</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">    } else if (bound2.value.isEmpty) {</span>
<span class="nc" id="L141">      bound2</span>
    } else {
<span class="nc" id="L143">      val c = bound1.value.get.asInstanceOf[Comparable[Any]].compareTo(bound2.value.get)</span>
<span class="nc bnc" id="L144" title="All 8 branches missed.">      if (c &lt; 0 || (c == 0 &amp;&amp; (bound1.inclusive || bound2.exclusive))) { bound1 } else { bound2 }</span>
    }
  }

  /**
    * Gets the larger value between two upper bounds, taking into account exclusivity.
    * If the bounds are equal, the first bound will always be returned
    *
    * @param bound1 first bound
    * @param bound2 second bound
    * @return larger bound
    */
  def largerUpperBound[T](bound1: Bound[T], bound2: Bound[T]): Bound[T] = {
<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (bound1.value.isEmpty) {</span>
<span class="nc" id="L158">      bound1</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">    } else if (bound2.value.isEmpty) {</span>
<span class="nc" id="L160">      bound2</span>
    } else {
<span class="nc" id="L162">      val c = bound1.value.get.asInstanceOf[Comparable[Any]].compareTo(bound2.value.get)</span>
<span class="nc bnc" id="L163" title="All 8 branches missed.">      if (c &gt; 0 || (c == 0 &amp;&amp; (bound1.inclusive || bound2.exclusive))) { bound1 } else { bound2 }</span>
    }
  }

  /**
    * Gets the smaller value between two upper bounds, taking into account exclusivity.
    * If the bounds are equal, the first bound will always be returned
    *
    * @param bound1 first bound
    * @param bound2 second bound
    * @return smaller bound
    */
  def smallerUpperBound[T](bound1: Bound[T], bound2: Bound[T]): Bound[T] = {
<span class="nc bnc" id="L176" title="All 2 branches missed.">    if (bound2.value.isEmpty) {</span>
<span class="nc" id="L177">      bound1</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">    } else if (bound1.value.isEmpty) {</span>
<span class="nc" id="L179">      bound2</span>
    } else {
<span class="nc" id="L181">      val c = bound1.value.get.asInstanceOf[Comparable[Any]].compareTo(bound2.value.get)</span>
<span class="nc bnc" id="L182" title="All 8 branches missed.">      if (c &lt; 0 || (c == 0 &amp;&amp; (bound2.inclusive || bound1.exclusive))) { bound1 } else { bound2 }</span>
    }
  }

  /**
    * Gets the larger value between two upper bounds, taking into account exclusivity.
    * If the bounds are equal, the first bound will always be returned
    *
    * @param bound1 first bound
    * @param bound2 second bound
    * @return larger bound
    */
  def largerLowerBound[T](bound1: Bound[T], bound2: Bound[T]): Bound[T] = {
<span class="nc bnc" id="L195" title="All 2 branches missed.">    if (bound2.value.isEmpty) {</span>
<span class="nc" id="L196">      bound1</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">    } else if (bound1.value.isEmpty) {</span>
<span class="nc" id="L198">      bound2</span>
    } else {
<span class="nc" id="L200">      val c = bound1.value.get.asInstanceOf[Comparable[Any]].compareTo(bound2.value.get)</span>
<span class="nc bnc" id="L201" title="All 8 branches missed.">      if (c &gt; 0 || (c == 0 &amp;&amp; (bound2.inclusive || bound1.exclusive))) { bound1 } else { bound2 }</span>
    }
  }

  /**
    * Takes the intersection of two bounds. If they are disjoint, will return None.
    *
    * @param left first bounds
    * @param right second bounds
    * @tparam T type parameter
    * @return intersection
    */
  def intersection[T](left: Bounds[T], right: Bounds[T]): Option[Bounds[T]] = {
<span class="nc" id="L214">    val lower = largerLowerBound(left.lower, right.lower)</span>
<span class="nc" id="L215">    val upper = smallerUpperBound(right.upper, left.upper)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    (lower.value, upper.value) match {</span>
<span class="nc bnc" id="L217" title="All 4 branches missed.">      case (Some(lo), Some(up)) =&gt;</span>
<span class="nc" id="L218">        lo.asInstanceOf[Comparable[Any]].compareTo(up) match {</span>
<span class="nc bnc" id="L219" title="All 8 branches missed.">          case i if i &gt; 0 || (i == 0 &amp;&amp; (!lower.inclusive || !upper.inclusive)) =&gt; None</span>
<span class="nc" id="L220">          case _ =&gt; Some(Bounds(lower, upper))</span>
        }
<span class="nc" id="L222">      case _ =&gt; Some(Bounds(lower, upper))</span>
    }
  }

  /**
    * Takes the union of two bound sequences.
    *
    * @param left first bounds
    * @param right second bounds
    * @tparam T type parameter
    * @return union
    */
  def union[T](left: Seq[Bounds[T]], right: Seq[Bounds[T]]): Seq[Bounds[T]] = {

    def mergeOverlapping(bound: Bounds[T], rest: Seq[Bounds[T]]): Seq[Bounds[T]] = {
<span class="nc" id="L237">      rest match {</span>
<span class="nc bnc" id="L238" title="All 6 branches missed.">        case Seq() =&gt; Seq(bound)</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        case head +: tail =&gt;</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">          bound.upper match {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            case Bound(None, _) =&gt; Seq(bound)</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            case Bound(Some(x), incX) =&gt;</span>
<span class="nc bnc" id="L243" title="All 4 branches missed.">              head.lower match {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                case Bound(None, _) =&gt;</span>
<span class="nc" id="L245">                  mergeOverlapping(Bounds(head.lower, largerUpperBound(bound.upper, head.upper)), tail)</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                case Bound(Some(y), incY) =&gt;</span>
<span class="nc" id="L247">                  val c = y.asInstanceOf[Comparable[Any]].compareTo(x)</span>
<span class="nc bnc" id="L248" title="All 8 branches missed.">                  if (c &lt; 0 || (c == 0 &amp;&amp; (incX || incY)))</span>
<span class="nc" id="L249">                    mergeOverlapping(Bounds(bound.lower, largerUpperBound(bound.upper, head.upper)), tail)</span>
                  else
<span class="nc" id="L251">                    bound +: mergeOverlapping(head, tail)</span>
              }
          }
      }
    }

<span class="nc bnc" id="L257" title="All 8 branches missed.">    val bounds = (left ++ right).sortWith { case (a, b) =&gt; smallerLowerBound(a.lower, b.lower) == a.lower }</span>
<span class="nc" id="L258">    bounds match {</span>
<span class="nc bnc" id="L259" title="All 6 branches missed.">      case Seq() =&gt; bounds</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      case head +: tail =&gt; mergeOverlapping(head, tail)</span>
    }
  }
<span class="nc" id="L263">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>