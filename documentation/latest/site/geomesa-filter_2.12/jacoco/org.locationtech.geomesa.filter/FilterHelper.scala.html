<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilterHelper.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Filters and Functions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.filter</a> &gt; <span class="el_source">FilterHelper.scala</span></div><h1>FilterHelper.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.filter

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter._
import org.geotools.api.filter.expression.{Expression, PropertyName}
import org.geotools.api.filter.spatial._
import org.geotools.api.filter.temporal.{After, Before, During, TEquals}
import org.geotools.api.temporal.Period
import org.geotools.data.DataUtilities
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.filter.Bounds.Bound
import org.locationtech.geomesa.filter.expression.AttributeExpression.{FunctionLiteral, PropertyLiteral}
import org.locationtech.geomesa.filter.visitor.IdDetectingFilterVisitor
import org.locationtech.geomesa.utils.geotools.GeometryUtils
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.jts.geom._

import java.time.{ZoneOffset, ZonedDateTime}
import java.util.{Date, Locale}
import scala.collection.JavaConverters._
import scala.collection.mutable.ListBuffer
import scala.util.Try

<span class="nc" id="L33">object FilterHelper {</span>

  import org.locationtech.geomesa.utils.geotools.WholeWorldPolygon

  // helper shim to let other classes avoid importing FilterHelper.logger
<span class="nc bnc" id="L38" title="All 4 branches missed.">  object FilterHelperLogger extends LazyLogging {</span>
<span class="nc" id="L39">    private [FilterHelper] def log = logger</span>
  }

<span class="nc" id="L42">  val ff: FilterFactory = org.locationtech.geomesa.filter.ff</span>

<span class="nc" id="L44">  def isFilterWholeWorld(f: Filter): Boolean = f match {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      case op: BBOX       =&gt; isOperationGeomWholeWorld(op)</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">      case op: Intersects =&gt; isOperationGeomWholeWorld(op)</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">      case op: Overlaps   =&gt; isOperationGeomWholeWorld(op)</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">      case op: Within     =&gt; isOperationGeomWholeWorld(op, SpatialOpOrder.PropertyFirst)</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">      case op: Contains   =&gt; isOperationGeomWholeWorld(op, SpatialOpOrder.LiteralFirst)</span>
<span class="nc" id="L50">      case _ =&gt; false</span>
    }

  private def isOperationGeomWholeWorld[Op &lt;: BinarySpatialOperator]
<span class="nc" id="L54">      (op: Op, order: SpatialOpOrder.SpatialOpOrder = SpatialOpOrder.AnyOrder): Boolean = {</span>
<span class="nc" id="L55">    val prop = checkOrder(op.getExpression1, op.getExpression2)</span>
    // validate that property and literal are in the specified order
<span class="nc" id="L57">    prop.exists { p =&gt;</span>
<span class="nc" id="L58">      val ordered = order match {</span>
<span class="nc bnc" id="L59" title="All 6 branches missed.">        case SpatialOpOrder.AnyOrder      =&gt; true</span>
<span class="nc bnc" id="L60" title="All 8 branches missed.">        case SpatialOpOrder.PropertyFirst =&gt; !p.flipped</span>
<span class="nc bnc" id="L61" title="All 6 branches missed.">        case SpatialOpOrder.LiteralFirst  =&gt; p.flipped</span>
      }
<span class="nc bnc" id="L63" title="All 4 branches missed.">      ordered &amp;&amp; Option(FastConverter.evaluate(p.literal, classOf[Geometry])).exists(isWholeWorld)</span>
    }
  }

<span class="nc bnc" id="L67" title="All 4 branches missed.">  def isWholeWorld[G &lt;: Geometry](g: G): Boolean = g != null &amp;&amp; g.union.covers(WholeWorldPolygon)</span>

  /**
    * Returns the intersection of this geometry with the world polygon
    *
    * Note: may return the geometry itself if it is already covered by the world
    *
    * @param g geometry
    * @return
    */
  def trimToWorld(g: Geometry): Geometry =
<span class="nc bnc" id="L78" title="All 2 branches missed.">    if (WholeWorldPolygon.covers(g)) { g } else { g.intersection(WholeWorldPolygon) }</span>

  /**
    * Add way points to a geometry, preventing it from being split by JTS AM handling
    *
    * @param g geom
    * @return
    */
  def addWayPointsToBBOX(g: Geometry): Geometry = {
<span class="nc" id="L87">    val geomArray = g.getCoordinates</span>
<span class="nc" id="L88">    val correctedGeom = GeometryUtils.addWayPoints(geomArray).toArray</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (geomArray.length == correctedGeom.length) { g } else { g.getFactory.createPolygon(correctedGeom) }</span>
  }

  /**
    * Extracts geometries from a filter into a sequence of OR'd geometries
    *
    * @param filter filter to evaluate
    * @param attribute attribute to consider
    * @param intersect intersect AND'd geometries or return them all
    *                  note if not intersected, 'and/or' distinction will be lost
    * @return geometry bounds from spatial filters
    */
<span class="nc" id="L101">  def extractGeometries(filter: Filter, attribute: String, intersect: Boolean = true): FilterValues[Geometry] =</span>
<span class="nc" id="L102">    extractUnclippedGeometries(filter, attribute, intersect).map(trimToWorld)</span>

  /**
    * Extract geometries from a filter without validating boundaries.
    *
    * @param filter filter to evaluate
    * @param attribute attribute to consider
    * @param intersect intersect AND'd geometries or return them all
    * @return geometry bounds from spatial filters
    */
  private def extractUnclippedGeometries(filter: Filter, attribute: String, intersect: Boolean): FilterValues[Geometry] = {
<span class="nc" id="L113">    filter match {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">      case o: Or  =&gt;</span>
<span class="nc" id="L115">        val all = o.getChildren.asScala.map(extractUnclippedGeometries(_, attribute, intersect))</span>
<span class="nc" id="L116">        val join = FilterValues.or[Geometry]((l, r) =&gt; l ++ r) _</span>
<span class="nc" id="L117">        all.reduceLeftOption[FilterValues[Geometry]](join).getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L119" title="All 2 branches missed.">      case a: And =&gt;</span>
<span class="nc" id="L120">        val all = a.getChildren.asScala.map(extractUnclippedGeometries(_, attribute, intersect)).filter(_.nonEmpty)</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (intersect) {</span>
<span class="nc" id="L122">          val intersect = FilterValues.and[Geometry]((l, r) =&gt; Option(l.intersection(r)).filterNot(_.isEmpty)) _</span>
<span class="nc" id="L123">          all.reduceLeftOption[FilterValues[Geometry]](intersect).getOrElse(FilterValues.empty)</span>
        } else {
<span class="nc" id="L125">          FilterValues(all.toSeq.flatMap(_.values))</span>
        }

      // Note: although not technically required, all known spatial predicates are also binary spatial operators
<span class="nc bnc" id="L129" title="All 4 branches missed.">      case f: BinarySpatialOperator if isSpatialFilter(f) =&gt;</span>
<span class="nc" id="L130">        FilterValues(GeometryProcessing.extract(f, attribute))</span>

      case _ =&gt;
<span class="nc" id="L133">        FilterValues.empty</span>
    }
  }

  /**
   * Extracts intervals from a filter. Intervals will be merged where possible - the resulting sequence
   * is considered to be a union (i.e. OR)
   *
   * @param filter filter to evaluate
   * @param attribute attribute to consider
   * @param handleExclusiveBounds will make all exclusive bounds inclusive instead, by rounding the value slightly
   * @return a sequence of intervals, if any. disjoint intervals will result in Seq((null, null))
   */
  def extractIntervals(
      filter: Filter,
      attribute: String,
<span class="nc" id="L149">      handleExclusiveBounds: Boolean = false): FilterValues[Bounds[ZonedDateTime]] = {</span>
<span class="nc" id="L150">    extractAttributeBounds(filter, attribute, classOf[Date]).map { bounds =&gt;</span>
<span class="nc" id="L151">      var lower, upper: Bound[ZonedDateTime] = null</span>
      // this if check determines if rounding will be used and if we need to account for narrow ranges
<span class="nc bnc" id="L153" title="All 6 branches missed.">      if (!handleExclusiveBounds || bounds.lower.value.isEmpty || bounds.upper.value.isEmpty ||</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">          (bounds.lower.inclusive &amp;&amp; bounds.upper.inclusive)) {</span>
<span class="nc" id="L155">        lower = createDateTime(bounds.lower, roundSecondsUp, handleExclusiveBounds)</span>
<span class="nc" id="L156">        upper = createDateTime(bounds.upper, roundSecondsDown, handleExclusiveBounds)</span>
      } else {
        // check for extremely narrow filters where our rounding makes the result out-of-order
        // note: both upper and lower are known to be defined based on hitting this else branch
<span class="nc bnc" id="L160" title="All 4 branches missed.">        val margin = if (bounds.lower.inclusive || bounds.upper.inclusive) { 1000 } else { 2000 }</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        val round = bounds.upper.value.get.getTime - bounds.lower.value.get.getTime &gt; margin</span>
<span class="nc" id="L162">        lower = createDateTime(bounds.lower, roundSecondsUp, round)</span>
<span class="nc" id="L163">        upper = createDateTime(bounds.upper, roundSecondsDown, round)</span>
      }
<span class="nc" id="L165">      Bounds(lower, upper)</span>
    }
  }

  private def createDateTime(bound: Bound[Date],
                             round: ZonedDateTime =&gt; ZonedDateTime,
                             roundExclusive: Boolean): Bound[ZonedDateTime] = {
<span class="nc bnc" id="L172" title="All 2 branches missed.">    if (bound.value.isEmpty) { Bound.unbounded } else {</span>
<span class="nc" id="L173">      val dt = bound.value.map(d =&gt; ZonedDateTime.ofInstant(d.toInstant, ZoneOffset.UTC))</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">      if (roundExclusive &amp;&amp; !bound.inclusive) {</span>
<span class="nc" id="L175">        Bound(dt.map(round), inclusive = true)</span>
      } else {
<span class="nc" id="L177">        Bound(dt, bound.inclusive)</span>
      }
    }
  }

<span class="nc" id="L182">  private def roundSecondsUp(dt: ZonedDateTime): ZonedDateTime = dt.plusSeconds(1).withNano(0)</span>

  private def roundSecondsDown(dt: ZonedDateTime): ZonedDateTime = {
<span class="nc" id="L185">    val nanos = dt.getNano</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (nanos == 0) { dt.minusSeconds(1) } else { dt.withNano(0) }</span>
  }

  /**
    * Extracts bounds from filters that pertain to a given attribute. Bounds will be merged where
    * possible.
    *
    * @param filter filter to evaluate
    * @param attribute attribute name to consider
    * @param binding attribute type
    * @return a sequence of bounds, if any
    */
  def extractAttributeBounds[T](filter: Filter, attribute: String, binding: Class[T]): FilterValues[Bounds[T]] = {
<span class="nc" id="L199">    filter match {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      case o: Or =&gt;</span>
<span class="nc" id="L201">        val union = FilterValues.or[Bounds[T]](Bounds.union[T]) _</span>
<span class="nc" id="L202">        o.getChildren.asScala.map(f =&gt;</span>
<span class="nc" id="L203">          extractAttributeBounds(f, attribute, binding)</span>
<span class="nc" id="L204">        ).reduceLeft[FilterValues[Bounds[T]]]((acc, child) =&gt; {</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">          if (acc.isEmpty || child.isEmpty) {</span>
<span class="nc" id="L206">            FilterValues.empty</span>
          } else {
<span class="nc" id="L208">            union(acc, child)</span>
          }
        })

<span class="nc bnc" id="L212" title="All 2 branches missed.">      case a: And =&gt;</span>
<span class="nc" id="L213">        val all = a.getChildren.asScala.flatMap { f =&gt;</span>
<span class="nc" id="L214">          val child = extractAttributeBounds(f, attribute, binding)</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">          if (child.isEmpty) { Seq.empty } else { Seq(child) }</span>
        }
<span class="nc" id="L217">        val intersection = FilterValues.and[Bounds[T]](Bounds.intersection[T]) _</span>
<span class="nc" id="L218">        all.reduceLeftOption[FilterValues[Bounds[T]]](intersection).getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">      case f: PropertyIsEqualTo =&gt;</span>
<span class="nc bnc" id="L221" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L223">            Option(FastConverter.evaluate(e.literal, binding)).map { lit =&gt;</span>
<span class="nc" id="L224">              val bound = Bound(Some(lit), inclusive = true)</span>
<span class="nc" id="L225">              FilterValues(Seq(Bounds(bound, bound)))</span>
            }

<span class="nc bnc" id="L228" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = true, binding)</span>
<span class="nc" id="L229">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">      case f: PropertyIsBetween =&gt;</span>
        try {
<span class="nc" id="L233">          val prop = f.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc bnc" id="L234" title="All 6 branches missed.">          if (prop != attribute) { FilterValues.empty } else {</span>
            // note that between is inclusive
<span class="nc" id="L236">            val lower = Bound(Option(FastConverter.evaluate(f.getLowerBoundary, binding)), inclusive = true)</span>
<span class="nc" id="L237">            val upper = Bound(Option(FastConverter.evaluate(f.getUpperBoundary, binding)), inclusive = true)</span>
<span class="nc" id="L238">            FilterValues(Seq(Bounds(lower, upper)))</span>
          }
        } catch {
          case e: Exception =&gt;
<span class="nc bnc" id="L242" title="All 2 branches missed.">            FilterHelperLogger.log.warn(s&quot;Unable to extract bounds from filter '${toString(f)}'&quot;, e)</span>
<span class="nc" id="L243">            FilterValues.empty</span>
        }

<span class="nc bnc" id="L246" title="All 4 branches missed.">      case f: During if classOf[Date].isAssignableFrom(binding) =&gt;</span>
<span class="nc bnc" id="L247" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L249">            Option(FastConverter.evaluate(e.literal, classOf[Period])).map { p =&gt;</span>
              // note that during is exclusive
<span class="nc" id="L251">              val lower = Bound(Option(p.getBeginning.getPosition.getDate.asInstanceOf[T]), inclusive = false)</span>
<span class="nc" id="L252">              val upper = Bound(Option(p.getEnding.getPosition.getDate.asInstanceOf[T]), inclusive = false)</span>
<span class="nc" id="L253">              FilterValues(Seq(Bounds(lower, upper)))</span>
            }

<span class="nc bnc" id="L256" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = false, binding)</span>
<span class="nc" id="L257">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">      case f: PropertyIsGreaterThan =&gt;</span>
<span class="nc bnc" id="L260" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L262">            Option(FastConverter.evaluate(e.literal, binding)).map { lit =&gt;</span>
<span class="nc" id="L263">              val bound = Bound(Some(lit), inclusive = false)</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">              val (lower, upper) = if (e.flipped) { (Bound.unbounded[T], bound) } else { (bound, Bound.unbounded[T]) }</span>
<span class="nc" id="L265">              FilterValues(Seq(Bounds(lower, upper)))</span>
            }

<span class="nc bnc" id="L268" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = false, binding)</span>
<span class="nc" id="L269">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L271" title="All 2 branches missed.">      case f: PropertyIsGreaterThanOrEqualTo =&gt;</span>
<span class="nc bnc" id="L272" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L274">            Option(FastConverter.evaluate(e.literal, binding)).map { lit =&gt;</span>
<span class="nc" id="L275">              val bound = Bound(Some(lit), inclusive = true)</span>
<span class="nc bnc" id="L276" title="All 4 branches missed.">              val (lower, upper) = if (e.flipped) { (Bound.unbounded[T], bound) } else { (bound, Bound.unbounded[T]) }</span>
<span class="nc" id="L277">              FilterValues(Seq(Bounds(lower, upper)))</span>
            }

<span class="nc bnc" id="L280" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = true, binding)</span>
<span class="nc" id="L281">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">      case f: PropertyIsLessThan =&gt;</span>
<span class="nc bnc" id="L284" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L286">            Option(FastConverter.evaluate(e.literal, binding)).map { lit =&gt;</span>
<span class="nc" id="L287">              val bound = Bound(Some(lit), inclusive = false)</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">              val (lower, upper) = if (e.flipped) { (bound, Bound.unbounded[T]) } else { (Bound.unbounded[T], bound) }</span>
<span class="nc" id="L289">              FilterValues(Seq(Bounds(lower, upper)))</span>
            }

<span class="nc bnc" id="L292" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = false, binding)</span>
<span class="nc" id="L293">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">      case f: PropertyIsLessThanOrEqualTo =&gt;</span>
<span class="nc bnc" id="L296" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L298">            Option(FastConverter.evaluate(e.literal, binding)).map { lit =&gt;</span>
<span class="nc" id="L299">              val bound = Bound(Some(lit), inclusive = true)</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">              val (lower, upper) = if (e.flipped) { (bound, Bound.unbounded[T]) } else { (Bound.unbounded[T], bound) }</span>
<span class="nc" id="L301">              FilterValues(Seq(Bounds(lower, upper)))</span>
            }

<span class="nc bnc" id="L304" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = true, binding)</span>
<span class="nc" id="L305">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">      case f: Before =&gt;</span>
<span class="nc bnc" id="L308" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L310">            Option(FastConverter.evaluate(e.literal, binding)).map { lit =&gt;</span>
              // note that before is exclusive
<span class="nc" id="L312">              val bound = Bound(Some(lit), inclusive = false)</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">              val (lower, upper) = if (e.flipped) { (bound, Bound.unbounded[T]) } else { (Bound.unbounded[T], bound) }</span>
<span class="nc" id="L314">              FilterValues(Seq(Bounds(lower, upper)))</span>
            }

<span class="nc bnc" id="L317" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = false, binding)</span>
<span class="nc" id="L318">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L320" title="All 2 branches missed.">      case f: After =&gt;</span>
<span class="nc bnc" id="L321" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">          case e: PropertyLiteral =&gt;</span>
<span class="nc" id="L323">            Option(FastConverter.evaluate(e.literal, binding)).map { lit =&gt;</span>
              // note that after is exclusive
<span class="nc" id="L325">              val bound = Bound(Some(lit), inclusive = false)</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">              val (lower, upper) = if (e.flipped) { (Bound.unbounded[T], bound) } else { (bound, Bound.unbounded[T]) }</span>
<span class="nc" id="L327">              FilterValues(Seq(Bounds(lower, upper)))</span>
            }

<span class="nc bnc" id="L330" title="All 2 branches missed.">          case e: FunctionLiteral =&gt; extractFunctionBounds(e, inclusive = false, binding)</span>
<span class="nc" id="L331">        }.getOrElse(FilterValues.empty)</span>

<span class="nc bnc" id="L333" title="All 8 branches missed.">      case f: PropertyIsLike if binding == classOf[String] =&gt;</span>
        try {
<span class="nc" id="L335">          val prop = f.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc bnc" id="L336" title="All 6 branches missed.">          if (prop != attribute) { FilterValues.empty } else {</span>
            // find the first wildcard and create a range prefix
<span class="nc" id="L338">            val literal = f.getLiteral</span>
<span class="nc" id="L339">            var i = literal.indexWhere(Wildcards.contains)</span>
            // check for escaped wildcards
<span class="nc bnc" id="L341" title="All 6 branches missed.">            while (i &gt; 1 &amp;&amp; literal.charAt(i - 1) == '\\' &amp;&amp; literal.charAt(i - 2) == '\\') {</span>
<span class="nc" id="L342">              i = literal.indexWhere(Wildcards.contains, i + 1)</span>
            }
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (i == -1) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">              val literals = if (f.isMatchingCase) { Seq(literal) } else { casePermutations(literal) }</span>
<span class="nc" id="L346">              val bounds = literals.map { lit =&gt;</span>
<span class="nc" id="L347">                val bound = Bound(Some(lit), inclusive = true)</span>
<span class="nc" id="L348">                Bounds(bound, bound)</span>
              }
<span class="nc" id="L350">              FilterValues(bounds.asInstanceOf[Seq[Bounds[T]]], precise = true)</span>
            } else {
<span class="nc" id="L352">              val prefix = literal.substring(0, i)</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">              val prefixes = if (f.isMatchingCase) { Seq(prefix) } else { casePermutations(prefix) }</span>
<span class="nc" id="L354">              val bounds = prefixes.map { p =&gt;</span>
<span class="nc" id="L355">                Bounds(Bound(Some(p), inclusive = true), Bound(Some(p + WildcardSuffix), inclusive = true))</span>
              }
              // our ranges fully capture the filter if there's a single trailing multi-char wildcard
<span class="nc bnc" id="L358" title="All 4 branches missed.">              val exact = i == literal.length - 1 &amp;&amp; literal.charAt(i) == WildcardMultiChar</span>
<span class="nc" id="L359">              FilterValues(bounds.asInstanceOf[Seq[Bounds[T]]], precise = exact)</span>
            }
          }
        } catch {
          case e: Exception =&gt;
<span class="nc bnc" id="L364" title="All 2 branches missed.">            FilterHelperLogger.log.warn(s&quot;Unable to extract bounds from filter '${toString(f)}'&quot;, e)</span>
<span class="nc" id="L365">            FilterValues.empty</span>
        }

<span class="nc bnc" id="L368" title="All 4 branches missed.">      case f: Not if f.getFilter.isInstanceOf[PropertyIsNull] =&gt;</span>
        try {
<span class="nc" id="L370">          val isNull = f.getFilter.asInstanceOf[PropertyIsNull]</span>
<span class="nc" id="L371">          val prop = isNull.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc bnc" id="L372" title="All 6 branches missed.">          if (prop != attribute) { FilterValues.empty } else {</span>
<span class="nc" id="L373">            FilterValues(Seq(Bounds.everything[T]))</span>
          }
        } catch {
          case e: Exception =&gt;
<span class="nc bnc" id="L377" title="All 2 branches missed.">            FilterHelperLogger.log.warn(s&quot;Unable to extract bounds from filter '${toString(f)}'&quot;, e)</span>
<span class="nc" id="L378">            FilterValues.empty</span>
        }

<span class="nc bnc" id="L381" title="All 2 branches missed.">      case f: Not =&gt;</span>
        // we extract the sub-filter bounds, then invert them
<span class="nc" id="L383">        val inverted = extractAttributeBounds(f.getFilter, attribute, binding)</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (inverted.isEmpty) {</span>
<span class="nc" id="L385">          inverted</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        } else if (inverted.disjoint) {</span>
<span class="nc" id="L387">          FilterValues(Seq(Bounds.everything[T])) // equivalent to not null</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        } else if (!inverted.precise) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">          FilterHelperLogger.log.warn(s&quot;Falling back to full table scan for inverted query: '${toString(f)}'&quot;)</span>
<span class="nc" id="L390">          FilterValues(Seq(Bounds.everything[T]), precise = false)</span>
        } else {
          // NOT(A OR B) turns into NOT(A) AND NOT(B)
<span class="nc" id="L393">          val uninverted = inverted.values.map { bounds =&gt;</span>
            // NOT the single bound
<span class="nc bnc" id="L395" title="All 8 branches missed.">            val not = bounds.bounds match {</span>
<span class="nc bnc" id="L396" title="All 4 branches missed.">              case (None, None) =&gt; Seq.empty</span>
<span class="nc bnc" id="L397" title="All 6 branches missed.">              case (Some(lo), None) =&gt; Seq(Bounds(Bound.unbounded, Bound(Some(lo), !bounds.lower.inclusive)))</span>
<span class="nc bnc" id="L398" title="All 6 branches missed.">              case (None, Some(hi)) =&gt; Seq(Bounds(Bound(Some(hi), !bounds.upper.inclusive), Bound.unbounded))</span>
<span class="nc bnc" id="L399" title="All 4 branches missed.">              case (Some(lo), Some(hi)) =&gt; Seq(</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                  Bounds(Bound.unbounded, Bound(Some(lo), !bounds.lower.inclusive)),</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                  Bounds(Bound(Some(hi), !bounds.upper.inclusive), Bound.unbounded)</span>
                )
            }
<span class="nc" id="L404">            FilterValues(not)</span>
          }
          // AND together
<span class="nc" id="L407">          val intersect = FilterValues.and[Bounds[T]](Bounds.intersection[T]) _</span>
<span class="nc" id="L408">          uninverted.reduceLeft[FilterValues[Bounds[T]]](intersect)</span>
        }

<span class="nc bnc" id="L411" title="All 2 branches missed.">      case f: TEquals =&gt;</span>
<span class="nc bnc" id="L412" title="All 6 branches missed.">        checkOrder(f.getExpression1, f.getExpression2).filter(_.name == attribute).flatMap { prop =&gt;</span>
<span class="nc" id="L413">          Option(FastConverter.evaluate(prop.literal, binding)).map { lit =&gt;</span>
<span class="nc" id="L414">            val bound = Bound(Some(lit), inclusive = true)</span>
<span class="nc" id="L415">            FilterValues(Seq(Bounds(bound, bound)))</span>
          }
<span class="nc" id="L417">        }.getOrElse(FilterValues.empty)</span>

<span class="nc" id="L419">      case _ =&gt; FilterValues.empty</span>
    }
  }

  private def extractFunctionBounds[T](function: FunctionLiteral,
                                       inclusive: Boolean,
                                       binding: Class[T]): Option[FilterValues[Bounds[T]]] = {
    // TODO GEOMESA-1990 extract some meaningful bounds from the function
<span class="nc" id="L427">    Some(FilterValues(Seq(Bounds.everything[T]), precise = false))</span>
  }

  /**
   * Calculates all the different case permutations of a string.
   *
   * For example, &quot;foo&quot; -&gt; Seq(&quot;foo&quot;, &quot;Foo&quot;, &quot;fOo&quot;, &quot;foO&quot;, &quot;fOO&quot;, &quot;FoO&quot;, &quot;FOo&quot;, &quot;FOO&quot;)
   *
   * @param string input string
   * @return
   */
  private def casePermutations(string: String): Seq[String] = {
<span class="nc" id="L439">    val max = FilterProperties.CaseInsensitiveLimit.toInt.getOrElse {</span>
      // has a valid default value so should never return a none
<span class="nc" id="L441">      throw new IllegalStateException(</span>
<span class="nc" id="L442">        s&quot;Error getting default value for ${FilterProperties.CaseInsensitiveLimit.property}&quot;)</span>
    }

<span class="nc" id="L445">    val lower = string.toLowerCase(Locale.US)</span>
<span class="nc" id="L446">    val upper = string.toUpperCase(Locale.US)</span>
    // account for chars without upper/lower cases, which we don't need to permute
<span class="nc bnc" id="L448" title="All 2 branches missed.">    val count = (0 until lower.length).count(i =&gt; lower(i) != upper(i))</span>

<span class="nc bnc" id="L450" title="All 2 branches missed.">    if (count &gt; max) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">      FilterHelperLogger.log.warn(s&quot;Not expanding case-insensitive prefix due to length: $string&quot;)</span>
<span class="nc" id="L452">      Seq.empty</span>
    } else {
      // there will be 2^n different permutations, accounting for chars that don't have an upper/lower case
<span class="nc" id="L455">      val permutations = Array.fill(math.pow(2, count).toInt)(Array(lower: _*))</span>
<span class="nc" id="L456">      var i = 0 // track the index of the current char</span>
<span class="nc" id="L457">      var c = 0 // track the index of the bit check, which skips chars that don't have an upper/lower case</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">      while (i &lt; string.length) {</span>
<span class="nc" id="L459">        val upperChar = upper.charAt(i)</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (lower.charAt(i) != upperChar) {</span>
<span class="nc" id="L461">          var j = 0</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">          while (j &lt; permutations.length) {</span>
            // set upper/lower based on the bit
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (((j &gt;&gt; c) &amp; 1) != 0) {</span>
<span class="nc" id="L465">              permutations(j)(i) = upperChar</span>
            }
<span class="nc" id="L467">            j += 1</span>
          }
<span class="nc" id="L469">          c += 1</span>
        }
<span class="nc" id="L471">        i += 1</span>
      }

<span class="nc" id="L474">      permutations.map(new String(_))</span>
    }
  }

  /**
    * Extract property names from a filter. If a schema is available,
    * prefer `propertyNames(Filter, SimpleFeatureType)` as that will handle
    * things like default geometry bboxes
    *
    * @param filter filter
    * @return unique property names referenced in the filter, in sorted order
    */
<span class="nc" id="L486">  def propertyNames(filter: Filter): Seq[String] = propertyNames(filter, null)</span>

  /**
    * Extract property names from a filter
    *
    * @param filter filter
    * @param sft simple feature type
    * @return unique property names referenced in the filter, in sorted order
    */
  def propertyNames(filter: Filter, sft: SimpleFeatureType): Seq[String] =
<span class="nc" id="L496">    DataUtilities.attributeNames(filter, sft).toSeq.distinct.sorted</span>

  def propertyNames(expression: Expression, sft: SimpleFeatureType): Seq[String] =
<span class="nc" id="L499">    DataUtilities.attributeNames(expression, sft).toSeq.distinct.sorted</span>

  def hasIdFilter(filter: Filter): Boolean =
<span class="nc" id="L502">    filter.accept(new IdDetectingFilterVisitor, false).asInstanceOf[Boolean]</span>

<span class="nc" id="L504">  def filterListAsAnd(filters: Seq[Filter]): Option[Filter] = andOption(filters)</span>

<span class="nc" id="L506">  def filterListAsOr(filters: Seq[Filter]): Option[Filter] = orOption(filters)</span>

  /**
    * Simplifies filters to make them easier to process.
    *
    * Current simplifications:
    *
    *   1) Extracts out common parts in an OR clause to simplify further processing.
    *
    *      Example: OR(AND(1, 2), AND(1, 3), AND(1, 4)) -&gt; AND(1, OR(2, 3, 4))
    *
    *   2) N/A - add more simplifications here as needed
    *
    * @param filter filter
    * @return
    */
  def simplify(filter: Filter): Filter = {
<span class="nc" id="L523">    def deduplicateOrs(f: Filter): Filter = f match {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">      case and: And =&gt; ff.and(and.getChildren.asScala.map(deduplicateOrs).asJava)</span>

<span class="nc bnc" id="L526" title="All 2 branches missed.">      case or: Or =&gt;</span>
        // OR(AND(1,2,3), AND(1,2,4)) -&gt; Seq(Seq(1,2,3), Seq(1,2,4))
<span class="nc" id="L528">        val decomposed = or.getChildren.asScala.map(decomposeAnd)</span>
<span class="nc" id="L529">        val clauses = decomposed.head // Seq(1,2,3)</span>
<span class="nc" id="L530">        val duplicates = clauses.filter(c =&gt; decomposed.tail.forall(_.contains(c))) // Seq(1,2)</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (duplicates.isEmpty) { or } else {</span>
<span class="nc" id="L532">          val simplified = decomposed.flatMap(d =&gt; andOption(d.filterNot(duplicates.contains)))</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">          if (simplified.length &lt; decomposed.length) {</span>
            // the duplicated filters are an entire clause, so we can ignore the rest of the clauses
<span class="nc" id="L535">            andFilters(duplicates)</span>
          } else {
<span class="nc" id="L537">            andFilters(orOption(simplified.toSeq).toSeq ++ duplicates)</span>
          }
        }

<span class="nc" id="L541">      case _ =&gt; f</span>
    }
    // TODO GEOMESA-1533 simplify ANDs of ORs for DNF
<span class="nc" id="L544">    flatten(deduplicateOrs(flatten(filter)))</span>
  }

  /**
    * Flattens nested ands and ors.
    *
    * Example: AND(1, AND(2, 3)) -&gt; AND(1, 2, 3)
    *
    * @param filter filter
    * @return
    */
  def flatten(filter: Filter): Filter = {
<span class="nc" id="L556">    filter match {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">      case and: And  =&gt; ff.and(flattenAnd(and.getChildren.asScala.toSeq).asJava)</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">      case or: Or    =&gt; ff.or(flattenOr(or.getChildren.asScala.toSeq).asJava)</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">      case f: Filter =&gt; f</span>
    }
  }

  private [filter] def flattenAnd(filters: Seq[Filter]): ListBuffer[Filter] = {
<span class="nc" id="L564">    val remaining = ListBuffer.empty[Filter] ++ filters</span>
<span class="nc" id="L565">    val result = ListBuffer.empty[Filter]</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">    while (remaining.nonEmpty) {</span>
<span class="nc" id="L567">      remaining.remove(0) match {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        case f: And =&gt; remaining.appendAll(f.getChildren.asScala)</span>
<span class="nc" id="L569">        case f      =&gt; result.append(flatten(f))</span>
      }
    }
<span class="nc" id="L572">    result</span>
  }

  private [filter] def flattenOr(filters: Seq[Filter]): ListBuffer[Filter] = {
<span class="nc" id="L576">    val remaining = ListBuffer.empty[Filter] ++ filters</span>
<span class="nc" id="L577">    val result = ListBuffer.empty[Filter]</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">    while (remaining.nonEmpty) {</span>
<span class="nc" id="L579">      remaining.remove(0) match {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        case f: Or =&gt; remaining.appendAll(f.getChildren.asScala)</span>
<span class="nc" id="L581">        case f     =&gt; result.append(flatten(f))</span>
      }
    }
<span class="nc" id="L584">    result</span>
  }

<span class="nc" id="L587">  def toString(filter: Filter): String = Try(ECQL.toCQL(filter)).getOrElse(filter.toString)</span>

<span class="nc" id="L589">  private object SpatialOpOrder extends Enumeration {</span>
    type SpatialOpOrder = Value
<span class="nc" id="L591">    val PropertyFirst, LiteralFirst, AnyOrder = Value</span>
  }
<span class="nc" id="L593">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>