<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilterValues.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Filters and Functions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.filter</a> &gt; <span class="el_source">FilterValues.scala</span></div><h1>FilterValues.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.filter

import scala.collection.GenTraversableOnce

/**
  * Holds values extracted from a filter. Values may be empty, in which case nothing was extracted from
  * the filter. May be marked as 'disjoint', which means that mutually exclusive values were extracted
  * from the filter. This may be checked to short-circuit queries that will not result in any hits.
  *
  * @param values values extracted from the filter. If nothing was extracted, will be empty
  * @param precise values exactly match the filter, or may return false positives
  * @param disjoint mutually exclusive values were extracted, e.g. 'a &lt; 1 &amp;&amp; a &gt; 2'
  * @tparam T type parameter
  */
<span class="nc bnc" id="L23" title="All 28 branches missed.">case class FilterValues[+T](values: Seq[T], precise: Boolean = true, disjoint: Boolean = false) {</span>
<span class="nc" id="L24">  def map[U](f: T =&gt; U): FilterValues[U] = FilterValues(values.map(f), precise, disjoint)</span>
<span class="nc" id="L25">  def flatMap[U](f: T =&gt; GenTraversableOnce[U]): FilterValues[U] = FilterValues(values.flatMap(f), precise, disjoint)</span>
<span class="nc" id="L26">  def foreach[U](f: T =&gt; U): Unit = values.foreach(f)</span>
<span class="nc" id="L27">  def forall(p: T =&gt; Boolean): Boolean = values.forall(p)</span>
<span class="nc" id="L28">  def exists(p: T =&gt; Boolean): Boolean = values.exists(p)</span>
<span class="nc" id="L29">  def filter(f: T =&gt; Boolean): FilterValues[T] = FilterValues(values.filter(f), precise, disjoint)</span>
<span class="nc bnc" id="L30" title="All 4 branches missed.">  def nonEmpty: Boolean = values.nonEmpty || disjoint</span>
<span class="nc bnc" id="L31" title="All 2 branches missed.">  def isEmpty: Boolean = !nonEmpty</span>
}

<span class="nc" id="L34">object FilterValues {</span>

<span class="nc" id="L36">  def empty[T]: FilterValues[T] = FilterValues[T](Seq.empty)</span>

<span class="nc" id="L38">  def disjoint[T]: FilterValues[T] = FilterValues[T](Seq.empty, disjoint = true)</span>

  def or[T](join: (Seq[T], Seq[T]) =&gt; Seq[T])(left: FilterValues[T], right: FilterValues[T]): FilterValues[T] = {
<span class="nc bnc" id="L41" title="All 8 branches missed.">    (left.disjoint, right.disjoint) match {</span>
<span class="nc bnc" id="L42" title="All 8 branches missed.">      case (false, false) =&gt; FilterValues(join(left.values, right.values), left.precise &amp;&amp; right.precise)</span>
<span class="nc bnc" id="L43" title="All 4 branches missed.">      case (false, true)  =&gt; left</span>
<span class="nc bnc" id="L44" title="All 4 branches missed.">      case (true,  false) =&gt; right</span>
<span class="nc bnc" id="L45" title="All 4 branches missed.">      case (true,  true)  =&gt; FilterValues.disjoint</span>
    }
  }

  def and[T](intersect: (T, T) =&gt; Option[T])(left: FilterValues[T], right: FilterValues[T]): FilterValues[T] = {
<span class="nc bnc" id="L50" title="All 4 branches missed.">    if (left.disjoint || right.disjoint) {</span>
<span class="nc" id="L51">      FilterValues.disjoint</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">    } else if (left.isEmpty) {</span>
<span class="nc" id="L53">      right</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">    } else if (right.isEmpty) {</span>
<span class="nc" id="L55">      left</span>
    } else {
<span class="nc" id="L57">      val intersections = left.values.flatMap(v =&gt; right.values.flatMap(intersect(_, v)))</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">      if (intersections.isEmpty) {</span>
<span class="nc" id="L59">        FilterValues.disjoint</span>
      } else {
<span class="nc bnc" id="L61" title="All 4 branches missed.">        FilterValues(intersections.distinct, left.precise &amp;&amp; right.precise)</span>
      }
    }
  }
<span class="nc" id="L65">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>