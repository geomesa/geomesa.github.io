<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>package.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Filters and Functions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.filter</a> &gt; <span class="el_source">package.scala</span></div><h1>package.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa

import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter._
import org.geotools.api.filter.expression.{Expression, Function, Literal, PropertyName}
import org.geotools.api.filter.spatial._
import org.geotools.api.filter.temporal._
import org.geotools.data.DataUtilities
import org.geotools.factory.CommonFactoryFinder
import org.locationtech.geomesa.filter.expression.AttributeExpression
import org.locationtech.geomesa.filter.expression.AttributeExpression.{FunctionLiteral, PropertyLiteral}
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty

import scala.collection.JavaConverters._

<span class="nc" id="L24">package object filter {</span>

  // Claim: FilterFactory implementations seem to be thread-safe away from
  //  'namespace' and 'function' calls.
  // As such, we can get away with using a shared Filter Factory.
<span class="nc" id="L29">  implicit val ff: FilterFactory = CommonFactoryFinder.getFilterFactory</span>

<span class="nc" id="L31">  object FilterProperties {</span>
<span class="nc" id="L32">    val GeometryProcessing: SystemProperty = SystemProperty(&quot;geomesa.geometry.processing&quot;, &quot;spatial4j&quot;)</span>
    // 10 characters results in 1024 ranges
<span class="nc" id="L34">    val CaseInsensitiveLimit: SystemProperty = SystemProperty(&quot;geomesa.ilike.max.length&quot;, &quot;10&quot;)</span>
  }

  /**
   * This function rewrites a org.geotools.api.filter.Filter in terms of a top-level OR with children filters which
   * 1) do not contain further ORs, (i.e., ORs bubble up)
   * 2) only contain at most one AND which is at the top of their 'tree'
   *
   * Note that this further implies that NOTs have been 'pushed down' and do have not have ANDs nor ORs as children.
   *
   * In boolean logic, this form is called disjunctive normal form (DNF).
   *
   * @param filter An arbitrary filter.
   * @return       A filter in DNF (described above).
   */
<span class="nc" id="L49">  def rewriteFilterInDNF(filter: Filter)(implicit ff: FilterFactory): Filter = {</span>
<span class="nc" id="L50">    val ll = logicDistributionDNF(filter)</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">    if (ll.size == 1) {</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">      if (ll.head.size == 1) {</span>
<span class="nc" id="L53">        ll.head.head</span>
      } else {
<span class="nc" id="L55">        ff.and(ll.head.asJava)</span>
      }
    } else {
<span class="nc" id="L58">      val children = ll.map { l =&gt;</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        l.size match {</span>
<span class="nc" id="L60">          case 1 =&gt; l.head</span>
<span class="nc" id="L61">          case _ =&gt; ff.and(l.asJava)</span>
        }
      }
<span class="nc" id="L64">      ff.or(children.asJava)</span>
    }
  }

  /**
   *
   * @param x: An arbitrary @org.geotools.api.filter.Filter
   * @return   A List[ List[Filter] ] where the inner List of Filters are to be joined by
   *           Ands and the outer list combined by Ors.
   */
<span class="nc" id="L74">  private[filter] def logicDistributionDNF(x: Filter): List[List[Filter]] = x match {</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">    case or: Or  =&gt; or.getChildren.asScala.toList.flatMap(logicDistributionDNF)</span>

<span class="nc bnc" id="L77" title="All 2 branches missed.">    case and: And =&gt; and.getChildren.asScala.foldRight (List(List.empty[Filter])) {</span>
<span class="nc" id="L78">      (f, dnf) =&gt; for {</span>
<span class="nc" id="L79">        a &lt;- logicDistributionDNF (f)</span>
<span class="nc" id="L80">        b &lt;- dnf</span>
<span class="nc" id="L81">      } yield a ++ b</span>
    }

<span class="nc bnc" id="L84" title="All 2 branches missed.">    case not: Not =&gt;</span>
<span class="nc" id="L85">      not.getFilter match {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        case and: And =&gt; logicDistributionDNF(deMorgan(and))</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        case or:  Or =&gt; logicDistributionDNF(deMorgan(or))</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        case _: Filter =&gt; List(List(not))</span>
      }

<span class="nc bnc" id="L91" title="All 2 branches missed.">    case f: Filter =&gt; List(List(f))</span>
  }

  /**
   * This function rewrites a org.geotools.api.filter.Filter in terms of a top-level AND with children filters which
   * 1) do not contain further ANDs, (i.e., ANDs bubble up)
   * 2) only contain at most one OR which is at the top of their 'tree'
   *
   * Note that this further implies that NOTs have been 'pushed down' and do have not have ANDs nor ORs as children.
   *
   * In boolean logic, this form is called conjunctive normal form (CNF).
   *
   * The main use case for this function is to aid in splitting filters between a combination of a
   * GeoMesa data store and some other data store. This is done with the AndSplittingFilter class.
   * In the examples below, anything with &quot;XAttr&quot; is assumed to be a filter that CANNOT be answered
   * through GeoMesa. In having a filter split on the AND, the portion of the filter that GeoMesa
   * CAN answer will be applied in GeoMesa, returning a result set, and then the portion that GeoMesa CANNOT
   * answer will be applied on that result set.
   *
   * Examples:
   *  1. (
   *       (GmAttr ILIKE 'test')
   *       OR
   *       (date BETWEEN '2014-01-01T10:30:00.000Z' AND '2014-01-02T10:30:00.000Z')
   *     )
   *      AND
   *     (XAttr ILIKE = 'example')
   *
   *     Converting to CNF will allow easily splitting the filter on the AND into two children
   *      - one child is the &quot;GmAttr&quot; and &quot;date&quot; filters that can be answered with GeoMesa
   *      - one child is the &quot;XAttr&quot; filter that cannot be answered by GeoMesa
   *
   *      In this case, the GeoMesa child filter will be processed first, and then the &quot;XAttr&quot; filter will
   *    be processed on the GeoMesa result set to return a subset of the GeoMesa results.
   *
   *  2. (GmAttr ILIKE 'test')
   *      AND
   *          (
   *            (date BETWEEN '2014-01-01T10:30:00.000Z' AND '2014-01-02T10:30:00.000Z')
   *             OR
   *            (XAttr1 ILIKE = 'example1')
   *          )
   *      AND
   *     (XAttr2 ILIKE = 'example2')
   *
   *     Converting to CNF still allows easily splitting the filter on the AND into three children
   *      - one child is the &quot;GmAttr&quot; filter
   *      - one child is the &quot;date&quot; OR &quot;XAttr1&quot; filter
   *      - one child is the &quot;XAttr2&quot; filter
   *
   *      In this case, the &quot;GmAttr&quot; child will be processed first, returning a result set from GeoMesa
   *    called RS1. Then, RS1 will be further filtered with the &quot;date&quot; predicate that can be handled
   *    by GeoMesa, returning a subset of RS1 called SS1. The additional filter which cannot be answered
   *    by GeoMesa, &quot;XAttr1,&quot; will be applied to RS1 and return subset SS2. Finally, the final child,
   *    the &quot;XAttr2&quot; filter, which cannot be answered by GeoMesa, will be applied to both SS1 and SS2 to
   *    return SS3, a JOIN of SS1+SS2 filtered with &quot;XAttr2.&quot;
   *
   *  3. (GmAttr ILIKE 'test')
   *      OR
   *     (XAttr ILIKE = 'example')
   *
   *     This is the worst-case-scenario for a query that is answered through two data stores, both
   *     GeoMesa and some other store.
   *
   *     CNF converts this to:
   *      - one child of &quot;GmAttr&quot; OR &quot;XAttr&quot;
   *
   *      In this case, the &quot;GmAttr&quot; will return a result set, RS1. The reason this is the
   *    worst-case-scenario is because, to answer the &quot;XAttr&quot; portion of the query (which cannot be
   *    answered by GeoMesa), a &quot;Filter.INCLUDE&quot; A.K.A a full table scan (on Accumulo) A.K.A. every
   *    record in GeoMesa is necessary to find the results that satisfy the &quot;XAttr&quot; portion of the
   *    query. This will product result set RS2. The returned results will be a JOIN of RS1+RS2.
   *
   *
   * @param filter An arbitrary filter.
   * @return       A filter in CNF (described above).
   */
  def rewriteFilterInCNF(filter: Filter)(implicit ff: FilterFactory): Filter = {
<span class="nc" id="L169">    val ll = logicDistributionCNF(FilterHelper.simplify(filter))</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">    if (ll.size == 1) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      if (ll.head.size == 1) ll.head.head else ff.or(ll.head.asJava)</span>
    } else {
<span class="nc" id="L173">      val children = ll.map { l =&gt;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        l.size match {</span>
<span class="nc" id="L175">          case 1 =&gt; l.head</span>
<span class="nc" id="L176">          case _ =&gt; ff.or(l.asJava)</span>
        }
      }
<span class="nc" id="L179">      ff.and(children.asJava)</span>
    }
  }

  /**
   *
   * @param x: An arbitrary @org.geotools.api.filter.Filter
   * @return   A List[ List[Filter] ] where the inner List of Filters are to be joined by
   *           Ors and the outer list combined by Ands.
   */
<span class="nc" id="L189">  def logicDistributionCNF(x: Filter): List[List[Filter]] = x match {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">    case and: And =&gt; and.getChildren.asScala.toList.flatMap(logicDistributionCNF)</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">    case or: Or =&gt; or.getChildren.asScala.foldRight (List(List.empty[Filter])) {</span>
<span class="nc" id="L193">      (f, cnf) =&gt; for {</span>
<span class="nc" id="L194">        a &lt;- logicDistributionCNF(f)</span>
<span class="nc" id="L195">        b &lt;- cnf</span>
<span class="nc" id="L196">      } yield a ++ b</span>
    }

<span class="nc bnc" id="L199" title="All 2 branches missed.">    case not: Not =&gt;</span>
<span class="nc" id="L200">      not.getFilter match {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        case and: And =&gt; logicDistributionCNF(deMorgan(and))</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        case or:  Or =&gt; logicDistributionCNF(deMorgan(or))</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        case _: Filter =&gt; List(List(not))</span>
      }

<span class="nc bnc" id="L206" title="All 2 branches missed.">    case f: Filter =&gt; List(List(f))</span>
  }

  /**
   *  The input is a filter which had a Not applied to it.
   *  This function uses deMorgan's law to 'push the Not down'
   *   as well as cancel adjacent Nots.
   */
<span class="nc" id="L214">  private[filter] def deMorgan(f: Filter)(implicit ff: FilterFactory): Filter = f match {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    case and: And =&gt; ff.or(and.getChildren.asScala.map(a =&gt; ff.not(a).asInstanceOf[Filter]).asJava)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    case or:  Or  =&gt; ff.and(or.getChildren.asScala.map(a =&gt; ff.not(a).asInstanceOf[Filter]).asJava)</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">    case not: Not =&gt; not.getFilter</span>
  }

  type PartionedFilter = (Seq[Filter], Seq[Filter])

  // Takes a filter and returns a Seq of Geometric/Topological filters under it.
  //  As a note, currently, only 'good' filters are considered.
  //  The list of acceptable filters is defined by 'spatialFilters'
  //  The notion of 'good' here means *good* to handle to the STII.
  //  Of particular note, we should not give negations to the STII.
  def partitionSubFilters(filter: Filter, filterFilter: Filter =&gt; Boolean): PartionedFilter = {
<span class="nc" id="L228">    filter match {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      case a: And =&gt; decomposeAnd(a).partition(filterFilter)</span>
<span class="nc" id="L230">      case _      =&gt; Seq(filter).partition(filterFilter)</span>
    }
  }

  def partitionPrimarySpatials(filter: Filter, sft: SimpleFeatureType): PartionedFilter =
<span class="nc" id="L235">    partitionSubFilters(filter, isPrimarySpatialFilter(_, sft))</span>

  def partitionPrimarySpatials(filters: Seq[Filter], sft: SimpleFeatureType): PartionedFilter =
<span class="nc" id="L238">    filters.partition(isPrimarySpatialFilter(_, sft))</span>

  def partitionPrimaryTemporals(filters: Seq[Filter], sft: SimpleFeatureType): PartionedFilter = {
<span class="nc" id="L241">    val isTemporal = isPrimaryTemporalFilter(_: Filter, sft)</span>
<span class="nc" id="L242">    filters.partition(isTemporal)</span>
  }

<span class="nc" id="L245">  def partitionID(filter: Filter): (Seq[Filter], Seq[Filter]) = partitionSubFilters(filter, isIdFilter)</span>

<span class="nc" id="L247">  def isIdFilter(f: Filter): Boolean = f.isInstanceOf[Id]</span>

  def isPrimarySpatialFilter(filter: Filter, sft: SimpleFeatureType): Boolean = {
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
<span class="nc" id="L251">    val geom = sft.getGeomField</span>
<span class="nc" id="L252">    val primary = filter match {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">      case f: BinarySpatialOperator =&gt;</span>
<span class="nc" id="L254">        checkOrder(f.getExpression1, f.getExpression2)</span>
<span class="nc bnc" id="L255" title="All 10 branches missed.">            .exists(p =&gt; p.name == null || p.name.isEmpty || p.name == geom)</span>
<span class="nc" id="L256">      case _ =&gt; false</span>
    }
<span class="nc bnc" id="L258" title="All 4 branches missed.">    primary &amp;&amp; isSpatialFilter(filter)</span>
  }

  // Defines the topological predicates we like for use in the STII.
  def isSpatialFilter(f: Filter): Boolean = {
<span class="nc" id="L263">    f match {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">      case _: BBOX =&gt; true</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">      case _: DWithin =&gt; true</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">      case _: Contains =&gt; true</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      case _: Crosses =&gt; true</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      case _: Intersects =&gt; true</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      case _: Overlaps =&gt; true</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">      case _: Within =&gt; true</span>
<span class="nc" id="L271">      case _ =&gt; false        // Beyond, Disjoint, DWithin, Equals, Touches</span>
    }
  }

  // noinspection ExistsEquals
<span class="nc bnc" id="L276" title="All 6 branches missed.">  def isTemporalFilter(f: Filter, dtg: String): Boolean = getAttributeProperty(f).exists(_ == dtg)</span>

  def isPrimaryTemporalFilter(f: Filter, sft: SimpleFeatureType): Boolean = {
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
<span class="nc" id="L280">    sft.getDtgField.exists(isTemporalFilter(f, _))</span>
  }

  def getAttributeProperty(f: Filter): Option[String] = {
<span class="nc" id="L284">    f match {</span>
      // equals checks
<span class="nc bnc" id="L286" title="All 2 branches missed.">      case f: PropertyIsEqualTo =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">      case f: TEquals           =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>

      // like checks
<span class="nc bnc" id="L290" title="All 2 branches missed.">      case f: PropertyIsLike =&gt;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (likeEligible(f)) {</span>
<span class="nc" id="L292">          val prop = f.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc" id="L293">          Some(prop)</span>
        } else {
<span class="nc" id="L295">          None</span>
        }

      // range checks
<span class="nc bnc" id="L299" title="All 2 branches missed.">      case f: PropertyIsGreaterThan          =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">      case f: PropertyIsGreaterThanOrEqualTo =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">      case f: PropertyIsLessThan             =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">      case f: PropertyIsLessThanOrEqualTo    =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">      case f: PropertyIsBetween =&gt;</span>
<span class="nc" id="L304">        val prop = f.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">        val (left, right) = (f.getLowerBoundary, f.getUpperBoundary) match {</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">          case (l: Literal, r: Literal) =&gt; (l, r)</span>
<span class="nc" id="L307">          case _ =&gt; (null, null)</span>
        }
<span class="nc bnc" id="L309" title="All 4 branches missed.">        if (left != null &amp;&amp; right != null) {</span>
<span class="nc" id="L310">          Some(prop)</span>
        } else {
<span class="nc" id="L312">          None</span>
        }

      // date range checks
<span class="nc bnc" id="L316" title="All 2 branches missed.">      case f: Before =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">      case f: After  =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">      case f: During =&gt; checkOrder(f.getExpression1, f.getExpression2).map(_.name)</span>

      // not check - we only support 'not null' for an indexed attribute
<span class="nc bnc" id="L321" title="All 2 branches missed.">      case n: Not =&gt;</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">        Option(n.getFilter).collect { case f: PropertyIsNull =&gt; f }.map { f =&gt;</span>
<span class="nc" id="L323">          f.getExpression.asInstanceOf[PropertyName].getPropertyName</span>
        }

<span class="nc" id="L326">      case _ =&gt; None</span>
    }
  }

<span class="nc" id="L330">  val WildcardMultiChar = '%'</span>
<span class="nc" id="L331">  val WildcardSingleChar = '_'</span>
<span class="nc" id="L332">  val Wildcards = Seq(WildcardMultiChar, WildcardSingleChar)</span>

<span class="nc" id="L334">  val WildcardSuffix = &quot;\uffff\uffff\uffff&quot;</span>

  /**
    * Like queries we can handle with our current index
    *
    * @param filter filter
    * @return
    */
  def likeEligible(filter: PropertyIsLike): Boolean = {
<span class="nc" id="L343">    val lit = filter.getLiteral</span>
    // no leading wildcard (otherwise it's a full table scan)
<span class="nc bnc" id="L345" title="All 4 branches missed.">    lit.nonEmpty &amp;&amp; !Wildcards.contains(lit.charAt(0))</span>
  }

  def decomposeBinary(f: Filter): Seq[Filter] =
<span class="nc" id="L349">    f match {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">      case b: BinaryLogicOperator =&gt; b.getChildren.asScala.toSeq.flatMap(decomposeBinary)</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">      case f: Filter =&gt; Seq(f)</span>
    }

  def decomposeAnd(f: Filter): Seq[Filter] =
<span class="nc" id="L355">    f match {</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">      case b: And =&gt; b.getChildren.asScala.toSeq.flatMap(decomposeAnd)</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">      case f: Filter =&gt; Seq(f)</span>
    }

  def decomposeOr(f: Filter): Seq[Filter] =
<span class="nc" id="L361">    f match {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">      case b: Or =&gt; b.getChildren.asScala.toSeq.flatMap(decomposeOr)</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">      case f: Filter =&gt; Seq(f)</span>
    }

<span class="nc" id="L366">  def orFilters(filters: Seq[Filter])(implicit ff: FilterFactory = ff): Filter =</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">    if (filters.lengthCompare(1) == 0) { filters.head } else { ff.or(filters.asJava) }</span>

<span class="nc" id="L369">  def andFilters(filters: Seq[Filter])(implicit ff: FilterFactory = ff): Filter =</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if (filters.lengthCompare(1) == 0) { filters.head } else { ff.and(filters.asJava) }</span>

<span class="nc" id="L372">  def orOption(filters: Seq[Filter])(implicit ff: FilterFactory = ff): Option[Filter] =</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">    if (filters.lengthCompare(2) &lt; 0) { filters.headOption } else { Some(ff.or(filters.asJava)) }</span>

<span class="nc" id="L375">  def andOption(filters: Seq[Filter])(implicit ff: FilterFactory = ff): Option[Filter] =</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">    if (filters.lengthCompare(2) &lt; 0) { filters.headOption } else { Some(ff.and(filters.asJava)) }</span>

  def mergeFilters(f1: Filter, f2: Filter): Filter = {
<span class="nc bnc" id="L379" title="All 6 branches missed.">    if (f1 == Filter.INCLUDE) {</span>
<span class="nc" id="L380">      f2</span>
<span class="nc bnc" id="L381" title="All 6 branches missed.">    } else if (f2 == Filter.INCLUDE) {</span>
<span class="nc" id="L382">      f1</span>
<span class="nc bnc" id="L383" title="All 6 branches missed.">    } else if (f1 == f2) {</span>
<span class="nc" id="L384">      f1</span>
    } else {
<span class="nc" id="L386">      ff.and(f1, f2)</span>
    }
  }

  /**
   * Checks the order of properties and literals in the expression
   *
   * @param one first expression
   * @param two second expression
   * @return (prop, literal, whether the order was flipped)
   */
  def checkOrder(one: Expression, two: Expression): Option[AttributeExpression] = {
<span class="nc bnc" id="L398" title="All 14 branches missed.">    (one, two) match {</span>
<span class="nc bnc" id="L399" title="All 4 branches missed.">      case (p: PropertyName, l: Literal) =&gt; Some(PropertyLiteral(p.getPropertyName, l, flipped = false))</span>
<span class="nc bnc" id="L400" title="All 4 branches missed.">      case (l: Literal, p: PropertyName) =&gt; Some(PropertyLiteral(p.getPropertyName, l, flipped = true))</span>
<span class="nc bnc" id="L401" title="All 4 branches missed.">      case (f: Function, l: Literal)     =&gt; attribute(f).map(FunctionLiteral(_, f, l, flipped = false))</span>
<span class="nc bnc" id="L402" title="All 4 branches missed.">      case (l: Literal, f: Function)     =&gt; attribute(f).map(FunctionLiteral(_, f, l, flipped = true))</span>

<span class="nc bnc" id="L404" title="All 6 branches missed.">      case (p: PropertyName, f: Function) if attribute(f).isEmpty =&gt;</span>
<span class="nc" id="L405">        Some(PropertyLiteral(p.getPropertyName, ff.literal(f.evaluate(null)), flipped = false))</span>

<span class="nc bnc" id="L407" title="All 6 branches missed.">      case (f: Function, p: PropertyName) if attribute(f).isEmpty =&gt;</span>
<span class="nc" id="L408">        Some(PropertyLiteral(p.getPropertyName, ff.literal(f.evaluate(null)), flipped = true))</span>

<span class="nc bnc" id="L410" title="All 4 branches missed.">      case (f1: Function, f2: Function) =&gt;</span>
<span class="nc bnc" id="L411" title="All 4 branches missed.">        (attribute(f1), attribute(f2)) match {</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">          case (Some(a), None) =&gt; Some(FunctionLiteral(a, f1, ff.literal(f2.evaluate(null)), flipped = false))</span>
<span class="nc bnc" id="L413" title="All 4 branches missed.">          case (None, Some(a)) =&gt; Some(FunctionLiteral(a, f2, ff.literal(f1.evaluate(null)), flipped = true))</span>
<span class="nc" id="L414">          case _ =&gt; None</span>
        }

<span class="nc" id="L417">      case _ =&gt; None</span>
    }
  }

  /**
   * Checks the order of properties and literals in the expression - if the expression does not contain
   * a property and a literal, throws an exception.
   *
   * @param one first expression
    * @param two second expression
    * @return (prop, literal, whether the order was flipped)
   */
  def checkOrderUnsafe(one: Expression, two: Expression): AttributeExpression = {
<span class="nc" id="L430">    checkOrder(one, two).getOrElse {</span>
<span class="nc" id="L431">      throw new RuntimeException(s&quot;Expressions did not contain valid property and literal: $one, $two&quot;)</span>
    }
  }

  private def attribute(f: Function): Option[String] =
<span class="nc bnc" id="L436" title="All 4 branches missed.">    f.getParameters.asScala.map(DataUtilities.attributeNames(_).headOption).collectFirst { case Some(p) =&gt; p }</span>
<span class="nc" id="L437">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>