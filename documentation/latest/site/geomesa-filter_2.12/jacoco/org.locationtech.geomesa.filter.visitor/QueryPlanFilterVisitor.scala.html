<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryPlanFilterVisitor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Filters and Functions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.filter.visitor</a> &gt; <span class="el_source">QueryPlanFilterVisitor.scala</span></div><h1>QueryPlanFilterVisitor.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.filter.visitor

import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter._
import org.geotools.api.filter.expression._
import org.geotools.api.filter.spatial._
import org.geotools.api.filter.temporal._
import org.geotools.api.temporal.Period
import org.geotools.filter.LikeToRegexConverter
import org.geotools.filter.function.InArrayFunction
import org.geotools.filter.visitor.{DuplicatingFilterVisitor, ExpressionTypeVisitor, IsStaticExpressionVisitor}
import org.locationtech.geomesa.filter.{FilterHelper, GeometryProcessing}
import org.locationtech.geomesa.utils.geotools.converters.FastConverter

import java.util
import java.util.regex.Pattern
import java.util.{Collections, Date}
import scala.util.{Success, Try}

/**
  * Updates filters to handle namespaces, default property names, IDL, dwithin units,
  * type binding, and to remove filters that aren't meaningful
  */
<span class="nc" id="L33">protected class QueryPlanFilterVisitor(sft: SimpleFeatureType) extends DuplicatingFilterVisitor {</span>

  import FilterHelper.isFilterWholeWorld
  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  import scala.collection.JavaConverters._

<span class="nc bnc" id="L40" title="All 2 branches missed.">  private val typeVisitor = new ExpressionTypeVisitor(sft) {</span>
    override def visit(expression: PropertyName, extraData: AnyRef): AnyRef = {
<span class="nc" id="L42">      val descriptor = expression.evaluate(sft, classOf[AttributeDescriptor])</span>
      // json attributes can return anything due to json path evaluation, so to avoid binding incorrectly
      // we return classOf[Object] here
      // we have to re-fetch the original descriptor as the json property accessor strips out the json flag
      // to prevent transform serialization issues
<span class="nc bnc" id="L47" title="All 4 branches missed.">      if (descriptor == null || sft.getDescriptor(descriptor.getLocalName).isJson) {</span>
<span class="nc" id="L48">        classOf[Object]</span>
      } else {
<span class="nc" id="L50">        descriptor.getType.getBinding</span>
      }
    }
  }

  override def visit(f: Or, data: AnyRef): AnyRef = {
<span class="nc" id="L56">    val children = new java.util.ArrayList[Filter](f.getChildren.size)</span>
<span class="nc" id="L57">    var i = 0</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">    while (i &lt; f.getChildren.size) {</span>
<span class="nc" id="L59">      val child = f.getChildren.get(i).accept(this, data).asInstanceOf[Filter]</span>
<span class="nc bnc" id="L60" title="All 6 branches missed.">      if (child == Filter.INCLUDE) {</span>
        // INCLUDE OR foo == INCLUDE
<span class="nc" id="L62">        return Filter.INCLUDE</span>
<span class="nc bnc" id="L63" title="All 6 branches missed.">      } else if (child != Filter.EXCLUDE) {</span>
        // EXCLUDE OR foo == foo
<span class="nc" id="L65">        children.add(child)</span>
      }
<span class="nc" id="L67">      i += 1</span>
    }

<span class="nc bnc" id="L70" title="All 3 branches missed.">    children.size() match {</span>
<span class="nc" id="L71">      case 0 =&gt; Filter.EXCLUDE</span>
<span class="nc" id="L72">      case 1 =&gt; children.get(0)</span>
<span class="nc" id="L73">      case _ =&gt; getFactory(data).or(children)</span>
    }
  }

  override def visit(f: And, data: AnyRef): AnyRef = {
<span class="nc" id="L78">    val children = new java.util.ArrayList[Filter](f.getChildren.size)</span>
<span class="nc" id="L79">    var i = 0</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">    while (i &lt; f.getChildren.size) {</span>
<span class="nc" id="L81">      val child = f.getChildren.get(i).accept(this, data).asInstanceOf[Filter]</span>
<span class="nc bnc" id="L82" title="All 6 branches missed.">      if (child == Filter.EXCLUDE) {</span>
        // EXCLUDE AND foo == EXCLUDE
<span class="nc" id="L84">        return Filter.EXCLUDE</span>
<span class="nc bnc" id="L85" title="All 6 branches missed.">      } else if (child != Filter.INCLUDE) {</span>
        // INCLUDE AND foo == foo
<span class="nc" id="L87">        children.add(child)</span>
      }
<span class="nc" id="L89">      i += 1</span>
    }
<span class="nc bnc" id="L91" title="All 3 branches missed.">    children.size() match {</span>
<span class="nc" id="L92">      case 0 =&gt; Filter.INCLUDE</span>
<span class="nc" id="L93">      case 1 =&gt; children.get(0)</span>
<span class="nc" id="L94">      case _ =&gt; getFactory(data).and(children)</span>
    }
  }

  // note: for the following filters, we call super.visit first to handle any property names

  override def visit(f: DWithin, data: AnyRef): AnyRef =
<span class="nc bnc" id="L101" title="All 2 branches missed.">    if (isFilterWholeWorld(f)) { Filter.INCLUDE } else {</span>
<span class="nc" id="L102">      GeometryProcessing.process(super.visit(f, data).asInstanceOf[BinarySpatialOperator], sft, getFactory(data))</span>
    }

  override def visit(f: BBOX, data: AnyRef): AnyRef =
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if (isFilterWholeWorld(f)) { Filter.INCLUDE } else {</span>
<span class="nc" id="L107">      GeometryProcessing.process(super.visit(f, data).asInstanceOf[BinarySpatialOperator], sft, getFactory(data))</span>
    }

  override def visit(f: Within, data: AnyRef): AnyRef =
<span class="nc bnc" id="L111" title="All 2 branches missed.">    if (isFilterWholeWorld(f)) { Filter.INCLUDE } else {</span>
<span class="nc" id="L112">      GeometryProcessing.process(super.visit(f, data).asInstanceOf[BinarySpatialOperator], sft, getFactory(data))</span>
    }

  override def visit(f: Intersects, data: AnyRef): AnyRef =
<span class="nc bnc" id="L116" title="All 2 branches missed.">    if (isFilterWholeWorld(f)) { Filter.INCLUDE } else {</span>
<span class="nc" id="L117">      GeometryProcessing.process(super.visit(f, data).asInstanceOf[BinarySpatialOperator], sft, getFactory(data))</span>
    }

  override def visit(f: Overlaps, data: AnyRef): AnyRef =
<span class="nc bnc" id="L121" title="All 2 branches missed.">    if (isFilterWholeWorld(f)) { Filter.INCLUDE } else {</span>
<span class="nc" id="L122">      GeometryProcessing.process(super.visit(f, data).asInstanceOf[BinarySpatialOperator], sft, getFactory(data))</span>
    }

  override def visit(f: Contains, data: AnyRef): AnyRef =
<span class="nc bnc" id="L126" title="All 2 branches missed.">    if (isFilterWholeWorld(f)) { Filter.INCLUDE } else {</span>
<span class="nc" id="L127">      GeometryProcessing.process(super.visit(f, data).asInstanceOf[BinarySpatialOperator], sft, getFactory(data))</span>
    }
  
  override def visit(expression: PropertyName, extraData: AnyRef): AnyRef = {
<span class="nc" id="L131">    val name = expression.getPropertyName</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">    if (name == null || name.isEmpty) {</span>
      // use the default geometry name
<span class="nc" id="L134">      val geomName = sft.getGeometryDescriptor.getLocalName</span>
<span class="nc" id="L135">      getFactory(extraData).property(geomName, expression.getNamespaceContext)</span>
    } else {
<span class="nc" id="L137">      val index = name.indexOf(':')</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">      if (index == -1) {</span>
<span class="nc" id="L139">        getFactory(extraData).property(name)</span>
      } else {
        // strip off the namespace
<span class="nc" id="L142">        getFactory(extraData).property(name.substring(index + 1), expression.getNamespaceContext)</span>
      }
    }
  }

  private def handleInArrayEquals(filter: PropertyIsEqualTo, extraData: AnyRef): Option[Filter] = {
<span class="nc" id="L148">    var inArrayFunction: InArrayFunction = null</span>
<span class="nc" id="L149">    var hasTrue: Boolean = false</span>

    def inspectExpression(expression: Expression, extraData: AnyRef): Unit = {
<span class="nc" id="L152">      expression match {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        case function: InArrayFunction =&gt;</span>
<span class="nc" id="L154">          inArrayFunction = function</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">        case literal: Literal if java.lang.Boolean.TRUE.equals(literal.getValue) =&gt;</span>
<span class="nc" id="L156">          hasTrue = true</span>
<span class="nc" id="L157">        case _ =&gt;</span>
      }
    }

<span class="nc" id="L161">    inspectExpression(filter.getExpression1, extraData)</span>
<span class="nc" id="L162">    inspectExpression(filter.getExpression2, extraData)</span>

<span class="nc bnc" id="L164" title="All 4 branches missed.">    if (inArrayFunction != null &amp;&amp; hasTrue) {</span>
<span class="nc" id="L165">      val attribute = inArrayFunction.getParameters.get(0)</span>
<span class="nc" id="L166">      val array = inArrayFunction.getParameters.get(1)</span>
      import scala.collection.JavaConverters._
      // The important part of this optimization is to handle ArrayLists generated by the
      // GeoServer cross-layer querylayer extension:  E.g.
      // https://github.com/geoserver/geoserver/blob/2.17.3/src/extension/querylayer/src/main/java/org/geoserver/filter/function/QueryFunction.java#L124-L151
<span class="nc" id="L171">      val filters = array.evaluate(null).asInstanceOf[util.List[_]].asScala.toSet[Any].map {</span>
<span class="nc" id="L172">        o =&gt; getFactory(extraData).equals(attribute, getFactory(extraData).literal(o)).asInstanceOf[Filter]</span>
      }.toList
<span class="nc" id="L174">      val newFilter = getFactory(extraData).or(filters.asJava)</span>
<span class="nc" id="L175">      Some(newFilter)</span>
    } else {
<span class="nc" id="L177">      None</span>
    }
  }

  override def visit(filter: PropertyIsEqualTo, extraData: AnyRef): AnyRef = {
<span class="nc" id="L182">    handleInArrayEquals(filter, extraData) match {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      case Some(newFilter) =&gt;</span>
<span class="nc" id="L184">        newFilter</span>
      case _ =&gt;
<span class="nc" id="L186">        val target = binding(Seq(filter.getExpression1, filter.getExpression2))</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L188">          super.visit(filter, extraData)</span>
        } else {
<span class="nc" id="L190">          val e1 = bind(filter.getExpression1, extraData, target)</span>
<span class="nc" id="L191">          val e2 = bind(filter.getExpression2, extraData, target)</span>
<span class="nc" id="L192">          getFactory(extraData).equal(e1, e2, filter.isMatchingCase, filter.getMatchAction)</span>
        }
    }
  }

  override def visit(filter: PropertyIsNotEqualTo, extraData: AnyRef): AnyRef = {
<span class="nc" id="L198">    val target = binding(Seq(filter.getExpression1, filter.getExpression2))</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    if (target == null) { super.visit(filter, extraData) } else {</span>
<span class="nc" id="L200">      val e1 = bind(filter.getExpression1, extraData, target)</span>
<span class="nc" id="L201">      val e2 = bind(filter.getExpression2, extraData, target)</span>
<span class="nc" id="L202">      getFactory(extraData).notEqual(e1, e2, filter.isMatchingCase, filter.getMatchAction)</span>
    }
  }

  override def visit(filter: PropertyIsBetween, extraData: AnyRef): AnyRef = {
<span class="nc" id="L207">    val target = binding(Seq(filter.getExpression, filter.getLowerBoundary, filter.getUpperBoundary))</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">    if (target == null) { super.visit(filter, extraData) } else {</span>
<span class="nc" id="L209">      val e = bind(filter.getExpression, extraData, target)</span>
<span class="nc" id="L210">      val lb = bind(filter.getLowerBoundary, extraData, target)</span>
<span class="nc" id="L211">      val ub = bind(filter.getUpperBoundary, extraData, target)</span>
<span class="nc" id="L212">      getFactory(extraData).between(e, lb, ub, filter.getMatchAction)</span>
    }
  }

  override def visit(filter: PropertyIsGreaterThan, extraData: AnyRef): AnyRef = {
<span class="nc" id="L217">    val target = binding(Seq(filter.getExpression1, filter.getExpression2))</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (target == null) { super.visit(filter, extraData) } else {</span>
<span class="nc" id="L219">      val e1 = bind(filter.getExpression1, extraData, target)</span>
<span class="nc" id="L220">      val e2 = bind(filter.getExpression2, extraData, target)</span>
<span class="nc" id="L221">      getFactory(extraData).greater(e1, e2, filter.isMatchingCase, filter.getMatchAction)</span>
    }
  }

  override def visit(filter: PropertyIsGreaterThanOrEqualTo, extraData: AnyRef): AnyRef = {
<span class="nc" id="L226">    val target = binding(Seq(filter.getExpression1, filter.getExpression2))</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    if (target == null) { super.visit(filter, extraData) } else {</span>
<span class="nc" id="L228">      val e1 = bind(filter.getExpression1, extraData, target)</span>
<span class="nc" id="L229">      val e2 = bind(filter.getExpression2, extraData, target)</span>
<span class="nc" id="L230">      getFactory(extraData).greaterOrEqual(e1, e2, filter.isMatchingCase, filter.getMatchAction)</span>
    }
  }

  override def visit(filter: PropertyIsLessThan, extraData: AnyRef): AnyRef = {
<span class="nc" id="L235">    val target = binding(Seq(filter.getExpression1, filter.getExpression2))</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">    if (target == null) { super.visit(filter, extraData) } else {</span>
<span class="nc" id="L237">      val e1 = bind(filter.getExpression1, extraData, target)</span>
<span class="nc" id="L238">      val e2 = bind(filter.getExpression2, extraData, target)</span>
<span class="nc" id="L239">      getFactory(extraData).less(e1, e2, filter.isMatchingCase, filter.getMatchAction)</span>
    }
  }

  override def visit(filter: PropertyIsLessThanOrEqualTo, extraData: AnyRef): AnyRef = {
<span class="nc" id="L244">    val target = binding(Seq(filter.getExpression1, filter.getExpression2))</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">    if (target == null) { super.visit(filter, extraData) } else {</span>
<span class="nc" id="L246">      val e1 = bind(filter.getExpression1, extraData, target)</span>
<span class="nc" id="L247">      val e2 = bind(filter.getExpression2, extraData, target)</span>
<span class="nc" id="L248">      getFactory(extraData).lessOrEqual(e1, e2, filter.isMatchingCase, filter.getMatchAction)</span>
    }
  }

  override def visit(filter: After, extraData: AnyRef): AnyRef = {
<span class="nc" id="L253">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L254">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L255">    getFactory(extraData).after(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: AnyInteracts, extraData: AnyRef): AnyRef = {
<span class="nc" id="L259">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L260">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L261">    getFactory(extraData).anyInteracts(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: Before, extraData: AnyRef): AnyRef = {
<span class="nc" id="L265">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L266">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L267">    getFactory(extraData).before(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: Begins, extraData: AnyRef): AnyRef = {
<span class="nc" id="L271">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L272">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L273">    getFactory(extraData).begins(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: BegunBy, extraData: AnyRef): AnyRef = {
<span class="nc" id="L277">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L278">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L279">    getFactory(extraData).begins(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: During, extraData: AnyRef): AnyRef = {
<span class="nc" id="L283">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L284">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L285">    getFactory(extraData).during(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: EndedBy, extraData: AnyRef): AnyRef = {
<span class="nc" id="L289">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L290">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L291">    getFactory(extraData).endedBy(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: Ends, extraData: AnyRef): AnyRef = {
<span class="nc" id="L295">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L296">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L297">    getFactory(extraData).ends(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: Meets, extraData: AnyRef): AnyRef = {
<span class="nc" id="L301">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L302">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L303">    getFactory(extraData).meets(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: MetBy, extraData: AnyRef): AnyRef = {
<span class="nc" id="L307">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L308">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L309">    getFactory(extraData).metBy(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: OverlappedBy, extraData: AnyRef): AnyRef = {
<span class="nc" id="L313">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L314">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L315">    getFactory(extraData).overlappedBy(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: TContains, extraData: AnyRef): AnyRef = {
<span class="nc" id="L319">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L320">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L321">    getFactory(extraData).tcontains(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: TEquals, extraData: AnyRef): AnyRef = {
<span class="nc" id="L325">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L326">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L327">    getFactory(extraData).tequals(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(filter: TOverlaps, extraData: AnyRef): AnyRef = {
<span class="nc" id="L331">    val e1 = bindTemporal(filter.getExpression1, extraData)</span>
<span class="nc" id="L332">    val e2 = bindTemporal(filter.getExpression2, extraData)</span>
<span class="nc" id="L333">    getFactory(extraData).toverlaps(e1, e2, filter.getMatchAction)</span>
  }

  override def visit(function: Function, extraData: AnyRef): AnyRef = {
<span class="nc" id="L337">    val types = Option(function.getFunctionName).map(_.getArguments.iterator).getOrElse(Collections.emptyIterator())</span>
<span class="nc" id="L338">    val params = function.getParameters.asScala.map { parameter =&gt;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">      if (types.hasNext) {</span>
<span class="nc" id="L340">        bind(parameter, extraData, types.next.getType)</span>
      } else {
<span class="nc" id="L342">        visit(parameter, extraData)</span>
      }
    }.toSeq

<span class="nc" id="L346">    function match {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">      case f: InternalFunction =&gt; f.duplicate(params: _*)</span>
<span class="nc" id="L348">      case f =&gt; getFactory(extraData).function(f.getName, params: _*)</span>
    }
  }

  override protected def visit(expression: Expression, extraData: AnyRef): Expression = {
<span class="nc bnc" id="L353" title="All 2 branches missed.">    if (expression.accept(IsStaticExpressionVisitor.VISITOR, null).asInstanceOf[Boolean]) {</span>
<span class="nc" id="L354">      Try(expression.evaluate(null)) match {</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">        case Success(lit) if lit != null =&gt; getFactory(extraData).literal(lit)</span>
<span class="nc" id="L356">        case _ =&gt; super.visit(expression, extraData)</span>
      }
    } else {
<span class="nc" id="L359">      super.visit(expression, extraData)</span>
    }
  }

  override def visit(filter: PropertyIsLike, extraData: Any): AnyRef = {
    try {
<span class="nc" id="L365">      val pattern = new LikeToRegexConverter(filter).getPattern</span>
<span class="nc" id="L366">      Pattern.compile(pattern)</span>
    } catch {
      case e: Exception =&gt;
<span class="nc" id="L369">        throw new IllegalArgumentException(s&quot;The regex filter (${filter.getLiteral}) for the (i)like filter is invalid.&quot;, e)</span>
    }
<span class="nc" id="L371">    super.visit(filter, extraData)</span>
  }

  private def binding(expressions: Seq[Expression]): Class[_] = {
<span class="nc" id="L375">    val bindings = expressions.flatMap {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">      case _: Literal =&gt; Seq.empty // don't consider literals, as we're trying to bind them to the right type</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">      case e =&gt; Seq(e.accept(typeVisitor, null)).filter(_ != null)</span>
    }
<span class="nc" id="L379">    bindings.distinct match {</span>
<span class="nc bnc" id="L380" title="All 6 branches missed.">      case Seq(b) =&gt; b.asInstanceOf[Class[_]]</span>
<span class="nc" id="L381">      case _ =&gt; null // if not exactly one type, we can't bind it</span>
    }
  }

  private def bind(e: Expression, extraData: AnyRef, target: Class[_]): Expression = {
<span class="nc bnc" id="L386" title="All 2 branches missed.">    if (e.isInstanceOf[Literal]) {</span>
<span class="nc" id="L387">      val bound = FastConverter.convert(e.evaluate(null), target)</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">      if (bound != null) {</span>
<span class="nc" id="L389">        return getFactory(extraData).literal(bound)</span>
      }
    }
<span class="nc" id="L392">    visit(e, extraData)</span>
  }

  private def bindTemporal(e: Expression, extraData: AnyRef): Expression = {
<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (e.isInstanceOf[Literal]) {</span>
<span class="nc" id="L397">      val lit = e.evaluate(null)</span>
<span class="nc" id="L398">      val bound = FastConverter.convertFirst[AnyRef](lit, Iterator(classOf[Period], classOf[Date]))</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">      if (bound != null) {</span>
<span class="nc" id="L400">        return getFactory(extraData).literal(bound)</span>
      }
    }
<span class="nc" id="L403">    visit(e, extraData)</span>
  }
}

<span class="nc" id="L407">object QueryPlanFilterVisitor {</span>
<span class="nc" id="L408">  def apply(sft: SimpleFeatureType, filter: Filter, filterFactory: FilterFactory = null): Filter = {</span>
    // Simplify the filter first to avoid leaning trees patterns causing StackOverflows
<span class="nc" id="L410">    FilterHelper.simplify(filter).accept(new QueryPlanFilterVisitor(sft), filterFactory).asInstanceOf[Filter]</span>
  }
<span class="nc" id="L412">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>