<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FastFilterFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Filters and Functions</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.filter.factory</a> &gt; <span class="el_source">FastFilterFactory.scala</span></div><h1>FastFilterFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.filter.factory

import org.geotools.api.feature.`type`.Name
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.MultiValuedFilter.MatchAction
import org.geotools.api.filter._
import org.geotools.api.filter.expression.{Expression, PropertyName}
import org.geotools.api.filter.spatial.DWithin
import org.geotools.api.filter.temporal.{After, Before, During}
import org.geotools.feature.simple.SimpleFeatureBuilder
import org.geotools.filter.text.ecql.ECQL
import org.geotools.filter.visitor.DuplicatingFilterVisitor
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.filter.expression.AttributeExpression.{FunctionLiteral, PropertyLiteral}
import org.locationtech.geomesa.filter.expression.FastDWithin.DWithinLiteral
import org.locationtech.geomesa.filter.expression.FastPropertyIsEqualTo.{FastIsEqualTo, FastIsEqualToIgnoreCase, FastListIsEqualToAny}
import org.locationtech.geomesa.filter.expression.FastPropertyName.{FastPropertyNameAccessor, FastPropertyNameAttribute}
import org.locationtech.geomesa.filter.expression.OrHashEquality.OrHashListEquality
import org.locationtech.geomesa.filter.expression.OrSequentialEquality.OrSequentialListEquality
import org.locationtech.geomesa.filter.expression._
import org.locationtech.geomesa.filter.visitor.QueryPlanFilterVisitor
import org.locationtech.geomesa.utils.geotools.SimpleFeaturePropertyAccessor
import org.locationtech.jts.geom.Geometry
import org.xml.sax.helpers.NamespaceSupport

/**
  * Filter factory that creates optimized filters
  *
  * Note: usage expects the sft to be set in FastFilterFactory.sfts
  * FastFilterFactory.toFilter will handle this for you
 */
<span class="nc" id="L40">class FastFilterFactory private extends org.geotools.filter.FilterFactoryImpl with FilterFactory {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  import scala.collection.JavaConverters._

<span class="nc" id="L46">  override def after(exp1: Expression, exp2: Expression): After = after(exp1, exp2, MatchAction.ANY)</span>

  override def after(exp1: Expression, exp2: Expression, matchAction: MatchAction): After = {
<span class="nc bnc" id="L49" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L50">      super.after(exp1, exp2, matchAction)</span>
    } else {
<span class="nc" id="L52">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L54">          super.after(exp1, exp2, matchAction)</span>

<span class="nc bnc" id="L56" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L57">          val exp1 = prop match {</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L61">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L62" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; classOf[java.util.Date].isAssignableFrom(descriptor.getType.getBinding)) {</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">            if (prop.flipped) {</span>
<span class="nc" id="L64">              FastTemporalOperator.after(prop.literal, exp1)</span>
            } else {
<span class="nc" id="L66">              FastTemporalOperator.after(exp1, prop.literal)</span>
            }
          } else {
<span class="nc" id="L69">            super.after(exp1, exp2, matchAction)</span>
          }
      }
    }
  }

<span class="nc" id="L75">  override def before(exp1: Expression, exp2: Expression): Before = before(exp1, exp2, MatchAction.ANY)</span>

  override def before(exp1: Expression, exp2: Expression, matchAction: MatchAction): Before = {
<span class="nc bnc" id="L78" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L79">      super.before(exp1, exp2, matchAction)</span>
    } else {
<span class="nc" id="L81">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L83">          super.before(exp1, exp2, matchAction)</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L86">          val exp1 = prop match {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L90">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L91" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; classOf[java.util.Date].isAssignableFrom(descriptor.getType.getBinding)) {</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">            if (prop.flipped) {</span>
<span class="nc" id="L93">              FastTemporalOperator.before(prop.literal, exp1)</span>
            } else {
<span class="nc" id="L95">              FastTemporalOperator.before(exp1, prop.literal)</span>
            }
          } else {
<span class="nc" id="L98">            super.before(exp1, exp2, matchAction)</span>
          }
      }
    }
  }

  override def greater(exp1: Expression, exp2: Expression): PropertyIsGreaterThan =
<span class="nc" id="L105">    greater(exp1, exp2, matchCase = false)</span>

  override def greater(exp1: Expression,
                       exp2: Expression,
<span class="nc" id="L109">                       matchCase: Boolean): PropertyIsGreaterThan = greater(exp1, exp2, matchCase, MatchAction.ANY)</span>

  override def greater(exp1: Expression,
                       exp2: Expression,
                       matchCase: Boolean,
                       matchAction: MatchAction): PropertyIsGreaterThan = {
<span class="nc bnc" id="L115" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L116">      super.greater(exp1, exp2, matchCase, matchAction)</span>
    } else {
<span class="nc" id="L118">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L120">          super.greater(exp1, exp2, matchCase, matchAction)</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L123">          val exp1 = prop match {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L127">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; classOf[Comparable[_]].isAssignableFrom(descriptor.getType.getBinding)) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            if (prop.flipped) {</span>
<span class="nc" id="L130">              FastComparisonOperator.greaterThan(prop.literal, exp1)</span>
            } else {
<span class="nc" id="L132">              FastComparisonOperator.greaterThan(exp1, prop.literal)</span>
            }
          } else {
<span class="nc" id="L135">            super.greater(exp1, exp2, matchCase, matchAction)</span>
          }
      }
    }
  }

  override def greaterOrEqual(exp1: Expression, exp2: Expression): PropertyIsGreaterThanOrEqualTo =
<span class="nc" id="L142">    greaterOrEqual(exp1, exp2, matchCase = false)</span>

  override def greaterOrEqual(exp1: Expression,
                              exp2: Expression,
                              matchCase: Boolean): PropertyIsGreaterThanOrEqualTo =
<span class="nc" id="L147">    greaterOrEqual(exp1, exp2, matchCase, MatchAction.ANY)</span>

  override def greaterOrEqual(exp1: Expression,
                              exp2: Expression,
                              matchCase: Boolean,
                              matchAction: MatchAction): PropertyIsGreaterThanOrEqualTo = {
<span class="nc bnc" id="L153" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L154">      super.greaterOrEqual(exp1, exp2, matchCase, matchAction)</span>
    } else {
<span class="nc" id="L156">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L158">          super.greaterOrEqual(exp1, exp2, matchCase, matchAction)</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L161">          val exp1 = prop match {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L165">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; classOf[Comparable[_]].isAssignableFrom(descriptor.getType.getBinding)) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (prop.flipped) {</span>
<span class="nc" id="L168">              FastComparisonOperator.greaterThanOrEqual(prop.literal, exp1)</span>
            } else {
<span class="nc" id="L170">              FastComparisonOperator.greaterThanOrEqual(exp1, prop.literal)</span>
            }
          } else {
<span class="nc" id="L173">            super.greaterOrEqual(exp1, exp2, matchCase, matchAction)</span>
          }
      }
    }
  }

<span class="nc" id="L179">  override def less(exp1: Expression, exp2: Expression): PropertyIsLessThan = less(exp1, exp2, matchCase = false)</span>

  override def less(exp1: Expression,
                    exp2: Expression,
<span class="nc" id="L183">                    matchCase: Boolean): PropertyIsLessThan = less(exp1, exp2, matchCase, MatchAction.ANY)</span>

  override def less(exp1: Expression,
                    exp2: Expression,
                    matchCase: Boolean,
                    matchAction: MatchAction): PropertyIsLessThan = {
<span class="nc bnc" id="L189" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L190">      super.less(exp1, exp2, matchCase, matchAction)</span>
    } else {
<span class="nc" id="L192">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L194">          super.less(exp1, exp2, matchCase, matchAction)</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L197">          val exp1 = prop match {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L201">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L202" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; classOf[Comparable[_]].isAssignableFrom(descriptor.getType.getBinding)) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (prop.flipped) {</span>
<span class="nc" id="L204">              FastComparisonOperator.lessThan(prop.literal, exp1)</span>
            } else {
<span class="nc" id="L206">              FastComparisonOperator.lessThan(exp1, prop.literal)</span>
            }
          } else {
<span class="nc" id="L209">            super.less(exp1, exp2, matchCase, matchAction)</span>
          }
      }
    }
  }

  override def lessOrEqual(exp1: Expression, exp2: Expression): PropertyIsLessThanOrEqualTo =
<span class="nc" id="L216">    lessOrEqual(exp1, exp2, matchCase = false)</span>

  override def lessOrEqual(exp1: Expression,
                           exp2: Expression,
                           matchCase: Boolean): PropertyIsLessThanOrEqualTo =
<span class="nc" id="L221">    lessOrEqual(exp1, exp2, matchCase, MatchAction.ANY)</span>

  override def lessOrEqual(exp1: Expression,
                           exp2: Expression,
                           matchCase: Boolean,
                           matchAction: MatchAction): PropertyIsLessThanOrEqualTo = {
<span class="nc bnc" id="L227" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L228">      super.lessOrEqual(exp1, exp2, matchCase, matchAction)</span>
    } else {
<span class="nc" id="L230">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L232">          super.lessOrEqual(exp1, exp2, matchCase, matchAction)</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L235">          val exp1 = prop match {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L239">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; classOf[Comparable[_]].isAssignableFrom(descriptor.getType.getBinding)) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (prop.flipped) {</span>
<span class="nc" id="L242">              FastComparisonOperator.lessThanOrEqual(prop.literal, exp1)</span>
            } else {
<span class="nc" id="L244">              FastComparisonOperator.lessThanOrEqual(exp1, prop.literal)</span>
            }
          } else {
<span class="nc" id="L247">            super.lessOrEqual(exp1, exp2, matchCase, matchAction)</span>
          }
      }
    }
  }

  override def property(name: String): PropertyName = {
<span class="nc" id="L254">    val sft = FastFilterFactory.sfts.get</span>
<span class="nc" id="L255">    val colon = name.indexOf(&quot;:&quot;)</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    val local = if (colon == -1) { name } else { name.substring(colon + 1) }</span>
<span class="nc" id="L257">    val index = sft.indexOf(local)</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">    if (index != -1) {</span>
<span class="nc" id="L259">      new FastPropertyNameAttribute(name, index)</span>
    } else {
<span class="nc" id="L261">      val sf = new SimpleFeatureBuilder(sft).buildFeature(&quot;&quot;)</span>
<span class="nc" id="L262">      val accessor = SimpleFeaturePropertyAccessor.getAccessor(sf, name).getOrElse {</span>
<span class="nc" id="L263">        throw new IllegalArgumentException(s&quot;Property '$name' does not exist in feature type ${sft.getTypeName}&quot;)</span>
      }
<span class="nc" id="L265">      new FastPropertyNameAccessor(name, accessor)</span>
    }
  }

<span class="nc" id="L269">  override def property(name: Name): PropertyName = property(name.getLocalPart)</span>

<span class="nc" id="L271">  override def property(name: String, namespaceContext: NamespaceSupport): PropertyName = property(name)</span>

<span class="nc" id="L273">  override def or(f: Filter, g: Filter): Or = or(java.util.Arrays.asList(f, g))</span>

  override def or(filters: java.util.List[Filter]): Or = {
<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (filters.isEmpty) {</span>
<span class="nc" id="L277">      return super.or(filters)</span>
    }

<span class="nc" id="L280">    val predicates = FilterHelper.flattenOr(filters.asScala.toSeq)</span>

<span class="nc" id="L282">    val props = scala.collection.mutable.HashSet.empty[String]</span>
<span class="nc" id="L283">    val literals = scala.collection.immutable.HashSet.newBuilder[AnyRef]</span>
<span class="nc" id="L284">    literals.sizeHint(predicates.length)</span>

<span class="nc" id="L286">    val iter = predicates.iterator</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">    while (iter.hasNext) {</span>
<span class="nc" id="L288">      iter.next() match {</span>
<span class="nc bnc" id="L289" title="All 10 branches missed.">        case p: PropertyIsEqualTo if p.getMatchAction == MatchAction.ANY &amp;&amp; p.isMatchingCase =&gt;</span>
<span class="nc" id="L290">          org.locationtech.geomesa.filter.checkOrder(p.getExpression1, p.getExpression2) match {</span>
<span class="nc bnc" id="L291" title="All 8 branches missed.">            case Some(PropertyLiteral(name, lit, _)) if !props.add(name) || props.size == 1 =&gt; literals += lit.getValue</span>
<span class="nc" id="L292">            case _ =&gt; return super.or(filters)</span>
          }

<span class="nc" id="L295">        case _ =&gt; return super.or(filters)</span>
      }
    }

    // if we've reached here, we have verified that all the child filters are equality matches on the same property
<span class="nc" id="L300">    val prop = property(props.head)</span>
<span class="nc" id="L301">    val values = literals.result</span>
<span class="nc" id="L302">    val isListType = Option(FastFilterFactory.sfts.get.getDescriptor(props.head)).exists(_.isList)</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (values.size &gt;= OrHashEquality.OrHashThreshold.get.toInt) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">      if (isListType) {</span>
<span class="nc" id="L306">        new OrHashListEquality(prop, values)</span>
      } else {
<span class="nc" id="L308">        new OrHashEquality(prop, values)</span>
      }
<span class="nc bnc" id="L310" title="All 2 branches missed.">    } else if (isListType) {</span>
<span class="nc" id="L311">      new OrSequentialListEquality(prop, values.toSeq)</span>
    } else {
<span class="nc" id="L313">      new OrSequentialEquality(prop, values.toSeq)</span>
    }
  }

  override def equals(exp1: Expression, exp2: Expression): PropertyIsEqualTo =
<span class="nc" id="L318">    equal(exp1, exp2, matchCase = true, MatchAction.ANY)</span>

  override def equal(exp1: Expression, exp2: Expression, matchCase: Boolean): PropertyIsEqualTo =
<span class="nc" id="L321">    equal(exp1, exp2, matchCase, MatchAction.ANY)</span>

  override def equal(exp1: Expression, exp2: Expression, matchCase: Boolean, matchAction: MatchAction): PropertyIsEqualTo = {
<span class="nc bnc" id="L324" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L325">      super.equal(exp1, exp2, matchCase, matchAction)</span>
    } else {
<span class="nc" id="L327">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L329">          super.equal(exp1, exp2, matchCase, matchAction)</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L332">          val exp1 = prop match {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L336">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L337" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; descriptor.isList) {</span>
<span class="nc" id="L338">            new FastListIsEqualToAny(exp1, prop.literal)</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">          } else if (matchCase) {</span>
<span class="nc" id="L340">            new FastIsEqualTo(exp1, prop.literal)</span>
          } else {
<span class="nc" id="L342">            new FastIsEqualToIgnoreCase(exp1, prop.literal)</span>
          }
      }
    }
  }

<span class="nc" id="L348">  override def during(exp1: Expression, exp2: Expression): During = during(exp1, exp2, MatchAction.ANY)</span>

  override def during(exp1: Expression, exp2: Expression, matchAction: MatchAction): During = {
<span class="nc bnc" id="L351" title="All 6 branches missed.">    if (matchAction != MatchAction.ANY) {</span>
<span class="nc" id="L352">      super.during(exp1, exp2, matchAction)</span>
    } else {
<span class="nc" id="L354">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2).filterNot(_.flipped) match {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L356">          super.during(exp1, exp2, matchAction)</span>

<span class="nc bnc" id="L358" title="All 2 branches missed.">        case Some(prop) =&gt;</span>
<span class="nc" id="L359">          val exp1 = prop match {</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            case p: PropertyLiteral =&gt; property(p.name)</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            case p: FunctionLiteral =&gt; p.function</span>
          }
<span class="nc" id="L363">          val descriptor = FastFilterFactory.sfts.get.getDescriptor(prop.name)</span>
<span class="nc bnc" id="L364" title="All 4 branches missed.">          if (descriptor != null &amp;&amp; classOf[java.util.Date].isAssignableFrom(descriptor.getType.getBinding)) {</span>
<span class="nc" id="L365">            FastTemporalOperator.during(exp1, prop.literal)</span>
          } else {
<span class="nc" id="L367">            super.during(exp1, exp2, matchAction)</span>
          }
      }
    }
  }

  override def dwithin(name: String, geom: Geometry, distance: Double, units: String): DWithin =
<span class="nc" id="L374">    dwithin(property(name), literal(geom), distance, units)</span>

  override def dwithin(name: String, geom: Geometry, distance: Double, units: String, action: MatchAction): DWithin =
<span class="nc" id="L377">    dwithin(property(name), literal(geom), distance, units, action)</span>

  override def dwithin(exp1: Expression, exp2: Expression, distance: Double, units: String): DWithin =
<span class="nc" id="L380">    dwithin(exp1, exp2, distance, units, MatchAction.ANY)</span>

  override def dwithin(exp1: Expression, exp2: Expression, distance: Double, units: String, action: MatchAction): DWithin = {
<span class="nc bnc" id="L383" title="All 6 branches missed.">    if (action != MatchAction.ANY) {</span>
<span class="nc" id="L384">      super.dwithin(exp1, exp2, distance, units, action)</span>
    } else {
<span class="nc" id="L386">      org.locationtech.geomesa.filter.checkOrder(exp1, exp2) match {</span>
<span class="nc bnc" id="L387" title="All 4 branches missed.">        case Some(PropertyLiteral(name, lit, _))  =&gt; new DWithinLiteral(property(name), lit, distance, units)</span>
<span class="nc bnc" id="L388" title="All 4 branches missed.">        case Some(FunctionLiteral(_, fn, lit, _)) =&gt; new DWithinLiteral(fn, lit, distance, units)</span>
<span class="nc" id="L389">        case _ =&gt; super.dwithin(exp1, exp2, distance, units, action)</span>
      }
    }
  }
}

<span class="nc" id="L395">object FastFilterFactory {</span>

<span class="nc" id="L397">  val factory = new FastFilterFactory</span>

<span class="nc" id="L399">  val sfts = new ThreadLocal[SimpleFeatureType]()</span>

<span class="nc" id="L401">  def toFilter(sft: SimpleFeatureType, ecql: String): Filter = optimize(sft, ECQL.toFilter(ecql))</span>

  def toExpression(sft: SimpleFeatureType, ecql: String): Expression = {
<span class="nc" id="L404">    sfts.set(sft)</span>
<span class="nc" id="L405">    try { ECQL.toExpression(ecql, factory) } finally {</span>
<span class="nc" id="L406">      sfts.remove()</span>
    }
  }

  def optimize(sft: SimpleFeatureType, filter: Filter): Filter = {
<span class="nc" id="L411">    sfts.set(sft)</span>
<span class="nc" id="L412">    try { QueryPlanFilterVisitor(sft, filter, factory) } finally {</span>
<span class="nc" id="L413">      sfts.remove()</span>
    }
  }

  def copy(sft: SimpleFeatureType, filter: Filter): Filter = {
<span class="nc" id="L418">    sfts.set(sft)</span>
<span class="nc" id="L419">    try { filter.accept(new DuplicatingFilterVisitor(factory), null).asInstanceOf[Filter] } finally {</span>
<span class="nc" id="L420">      sfts.remove()</span>
    }
  }
<span class="nc" id="L423">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>