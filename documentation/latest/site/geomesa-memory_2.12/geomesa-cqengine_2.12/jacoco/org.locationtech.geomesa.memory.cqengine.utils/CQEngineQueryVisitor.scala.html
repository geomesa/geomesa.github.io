<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CQEngineQueryVisitor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Geo-support for CQ Engine</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.memory.cqengine.utils</a> &gt; <span class="el_source">CQEngineQueryVisitor.scala</span></div><h1>CQEngineQueryVisitor.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.memory.cqengine.utils

import com.googlecode.cqengine.attribute.Attribute
import com.googlecode.cqengine.query.Query
import com.googlecode.cqengine.query.simple.All
import com.googlecode.cqengine.{query =&gt; cqquery}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter._
import org.geotools.api.filter.expression.Literal
import org.geotools.api.filter.spatial._
import org.geotools.api.filter.temporal._
import org.geotools.filter.LikeToRegexConverter
import org.geotools.filter.visitor.AbstractFilterVisitor
import org.locationtech.geomesa.filter._
import org.locationtech.geomesa.memory.cqengine.query.{GeoToolsFilterQuery, Intersects =&gt; CQIntersects}
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.jts.geom.Geometry

import java.util.Date
import java.util.regex.Pattern
import scala.collection.JavaConverters._
import scala.language._

<span class="nc" id="L32">class CQEngineQueryVisitor(sft: SimpleFeatureType) extends AbstractFilterVisitor {</span>

<span class="nc" id="L34">  implicit val lookup: SFTAttributes = SFTAttributes(sft)</span>

  /* Logical operators */

  /**
    * And
    */
  override def visit(filter: And, data: scala.Any): AnyRef = {
<span class="nc" id="L42">    val children = filter.getChildren</span>

<span class="nc" id="L44">    val query = children.asScala.map { f =&gt;</span>
<span class="nc" id="L45">      f.accept(this, null) match {</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        case q: Query[SimpleFeature] =&gt; q</span>
<span class="nc" id="L47">        case _ =&gt; throw new RuntimeException(s&quot;Can't parse filter: $f.&quot;)</span>
      }
    }.toList
<span class="nc bnc" id="L50" title="All 2 branches missed.">    if (query.exists(_.isInstanceOf[All[_]])) {</span>
<span class="nc" id="L51">      new cqquery.simple.All(classOf[SimpleFeature])</span>
    } else {
<span class="nc" id="L53">      new cqquery.logical.And[SimpleFeature](query.asJava)</span>
    }
  }

  /**
    * Or
    */
  override def visit(filter: Or, data: scala.Any): AnyRef = {
<span class="nc" id="L61">    val children = filter.getChildren</span>

<span class="nc" id="L63">    val query = children.asScala.map { f =&gt;</span>
<span class="nc" id="L64">      f.accept(this, null) match {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        case q: Query[SimpleFeature] =&gt; q</span>
<span class="nc" id="L66">        case _ =&gt; throw new RuntimeException(s&quot;Can't parse filter: $f.&quot;)</span>
      }
    }.toList
<span class="nc bnc" id="L69" title="All 2 branches missed.">    if (query.exists(_.isInstanceOf[All[_]])) {</span>
<span class="nc" id="L70">      new cqquery.simple.All(classOf[SimpleFeature])</span>
    } else {
<span class="nc" id="L72">      new cqquery.logical.Or[SimpleFeature](query.asJava)</span>
    }
  }

  /**
    * Not
    */
  override def visit(filter: Not, data: scala.Any): AnyRef = {
<span class="nc" id="L80">    val subfilter = filter.getFilter</span>

<span class="nc" id="L82">    val subquery = subfilter.accept(this, null) match {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      case q: Query[SimpleFeature] =&gt; q</span>
<span class="nc" id="L84">      case _ =&gt; throw new RuntimeException(s&quot;Can't parse filter: $subfilter.&quot;)</span>
    }
    // In the event that the visitor cannot 'plan' a query, it returns an 'All' Query to indicate
    //  that all the Simple Features should be considered.
    // As such, we do not negate the query going back.
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (subquery.isInstanceOf[All[_]]) {</span>
<span class="nc" id="L90">      subquery</span>
    } else {
<span class="nc" id="L92">      new cqquery.logical.Not[SimpleFeature](subquery)</span>
    }
  }

  /* Id, null, nil, exclude, include */

  /**
    * Id
    */
  override def visit(filter: Id, extractData: scala.AnyRef): AnyRef = {
<span class="nc" id="L102">    val attr = SFTAttributes.fidAttribute</span>
<span class="nc" id="L103">    val values = filter.getIDs.asScala.map(_.toString)</span>
<span class="nc" id="L104">    new cqquery.simple.In[SimpleFeature, String](attr, true, values.asJava)</span>
  }

  /**
    * PropertyIsNil:
    * follows the example of IsNilImpl by using the same implementation as PropertyIsNull
    */
  override def visit(filter: PropertyIsNil, extraData: scala.Any): AnyRef = {
<span class="nc" id="L112">    val name = getAttribute(filter)</span>
<span class="nc" id="L113">    val attr = lookup.lookup[Any](name)</span>
<span class="nc" id="L114">    new cqquery.logical.Not[SimpleFeature](new cqquery.simple.Has(attr))</span>
  }

  /**
    * PropertyIsNull
    */
  override def visit(filter: PropertyIsNull, data: scala.Any): AnyRef = {
<span class="nc" id="L121">    val name = getAttribute(filter)</span>
<span class="nc" id="L122">    val attr = lookup.lookup[Any](name)</span>
    // TODO: could this be done better?
<span class="nc" id="L124">    new cqquery.logical.Not[SimpleFeature](new cqquery.simple.Has(attr))</span>
  }

  /**
    * ExcludeFilter
    */
<span class="nc" id="L130">  override def visit(filter: ExcludeFilter, data: scala.Any): AnyRef = new cqquery.simple.None(classOf[SimpleFeature])</span>

  /**
    * IncludeFilter
    * (handled a level above if IncludeFilter is the root node)
    */
<span class="nc" id="L136">  override def visit(filter: IncludeFilter, data: scala.Any): AnyRef = new cqquery.simple.All(classOf[SimpleFeature])</span>

  /* MultiValuedFilters */

  /**
    * PropertyIsEqualTo
    */
  override def visit(filter: PropertyIsEqualTo, data: scala.Any): AnyRef = {
<span class="nc" id="L144">    val name = getAttribute(filter)</span>
<span class="nc" id="L145">    val attribute: Attribute[SimpleFeature, Any] = lookup.lookup[Any](name)</span>
<span class="nc" id="L146">    val bounds = FilterHelper.extractAttributeBounds(filter, name, attribute.getAttributeType).values.headOption.getOrElse {</span>
<span class="nc" id="L147">      Bounds.everything[Any]</span>
    }
<span class="nc bnc" id="L149" title="All 2 branches missed.">    if(!bounds.isBounded) new cqquery.simple.All(classOf[SimpleFeature])</span>
<span class="nc" id="L150">    else new cqquery.simple.Equal(attribute, bounds.lower.value.get)</span>
  }

  /**
    * PropertyIsGreaterThan
    */
  override def visit(filter: PropertyIsGreaterThan, data: scala.Any): AnyRef = {
<span class="nc" id="L157">    val name = getAttribute(filter)</span>
<span class="nc" id="L158">    val binding = sft.getDescriptor(name).getType.getBinding</span>
<span class="nc" id="L159">    FilterHelper.extractAttributeBounds(filter, name, binding).values.headOption.getOrElse {</span>
<span class="nc" id="L160">      Bounds.everything[Any]</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">    }.bounds match {</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">      case (Some(lo), None) =&gt;</span>
<span class="nc" id="L163">        binding match {</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntGTQuery(name, lo.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongGTQuery(name, lo.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatGTQuery(name, lo.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleGTQuery(name, lo.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateGTQuery(name, lo.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">          case c if classOf[java.lang.String ].isAssignableFrom(c) =&gt; BuildStringGTQuery(name, lo.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L170">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsGreaterThan: $c not supported&quot;)</span>
        }
<span class="nc bnc" id="L172" title="All 4 branches missed.">      case (None, Some(hi)) =&gt;</span>
<span class="nc" id="L173">        binding match {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntLTQuery(name, hi.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongLTQuery(name, hi.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatLTQuery(name, hi.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleLTQuery(name, hi.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateLTQuery(name, hi.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">          case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringLTQuery(name, hi.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L180">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsGreaterThan: $c not supported&quot;)</span>
        }
<span class="nc" id="L182">      case _ =&gt; new cqquery.simple.All(classOf[SimpleFeature])</span>
    }
  }

  /**
    * PropertyIsGreaterThanOrEqualTo
    */
  override def visit(filter: PropertyIsGreaterThanOrEqualTo, data: scala.Any): AnyRef = {
<span class="nc" id="L190">    val name = getAttribute(filter)</span>
<span class="nc" id="L191">    val binding = sft.getDescriptor(name).getType.getBinding</span>
<span class="nc" id="L192">    FilterHelper.extractAttributeBounds(filter, name, binding).values.headOption.getOrElse {</span>
<span class="nc" id="L193">      Bounds.everything[Any]</span>
<span class="nc bnc" id="L194" title="All 4 branches missed.">    }.bounds match {</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">      case (Some(lo), None) =&gt;</span>
<span class="nc" id="L196">        binding match {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntGTEQuery(name, lo.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongGTEQuery(name, lo.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatGTEQuery(name, lo.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleGTEQuery(name, lo.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateGTEQuery(name, lo.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">          case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringGTEQuery(name, lo.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L203">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsGreaterThanOrEqualTo: $c not supported&quot;)</span>
        }
<span class="nc bnc" id="L205" title="All 4 branches missed.">      case (None, Some(hi)) =&gt;</span>
<span class="nc" id="L206">        binding match {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntLTEQuery(name, hi.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongLTEQuery(name, hi.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatLTEQuery(name, hi.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleLTEQuery(name, hi.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateLTEQuery(name, hi.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">          case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringLTEQuery(name, hi.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L213">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsGreaterThanOrEqualTo: $c not supported&quot;)</span>
        }
<span class="nc" id="L215">      case _ =&gt; new cqquery.simple.All(classOf[SimpleFeature])</span>
    }
  }

  /**
    * PropertyIsLessThan
    */
  override def visit(filter: PropertyIsLessThan, data: scala.Any): AnyRef = {
<span class="nc" id="L223">    val name = getAttribute(filter)</span>
<span class="nc" id="L224">    val binding = sft.getDescriptor(name).getType.getBinding</span>
<span class="nc" id="L225">    FilterHelper.extractAttributeBounds(filter, name, binding).values.headOption.getOrElse {</span>
<span class="nc" id="L226">      Bounds.everything[Any]</span>
<span class="nc bnc" id="L227" title="All 4 branches missed.">    }.bounds match {</span>
<span class="nc bnc" id="L228" title="All 4 branches missed.">      case (Some(lo), None) =&gt;</span>
<span class="nc" id="L229">        binding match {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntGTQuery(name, lo.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongGTQuery(name, lo.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatGTQuery(name, lo.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleGTQuery(name, lo.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateGTQuery(name, lo.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">          case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringGTQuery(name, lo.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L236">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsLessThan: $c not supported&quot;)</span>
        }
<span class="nc bnc" id="L238" title="All 4 branches missed.">      case (None, Some(hi)) =&gt;</span>
<span class="nc" id="L239">        binding match {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntLTQuery(name, hi.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongLTQuery(name, hi.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatLTQuery(name, hi.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleLTQuery(name, hi.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateLTQuery(name, hi.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">          case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringLTQuery(name, hi.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L246">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsLessThan: $c not supported&quot;)</span>
        }
<span class="nc" id="L248">      case _ =&gt; new cqquery.simple.All(classOf[SimpleFeature])</span>
    }
  }

  /**
    * PropertyIsLessThanOrEqualTo
    */
  override def visit(filter: PropertyIsLessThanOrEqualTo, data: scala.Any): AnyRef = {
<span class="nc" id="L256">    val name = getAttribute(filter)</span>
<span class="nc" id="L257">    val binding = sft.getDescriptor(name).getType.getBinding</span>
<span class="nc" id="L258">    FilterHelper.extractAttributeBounds(filter, name, binding).values.headOption.getOrElse {</span>
<span class="nc" id="L259">      Bounds.everything[Any]</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">    }.bounds match {</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">      case (Some(lo), None) =&gt;</span>
<span class="nc" id="L262">        binding match {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntGTEQuery(name, lo.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongGTEQuery(name, lo.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatGTEQuery(name, lo.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleGTEQuery(name, lo.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateGTEQuery(name, lo.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">          case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringGTEQuery(name, lo.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L269">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsLessThanOrEqualTo: $c not supported&quot;)</span>
        }
<span class="nc bnc" id="L271" title="All 4 branches missed.">      case (None, Some(hi)) =&gt;</span>
<span class="nc" id="L272">        binding match {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">          case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntLTEQuery(name, hi.asInstanceOf[java.lang.Integer])</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">          case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongLTEQuery(name, hi.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">          case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatLTEQuery(name, hi.asInstanceOf[java.lang.Float])</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">          case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleLTEQuery(name, hi.asInstanceOf[java.lang.Double])</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">          case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateLTEQuery(name, hi.asInstanceOf[java.util.Date])</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">          case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringLTEQuery(name, hi.asInstanceOf[java.lang.String])</span>
<span class="nc" id="L279">          case c =&gt; throw new RuntimeException(s&quot;PropertyIsLessThanOrEqualTo: $c not supported&quot;)</span>
        }
<span class="nc" id="L281">      case _ =&gt; new cqquery.simple.All(classOf[SimpleFeature])</span>
    }
  }

  /**
    * PropertyIsNotEqualTo
    */
  override def visit(filter: PropertyIsNotEqualTo, data: scala.Any): AnyRef = {
<span class="nc" id="L289">    val name = getAttribute(filter)</span>
<span class="nc" id="L290">    val attribute: Attribute[SimpleFeature, Any] = lookup.lookup[Any](name)</span>
<span class="nc" id="L291">    val literals = Iterator(filter.getExpression1, filter.getExpression2).collect {</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">      case lit: Literal =&gt; FastConverter.evaluate(lit, attribute.getAttributeType)</span>
    }
<span class="nc bnc" id="L294" title="All 2 branches missed.">    if (literals.hasNext) {</span>
<span class="nc" id="L295">      val value = literals.next()</span>
      // TODO: could this be done better?
      // may not be as big an issue as PropertyIsNull, as I'm not
      // even sure how to build this filter in (E)CQL
<span class="nc" id="L299">      new cqquery.logical.Not(new cqquery.simple.Equal(attribute, value))</span>
    } else {
<span class="nc" id="L301">      throw new RuntimeException(s&quot;Can't parse not equal to values: ${FilterHelper.toString(filter)}&quot;)</span>
    }
  }

  /**
    * PropertyIsBetween
    * (in the OpenGIS spec, lower and upper are inclusive)
   */
  override def visit(filter: PropertyIsBetween, data: scala.Any): AnyRef = {
<span class="nc" id="L310">    val name = getAttribute(filter)</span>
<span class="nc" id="L311">    val binding = sft.getDescriptor(name).getType.getBinding</span>
<span class="nc" id="L312">    val values = FilterHelper.extractAttributeBounds(filter, name, binding).values.headOption.getOrElse {</span>
<span class="nc" id="L313">      throw new RuntimeException(s&quot;Can't parse less than or equal to values ${FilterHelper.toString(filter)}&quot;)</span>
    }
<span class="nc" id="L315">    val between = (values.lower.value.get, values.upper.value.get)</span>

<span class="nc" id="L317">    binding match {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">      case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; BuildIntBetweenQuery(name, between.asInstanceOf[(java.lang.Integer, java.lang.Integer)])</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">      case c if classOf[java.lang.Long   ].isAssignableFrom(c) =&gt; BuildLongBetweenQuery(name, between.asInstanceOf[(java.lang.Long, java.lang.Long)])</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">      case c if classOf[java.lang.Float  ].isAssignableFrom(c) =&gt; BuildFloatBetweenQuery(name, between.asInstanceOf[(java.lang.Float, java.lang.Float)])</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">      case c if classOf[java.lang.Double ].isAssignableFrom(c) =&gt; BuildDoubleBetweenQuery(name, between.asInstanceOf[(java.lang.Double, java.lang.Double)])</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      case c if classOf[java.util.Date   ].isAssignableFrom(c) =&gt; BuildDateBetweenQuery(name, between.asInstanceOf[(java.util.Date, java.util.Date)])</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">      case c if classOf[java.lang.String   ].isAssignableFrom(c) =&gt; BuildStringBetweenQuery(name, between.asInstanceOf[(java.lang.String, java.lang.String)])</span>
<span class="nc" id="L324">      case c =&gt; throw new RuntimeException(s&quot;PropertyIsBetween: $c not supported&quot;)</span>
    }
  }

  /**
    * PropertyIsLike
    */
  override def visit(filter: PropertyIsLike, data: scala.Any): AnyRef = {
<span class="nc" id="L332">    val name = getAttribute(filter)</span>
<span class="nc" id="L333">    val attr = lookup.lookup[String](name)</span>

<span class="nc" id="L335">    val converter = new LikeToRegexConverter(filter)</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">    val pattern = if (filter.isMatchingCase) {</span>
<span class="nc" id="L337">      Pattern.compile(converter.getPattern)</span>
    } else {
<span class="nc" id="L339">      Pattern.compile(converter.getPattern, Pattern.CASE_INSENSITIVE)</span>
    }
<span class="nc" id="L341">    new cqquery.simple.StringMatchesRegex[SimpleFeature, String](attr, pattern)</span>
  }

  /* Spatial filters */

  /**
    * BBOX
    */
  override def visit(filter: BBOX, data: scala.Any): AnyRef = {
<span class="nc" id="L350">    val name = getAttribute(filter)</span>
<span class="nc" id="L351">    val geom = FilterHelper.extractGeometries(filter, name).values.headOption.getOrElse {</span>
<span class="nc" id="L352">      throw new RuntimeException(s&quot;Can't parse bbox values ${FilterHelper.toString(filter)}&quot;)</span>
    }
<span class="nc" id="L354">    val geomAttribute = lookup.lookup[Geometry](name)</span>

<span class="nc" id="L356">    new CQIntersects(geomAttribute, geom)</span>
  }

  /**
    * Intersects
    */
  override def visit(filter: Intersects, data: scala.Any): AnyRef = {
<span class="nc" id="L363">    val name = getAttribute(filter)</span>
<span class="nc" id="L364">    val geom = FilterHelper.extractGeometries(filter, name).values.headOption.getOrElse {</span>
<span class="nc" id="L365">      throw new RuntimeException(s&quot;Can't parse intersects values ${FilterHelper.toString(filter)}&quot;)</span>
    }
<span class="nc" id="L367">    val geomAttribute = lookup.lookup[Geometry](name)</span>

<span class="nc" id="L369">    new CQIntersects(geomAttribute, geom)</span>
  }

  /**
    * BinarySpatialOperator: fallback non-indexable implementation of other spatial operators.
    * Handles:
    *    Contains, Crosses, Disjoint, Beyond, DWithin, Equals, Overlaps, Touches, Within
    */
<span class="nc" id="L377">  override def visit(filter: BinarySpatialOperator, data: scala.Any): AnyRef = handleGeneralCQLFilter(filter)</span>

  /* Temporal filters */

  /**
    * After: only for time attributes, and is exclusive
    */
  override def visit(after: After, extraData: scala.Any): AnyRef = {
<span class="nc" id="L385">    val name = getAttribute(after)</span>
<span class="nc" id="L386">    sft.getDescriptor(name).getType.getBinding match {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">      case c if classOf[Date].isAssignableFrom(c) =&gt;</span>
<span class="nc" id="L388">        val attr = lookup.lookup[Date](name)</span>
<span class="nc" id="L389">        FilterHelper.extractIntervals(after, name).values.headOption.getOrElse {</span>
<span class="nc" id="L390">          throw new RuntimeException(s&quot;Can't parse after values ${FilterHelper.toString(after)}&quot;)</span>
<span class="nc bnc" id="L391" title="All 4 branches missed.">        }.bounds match {</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">          case (Some(lo), None) =&gt; new cqquery.simple.GreaterThan[SimpleFeature, Date](attr, Date.from(lo.toInstant), false)</span>
<span class="nc bnc" id="L393" title="All 4 branches missed.">          case (None, Some(hi)) =&gt; new cqquery.simple.LessThan[SimpleFeature, Date](attr, Date.from(hi.toInstant), false)</span>
        }

<span class="nc" id="L396">      case c =&gt; throw new RuntimeException(s&quot;After: $c not supported&quot;)</span>
    }
  }

  /**
    * Before: only for time attributes, and is exclusive
    */
  override def visit(before: Before, extraData: scala.Any): AnyRef = {
<span class="nc" id="L404">    val name = getAttribute(before)</span>
<span class="nc" id="L405">    sft.getDescriptor(name).getType.getBinding match {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">      case c if classOf[Date].isAssignableFrom(c) =&gt;</span>
<span class="nc" id="L407">        val attr = lookup.lookup[Date](name)</span>
<span class="nc" id="L408">        FilterHelper.extractIntervals(before, name).values.headOption.getOrElse {</span>
<span class="nc" id="L409">          throw new RuntimeException(s&quot;Can't parse before values ${FilterHelper.toString(before)}&quot;)</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">        }.bounds match {</span>
<span class="nc bnc" id="L411" title="All 4 branches missed.">          case (Some(lo), None) =&gt; new cqquery.simple.GreaterThan[SimpleFeature, Date](attr, Date.from(lo.toInstant), false)</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">          case (None, Some(hi)) =&gt; new cqquery.simple.LessThan[SimpleFeature, Date](attr, Date.from(hi.toInstant), false)</span>
        }

<span class="nc" id="L415">      case c =&gt; throw new RuntimeException(s&quot;Before: $c not supported&quot;)</span>
    }
  }

  /**
    * During: only for time attributes, and is exclusive at both ends
    */
  override def visit(during: During, extraData: scala.Any): AnyRef = {
<span class="nc" id="L423">    val name = getAttribute(during)</span>
<span class="nc" id="L424">    sft.getDescriptor(name).getType.getBinding match {</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">      case c if classOf[Date].isAssignableFrom(c) =&gt;</span>
<span class="nc" id="L426">        val attr = lookup.lookup[Date](name)</span>
<span class="nc" id="L427">        val bounds = FilterHelper.extractIntervals(during, name).values.headOption.getOrElse {</span>
<span class="nc" id="L428">          throw new RuntimeException(s&quot;Can't parse during values ${FilterHelper.toString(during)}&quot;)</span>
        }
<span class="nc" id="L430">        new cqquery.simple.Between[SimpleFeature, java.util.Date](attr, Date.from(bounds.lower.value.get.toInstant),</span>
<span class="nc" id="L431">          bounds.lower.inclusive, Date.from(bounds.upper.value.get.toInstant), bounds.upper.inclusive)</span>

<span class="nc" id="L433">      case c =&gt; throw new RuntimeException(s&quot;During: $c not supported&quot;)</span>
    }
  }

  /**
    * BinaryTemporalOperator: Fallback non-indexable implementation of other temporal operators.
    * Handles:
    *     AnyInteracts, Begins, BegunBy, EndedBy, Ends, Meets,
    *     MetBy, OverlappedBy, TContains, TEquals, TOverlaps
    */
<span class="nc" id="L443">  override def visit(filter: BinaryTemporalOperator, data: scala.Any): AnyRef = handleGeneralCQLFilter(filter)</span>

  def handleGeneralCQLFilter(filter: Filter): Query[SimpleFeature] = {
<span class="nc" id="L446">    new GeoToolsFilterQuery(filter)</span>
  }

<span class="nc" id="L449">  def getAttribute(filter: Filter): String = FilterHelper.propertyNames(filter, null).headOption.getOrElse {</span>
<span class="nc" id="L450">    throw new RuntimeException(s&quot;Can't parse filter ${FilterHelper.toString(filter)}&quot;)</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>