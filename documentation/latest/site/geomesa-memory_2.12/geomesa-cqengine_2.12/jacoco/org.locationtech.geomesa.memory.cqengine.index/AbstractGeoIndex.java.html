<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractGeoIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Geo-support for CQ Engine</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.memory.cqengine.index</a> &gt; <span class="el_source">AbstractGeoIndex.java</span></div><h1>AbstractGeoIndex.java</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.memory.cqengine.index;

import com.googlecode.cqengine.attribute.Attribute;
import com.googlecode.cqengine.index.Index;
import com.googlecode.cqengine.index.support.AbstractAttributeIndex;
import com.googlecode.cqengine.index.support.indextype.OnHeapTypeIndex;
import com.googlecode.cqengine.persistence.support.ObjectSet;
import com.googlecode.cqengine.persistence.support.ObjectStore;
import com.googlecode.cqengine.query.Query;
import com.googlecode.cqengine.query.option.QueryOptions;
import com.googlecode.cqengine.resultset.ResultSet;
import org.geotools.api.feature.simple.SimpleFeature;
import org.geotools.api.feature.simple.SimpleFeatureType;
import org.locationtech.geomesa.memory.cqengine.query.Intersects;
import org.locationtech.geomesa.memory.index.SpatialIndex;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import scala.Function1;
import scala.runtime.AbstractFunction1;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public abstract class AbstractGeoIndex&lt;A extends Geometry, O extends SimpleFeature&gt;
      extends AbstractAttributeIndex&lt;A, O&gt; implements OnHeapTypeIndex {

<span class="fc" id="L38">    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractGeoIndex.class);</span>

    private static final int INDEX_RETRIEVAL_COST = 40;

    private final SpatialIndex&lt;O&gt; index;
    private final int geomAttributeIndex;

<span class="fc" id="L45">    public static final ThreadLocal&lt;SpatialIndex&lt;? extends SimpleFeature&gt;&gt; lastUsed = new ThreadLocal&lt;&gt;();</span>

<span class="fc" id="L47">    static Set&lt;Class&lt;? extends Query&gt;&gt; supportedQueries = new HashSet&lt;Class&lt;? extends Query&gt;&gt;() {{</span>
<span class="fc" id="L48">        add(Intersects.class);</span>
<span class="fc" id="L49">    }};</span>

    AbstractGeoIndex(SimpleFeatureType sft, Attribute&lt;O, A&gt; attribute, SpatialIndex&lt;O&gt; index) {
<span class="fc" id="L52">        super(attribute, supportedQueries);</span>
<span class="fc" id="L53">        this.index = index;</span>
<span class="fc" id="L54">        this.geomAttributeIndex = sft.indexOf(attribute.getAttributeName());</span>
<span class="fc" id="L55">    }</span>


    @Override
    public void init(ObjectStore&lt;O&gt; objectStore, QueryOptions queryOptions) {
<span class="fc" id="L60">        addAll(ObjectSet.fromObjectStore(objectStore, queryOptions), queryOptions);</span>
<span class="fc" id="L61">    }</span>

    @Override
    public boolean addAll(ObjectSet&lt;O&gt; objectSet, QueryOptions queryOptions) {
        try {
<span class="fc" id="L66">            boolean modified = false;</span>

<span class="fc bfc" id="L68" title="All 2 branches covered.">            for (O object : objectSet) {</span>
<span class="fc" id="L69">                Geometry geom = (Geometry) object.getDefaultGeometry();</span>
<span class="fc" id="L70">                index.insert(geom, object.getID(), object);</span>
<span class="fc" id="L71">                modified = true;</span>
<span class="fc" id="L72">            }</span>

<span class="fc" id="L74">            return modified;</span>
        } finally {
<span class="fc" id="L76">            objectSet.close();</span>
        }
    }

    @Override
    public boolean removeAll(ObjectSet&lt;O&gt; objectSet, QueryOptions queryOptions) {
        try {
<span class="nc" id="L83">            boolean modified = false;</span>

<span class="nc bnc" id="L85" title="All 2 branches missed.">            for (O object : objectSet) {</span>
<span class="nc" id="L86">                Geometry geom = (Geometry) object.getDefaultGeometry();</span>
<span class="nc" id="L87">                index.remove(geom, object.getID());</span>
<span class="nc" id="L88">                modified = true;</span>
<span class="nc" id="L89">            }</span>

<span class="nc" id="L91">            return modified;</span>
        } finally {
<span class="nc" id="L93">            objectSet.close();</span>
        }
    }

    @Override
    public void clear(QueryOptions queryOptions) {
<span class="nc" id="L99">        this.index.clear();</span>
<span class="nc" id="L100">    }</span>

    public void destroy(QueryOptions queryOptions) {
<span class="nc" id="L103">        this.index.clear();</span>
<span class="nc" id="L104">    }</span>

    @Override
    public ResultSet&lt;O&gt; retrieve(final Query&lt;O&gt; query, final QueryOptions queryOptions) {
<span class="fc" id="L108">        lastUsed.set(this.index);</span>
<span class="fc" id="L109">        return new GeoIndexResultSet(query, queryOptions);</span>
    }

    private scala.collection.Iterator&lt;O&gt; getSimpleFeatureIteratorInternal(Intersects query,
                                                                          final QueryOptions queryOptions) {
<span class="fc" id="L114">        final Intersects intersects = query;</span>
<span class="fc" id="L115">        Envelope queryEnvelope = intersects.getEnvelope();</span>
<span class="fc" id="L116">        return index.query(queryEnvelope).filter((Function1&lt;O, Object&gt;) new AbstractFunction1&lt;SimpleFeature, Object&gt;() {</span>
            @Override
            public Object apply(SimpleFeature feature) {
                try {
<span class="fc" id="L120">                    Geometry geom = (Geometry) feature.getAttribute(geomAttributeIndex);</span>
<span class="fc" id="L121">                    return intersects.matchesValue(geom, queryOptions);</span>
<span class="nc" id="L122">                } catch (Exception e) {</span>
<span class="nc" id="L123">                    LOGGER.warn(&quot;Caught exception while trying to look up geometry&quot;, e);</span>
<span class="nc" id="L124">                    return false;</span>
                }
            }
        });
    }


    @Override
    public boolean isMutable() {
<span class="fc" id="L133">        return true;</span>
    }

    @Override
    public boolean isQuantized() {
<span class="nc" id="L138">        return false;</span>
    }

    @Override
    public Index&lt;O&gt; getEffectiveIndex() {
<span class="nc" id="L143">        return this;</span>
    }

    public class GeoIndexResultSet extends ResultSet&lt;O&gt; {

        private final Query&lt;O&gt; query;
        private final QueryOptions queryOptions;

<span class="fc" id="L151">        public GeoIndexResultSet(Query&lt;O&gt; query, QueryOptions queryOptions) {</span>
<span class="fc" id="L152">            this.query = query;</span>
<span class="fc" id="L153">            this.queryOptions = queryOptions;</span>
<span class="fc" id="L154">        }</span>

        @Override
        public Iterator&lt;O&gt; iterator() {
<span class="fc" id="L158">            scala.collection.Iterator&lt;O&gt; iter =</span>
<span class="fc" id="L159">                  getSimpleFeatureIteratorInternal((Intersects) query, queryOptions);</span>
<span class="fc" id="L160">            return new Iterator&lt;O&gt;() {</span>
                @Override
                public boolean hasNext() {
<span class="fc" id="L163">                    return iter.hasNext();</span>
                }

                @Override
                public O next() {
<span class="fc" id="L168">                    return iter.next();</span>
                }
            };
        }

        @Override
        public boolean contains(O object) {
<span class="nc" id="L175">            final Intersects intersects = (Intersects) query;</span>
<span class="nc" id="L176">            Geometry geom = (Geometry) object.getAttribute(geomAttributeIndex);</span>
<span class="nc" id="L177">            return intersects.matchesValue(geom, queryOptions);</span>
        }

        @Override
        public boolean matches(O object) {
<span class="fc" id="L182">            return query.matches(object, queryOptions);</span>
        }

        @Override
        public Query&lt;O&gt; getQuery() {
<span class="nc" id="L187">            return query;</span>
        }

        @Override
        public QueryOptions getQueryOptions() {
<span class="nc" id="L192">            return queryOptions;</span>
        }

        @Override
        public int getRetrievalCost() {
<span class="fc" id="L197">            return INDEX_RETRIEVAL_COST;</span>
        }

        // Returning the size here as the MergeCost.
        // The geoindex size isn't optimal, so there might be a better
        // measure of this.
        @Override
        public int getMergeCost() {
<span class="fc" id="L205">            return size();</span>
        }

        @Override
        public int size() {
<span class="fc" id="L210">            return getSimpleFeatureIteratorInternal((Intersects) query, queryOptions).size();</span>
        }

        @Override
        public void close() {
<span class="nc" id="L215">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>