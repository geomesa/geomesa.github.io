<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoCQEngine.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Geo-support for CQ Engine</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.memory.cqengine</a> &gt; <span class="el_source">GeoCQEngine.scala</span></div><h1>GeoCQEngine.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.memory.cqengine

import com.googlecode.cqengine.attribute.Attribute
import com.googlecode.cqengine.index.hash.HashIndex
import com.googlecode.cqengine.index.navigable.NavigableIndex
import com.googlecode.cqengine.index.radix.RadixTreeIndex
import com.googlecode.cqengine.index.unique.UniqueIndex
import com.googlecode.cqengine.query.option.DeduplicationStrategy
import com.googlecode.cqengine.query.simple.{All, Equal}
import com.googlecode.cqengine.query.{Query, QueryFactory}
import com.googlecode.cqengine.{ConcurrentIndexedCollection, IndexedCollection}
import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter._
import org.locationtech.geomesa.memory.cqengine.attribute.SimpleFeatureAttribute
import org.locationtech.geomesa.memory.cqengine.index.GeoIndexType
import org.locationtech.geomesa.memory.cqengine.index.param.{BucketIndexParam, GeoIndexParams}
import org.locationtech.geomesa.memory.cqengine.utils.CQIndexType.CQIndexType
import org.locationtech.geomesa.memory.cqengine.utils._
import org.locationtech.jts.geom.Geometry

import java.util.UUID
import scala.collection.JavaConverters._

<span class="nc bnc" id="L33" title="All 4 branches missed.">class GeoCQEngine(val sft: SimpleFeatureType,</span>
<span class="nc" id="L34">                  attributes: Seq[(String, CQIndexType)],</span>
<span class="nc" id="L35">                  enableFidIndex: Boolean = false,</span>
<span class="nc" id="L36">                  geoIndexType: GeoIndexType = GeoIndexType.Bucket,</span>
<span class="nc" id="L37">                  geoIndexParam: Option[_ &lt;: GeoIndexParams] = Option.empty,</span>
<span class="nc" id="L38">                  dedupe: Boolean = true) extends LazyLogging {</span>

<span class="nc" id="L40">  protected val cqcache: IndexedCollection[SimpleFeature] = new ConcurrentIndexedCollection[SimpleFeature]()</span>

  def this(sft: SimpleFeatureType,
           attributes: Seq[(String, CQIndexType)],
           enableFidIndex: Boolean,
           geomResolution: (Int, Int),
<span class="nc" id="L46">           dedupe: Boolean) = {</span>
<span class="nc" id="L47">    this(sft, attributes, enableFidIndex, GeoIndexType.Bucket, Option.apply(new BucketIndexParam(geomResolution._1, geomResolution._2).asInstanceOf[GeoIndexParams]), dedupe)</span>
  }


  def this(sft: SimpleFeatureType,
           attributes: Seq[(String, CQIndexType)],
           enableFidIndex: Boolean,
<span class="nc" id="L54">           geomResolution: (Int, Int)) = {</span>
<span class="nc" id="L55">    this(sft, attributes, enableFidIndex, geomResolution, true)</span>
  }

<span class="nc" id="L58">  addIndices()</span>

  /**
   * Insert a simple feature into the index
   *
   * @param feature feature
   */
<span class="nc" id="L65">  def insert(feature: SimpleFeature): Unit = cqcache.add(feature)</span>

  /**
   * Insert multiple features into the index
   *
   * @param features features
   */
<span class="nc" id="L72">  def insert(features: Iterable[SimpleFeature]): Unit = cqcache.addAll(features.asJavaCollection)</span>

  /**
   * Update an existing feature
   *
   * @param feature new feature
   * @return old feature, if any
   */
  def update(feature: SimpleFeature): SimpleFeature = {
<span class="nc" id="L81">    val existing = remove(feature.getID)</span>
<span class="nc" id="L82">    cqcache.add(feature)</span>
<span class="nc" id="L83">    existing</span>
  }

  /**
   * Remove an existing feature
   *
   * @param id feature ID
   * @return removed feature, if any
   */
  def remove(id: String): SimpleFeature = {
<span class="nc" id="L93">    val existing = get(id)</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">    if (existing != null) {</span>
<span class="nc" id="L95">      cqcache.remove(existing)</span>
    }
<span class="nc" id="L97">    existing</span>
  }

  /**
   * Return a feature by feature ID
   *
   * @param id feature id
   * @return feature, if it exists
   */
  def get(id: String): SimpleFeature = {
    // if this gets used, set enableFidIndex=true
<span class="nc" id="L108">    cqcache.retrieve(new Equal(SFTAttributes.fidAttribute, id)).asScala.headOption.orNull</span>
  }

  /**
   * Query features
   *
   * @param filter filter
   * @return
   */
  def query(filter: Filter): Iterator[SimpleFeature] = {
<span class="nc" id="L118">    val query = filter.accept(new CQEngineQueryVisitor(sft), null).asInstanceOf[Query[SimpleFeature]]</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">    val iter = if (dedupe) {</span>
<span class="nc" id="L120">      val dedupeOpt = QueryFactory.deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION)</span>
<span class="nc" id="L121">      cqcache.retrieve(query, QueryFactory.queryOptions(dedupeOpt)).iterator()</span>
    } else {
<span class="nc" id="L123">      cqcache.retrieve(query).iterator()</span>
    }
<span class="nc bnc" id="L125" title="All 2 branches missed.">    if (query.isInstanceOf[All[_]]) { iter.asScala.filter(filter.evaluate) } else { iter.asScala }</span>
  }

<span class="nc" id="L128">  def size(): Int = cqcache.size()</span>
<span class="nc" id="L129">  def clear(): Unit = cqcache.clear()</span>

  private def addIndices(): Unit = {

    import CQIndexType._

<span class="nc bnc" id="L135" title="All 2 branches missed.">    if (enableFidIndex) {</span>
<span class="nc" id="L136">      cqcache.addIndex(HashIndex.onAttribute(SFTAttributes.fidAttribute))</span>
    }

    // track attribute names in case there are duplicates...
<span class="nc" id="L140">    val names = scala.collection.mutable.Set.empty[String]</span>

    // works around casting to T &lt;: Comparable[T]
    def navigableIndex[T &lt;: Comparable[T]](name: String): NavigableIndex[T, SimpleFeature] = {
<span class="nc" id="L144">      val attribute = new SimpleFeatureAttribute(classOf[Comparable[_]], sft, name)</span>
<span class="nc" id="L145">      NavigableIndex.onAttribute(attribute.asInstanceOf[Attribute[SimpleFeature, T]])</span>
    }

<span class="nc bnc" id="L148" title="All 2 branches missed.">    attributes.foreach { case (name, indexType) =&gt;</span>
<span class="nc bnc" id="L149" title="All 8 branches missed.">      if (indexType != NONE &amp;&amp; names.add(name)) {</span>
<span class="nc" id="L150">        val descriptor = sft.getDescriptor(name)</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        require(descriptor != null, s&quot;Could not find descriptor for $name in schema ${sft.getTypeName}&quot;)</span>
<span class="nc" id="L152">        val binding = descriptor.getType.getBinding</span>
<span class="nc" id="L153">        val index = indexType match {</span>
<span class="nc bnc" id="L154" title="All 16 branches missed.">          case RADIX | DEFAULT if classOf[String].isAssignableFrom(binding) =&gt;</span>
<span class="nc" id="L155">              RadixTreeIndex.onAttribute(new SimpleFeatureAttribute(classOf[String], sft, name))</span>

<span class="nc bnc" id="L157" title="All 16 branches missed.">          case GEOMETRY | DEFAULT if classOf[Geometry].isAssignableFrom(binding) =&gt;</span>
<span class="nc" id="L158">              val attribute = new SimpleFeatureAttribute(binding.asInstanceOf[Class[Geometry]], sft, name)</span>
<span class="nc" id="L159">              GeoIndexFactory.onAttribute(sft, attribute, geoIndexType, geoIndexParam);</span>

<span class="nc bnc" id="L161" title="All 8 branches missed.">          case DEFAULT if classOf[UUID].isAssignableFrom(binding) =&gt;</span>
<span class="nc" id="L162">              UniqueIndex.onAttribute(new SimpleFeatureAttribute(classOf[UUID], sft, name))</span>

<span class="nc bnc" id="L164" title="All 4 branches missed.">          case DEFAULT if classOf[java.lang.Boolean].isAssignableFrom(binding) =&gt;</span>
<span class="nc" id="L165">              HashIndex.onAttribute(new SimpleFeatureAttribute(classOf[java.lang.Boolean], sft, name))</span>

<span class="nc bnc" id="L167" title="All 16 branches missed.">          case NAVIGABLE | DEFAULT if classOf[Comparable[_]].isAssignableFrom(binding) =&gt;</span>
<span class="nc" id="L168">            navigableIndex(name)</span>

<span class="nc bnc" id="L170" title="All 6 branches missed.">          case UNIQUE =&gt;</span>
<span class="nc" id="L171">            UniqueIndex.onAttribute(new SimpleFeatureAttribute(classOf[AnyRef], sft, name))</span>

<span class="nc bnc" id="L173" title="All 6 branches missed.">          case HASH =&gt;</span>
<span class="nc" id="L174">            HashIndex.onAttribute(new SimpleFeatureAttribute(classOf[AnyRef], sft, name))</span>

          case t =&gt;
<span class="nc" id="L177">              throw new IllegalArgumentException(s&quot;No CQEngine binding available for type $t and class $binding&quot;)</span>
        }
<span class="nc" id="L179">        cqcache.addIndex(index)</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>