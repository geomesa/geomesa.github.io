<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SizeSeparatedBucketIndex.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Geo-support for CQ Engine</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.memory.index.impl</a> &gt; <span class="el_source">SizeSeparatedBucketIndex.scala</span></div><h1>SizeSeparatedBucketIndex.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.memory.index.impl

import com.typesafe.scalalogging.StrictLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.memory.index.{SimpleFeatureSpatialIndex, SpatialIndex}
import org.locationtech.geomesa.utils.geotools.GridSnap
import org.locationtech.jts.geom.{Envelope, Geometry}

import java.util.concurrent.ConcurrentHashMap
import scala.annotation.tailrec

/**
  * Creates an index suitable for geometries with extents. The index is broken up into tiers, where each
  * geometry is assigned a tier based on its envelope size. When querying, each tier must be evaluated, so
  * if possible tiers should be matched closely to the envelopes of the entries.
  *
  * Values are indexed by the centroid of their envelope. When querying, the bounding box is expanded based
  * on the max envelope size of the tier, to ensure that all potential results are found. Thus, the false
  * positive rate tends to go up with larger tiers, and post-filtering is recommended.
  *
  * @param sizes (x, y) max envelope size for each tier
  * @param xBucketMultiplier multiplier for number of x buckets to create per tier
  * @param yBucketMultiplier multiplier for number of y buckets to create per tier
  * @param extents total area being indexed
  * @tparam T item type
  */
<span class="nc" id="L35">class SizeSeparatedBucketIndex[T](sizes: Seq[(Double, Double)] = SizeSeparatedBucketIndex.DefaultTiers,</span>
<span class="nc" id="L36">                                  xBucketMultiplier: Double = 1,</span>
<span class="nc" id="L37">                                  yBucketMultiplier: Double = 1,</span>
<span class="nc" id="L38">                                  extents: Envelope = new Envelope(-180.0, 180.0, -90.0, 90.0))</span>
<span class="nc" id="L39">    extends SpatialIndex[T] with StrictLogging {</span>

  // TODO https://geomesa.atlassian.net/browse/GEOMESA-2323 better anti-meridian handling

<span class="nc" id="L43">  require(sizes.nonEmpty, &quot;No valid tier sizes specified&quot;)</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">  require(sizes.lengthCompare(1) == 0 ||</span>
<span class="nc bnc" id="L45" title="All 16 branches missed.">      sizes.sliding(2).forall { case Seq((x1, y1), (x2, y2)) =&gt; x1 &lt;= x2 &amp;&amp; y1 &lt;= y2 },</span>
<span class="nc" id="L46">    &quot;Tiers must be ordered by increasing size&quot;)</span>

  // note: for point ops, we always use the first (smallest) tier

<span class="nc bnc" id="L50" title="All 2 branches missed.">  private val tiers = sizes.map { case (width, height) =&gt;</span>
<span class="nc" id="L51">    val xSize = math.ceil(extents.getWidth * xBucketMultiplier / width).toInt</span>
<span class="nc" id="L52">    val ySize = math.ceil(extents.getHeight * yBucketMultiplier / height).toInt</span>
    // create the buckets up front to avoid having to synchronize the whole array
    // we use a ConcurrentHashMap, which gives us iterators that aren't affected by modifications to the backing map
<span class="nc" id="L55">    val buckets = Array.fill(xSize, ySize)(new ConcurrentHashMap[String, T]())</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    logger.debug(s&quot;Creating tier for size ($width $height) with buckets [${xSize}x$ySize]&quot;)</span>
<span class="nc" id="L57">    new Tier(width, height, buckets, new GridSnap(extents, xSize, ySize))</span>
  }


  override def insert(geom: Geometry, key: String, value: T): Unit = {
<span class="nc" id="L62">    val envelope = geom.getEnvelopeInternal</span>
<span class="nc" id="L63">    val tier = selectTier(envelope)</span>
    // volatile reads should be cheaper than writes, so only update the variable if necessary
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (tier.empty) {</span>
<span class="nc" id="L66">      tier.empty = false</span>
    }
<span class="nc" id="L68">    tier.bucket(envelope).put(key, value)</span>
  }

  override def remove(geom: Geometry, key: String): T = {
<span class="nc" id="L72">    val envelope = geom.getEnvelopeInternal</span>
<span class="nc" id="L73">    selectTier(envelope).bucket(envelope).remove(key)</span>
  }

  override def get(geom: Geometry, key: String): T = {
<span class="nc" id="L77">    val envelope = geom.getEnvelopeInternal</span>
<span class="nc" id="L78">    selectTier(envelope).bucket(envelope).get(key)</span>
  }

  override def query(xmin: Double, ymin: Double, xmax: Double, ymax: Double): Iterator[T] =
<span class="nc" id="L82">    tiers.iterator.flatMap(_.iterator(xmin, ymin, xmax, ymax))</span>

<span class="nc" id="L84">  override def query(): Iterator[T] = query(extents.getMinX, extents.getMinY, extents.getMaxX, extents.getMaxY)</span>

  override def size(): Int = {
<span class="nc" id="L87">    var size = 0</span>
<span class="nc" id="L88">    tiers.foreach(tier =&gt; size += tier.size())</span>
<span class="nc" id="L89">    size</span>
  }

<span class="nc" id="L92">  override def clear(): Unit = tiers.foreach(_.clear())</span>

  private def selectTier(envelope: Envelope): Tier = {
<span class="nc" id="L95">    val width = envelope.getWidth</span>
<span class="nc" id="L96">    val height = envelope.getHeight</span>
<span class="nc bnc" id="L97" title="All 4 branches missed.">    tiers.find(t =&gt; t.maxSizeX &gt;= width &amp;&amp; t.maxSizeY &gt;= height).getOrElse {</span>
<span class="nc" id="L98">      throw new IllegalArgumentException(s&quot;Envelope $envelope exceeds the max tier size ${sizes.last}&quot;)</span>
    }
  }

<span class="nc bnc" id="L102" title="All 2 branches missed.">  private class Tier(val maxSizeX: Double,</span>
<span class="nc" id="L103">                     val maxSizeY: Double,</span>
<span class="nc" id="L104">                     buckets: Array[Array[ConcurrentHashMap[String, T]]],</span>
<span class="nc" id="L105">                     gridSnap: GridSnap) {</span>

    // we can safely use volatile instead of synchronized here, as this is a primitive boolean whose
    // state doesn't depend on its own value
    @volatile
<span class="nc" id="L110">    var empty: Boolean = true</span>

<span class="nc" id="L112">    private val maxX = buckets.length - 1</span>
<span class="nc" id="L113">    private val maxY = buckets(0).length - 1</span>

<span class="nc" id="L115">    def bucket(x: Double, y: Double): ConcurrentHashMap[String, T] = buckets(snapX(x))(snapY(y))</span>

    // the bucket is selected based on the envelope centroid
    def bucket(envelope: Envelope): ConcurrentHashMap[String, T] =
<span class="nc" id="L119">      buckets(snapX((envelope.getMinX + envelope.getMaxX) / 2.0))(snapY((envelope.getMinY + envelope.getMaxY) / 2.0))</span>

    def iterator(xmin: Double, ymin: Double, xmax: Double, ymax: Double): Iterator[T] =
<span class="nc bnc" id="L122" title="All 2 branches missed.">      if (empty) { Iterator.empty } else { new TierIterator(xmin, ymin, xmax, ymax) }</span>

    def size(): Int = {
<span class="nc bnc" id="L125" title="All 2 branches missed.">      if (empty) { 0 } else {</span>
<span class="nc" id="L126">        var size = 0</span>
<span class="nc" id="L127">        var i = 0</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        while (i &lt;= maxX) {</span>
<span class="nc" id="L129">          var j = 0</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">          while (j &lt;= maxY) {</span>
<span class="nc" id="L131">            size += buckets(i)(j).size()</span>
<span class="nc" id="L132">            j += 1</span>
          }
<span class="nc" id="L134">          i += 1</span>
        }
<span class="nc" id="L136">        size</span>
      }
    }

    def clear(): Unit = {
<span class="nc" id="L141">      var i = 0</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">      while (i &lt;= maxX) {</span>
<span class="nc" id="L143">        var j = 0</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        while (j &lt;= maxY) {</span>
<span class="nc" id="L145">          buckets(i)(j).clear()</span>
<span class="nc" id="L146">          j += 1</span>
        }
<span class="nc" id="L148">        i += 1</span>
      }
    }

    private def snapX(x: Double): Int = {
<span class="nc" id="L153">      val i = gridSnap.i(x)</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">      if (i != -1) { i } else if (x &lt; extents.getMinX) { 0 } else { maxX }</span>
    }

    private def snapY(y: Double): Int = {
<span class="nc" id="L158">      val j = gridSnap.j(y)</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">      if (j != -1) { j } else if (y &lt; extents.getMinY) { 0 } else { maxY }</span>
    }

    /**
      * Iterator over a range of buckets
      */
<span class="nc bnc" id="L165" title="All 2 branches missed.">    class TierIterator (xmin: Double, ymin: Double, xmax: Double, ymax: Double) extends Iterator[T] {</span>

<span class="nc" id="L167">      private val maxi = snapX(xmax + maxSizeX)</span>
<span class="nc" id="L168">      private val minj = snapY(ymin - maxSizeY)</span>
<span class="nc" id="L169">      private val maxj = snapY(ymax + maxSizeY)</span>

<span class="nc" id="L171">      private var i = snapX(xmin - maxSizeX)</span>
<span class="nc" id="L172">      private var j = minj</span>
<span class="nc" id="L173">      private var iter = buckets(i)(j).values.iterator() // note: `.values` is a cached view</span>

      @tailrec
<span class="nc bnc" id="L176" title="All 2 branches missed.">      override final def hasNext: Boolean = iter.hasNext || {</span>
<span class="nc bnc" id="L177" title="All 6 branches missed.">        if (i == maxi &amp;&amp; j == maxj) { false } else {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">          if (j &lt; maxj) {</span>
<span class="nc" id="L179">            j += 1</span>
          } else {
<span class="nc" id="L181">            j = minj</span>
<span class="nc" id="L182">            i += 1</span>
          }
<span class="nc" id="L184">          iter = buckets(i)(j).values.iterator() // note: `.values` is a cached view</span>
<span class="nc" id="L185">          hasNext</span>
        }
      }

<span class="nc" id="L189">      override def next(): T = iter.next()</span>
    }
  }
<span class="nc" id="L192">}</span>

<span class="nc" id="L194">object SizeSeparatedBucketIndex {</span>

  // TODO https://geomesa.atlassian.net/browse/GEOMESA-2322 these are somewhat arbitrary
<span class="nc" id="L197">  val DefaultTiers: Seq[(Double, Double)] = Seq((1, 1), (4, 4), (32, 32), (360, 180))</span>

  def apply(
      sft: SimpleFeatureType,
      tiers: Seq[(Double, Double)],
      xBucketMultiplier: Double,
      yBucketMultiplier: Double): SimpleFeatureSpatialIndex =
<span class="nc" id="L204">    new SimpleFeatureSizeSeparatedBucketIndex(sft, tiers, xBucketMultiplier, yBucketMultiplier)</span>

<span class="nc" id="L206">  private class SimpleFeatureSizeSeparatedBucketIndex(</span>
<span class="nc" id="L207">      val sft: SimpleFeatureType,</span>
      tiers: Seq[(Double, Double)],
      xBucketMultiplier: Double,
      yBucketMultiplier: Double
<span class="nc" id="L211">    ) extends SizeSeparatedBucketIndex[SimpleFeature](tiers, xBucketMultiplier, yBucketMultiplier) with SimpleFeatureSpatialIndex</span>
<span class="nc" id="L212">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>