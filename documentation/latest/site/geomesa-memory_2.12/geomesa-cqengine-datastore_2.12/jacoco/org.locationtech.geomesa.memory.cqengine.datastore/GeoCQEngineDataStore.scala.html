<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoCQEngineDataStore.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Geo-CQ Engine DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.memory.cqengine.datastore</a> &gt; <span class="el_source">GeoCQEngineDataStore.scala</span></div><h1>GeoCQEngineDataStore.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.memory.cqengine.datastore

import com.github.benmanes.caffeine.cache.{CacheLoader, Caffeine}
import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.{Query, Transaction}
import org.geotools.api.feature.`type`.Name
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.data.store.{ContentDataStore, ContentEntry, ContentFeatureStore}
import org.geotools.feature.NameImpl
import org.locationtech.geomesa.memory.cqengine.GeoCQEngine
import org.locationtech.geomesa.memory.cqengine.utils.CQIndexType

import java.util
import java.util.concurrent.ConcurrentHashMap
import scala.collection.JavaConverters._

<span class="nc bnc" id="L25" title="All 4 branches missed.">class GeoCQEngineDataStore(</span>
<span class="nc" id="L26">    useGeoIndex: Boolean,</span>
<span class="nc" id="L27">    namesToEngine: ConcurrentHashMap[String, GeoCQEngine] = new ConcurrentHashMap[String, GeoCQEngine]()</span>
<span class="nc" id="L28">  ) extends ContentDataStore with LazyLogging {</span>

<span class="nc bnc" id="L30" title="All 2 branches missed.">  logger.debug(s&quot;useGeoIndex=$useGeoIndex&quot;)</span>

  override def getFeatureSource(typeName: String, tx: Transaction): ContentFeatureStore =
<span class="nc" id="L33">    super.getFeatureSource(typeName, tx).asInstanceOf[ContentFeatureStore]</span>
  override def getFeatureSource(typeName: Name, tx: Transaction): ContentFeatureStore =
<span class="nc" id="L35">    super.getFeatureSource(typeName, tx).asInstanceOf[ContentFeatureStore]</span>
  override def getFeatureSource(typeName: Name): ContentFeatureStore =
<span class="nc" id="L37">    super.getFeatureSource(typeName).asInstanceOf[ContentFeatureStore]</span>
  override def getFeatureSource(typeName: String): ContentFeatureStore =
<span class="nc" id="L39">    super.getFeatureSource(typeName).asInstanceOf[ContentFeatureStore]</span>

  override def createFeatureSource(entry: ContentEntry): ContentFeatureStore = {
<span class="nc" id="L42">    val engine = namesToEngine.get(entry.getTypeName)</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    if (engine != null) {</span>
<span class="nc" id="L44">      new GeoCQEngineFeatureStore(engine, entry, Query.ALL)</span>
    } else {
<span class="nc" id="L46">      null</span>
    }
  }

<span class="nc" id="L50">  override def createTypeNames(): util.List[Name] = { namesToEngine.keys().asScala.toList.map { new NameImpl(_).asInstanceOf[Name] }.asJava }</span>

  override def createSchema(featureType: SimpleFeatureType): Unit = {
<span class="nc" id="L53">    namesToEngine.computeIfAbsent(featureType.getTypeName, _ =&gt; {</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">      val geo = if (!useGeoIndex) { Seq.empty } else {</span>
<span class="nc" id="L55">        Seq((featureType.getGeometryDescriptor.getLocalName, CQIndexType.GEOMETRY))</span>
      }
<span class="nc" id="L57">      val attributes = CQIndexType.getDefinedAttributes(featureType) ++ geo</span>
<span class="nc" id="L58">      new GeoCQEngine(featureType, attributes)</span>
    })
  }
}

<span class="nc" id="L63">object GeoCQEngineDataStore {</span>

<span class="nc" id="L65">  private val engines = Caffeine.newBuilder().build[(String, Boolean), ConcurrentHashMap[String, GeoCQEngine]](</span>
<span class="nc" id="L66">    new CacheLoader[(String, Boolean), ConcurrentHashMap[String, GeoCQEngine]]() {</span>
      override def load(key: (String, Boolean)): ConcurrentHashMap[String, GeoCQEngine] =
<span class="nc" id="L68">        new ConcurrentHashMap[String, GeoCQEngine]()</span>
    }
  )

<span class="nc" id="L72">  def getStore(useGeoIndex: Boolean = true, namespace: Option[String] = None): GeoCQEngineDataStore =</span>
<span class="nc" id="L73">    new GeoCQEngineDataStore(useGeoIndex, engines.get((namespace.getOrElse(&quot;&quot;), useGeoIndex)))</span>
<span class="nc" id="L74">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>