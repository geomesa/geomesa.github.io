<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoCQEngineFeatureStore.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Geo-CQ Engine DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.memory.cqengine.datastore</a> &gt; <span class="el_source">GeoCQEngineFeatureStore.scala</span></div><h1>GeoCQEngineFeatureStore.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.memory.cqengine.datastore

import org.geotools.api.data._
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.data.collection.DelegateFeatureReader
import org.geotools.data.store.{ContentEntry, ContentFeatureStore}
import org.geotools.feature.collection.DelegateFeatureIterator
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.features.ScalaSimpleFeature.ImmutableSimpleFeature
import org.locationtech.geomesa.memory.cqengine.GeoCQEngine
import org.locationtech.geomesa.memory.cqengine.datastore.GeoCQEngineFeatureStore.{GeoCQEngineFeatureWriter, GeoCQEngineQueryCapabilities}

import java.util.UUID
import java.util.concurrent.atomic.AtomicLong

<span class="nc" id="L26">class GeoCQEngineFeatureStore(engine: GeoCQEngine, entry: ContentEntry, query: Query) extends</span>
<span class="nc" id="L27">  ContentFeatureStore(entry, query) {</span>

  import scala.collection.JavaConverters._

  override def getWriterInternal(query: Query, flags: Int): FeatureWriter[SimpleFeatureType, SimpleFeature] =
<span class="nc" id="L32">    new GeoCQEngineFeatureWriter(engine)</span>

<span class="nc" id="L34">  override def buildFeatureType(): SimpleFeatureType = engine.sft</span>

<span class="nc" id="L36">  override def getBoundsInternal(query: Query): ReferencedEnvelope = null</span>

<span class="nc" id="L38">  override def getCountInternal(query: Query): Int = engine.query(query.getFilter).length</span>

  override def getReaderInternal(query: Query): FeatureReader[SimpleFeatureType, SimpleFeature] =
<span class="nc" id="L41">    new DelegateFeatureReader(engine.sft, new DelegateFeatureIterator(engine.query(query.getFilter).asJava))</span>

<span class="nc" id="L43">  override def getQueryCapabilities: QueryCapabilities = GeoCQEngineQueryCapabilities</span>

<span class="nc" id="L45">  override def canEvent: Boolean = true</span>
}

<span class="nc" id="L48">object GeoCQEngineFeatureStore {</span>

<span class="nc" id="L50">  object GeoCQEngineQueryCapabilities extends QueryCapabilities {</span>
<span class="nc" id="L51">    override def isUseProvidedFIDSupported = true</span>
  }

<span class="nc" id="L54">  class GeoCQEngineFeatureWriter(engine: GeoCQEngine) extends SimpleFeatureWriter {</span>

<span class="nc" id="L56">    private val tempFeatureIds = new AtomicLong(0)</span>
<span class="nc" id="L57">    private val currentFeature: ScalaSimpleFeature = new ScalaSimpleFeature(engine.sft, &quot;&quot;)</span>
<span class="nc" id="L58">    private var queued = false</span>

<span class="nc" id="L60">    override def getFeatureType: SimpleFeatureType = engine.sft</span>

<span class="nc" id="L62">    override def hasNext: Boolean = false</span>

    override def next(): SimpleFeature = {
<span class="nc" id="L65">      var i = 0</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">      while (i &lt; engine.sft.getAttributeCount) {</span>
<span class="nc" id="L67">        currentFeature.setAttributeNoConvert(i, null)</span>
<span class="nc" id="L68">        i += 1</span>
      }
<span class="nc" id="L70">      currentFeature.getUserData.clear()</span>
<span class="nc" id="L71">      currentFeature.setId(tempFeatureIds.getAndIncrement().toString)</span>
<span class="nc" id="L72">      queued = true</span>
<span class="nc" id="L73">      currentFeature</span>
    }

    override def write(): Unit = {
<span class="nc bnc" id="L77" title="All 2 branches missed.">      if (!queued) {</span>
<span class="nc" id="L78">        throw new IllegalStateException(&quot;Must call 'next' before 'write'&quot;)</span>
      }
<span class="nc" id="L80">      val values = Array.tabulate(engine.sft.getAttributeCount)(currentFeature.getAttribute)</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      val id = if (currentFeature.getUserData.containsKey(Hints.PROVIDED_FID)) {</span>
<span class="nc" id="L82">        currentFeature.getUserData.get(Hints.PROVIDED_FID).toString</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      } else if (currentFeature.getUserData.containsKey(Hints.USE_PROVIDED_FID) &amp;&amp;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">          currentFeature.getUserData.get(Hints.USE_PROVIDED_FID).asInstanceOf[Boolean]) {</span>
<span class="nc" id="L85">        currentFeature.getID</span>
      } else {
<span class="nc" id="L87">        UUID.randomUUID.toString</span>
      }
<span class="nc" id="L89">      val userData = new java.util.HashMap[AnyRef, AnyRef](currentFeature.getUserData)</span>
<span class="nc" id="L90">      engine.update(new ImmutableSimpleFeature(engine.sft, id, values, userData))</span>
<span class="nc" id="L91">      queued = false</span>
    }

<span class="nc" id="L94">    override def remove(): Unit = throw new UnsupportedOperationException()</span>

<span class="nc" id="L96">    override def close(): Unit = {}</span>
  }
<span class="nc" id="L98">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>