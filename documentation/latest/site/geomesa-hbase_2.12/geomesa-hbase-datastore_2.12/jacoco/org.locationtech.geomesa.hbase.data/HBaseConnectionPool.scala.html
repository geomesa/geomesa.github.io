<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HBaseConnectionPool.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa HBase DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.hbase.data</a> &gt; <span class="el_source">HBaseConnectionPool.scala</span></div><h1>HBaseConnectionPool.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.hbase.data

import com.github.benmanes.caffeine.cache.{CacheLoader, Caffeine, LoadingCache}
import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.hbase.client.{Connection, ConnectionFactory, HBaseAdmin}
import org.apache.hadoop.hbase.security.User
import org.apache.hadoop.hbase.security.token.AuthenticationTokenIdentifier
import org.apache.hadoop.hbase.{HBaseConfiguration, HConstants}
import org.apache.hadoop.security.authentication.util.KerberosUtil
import org.apache.hadoop.security.{SecurityUtil, UserGroupInformation}
import org.locationtech.geomesa.hbase.HBaseSystemProperties
import org.locationtech.geomesa.hbase.data.HBaseDataStoreFactory.{HBaseGeoMesaKeyTab, HBaseGeoMesaPrincipal}
import org.locationtech.geomesa.hbase.data.HBaseDataStoreParams.{ConfigPathsParam, ConfigsParam, ConnectionParam, ZookeeperParam}
import org.locationtech.geomesa.utils.hadoop.HadoopUtils
import org.locationtech.geomesa.utils.io.CloseWithLogging

import java.io.{ByteArrayInputStream, Closeable}
import java.nio.charset.StandardCharsets
import java.security.PrivilegedExceptionAction
import scala.util.{Failure, Success, Try}

<span class="nc bnc" id="L31" title="All 4 branches missed.">object HBaseConnectionPool extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L35">  private val configs: LoadingCache[ConfigKey, Configuration] = Caffeine.newBuilder().build(</span>
<span class="nc" id="L36">    new CacheLoader[ConfigKey, Configuration] {</span>

      // add common resources from system property - lazy to allow object initialization if there's an error
<span class="nc bnc" id="L39" title="All 4 branches missed.">      private lazy val configuration = {</span>
<span class="nc" id="L40">        val base = HBaseConfiguration.create()</span>
<span class="nc" id="L41">        HBaseSystemProperties.ConfigPathProperty.option.foreach(addResources(base, _))</span>
<span class="nc" id="L42">        base</span>
      }

      override def load(key: ConfigKey): Configuration = {
<span class="nc" id="L46">        val conf = new Configuration(configuration)</span>
        // Make sure that current user is always logged-in user
<span class="nc" id="L48">        conf.set(&quot;hbase.client.userprovider.class&quot;, &quot;org.locationtech.geomesa.hbase.data.LoginUserProvider&quot;)</span>
        // add the explicit props first, they may be needed for loading the path resources
<span class="nc" id="L50">        key.xml.foreach(xml =&gt; conf.addResource(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8))))</span>
<span class="nc" id="L51">        key.paths.foreach(addResources(conf, _))</span>
<span class="nc" id="L52">        key.zookeepers.foreach(zk =&gt; conf.set(HConstants.ZOOKEEPER_QUORUM, zk))</span>
<span class="nc bnc" id="L53" title="All 8 branches missed.">        if (key.zookeepers.isEmpty &amp;&amp; conf.get(HConstants.ZOOKEEPER_QUORUM) == &quot;localhost&quot;) {</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">          logger.warn(&quot;HBase connection is set to localhost - &quot; +</span>
              &quot;this may indicate that 'hbase-site.xml' is not on the classpath&quot;)
        }
<span class="nc" id="L57">        conf</span>
      }

      private def addResources(conf: Configuration, paths: String): Unit =
<span class="nc" id="L61">        paths.split(',').map(_.trim).filterNot(_.isEmpty).foreach(HadoopUtils.addResource(conf, _))</span>
    }
  )

<span class="nc" id="L65">  private val connections: LoadingCache[(Configuration, Boolean), CachedConnection] =  Caffeine.newBuilder().build(</span>
<span class="nc" id="L66">    new CacheLoader[(Configuration, Boolean), CachedConnection] {</span>
      override def load(key: (Configuration, Boolean)): CachedConnection = {
<span class="nc" id="L68">        createConnection(key._1, key._2) match {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">          case SingletonConnection(connection, kerberos) =&gt; CachedConnection(connection, kerberos)</span>
<span class="nc" id="L70">          case c =&gt; throw new UnsupportedOperationException(s&quot;Expected SingletonConnection but got $c&quot;)</span>
        }
      }
    }
  )

<span class="nc" id="L76">  Runtime.getRuntime.addShutdownHook(new Thread() {</span>
    override def run(): Unit =
<span class="nc bnc" id="L78" title="All 2 branches missed.">      CloseWithLogging(connections.asMap().values().asScala.flatMap { case CachedConnection(c, k) =&gt; Seq(c) ++ k })</span>
  })

  /**
   * Get (or create) a cached configuration
   *
   * @param params data store params
   * @return
   */
  def getConfiguration(params: java.util.Map[String, _]): Configuration = {
<span class="nc" id="L88">    val zk = ZookeeperParam.lookupOpt(params)</span>
<span class="nc" id="L89">    val paths = ConfigPathsParam.lookupOpt(params)</span>
<span class="nc" id="L90">    val xml = ConfigsParam.lookupOpt(params)</span>
<span class="nc" id="L91">    configs.get(ConfigKey(zk, paths, xml))</span>
  }

  /**
   * Get (or create) a cached connection
   *
   * @param params data store params
   * @param validate validate the connection after creation, or not
   * @return
   */
  def getConnection(params: java.util.Map[String, _], validate: Boolean): ConnectionWrapper = {
<span class="nc bnc" id="L102" title="All 2 branches missed.">    if (ConnectionParam.exists(params)) {</span>
<span class="nc" id="L103">      ProvidedConnection(ConnectionParam.lookup(params))</span>
    } else {
<span class="nc" id="L105">      val conf = getConfiguration(params)</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">      logger.debug(s&quot;Connecting to HBase instance at ${conf.get(HConstants.ZOOKEEPER_QUORUM)}&quot;)</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">      if (HBaseDataStoreParams.CacheConnectionsParam.lookup(params)) {</span>
<span class="nc" id="L108">        connections.get((conf, validate))</span>
      } else {
<span class="nc" id="L110">        createConnection(conf, validate)</span>
      }
    }
  }

  /**
   * Create a new connection (not pooled)
   *
   * @param conf hbase configuration
   * @param validate validate the connection after creation, or not
   * @return
   */
<span class="nc" id="L122">  def createConnection(conf: Configuration, validate: Boolean): ConnectionWrapper = {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">    if (User.isHBaseSecurityEnabled(conf)) {</span>
<span class="nc" id="L124">      configureSecurity(conf)</span>
<span class="nc" id="L125">      val action = new PrivilegedExceptionAction[ConnectionWrapper]() {</span>
<span class="nc" id="L126">        override def run(): ConnectionWrapper = doCreateConnection(conf, validate)</span>
      }
<span class="nc" id="L128">      val user = UserGroupInformation.getLoginUser</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      logger.info(s&quot;Creating Secured HBase connection with user $user&quot;)</span>
<span class="nc" id="L130">      user.doAs(action)</span>
    } else {
<span class="nc bnc" id="L132" title="All 2 branches missed.">      logger.info(s&quot;Creating unsecured HBase connection&quot;)</span>
<span class="nc" id="L133">      doCreateConnection(conf, validate)</span>
    }
  }

  private def doCreateConnection(conf: Configuration, validate: Boolean): ConnectionWrapper = {
<span class="nc bnc" id="L138" title="All 2 branches missed.">    if (validate) {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">      logger.debug(&quot;Checking configuration availability&quot;)</span>
<span class="nc" id="L140">      HBaseAdmin.available(conf)</span>
    }
<span class="nc" id="L142">    val connection = ConnectionFactory.createConnection(conf)</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">    val kerberos = if (User.isHBaseSecurityEnabled(conf)) { Some(HadoopUtils.kerberosTicketRenewer()) } else { None }</span>
<span class="nc" id="L144">    SingletonConnection(connection, kerberos)</span>
  }

  /**
   * Configures hadoop security, based on the configuration.
   *
   * Note: hadoop security is configured globally - having different security settings in a single JVM
   * will likely result in errors
   *
   * @param conf conf
   */
  def configureSecurity(conf: Configuration): Unit = synchronized {
    import AuthenticationTokenIdentifier.AUTH_TOKEN_TYPE

<span class="nc bnc" id="L158" title="All 2 branches missed.">    if (User.isHBaseSecurityEnabled(conf)) {</span>
<span class="nc" id="L159">      val currentUser = UserGroupInformation.getLoginUser</span>
<span class="nc bnc" id="L160" title="All 8 branches missed.">      if (currentUser.getCredentials.getAllTokens.asScala.exists(_.getKind == AUTH_TOKEN_TYPE)) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        logger.debug(&quot;Using existing HBase authentication token&quot;)</span>
      } else {
<span class="nc" id="L163">        val keytab = conf.get(HBaseGeoMesaKeyTab)</span>
<span class="nc" id="L164">        val rawPrincipal = conf.get(HBaseGeoMesaPrincipal)</span>

<span class="nc bnc" id="L166" title="All 4 branches missed.">        if (keytab == null || rawPrincipal == null) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">          lazy val missing =</span>
<span class="nc bnc" id="L168" title="All 8 branches missed.">            Seq(HBaseGeoMesaKeyTab -&gt; keytab, HBaseGeoMesaPrincipal -&gt; rawPrincipal).collect { case (k, null) =&gt; k }</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">          logger.warn(s&quot;Security is enabled but missing credentials under '${missing.mkString(&quot;' and '&quot;)}'&quot;)</span>
        } else {
<span class="nc" id="L171">          val principal = fullPrincipal(rawPrincipal)</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">          lazy val principalMsg =</span>
            s&quot;'$principal'${if (principal == rawPrincipal) { &quot;&quot; } else { s&quot; (original '$rawPrincipal')&quot;}}&quot;
<span class="nc bnc" id="L175" title="All 2 branches missed.">          logger.debug(</span>
<span class="nc" id="L176">            s&quot;Using Kerberos with principal $principalMsg, keytab '$keytab', &quot; +</span>
<span class="nc" id="L177">                s&quot;and Hadoop authentication method '${SecurityUtil.getAuthenticationMethod(conf)}'&quot;)</span>

<span class="nc bnc" id="L179" title="All 8 branches missed.">          if (currentUser.hasKerberosCredentials &amp;&amp; currentUser.getUserName == principal) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            logger.debug(s&quot;User '$principal' is already authenticated&quot;)</span>
          } else {
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (currentUser.hasKerberosCredentials) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">              logger.warn(</span>
<span class="nc" id="L184">                s&quot;Changing global authenticated Hadoop user from '${currentUser.getUserName}' to '$principal' -&quot; +</span>
<span class="nc" id="L185">                    &quot;this will affect any connections still using the old user&quot;)</span>
            }
<span class="nc" id="L187">            UserGroupInformation.setConfiguration(conf)</span>
<span class="nc" id="L188">            UserGroupInformation.loginUserFromKeytab(principal, keytab)</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">            logger.debug(s&quot;Logged into Hadoop with user '${UserGroupInformation.getLoginUser.getUserName}'&quot;)</span>
          }
        }
      }
    }
  }

  /**
   * Replace _HOST with the current host and add the default realm if nothing is specified.
   *
   * `SecurityUtil.getServerPrincipal` will replace the _HOST but only if there is already a realm.
   *
   * @param principal kerberos principal
   * @return
   */
  private def fullPrincipal(principal: String): String = {
<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (principal.indexOf('@') != -1) {</span>
      // we have a realm so this should be work to replace _HOST if present
<span class="nc" id="L208">      SecurityUtil.getServerPrincipal(principal, null: String)</span>
    } else {
      // try to add the default realm and replace _HOST if present
<span class="nc" id="L211">      Try(KerberosUtil.getDefaultRealm) match {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        case Success(realm) =&gt; SecurityUtil.getServerPrincipal(s&quot;$principal@$realm&quot;, null: String)</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        case Failure(e) =&gt;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">          logger.warn(s&quot;Unable to get default Kerberos realm: $e&quot;)</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">          if (!principal.contains(SecurityUtil.HOSTNAME_PATTERN)) { principal } else {</span>
            // append a fake realm so that the _HOST replacement works and then remove it afterwards
<span class="nc" id="L217">            SecurityUtil.getServerPrincipal(s&quot;$principal@foo&quot;, null: String).dropRight(4)</span>
          }
      }
    }
  }

  /**
   * Managed connection. The connection itself should not be closed - instead close the wrapper to handle
   * lifecycle events appropriately.
   */
  sealed trait ConnectionWrapper extends Closeable {
    val connection: Connection
  }

  /**
   * An unshared connection
   *
   * @param connection connection
   * @param kerberos kerberos ticket renewal thread
   */
<span class="nc bnc" id="L237" title="All 25 branches missed.">  case class SingletonConnection(connection: Connection, kerberos: Option[Closeable]) extends ConnectionWrapper {</span>
<span class="nc" id="L238">    override def close(): Unit = CloseWithLogging(kerberos.toSeq ++ Seq(connection))</span>
  }

  /**
   * A shared, cached connection
   *
   * @param connection connection
   * @param kerberos kerberos ticket renewal thread
   */
<span class="nc bnc" id="L247" title="All 25 branches missed.">  case class CachedConnection(connection: Connection, kerberos: Option[Closeable]) extends ConnectionWrapper {</span>
<span class="nc" id="L248">    override def close(): Unit = {}</span>
  }

  /**
   * Provided connection - no lifecycle management is performed
   *
   * @param connection connection
   */
<span class="nc bnc" id="L256" title="All 18 branches missed.">  case class ProvidedConnection(connection: Connection) extends ConnectionWrapper {</span>
<span class="nc" id="L257">    override def close(): Unit = {}</span>
  }

<span class="nc bnc" id="L260" title="All 32 branches missed.">  private case class ConfigKey(zookeepers: Option[String], paths: Option[String], xml: Option[String])</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>