<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaCoprocessor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa HBase RPC</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.hbase.rpc.coprocessor</a> &gt; <span class="el_source">GeoMesaCoprocessor.scala</span></div><h1>GeoMesaCoprocessor.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.hbase.rpc.coprocessor

import com.google.protobuf.ByteString
import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.hbase.TableName
import org.apache.hadoop.hbase.client.{Connection, Scan}
import org.locationtech.geomesa.hbase.proto.GeoMesaProto.GeoMesaCoprocessorService
import org.locationtech.geomesa.index.utils.ThreadManagement.Timeout
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.concurrent.CachedThreadPool
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.io.WithClose

import java.io._
import java.util.concurrent._

/**
 * Client-side coprocessor execution and common functions
 */
<span class="nc bnc" id="L28" title="All 4 branches missed.">object GeoMesaCoprocessor extends LazyLogging {</span>

<span class="nc" id="L30">  val GeoMesaHBaseRequestVersion = 1</span>

<span class="nc" id="L32">  val AggregatorClass = &quot;geomesa.hbase.aggregator.class&quot;</span>

<span class="nc" id="L34">  val FilterOpt  = &quot;filter&quot;</span>
<span class="nc" id="L35">  val ScanOpt    = &quot;scan&quot;</span>
<span class="nc" id="L36">  val TimeoutOpt = &quot;timeout&quot;</span>
<span class="nc" id="L37">  val YieldOpt   = &quot;yield&quot;</span>

<span class="nc" id="L39">  private val service = classOf[GeoMesaCoprocessorService]</span>

<span class="nc" id="L41">  private val terminator = ByteString.EMPTY</span>

  def deserializeOptions(bytes: Array[Byte]): Map[String, String] = {
<span class="nc" id="L44">    WithClose(new ByteArrayInputStream(bytes)) { bais =&gt;</span>
<span class="nc" id="L45">      WithClose(new ObjectInputStream(bais)) { ois =&gt;</span>
<span class="nc" id="L46">        ois.readObject.asInstanceOf[Map[String, String]]</span>
      }
    }
  }

  @throws[IOException]
  private [coprocessor] def serializeOptions(map: Map[String, String]): Array[Byte] = {
<span class="nc" id="L53">    WithClose(new ByteArrayOutputStream) { baos =&gt;</span>
<span class="nc" id="L54">      WithClose(new ObjectOutputStream(baos)) { oos =&gt;</span>
<span class="nc" id="L55">        oos.writeObject(map)</span>
<span class="nc" id="L56">        oos.flush()</span>
      }
<span class="nc" id="L58">      baos.toByteArray</span>
    }
  }

  /**
   * Executes a geomesa coprocessor
   *
   * @param connection connection
   * @param table table to execute against
   * @param scan scan to execute
   * @param options configuration options
   * @param executor executor service to use for hbase rpc calls
   * @return serialized results
   */
  def execute(
      connection: Connection,
      table: TableName,
      scan: Scan,
      options: Map[String, String],
      executor: ExecutorService): CloseableIterator[ByteString] = {
<span class="nc" id="L78">    new RpcIterator(connection, table, scan, options, executor)</span>
  }

  /**
   * Timeout coprocessor configuration options
   *
   * @param t timeout
   * @return
   */
<span class="nc" id="L87">  def timeout(t: Timeout): (String, String) = TimeoutOpt -&gt; java.lang.Long.toString(t.absolute)</span>

  /**
   * Closeable iterator implementation for invoking coprocessor rpcs
   *
   * @param table hbase table (not closed by this iterator)
   * @param scan scan (note: may be mutated)
   * @param options coprocessor options
   */
<span class="nc" id="L96">  private class RpcIterator(</span>
      connection: Connection,
      table: TableName,
<span class="nc" id="L99">      scan: Scan,</span>
<span class="nc" id="L100">      options: Map[String, String],</span>
      pool: ExecutorService
<span class="nc" id="L102">    ) extends CloseableIterator[ByteString] {</span>

<span class="nc" id="L104">    private var staged: ByteString = _</span>

<span class="nc" id="L106">    private val htable = connection.getTable(table, pool)</span>
<span class="nc" id="L107">    private val resultQueue = new LinkedBlockingQueue[ByteString]()</span>
<span class="nc" id="L108">    private val call = CachedThreadPool.submit(new CoprocessorInvoker())</span>

    override def hasNext: Boolean = {
<span class="nc bnc" id="L111" title="All 2 branches missed.">      if (staged != null) { true } else {</span>
        try {
<span class="nc" id="L113">          staged = resultQueue.take()</span>
        } catch {
          case _ :InterruptedException =&gt;
            // propagate the interruption through to the rpc call
<span class="nc" id="L117">            call.cancel(true)</span>
<span class="nc" id="L118">            return false</span>
        }
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (terminator eq staged) {</span>
<span class="nc" id="L121">          resultQueue.add(staged)</span>
<span class="nc" id="L122">          staged = null</span>
<span class="nc" id="L123">          false</span>
        } else {
<span class="nc" id="L125">          true</span>
        }
      }
    }

    override def next(): ByteString = {
<span class="nc" id="L131">      val res = staged</span>
<span class="nc" id="L132">      staged = null</span>
<span class="nc" id="L133">      res</span>
    }

<span class="nc" id="L136">    override def close(): Unit = htable.close()</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">    class CoprocessorInvoker extends Runnable() {</span>
      override def run(): Unit = {
<span class="nc" id="L140">        try {</span>
<span class="nc" id="L141">          val callback = new GeoMesaHBaseCallBack(scan, options, resultQueue)</span>
<span class="nc" id="L142">          var i = 0</span>
          // if the scan hasn't been killed and we are not done, issue a new request
<span class="nc bnc" id="L144" title="All 2 branches missed.">          while (callback.hasNext) {</span>
<span class="nc" id="L145">            val next = callback.next</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            logger.trace(</span>
<span class="nc" id="L147">              s&quot;Calling htable.coprocessorService (call ${i += 1; i}): &quot; +</span>
<span class="nc" id="L148">                  s&quot;${ByteArrays.printable(next.getStartRow)} to ${ByteArrays.printable(next.getStopRow)}&quot;)</span>
<span class="nc" id="L149">            htable.coprocessorService(service, next.getStartRow, next.getStopRow, callback.callable, callback)</span>
          }
        } catch {
<span class="nc bnc" id="L152" title="All 6 branches missed.">          case e @ (_ :InterruptedException | _ :InterruptedIOException) =&gt;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            logger.warn(&quot;Interrupted executing coprocessor query:&quot;, e)</span>
        } finally {
<span class="nc" id="L155">          resultQueue.add(terminator)</span>
        }
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>