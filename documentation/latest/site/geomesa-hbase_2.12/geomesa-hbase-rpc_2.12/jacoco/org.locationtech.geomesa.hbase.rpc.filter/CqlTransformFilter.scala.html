<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CqlTransformFilter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa HBase RPC</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.hbase.rpc.filter</a> &gt; <span class="el_source">CqlTransformFilter.scala</span></div><h1>CqlTransformFilter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.hbase.rpc.filter

import com.typesafe.scalalogging.StrictLogging
import org.apache.hadoop.hbase.exceptions.DeserializationException
import org.apache.hadoop.hbase.filter.Filter.ReturnCode
import org.apache.hadoop.hbase.filter.FilterBase
import org.apache.hadoop.hbase.{Cell, KeyValue}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.filter.text.ecql.ECQL
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.SerializationOption
import org.locationtech.geomesa.features.kryo.{KryoBufferSimpleFeature, KryoFeatureSerializer}
import org.locationtech.geomesa.hbase.filters.JSimpleFeatureFilter
import org.locationtech.geomesa.hbase.rpc.filter.CqlTransformFilter.DelegateFilter
import org.locationtech.geomesa.index.api.{FilterStrategy, GeoMesaFeatureIndex, IndexKeySpace}
import org.locationtech.geomesa.index.conf.FilterCompatibility
import org.locationtech.geomesa.index.conf.QueryHints.RichHints
import org.locationtech.geomesa.index.iterators.{IteratorCache, SamplingIterator}
import org.locationtech.geomesa.utils.conf.GeoMesaProperties
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.index.{ByteArrays, IndexMode}

import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets
import scala.util.control.NonFatal

/**
  * HBase filter for CQL predicates and transformations
  *
  * The internal processing logic is kept in a delegate filter that will do either filtering, transforming, or both.
  *
  * @param delegate delegate filter
  */
<span class="nc" id="L43">class CqlTransformFilter(delegate: DelegateFilter) extends FilterBase {</span>

  /**
    * From the Filter javadocs:
    *
    * A filter can expect the following call sequence:
    *
    * &lt;ul&gt;
    * &lt;li&gt; `reset()` : reset the filter state before filtering a new row. &lt;/li&gt;
    * &lt;li&gt; `filterAllRemaining()`: true means row scan is over; false means keep going. &lt;/li&gt;
    * &lt;li&gt; `filterRowKey(byte[],int,int)`: true means drop this row; false means include.&lt;/li&gt;
    * &lt;li&gt; `filterKeyValue(Cell)`: decides whether to include or exclude this KeyValue. See `ReturnCode`. &lt;/li&gt;
    * &lt;li&gt; `transform(KeyValue)`: if the KeyValue is included, let the filter transform the KeyValue. &lt;/li&gt;
    * &lt;li&gt; `filterRowCells(List)`: allows direct modification of the final list to be submitted
    * &lt;li&gt; `filterRow()`: last chance to drop entire row based on the sequence of
    *   filter calls. Eg: filter a row if it doesn't contain a specified column. &lt;/li&gt;
    * &lt;/ul&gt;
    */

<span class="nc" id="L62">  override def filterKeyValue(v: Cell): ReturnCode = delegate.filterKeyValue(v)</span>
<span class="nc" id="L63">  override def transformCell(v: Cell): Cell = delegate.transformCell(v)</span>
<span class="nc" id="L64">  override def toByteArray: Array[Byte] = CqlTransformFilter.serialize(delegate)</span>
<span class="nc" id="L65">  override def toString: String = delegate.toString</span>
}

<span class="nc" id="L68">object CqlTransformFilter extends StrictLogging {</span>

<span class="nc" id="L70">  val Priority: Int = 30</span>

  /**
    * Override of static method from org.apache.hadoop.hbase.filter.Filter
    *
    * @param pbBytes serialized bytes
    * @throws org.apache.hadoop.hbase.exceptions.DeserializationException serialization exception
    * @return
    */
  @throws(classOf[DeserializationException])
  def parseFrom(pbBytes: Array[Byte]): org.apache.hadoop.hbase.filter.Filter =
<span class="nc" id="L81">    new CqlTransformFilter(deserialize(pbBytes))</span>

  /**
    * Create a new filter. Typically, filters created by this method will just be serialized to bytes and sent
    * as part of an HBase scan
    *
    * Note: calling this without at least one of the cql filter or transform would introduce extra processing
    * but not actually do anything, and thus is not allowed
    *
    * @param sft simple feature type
    * @param filter cql filter, if any
    * @param transform transform, if any
    * @param hints is used to get sampling options
    * @return
    */
  def apply(
      sft: SimpleFeatureType,
      index: GeoMesaFeatureIndex[_, _],
      filter: Option[Filter],
      transform: Option[(String, SimpleFeatureType)],
      hints: Hints): CqlTransformFilter = {
<span class="nc bnc" id="L102" title="All 6 branches missed.">    if (filter.isEmpty &amp;&amp; transform.isEmpty &amp;&amp; hints.getSampling.isEmpty) {</span>
<span class="nc" id="L103">      throw new IllegalArgumentException(&quot;The filter must have a predicate and/or transform&quot;)</span>
    }

<span class="nc" id="L106">    val feature = KryoFeatureSerializer(sft, SerializationOption.WithoutId).getReusableFeature</span>
<span class="nc" id="L107">    feature.setIdParser(index.getIdFromRow(_, _, _, null))</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">    transform.foreach { case (tdefs, tsft) =&gt; feature.setTransforms(tdefs, tsft) }</span>

<span class="nc" id="L110">    val samplingOpts: Option[(Float, Option[String])] = hints.getSampling</span>

<span class="nc bnc" id="L112" title="All 10 branches missed.">    val delegate = (filter, transform, samplingOpts) match {</span>
<span class="nc bnc" id="L113" title="All 6 branches missed.">      case (None, None, Some(_))    =&gt; new FilterDelegate(sft, index, feature, Filter.INCLUDE, samplingOpts)</span>
<span class="nc bnc" id="L114" title="All 6 branches missed.">      case (None, Some(_), Some(_)) =&gt; new FilterTransformDelegate(sft, index, feature, Filter.INCLUDE, samplingOpts)</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">      case (Some(f), None , _)      =&gt; new FilterDelegate(sft, index, feature, f, samplingOpts)</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">      case (Some(f), Some(_), _)    =&gt; new FilterTransformDelegate(sft, index, feature, f, samplingOpts)</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">      case (None, Some(_), _)       =&gt; new TransformDelegate(sft, index, feature, samplingOpts)</span>
    }

    // noinspection ScalaDeprecation
<span class="nc" id="L121">    hints.getFilterCompatibility match {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">      case None =&gt; new CqlTransformFilter(delegate)</span>
<span class="nc bnc" id="L123" title="All 8 branches missed.">      case Some(FilterCompatibility.`2.3`) =&gt; new JSimpleFeatureFilter(delegate)</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">      case Some(c) =&gt; throw new UnsupportedOperationException(s&quot;Filter compatibility $c is not implemented for this query&quot;)</span>
    }
  }

  /**
    * Full serialization of the delegate filter
    *
    * @param delegate delegate filter
    * @return
    */
  private def serialize(delegate: DelegateFilter): Array[Byte] = {
<span class="nc" id="L135">    val sftBytes = SimpleFeatureTypes.encodeType(delegate.sft, includeUserData = true).getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L136">    val cqlBytes = delegate.filter.map(ECQL.toCQL(_).getBytes(StandardCharsets.UTF_8)).getOrElse(Array.empty)</span>
<span class="nc" id="L137">    val indexBytes = delegate.index.identifier.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc bnc" id="L138" title="All 12 branches missed.">    val indexSftBytes = if (delegate.index == NullFeatureIndex || delegate.index.sft == delegate.sft) { Array.empty[Byte] } else {</span>
<span class="nc" id="L139">      SimpleFeatureTypes.encodeType(delegate.index.sft, includeUserData = true).getBytes(StandardCharsets.UTF_8)</span>
    }
<span class="nc" id="L141">    val samplingFactor: Option[Float] = delegate.samplingOptions.map(s =&gt; s._1)</span>
<span class="nc" id="L142">    val samplingField: Option[String] = delegate.samplingOptions.flatMap(s =&gt; s._2)</span>

<span class="nc" id="L144">    val samplingFactorBytes = samplingFactor.map(f =&gt; ByteBuffer.allocate(4).putFloat(f).array()).getOrElse(Array.empty)</span>
<span class="nc" id="L145">    val samplingFieldBytes = samplingField.map(field =&gt; field.getBytes(StandardCharsets.UTF_8)).getOrElse(Array.empty)</span>

<span class="nc" id="L147">    val version = GeoMesaProperties.ProjectVersion.getBytes(StandardCharsets.UTF_8)</span>

<span class="nc" id="L149">    delegate.transform match {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">      case None =&gt;</span>
        val array =
<span class="nc" id="L152">          Array.ofDim[Byte](sftBytes.length + cqlBytes.length +</span>
<span class="nc" id="L153">              indexBytes.length + indexSftBytes.length + samplingFactorBytes.length +</span>
<span class="nc" id="L154">              samplingFieldBytes.length + version.length + 4*8) // 4 bytes (length info) per 8 fields</span>

<span class="nc" id="L156">        var offset = 0</span>
<span class="nc" id="L157">        ByteArrays.writeInt(sftBytes.length, array, offset)</span>
<span class="nc" id="L158">        offset += 4</span>
<span class="nc" id="L159">        System.arraycopy(sftBytes, 0, array, offset, sftBytes.length)</span>
<span class="nc" id="L160">        offset += sftBytes.length</span>
<span class="nc" id="L161">        ByteArrays.writeInt(cqlBytes.length, array, offset)</span>
<span class="nc" id="L162">        offset += 4</span>
<span class="nc" id="L163">        System.arraycopy(cqlBytes, 0, array, offset, cqlBytes.length)</span>
<span class="nc" id="L164">        offset += cqlBytes.length</span>
        // write out a -1 to indicate that there aren't any transforms
<span class="nc" id="L166">        ByteArrays.writeInt(-1, array, offset)</span>
<span class="nc" id="L167">        offset += 4</span>
<span class="nc" id="L168">        ByteArrays.writeInt(indexBytes.length, array, offset)</span>
<span class="nc" id="L169">        offset += 4</span>
<span class="nc" id="L170">        System.arraycopy(indexBytes, 0, array, offset, indexBytes.length)</span>
<span class="nc" id="L171">        offset += indexBytes.length</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (indexSftBytes.isEmpty) {</span>
<span class="nc bnc" id="L173" title="All 6 branches missed.">          if (delegate.index == NullFeatureIndex) {</span>
<span class="nc" id="L174">            ByteArrays.writeInt(-1, array, offset)</span>
<span class="nc" id="L175">            offset += 4</span>
          } else {
<span class="nc" id="L177">            ByteArrays.writeInt(0, array, offset)</span>
<span class="nc" id="L178">            offset += 4</span>
          }
        } else {
<span class="nc" id="L181">          ByteArrays.writeInt(indexSftBytes.length, array, offset)</span>
<span class="nc" id="L182">          offset += 4</span>
<span class="nc" id="L183">          System.arraycopy(indexSftBytes, 0, array, offset, indexSftBytes.length)</span>
<span class="nc" id="L184">          offset += indexSftBytes.length</span>
        }

<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (samplingFactorBytes.isEmpty) {</span>
<span class="nc" id="L188">          ByteArrays.writeInt(0, array, offset)</span>
<span class="nc" id="L189">          offset += 4</span>
        } else {
<span class="nc" id="L191">          ByteArrays.writeInt(samplingFactorBytes.length, array, offset)</span>
<span class="nc" id="L192">          offset += 4</span>
<span class="nc" id="L193">          System.arraycopy(samplingFactorBytes, 0, array, offset, samplingFactorBytes.length)</span>
<span class="nc" id="L194">          offset += samplingFactorBytes.length</span>
        }

<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (samplingFieldBytes.isEmpty) {</span>
<span class="nc" id="L198">          ByteArrays.writeInt(0, array, offset)</span>
<span class="nc" id="L199">          offset += 4</span>
        } else {
<span class="nc" id="L201">          ByteArrays.writeInt(samplingFieldBytes.length, array, offset)</span>
<span class="nc" id="L202">          offset += 4</span>
<span class="nc" id="L203">          System.arraycopy(samplingFieldBytes, 0, array, offset, samplingFieldBytes.length)</span>
<span class="nc" id="L204">          offset += samplingFieldBytes.length</span>
        }

<span class="nc" id="L207">        ByteArrays.writeInt(version.length, array, offset)</span>
<span class="nc" id="L208">        offset += 4</span>
<span class="nc" id="L209">        System.arraycopy(version, 0, array, offset, version.length)</span>
<span class="nc" id="L210">        offset += version.length</span>

<span class="nc" id="L212">        array</span>

<span class="nc bnc" id="L214" title="All 4 branches missed.">      case Some((tdefs, tsft)) =&gt;</span>
<span class="nc" id="L215">        val tdefsBytes = tdefs.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L216">        val tsftBytes = SimpleFeatureTypes.encodeType(tsft).getBytes(StandardCharsets.UTF_8)</span>

        val array =
<span class="nc" id="L219">          Array.ofDim[Byte](sftBytes.length + cqlBytes.length + tdefsBytes.length + tsftBytes.length +</span>
<span class="nc" id="L220">              indexBytes.length + indexSftBytes.length + samplingFactorBytes.length +</span>
<span class="nc" id="L221">              samplingFieldBytes.length + version.length + 4*9) // 4 bytes (length info) per 9 fields</span>

<span class="nc" id="L223">        var offset = 0</span>
<span class="nc" id="L224">        ByteArrays.writeInt(sftBytes.length, array, offset)</span>
<span class="nc" id="L225">        offset += 4</span>
<span class="nc" id="L226">        System.arraycopy(sftBytes, 0, array, offset, sftBytes.length)</span>
<span class="nc" id="L227">        offset += sftBytes.length</span>
<span class="nc" id="L228">        ByteArrays.writeInt(cqlBytes.length, array, offset)</span>
<span class="nc" id="L229">        offset += 4</span>
<span class="nc" id="L230">        System.arraycopy(cqlBytes, 0, array, offset, cqlBytes.length)</span>
<span class="nc" id="L231">        offset += cqlBytes.length</span>
<span class="nc" id="L232">        ByteArrays.writeInt(tdefsBytes.length, array, offset)</span>
<span class="nc" id="L233">        offset += 4</span>
<span class="nc" id="L234">        System.arraycopy(tdefsBytes, 0, array, offset, tdefsBytes.length)</span>
<span class="nc" id="L235">        offset += tdefsBytes.length</span>
<span class="nc" id="L236">        ByteArrays.writeInt(tsftBytes.length, array, offset)</span>
<span class="nc" id="L237">        offset += 4</span>
<span class="nc" id="L238">        System.arraycopy(tsftBytes, 0, array, offset, tsftBytes.length)</span>
<span class="nc" id="L239">        offset += tsftBytes.length</span>
<span class="nc" id="L240">        ByteArrays.writeInt(indexBytes.length, array, offset)</span>
<span class="nc" id="L241">        offset += 4</span>
<span class="nc" id="L242">        System.arraycopy(indexBytes, 0, array, offset, indexBytes.length)</span>
<span class="nc" id="L243">        offset += indexBytes.length</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (indexSftBytes.isEmpty) {</span>
<span class="nc bnc" id="L245" title="All 6 branches missed.">          if (delegate.index == NullFeatureIndex) {</span>
<span class="nc" id="L246">            ByteArrays.writeInt(-1, array, offset)</span>
<span class="nc" id="L247">            offset += 4</span>
          } else {
<span class="nc" id="L249">            ByteArrays.writeInt(0, array, offset)</span>
<span class="nc" id="L250">            offset += 4</span>
          }
        } else {
<span class="nc" id="L253">          ByteArrays.writeInt(indexSftBytes.length, array, offset)</span>
<span class="nc" id="L254">          offset += 4</span>
<span class="nc" id="L255">          System.arraycopy(indexSftBytes, 0, array, offset, indexSftBytes.length)</span>
<span class="nc" id="L256">          offset += indexSftBytes.length</span>
        }

<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (samplingFactorBytes.isEmpty) {</span>
<span class="nc" id="L260">          ByteArrays.writeInt(0, array, offset)</span>
<span class="nc" id="L261">          offset += 4</span>
        } else {
<span class="nc" id="L263">          ByteArrays.writeInt(samplingFactorBytes.length, array, offset)</span>
<span class="nc" id="L264">          offset += 4</span>
<span class="nc" id="L265">          System.arraycopy(samplingFactorBytes, 0, array, offset, samplingFactorBytes.length)</span>
<span class="nc" id="L266">          offset += samplingFactorBytes.length</span>
        }

<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (samplingFieldBytes.isEmpty) {</span>
<span class="nc" id="L270">          ByteArrays.writeInt(0, array, offset)</span>
<span class="nc" id="L271">          offset += 4</span>
        } else {
<span class="nc" id="L273">          ByteArrays.writeInt(samplingFieldBytes.length, array, offset)</span>
<span class="nc" id="L274">          offset += 4</span>
<span class="nc" id="L275">          System.arraycopy(samplingFieldBytes, 0, array, offset, samplingFieldBytes.length)</span>
<span class="nc" id="L276">          offset += samplingFieldBytes.length</span>
        }

<span class="nc" id="L279">        ByteArrays.writeInt(version.length, array, offset)</span>
<span class="nc" id="L280">        offset += 4</span>
<span class="nc" id="L281">        System.arraycopy(version, 0, array, offset, version.length)</span>
<span class="nc" id="L282">        offset += version.length</span>

<span class="nc" id="L284">        array</span>
    }
  }

  /**
    * Deserialize a new delegate instance
    *
    * @param bytes serialized bytes
    * @throws org.apache.hadoop.hbase.exceptions.DeserializationException if anything goes wrong
    * @return
    */
  @throws(classOf[DeserializationException])
  private def deserialize(bytes: Array[Byte]): DelegateFilter = {
<span class="nc" id="L297">    try {</span>
<span class="nc" id="L298">      var offset = 0</span>
<span class="nc" id="L299">      val sftLength = ByteArrays.readInt(bytes, offset)</span>
<span class="nc" id="L300">      offset += 4</span>
<span class="nc" id="L301">      val spec = new String(bytes, offset, sftLength,StandardCharsets.UTF_8)</span>
<span class="nc" id="L302">      offset += sftLength</span>

<span class="nc" id="L304">      val sft = IteratorCache.sft(spec)</span>
<span class="nc" id="L305">      val feature = IteratorCache.serializer(spec, SerializationOption.WithoutId).getReusableFeature</span>

<span class="nc" id="L307">      val cqlLength = ByteArrays.readInt(bytes, offset)</span>
<span class="nc" id="L308">      offset += 4</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">      val cql = if (cqlLength == 0) { null } else {</span>
<span class="nc" id="L310">        IteratorCache.filter(sft, spec, new String(bytes, offset, cqlLength,StandardCharsets.UTF_8))</span>
      }
<span class="nc" id="L312">      offset += cqlLength</span>

<span class="nc" id="L314">      val tdefsLength = ByteArrays.readInt(bytes, offset)</span>

<span class="nc bnc" id="L316" title="All 2 branches missed.">      if (tdefsLength == -1) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (cql == null) {</span>
<span class="nc" id="L318">          throw new DeserializationException(&quot;No filter or transform defined&quot;)</span>
        } else {
<span class="nc bnc" id="L320" title="All 2 branches missed.">          val (index,newOffset) = deserializeIndex(sft, spec, bytes, offset + 4)</span>
<span class="nc" id="L321">          offset = newOffset</span>
<span class="nc" id="L322">          feature.setIdParser(index.getIdFromRow(_, _, _, null))</span>

<span class="nc" id="L324">          val samplingOptions = deserializeSamplingOptions(bytes,offset)</span>

<span class="nc" id="L326">          new FilterDelegate(sft, index, feature, cql,samplingOptions)</span>
        }
      } else {
<span class="nc" id="L329">        offset += 4</span>
<span class="nc" id="L330">        val tdefs = new String(bytes, offset, tdefsLength,StandardCharsets.UTF_8)</span>
<span class="nc" id="L331">        offset += tdefsLength</span>

<span class="nc" id="L333">        val tsftLength = ByteArrays.readInt(bytes, offset)</span>
<span class="nc" id="L334">        offset += 4</span>
<span class="nc" id="L335">        val tsft = IteratorCache.sft(new String(bytes, offset, tsftLength,StandardCharsets.UTF_8))</span>

<span class="nc" id="L337">        feature.setTransforms(tdefs, tsft)</span>

<span class="nc bnc" id="L339" title="All 2 branches missed.">        val (index,newOffset) = deserializeIndex(sft, spec, bytes, offset + tsftLength)</span>
<span class="nc" id="L340">        offset = newOffset</span>
<span class="nc" id="L341">        feature.setIdParser(index.getIdFromRow(_, _, _, null))</span>

<span class="nc" id="L343">        val samplingOptions = deserializeSamplingOptions(bytes,offset)</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (cql == null) {</span>
<span class="nc" id="L346">          new TransformDelegate(sft, index, feature,samplingOptions)</span>
        } else {
<span class="nc" id="L348">          new FilterTransformDelegate(sft, index, feature, cql,samplingOptions)</span>
        }
      }
    } catch {
<span class="nc bnc" id="L352" title="All 2 branches missed.">      case e: DeserializationException =&gt; throw e</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">      case NonFatal(e) =&gt; throw new DeserializationException(&quot;Error deserializing filter&quot;, e)</span>
    }
  }

  /**
    * Deserialize the sampling options
    *
    * @param bytes raw byte array
    * @param start offset into the byte array to start reading
    * @return the sampling options
    */
  private def deserializeSamplingOptions(
                                bytes: Array[Byte],
                                start: Int) : Option[(Float,Option[String])]={

<span class="nc" id="L368">    var samplingOption: Option[(Float,Option[String])]= Option.empty</span>

<span class="nc" id="L370">    var offset = start</span>
<span class="nc" id="L371">    val factorLength = ByteArrays.readInt(bytes, offset)</span>
<span class="nc" id="L372">    offset += 4</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">    if (factorLength != 0) {</span>
<span class="nc" id="L374">      val samplingFactor = ByteBuffer.wrap(bytes,offset,factorLength).getFloat</span>
<span class="nc" id="L375">      offset+=factorLength</span>
<span class="nc" id="L376">      val fieldNameLength = ByteArrays.readInt(bytes, offset)</span>
<span class="nc" id="L377">      offset+=4</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">      if (fieldNameLength!=0){</span>
<span class="nc" id="L379">        val fieldName = new String(bytes, offset, fieldNameLength,StandardCharsets.UTF_8)</span>
<span class="nc" id="L380">        samplingOption = Option.apply((samplingFactor,Option.apply(fieldName)))</span>
      }
      else {
<span class="nc" id="L383">        samplingOption = Option.apply((samplingFactor,Option.empty))</span>
      }
    }
<span class="nc" id="L386">    samplingOption</span>

  }

  /**
    * Deserialize the feature index
    *
    * @param sft simple feature type
    * @param spec simple feature type spec string
    * @param bytes raw byte array
    * @param start offset into the byte array to start reading
    * @return index and the new offset
    */
  private def deserializeIndex(
      sft: SimpleFeatureType,
      spec: String,
      bytes: Array[Byte],
      start: Int): (GeoMesaFeatureIndex[_, _],Int) = {
<span class="nc bnc" id="L404" title="All 2 branches missed.">    if (bytes.length &lt;= start) {</span>
      // we're reading a filter serialized without the index - just use a placeholder instead
      // note: serializing this filter will fail, but it shouldn't ever be serialized
<span class="nc" id="L407">      (NullFeatureIndex, start)</span>
    } else {
<span class="nc" id="L409">      var offset = start</span>
<span class="nc" id="L410">      val identifierLength = ByteArrays.readInt(bytes, offset)</span>
<span class="nc" id="L411">      offset += 4</span>
<span class="nc" id="L412">      val identifier = new String(bytes, offset, identifierLength, StandardCharsets.UTF_8)</span>
<span class="nc" id="L413">      offset += identifierLength</span>
<span class="nc" id="L414">      val indexSftLength = ByteArrays.readInt(bytes, offset)</span>
<span class="nc" id="L415">      offset += 4</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">      if (indexSftLength == -1) {</span>
<span class="nc" id="L417">        (NullFeatureIndex,offset)</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">      } else if (indexSftLength == 0) {</span>
<span class="nc" id="L419">        (IteratorCache.index(sft, spec, identifier), offset)</span>
      } else {
<span class="nc" id="L421">        val indexSpec = new String(bytes, offset, indexSftLength, StandardCharsets.UTF_8)</span>
<span class="nc" id="L422">        offset += indexSftLength</span>
<span class="nc" id="L423">        (IteratorCache.index(IteratorCache.sft(indexSpec), indexSpec, identifier), offset)</span>
      }

    }

  }

  /**
    * Delegate filter for handling filtering and/or transforming
    */
<span class="nc" id="L433">  private[hbase] sealed trait DelegateFilter extends SamplingIterator {</span>
    def sft: SimpleFeatureType
    def index: GeoMesaFeatureIndex[_, _]
    def filter: Option[Filter]
    def transform: Option[(String, SimpleFeatureType)]
    def filterKeyValue(v: Cell): ReturnCode
    def transformCell(v: Cell): Cell
    def samplingOptions: Option[(Float,Option[String])]

<span class="nc" id="L442">    protected val sampling: Option[SimpleFeature =&gt; Boolean] =</span>
<span class="nc" id="L443">      samplingOptions.flatMap(opt =&gt; sample(SamplingIterator.configure(sft, opt)))</span>
  }

  /**
    * Filters without transforming
    *
    * @param sft simple feature type
    * @param feature reusable feature
    * @param filt filter
    * @param samplingOptions sampling options
    */
<span class="nc" id="L454">  private[hbase] class FilterDelegate(</span>
<span class="nc" id="L455">      val sft: SimpleFeatureType,</span>
<span class="nc" id="L456">      val index: GeoMesaFeatureIndex[_, _],</span>
<span class="nc" id="L457">      feature: KryoBufferSimpleFeature,</span>
<span class="nc" id="L458">      filt: Filter,</span>
<span class="nc" id="L459">      val samplingOptions: Option[(Float, Option[String])]</span>
<span class="nc" id="L460">    ) extends DelegateFilter with SamplingIterator {</span>

<span class="nc" id="L462">    override def filter: Option[Filter] = Some(filt)</span>
<span class="nc" id="L463">    override def transform: Option[(String, SimpleFeatureType)] = None</span>

    override def filterKeyValue(v: Cell): ReturnCode = {
<span class="nc" id="L466">      try {</span>
<span class="nc" id="L467">        feature.setIdBuffer(v.getRowArray, v.getRowOffset, v.getRowLength)</span>
<span class="nc" id="L468">        feature.setBuffer(v.getValueArray, v.getValueOffset, v.getValueLength)</span>
<span class="nc bnc" id="L469" title="All 4 branches missed.">        if (filt.evaluate(feature) &amp;&amp; sampling.forall(_.apply(feature))) { ReturnCode.INCLUDE } else { ReturnCode.SKIP }</span>
      } catch {
<span class="nc bnc" id="L471" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">          CqlTransformFilter.logger.error(&quot;Error evaluating filter, skipping:&quot;, e)</span>
<span class="nc" id="L473">          ReturnCode.SKIP</span>
      }
    }

<span class="nc" id="L477">    override def transformCell(v: Cell): Cell = v</span>

<span class="nc" id="L479">    override def toString: String = s&quot;CqlFilter[${ECQL.toCQL(filt)}]&quot;</span>
  }

  /**
    * Transforms without filtering
    *
    * @param sft simple feature type
    * @param feature reusable feature, with transforms set
    * @param samplingOptions sampling options
    */
<span class="nc" id="L489">  private[hbase] class TransformDelegate(</span>
<span class="nc" id="L490">      val sft: SimpleFeatureType,</span>
<span class="nc" id="L491">      val index: GeoMesaFeatureIndex[_, _],</span>
<span class="nc" id="L492">      feature: KryoBufferSimpleFeature,</span>
<span class="nc" id="L493">      val samplingOptions: Option[(Float,Option[String])]</span>
<span class="nc" id="L494">    ) extends DelegateFilter {</span>

<span class="nc" id="L496">    override def filter: Option[Filter] = None</span>
<span class="nc" id="L497">    override def transform: Option[(String, SimpleFeatureType)] = feature.getTransform</span>

    override def filterKeyValue(v: Cell): ReturnCode = {
<span class="nc" id="L500">      try {</span>
<span class="nc" id="L501">        feature.setIdBuffer(v.getRowArray, v.getRowOffset, v.getRowLength)</span>
<span class="nc" id="L502">        feature.setBuffer(v.getValueArray, v.getValueOffset, v.getValueLength)</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (sampling.forall(_.apply(feature))) { ReturnCode.INCLUDE } else { ReturnCode.SKIP }</span>
      } catch {
<span class="nc bnc" id="L505" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">          CqlTransformFilter.logger.error(&quot;Error setting feature buffer, skipping:&quot;, e)</span>
<span class="nc" id="L507">          ReturnCode.SKIP</span>
      }
    }

    override def transformCell(v: Cell): Cell = {
<span class="nc" id="L512">      val value: Array[Byte] = feature.transform()</span>
<span class="nc" id="L513">      new KeyValue(v.getRowArray, v.getRowOffset, v.getRowLength, v.getFamilyArray, v.getFamilyOffset,</span>
<span class="nc" id="L514">        v.getFamilyLength, v.getQualifierArray, v.getQualifierOffset, v.getQualifierLength, v.getTimestamp,</span>
<span class="nc" id="L515">        KeyValue.Type.Put, value, 0, value.length)</span>
    }

<span class="nc" id="L518">    override def toString: String = s&quot;TransformFilter[${feature.getTransform.get._1}]&quot;</span>
  }

  /**
    * Filters and transforms
    *
    * @param sft simple feature type
    * @param feature reusable feature, with transforms set
    * @param filt filter
    * @param samplingOptions sampling options
    */
<span class="nc" id="L529">  private[hbase] class FilterTransformDelegate(</span>
<span class="nc" id="L530">      val sft: SimpleFeatureType,</span>
<span class="nc" id="L531">      val index: GeoMesaFeatureIndex[_, _],</span>
<span class="nc" id="L532">      feature: KryoBufferSimpleFeature,</span>
<span class="nc" id="L533">      filt: Filter,</span>
<span class="nc" id="L534">      val samplingOptions: Option[(Float,Option[String])]</span>
<span class="nc" id="L535">    ) extends DelegateFilter {</span>

<span class="nc" id="L537">    override def filter: Option[Filter] = Some(filt)</span>
<span class="nc" id="L538">    override def transform: Option[(String, SimpleFeatureType)] = feature.getTransform</span>

    override def filterKeyValue(v: Cell): ReturnCode = {
<span class="nc" id="L541">      try {</span>
<span class="nc" id="L542">        feature.setIdBuffer(v.getRowArray, v.getRowOffset, v.getRowLength)</span>
<span class="nc" id="L543">        feature.setBuffer(v.getValueArray, v.getValueOffset, v.getValueLength)</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">        if (filt.evaluate(feature)&amp;&amp; sampling.forall(_.apply(feature))) { ReturnCode.INCLUDE } else { ReturnCode.SKIP }</span>
      } catch {
<span class="nc bnc" id="L546" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">          CqlTransformFilter.logger.error(&quot;Error evaluating filter, skipping:&quot;, e)</span>
<span class="nc" id="L548">          ReturnCode.SKIP</span>
      }
    }

    override def transformCell(v: Cell): Cell = {
<span class="nc" id="L553">      val value: Array[Byte] = feature.transform()</span>
<span class="nc" id="L554">      new KeyValue(v.getRowArray, v.getRowOffset, v.getRowLength, v.getFamilyArray, v.getFamilyOffset,</span>
<span class="nc" id="L555">        v.getFamilyLength, v.getQualifierArray, v.getQualifierOffset, v.getQualifierLength, v.getTimestamp,</span>
<span class="nc" id="L556">        KeyValue.Type.Put, value, 0, value.length)</span>
    }

<span class="nc" id="L559">    override def toString: String = s&quot;CqlTransformFilter[${ECQL.toCQL(filt)}, ${feature.getTransform.get._1}]&quot;</span>
  }


  private[hbase] object NullFeatureIndex
<span class="nc" id="L564">      extends GeoMesaFeatureIndex[Any, Any](null, null, &quot;&quot;, 0, Seq.empty, IndexMode.Read) {</span>

<span class="nc" id="L566">    override def keySpace: IndexKeySpace[Any, Any] = throw new UnsupportedOperationException()</span>

<span class="nc" id="L568">    override def tieredKeySpace: Option[IndexKeySpace[_, _]] = throw new UnsupportedOperationException()</span>

    override def getFilterStrategy(filter: Filter, hints: Hints): Option[FilterStrategy] =
<span class="nc" id="L571">      throw new UnsupportedOperationException()</span>

<span class="nc" id="L573">    override def getIdFromRow(row: Array[Byte], offset: Int, length: Int, feature: SimpleFeature): String = &quot;&quot;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>