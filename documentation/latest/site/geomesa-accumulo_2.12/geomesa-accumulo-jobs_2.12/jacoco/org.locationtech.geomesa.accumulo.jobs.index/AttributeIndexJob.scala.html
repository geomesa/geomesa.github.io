<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttributeIndexJob.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo Jobs</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.jobs.index</a> &gt; <span class="el_source">AttributeIndexJob.scala</span></div><h1>AttributeIndexJob.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.jobs.index

import com.beust.jcommander.Parameter
import org.apache.accumulo.core.data.Mutation
import org.apache.accumulo.core.security.ColumnVisibility
import org.apache.accumulo.hadoop.mapreduce.AccumuloOutputFormat
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.io.Text
import org.apache.hadoop.mapreduce.{Counter, Job, Mapper}
import org.apache.hadoop.util.{Tool, ToolRunner}
import org.geotools.api.data.Query
import org.geotools.api.feature.simple.SimpleFeature
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.accumulo.data._
import org.locationtech.geomesa.accumulo.data.writer.ColumnFamilyMapper
import org.locationtech.geomesa.accumulo.index.JoinIndex
import org.locationtech.geomesa.accumulo.jobs.index.AttributeIndexJob.{AttributeIndexArgs, AttributeMapper}
import org.locationtech.geomesa.accumulo.jobs.mapreduce.GeoMesaAccumuloInputFormat
import org.locationtech.geomesa.accumulo.jobs.{AccumuloJobUtils, GeoMesaArgs, InputDataStoreArgs, InputFeatureArgs}
import org.locationtech.geomesa.index.api.WritableFeature.FeatureWrapper
import org.locationtech.geomesa.index.api.{MultiRowKeyValue, SingleRowKeyValue, WritableFeature, WriteConverter}
import org.locationtech.geomesa.index.conf.partition.TablePartition
import org.locationtech.geomesa.index.index.attribute.AttributeIndex
import org.locationtech.geomesa.jobs._
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeOptions
import org.locationtech.geomesa.utils.index.{IndexCoverage, IndexMode}
import org.locationtech.geomesa.utils.io.WithStore

import scala.util.control.NonFatal

<span class="nc" id="L40">object AttributeIndexJob {</span>

  import scala.collection.JavaConverters._

  final val IndexAttributes = &quot;--geomesa.index.attributes&quot;
  final val IndexCoverage = &quot;--geomesa.index.coverage&quot;

<span class="nc" id="L47">  private val AttributesKey = &quot;org.locationtech.geomesa.attributes&quot;</span>
<span class="nc" id="L48">  private val TypeNameKey   = &quot;org.locationtech.geomesa.attributes.type&quot;</span>

  def main(args: Array[String]): Unit = {
<span class="nc" id="L51">    val result = ToolRunner.run(new AttributeIndexJob(), args)</span>
<span class="nc" id="L52">    System.exit(result)</span>
  }

  private def setAttributes(conf: Configuration, attributes: Seq[String]): Unit =
<span class="nc" id="L56">    conf.set(AttributesKey, attributes.mkString(&quot;,&quot;))</span>
<span class="nc" id="L57">  private def getAttributes(conf: Configuration): Seq[String] = conf.get(AttributesKey).split(&quot;,&quot;)</span>

<span class="nc" id="L59">  private def setTypeName(conf: Configuration, typeName: String): Unit = conf.set(TypeNameKey, typeName)</span>
<span class="nc" id="L60">  private def getTypeName(conf: Configuration): String = conf.get(TypeNameKey)</span>

<span class="nc" id="L62">  class AttributeIndexArgs(args: Array[String]) extends GeoMesaArgs(args) with InputFeatureArgs with InputDataStoreArgs {</span>

    @Parameter(names = Array(AttributeIndexJob.IndexAttributes), description = &quot;Attributes to index&quot;, variableArity = true, required = true)
<span class="nc" id="L65">    var attributes: java.util.List[String] = new java.util.ArrayList[String]()</span>

    @Parameter(names = Array(AttributeIndexJob.IndexCoverage), description = &quot;Type of index (join or full)&quot;)
<span class="nc" id="L68">    var coverage: String = _</span>

    override def unparse(): Array[String] = {
<span class="nc bnc" id="L71" title="All 4 branches missed.">      val attrs = if (attributes == null || attributes.isEmpty) {</span>
<span class="nc" id="L72">        Array.empty[String]</span>
      } else {
<span class="nc" id="L74">        attributes.asScala.flatMap(n =&gt; Seq(AttributeIndexJob.IndexAttributes, n)).toArray</span>
      }
<span class="nc bnc" id="L76" title="All 2 branches missed.">      val cov = if (coverage == null) {</span>
<span class="nc" id="L77">        Array.empty[String]</span>
      } else {
<span class="nc" id="L79">        Array(AttributeIndexJob.IndexCoverage, coverage)</span>
      }
<span class="nc" id="L81">      Array.concat(super[InputFeatureArgs].unparse(), super[InputDataStoreArgs].unparse(), attrs, cov)</span>
    }
  }

<span class="nc" id="L85">  class AttributeMapper extends Mapper[Text, SimpleFeature, Text, Mutation] {</span>

    type Context = Mapper[Text, SimpleFeature, Text, Mutation]#Context

<span class="nc" id="L89">    private var counter: Counter = _</span>

    // TODO GEOMESA-2545 have a standardized writer that returns mutations instead of using a batch writer

<span class="nc" id="L93">    private var wrapper: FeatureWrapper[WritableFeature] = _</span>
<span class="nc" id="L94">    private var converters: Seq[(WriteConverter[_], Int)] = _</span>
<span class="nc" id="L95">    private var colFamilyMappings: IndexedSeq[Array[Byte] =&gt; Array[Byte]] = _</span>
<span class="nc" id="L96">    private var defaultVis: ColumnVisibility = _</span>
<span class="nc" id="L97">    private var tables: SimpleFeature =&gt; IndexedSeq[Text] = _</span>

    override protected def setup(context: Context): Unit = {
<span class="nc" id="L100">      counter = context.getCounter(&quot;org.locationtech.geomesa&quot;, &quot;attributes-written&quot;)</span>
<span class="nc" id="L101">      WithStore[AccumuloDataStore](GeoMesaConfigurator.getDataStoreOutParams(context.getConfiguration)) { ds =&gt;</span>
<span class="nc" id="L102">        val sft = SimpleFeatureTypes.mutable(ds.getSchema(getTypeName(context.getConfiguration)))</span>
<span class="nc" id="L103">        val attributes = getAttributes(context.getConfiguration).toSet</span>
<span class="nc" id="L104">        val indices = ds.manager.indices(sft, IndexMode.Write).filter { i =&gt;</span>
<span class="nc bnc" id="L105" title="All 12 branches missed.">          (i.name == AttributeIndex.name || i.name == JoinIndex.name) &amp;&amp;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">              i.attributes.headOption.exists(attributes.contains)</span>
        }
<span class="nc" id="L108">        wrapper = WritableFeature.wrapper(sft, ds.adapter.groups)</span>
<span class="nc" id="L109">        converters = indices.map(_.createConverter()).zipWithIndex</span>
<span class="nc" id="L110">        colFamilyMappings = indices.map(ColumnFamilyMapper.apply).toIndexedSeq</span>
<span class="nc" id="L111">        defaultVis = new ColumnVisibility()</span>
<span class="nc" id="L112">        tables = TablePartition(ds, sft) match {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">          case Some(tp) =&gt;</span>
<span class="nc" id="L114">            val tables = scala.collection.mutable.Map.empty[String, IndexedSeq[Text]]</span>
<span class="nc" id="L115">            f =&gt; {</span>
              // create the new partition table if needed, which also writes the metadata for it
<span class="nc" id="L117">              val partition = tp.partition(f)</span>
<span class="nc" id="L118">              tables.getOrElseUpdate(partition,</span>
<span class="nc" id="L119">                indices.map(i =&gt; new Text(i.configureTableName(Some(partition)))).toIndexedSeq)</span>
            }

<span class="nc bnc" id="L122" title="All 2 branches missed.">          case None =&gt;</span>
<span class="nc" id="L123">            val names = indices.map(i =&gt; new Text(i.getTableName())).toIndexedSeq</span>
<span class="nc" id="L124">            _ =&gt; names</span>
        }
      }
    }

<span class="nc" id="L129">    override protected def cleanup(context: Context): Unit = {}</span>

    override def map(key: Text, value: SimpleFeature, context: Context): Unit = {
<span class="nc" id="L132">      val writable = wrapper.wrap(value)</span>
<span class="nc" id="L133">      val out = tables(value)</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">      converters.foreach { case (converter, i) =&gt;</span>
<span class="nc" id="L135">        converter.convert(writable) match {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">          case SingleRowKeyValue(row, _, _, _, _, _, vals) =&gt;</span>
<span class="nc" id="L137">            val mutation = new Mutation(row)</span>
<span class="nc" id="L138">            vals.foreach { v =&gt;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">              val vis = if (v.vis.isEmpty) { defaultVis } else { new ColumnVisibility(v.vis) }</span>
<span class="nc" id="L140">              mutation.put(colFamilyMappings(i)(v.cf), v.cq, vis, v.value)</span>
            }
<span class="nc" id="L142">            context.write(out(i), mutation)</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">          case MultiRowKeyValue(rows, _, _, _, _, _, vals) =&gt;</span>
<span class="nc" id="L145">            rows.foreach { row =&gt;</span>
<span class="nc" id="L146">              val mutation = new Mutation(row)</span>
<span class="nc" id="L147">              vals.foreach { v =&gt;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                val vis = if (v.vis.isEmpty) { defaultVis } else { new ColumnVisibility(v.vis) }</span>
<span class="nc" id="L149">                mutation.put(colFamilyMappings(i)(v.cf), v.cq, vis, v.value)</span>
              }
<span class="nc" id="L151">              context.write(out(i), mutation)</span>
            }
        }
      }
<span class="nc" id="L155">      counter.increment(converters.length)</span>
    }
  }
}

<span class="nc" id="L160">class AttributeIndexJob extends Tool {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L164">  private var conf: Configuration = new Configuration()</span>

  override def run(args: Array[String]): Int = {
<span class="nc" id="L167">    val parsedArgs = new AttributeIndexArgs(args)</span>
<span class="nc" id="L168">    parsedArgs.parse()</span>

<span class="nc" id="L170">    val typeName   = parsedArgs.inFeature</span>
<span class="nc" id="L171">    val dsInParams = parsedArgs.inDataStore</span>
<span class="nc" id="L172">    val attributes = parsedArgs.attributes.asScala</span>

<span class="nc" id="L174">    val coverage = Option(parsedArgs.coverage).map { c =&gt;</span>
<span class="nc" id="L175">      try { IndexCoverage.withName(c) } catch {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        case NonFatal(_) =&gt; throw new IllegalArgumentException(s&quot;Invalid coverage value $c&quot;)</span>
      }
<span class="nc" id="L178">    }.getOrElse(IndexCoverage.FULL)</span>

    // validation and initialization - ensure the types exist before launching distributed job
<span class="nc" id="L181">    WithStore[AccumuloDataStore](dsInParams) { ds =&gt;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">      require(ds != null, &quot;The specified input data store could not be created - check your job parameters&quot;)</span>
<span class="nc" id="L183">      var sft = Option(ds.getSchema(typeName)).map(SimpleFeatureTypes.mutable).orNull</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      require(sft != null, s&quot;The schema '$typeName' does not exist in the input data store&quot;)</span>

      // validate attributes and set the index coverage
<span class="nc" id="L187">      attributes.foreach { a =&gt;</span>
<span class="nc" id="L188">        val descriptor = sft.getDescriptor(a)</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        require(descriptor != null, s&quot;Attribute '$a' does not exist in schema '$typeName'&quot;)</span>
<span class="nc" id="L190">        descriptor.getUserData.put(AttributeOptions.OptIndex, coverage.toString)</span>
      }

      // update the schema - this will create the table if it doesn't exist, and add splits
<span class="nc" id="L194">      ds.updateSchema(sft.getTypeName, sft)</span>

      // re-load the sft now that we've updated it
<span class="nc" id="L197">      sft = ds.getSchema(sft.getTypeName)</span>

<span class="nc" id="L199">      val job = Job.getInstance(conf,</span>
<span class="nc" id="L200">        s&quot;GeoMesa Attribute Index Job '${sft.getTypeName}' - '${attributes.mkString(&quot;, &quot;)}'&quot;)</span>

<span class="nc" id="L202">      AccumuloJobUtils.setLibJars(job.getConfiguration)</span>

<span class="nc" id="L204">      job.setJarByClass(AttributeIndexJob.getClass)</span>
<span class="nc" id="L205">      job.setMapperClass(classOf[AttributeMapper])</span>
<span class="nc" id="L206">      job.setInputFormatClass(classOf[GeoMesaAccumuloInputFormat])</span>
<span class="nc" id="L207">      job.setOutputFormatClass(classOf[AccumuloOutputFormat])</span>
<span class="nc" id="L208">      job.setMapOutputKeyClass(classOf[Text])</span>
<span class="nc" id="L209">      job.setMapOutputValueClass(classOf[Mutation])</span>
<span class="nc" id="L210">      job.setNumReduceTasks(0)</span>

<span class="nc" id="L212">      val plan = ds.getSingleQueryPlan(new Query(sft.getTypeName, Filter.INCLUDE))</span>
<span class="nc" id="L213">      GeoMesaAccumuloInputFormat.configure(job.getConfiguration, dsInParams.asJava, plan)</span>
<span class="nc" id="L214">      GeoMesaConfigurator.setDataStoreOutParams(job.getConfiguration, dsInParams)</span>
<span class="nc" id="L215">      AttributeIndexJob.setAttributes(job.getConfiguration, attributes.toSeq)</span>
<span class="nc" id="L216">      AttributeIndexJob.setTypeName(job.getConfiguration, sft.getTypeName)</span>

<span class="nc" id="L218">      val props = AccumuloDataStoreFactory.buildAccumuloClientConfig(</span>
        java.util.Map.of(
<span class="nc" id="L220">          AccumuloDataStoreParams.InstanceNameParam.key, parsedArgs.inInstanceId,</span>
<span class="nc" id="L221">          AccumuloDataStoreParams.ZookeepersParam.key, parsedArgs.inZookeepers,</span>
<span class="nc" id="L222">          AccumuloDataStoreParams.UserParam.key, parsedArgs.inUser,</span>
<span class="nc" id="L223">          AccumuloDataStoreParams.PasswordParam.key, parsedArgs.inPassword</span>
        )
      )

<span class="nc" id="L227">      AccumuloOutputFormat.configure().clientProperties(props).createTables(true).store(job)</span>

<span class="nc" id="L229">      val result = job.waitForCompletion(true)</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (result) { 0 } else { 1 }</span>
    }
  }

<span class="nc" id="L235">  override def getConf: Configuration = conf</span>

<span class="nc" id="L237">  override def setConf(conf: Configuration): Unit = this.conf = conf</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>