<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumuloIndexWriter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.data.writer</a> &gt; <span class="el_source">AccumuloIndexWriter.scala</span></div><h1>AccumuloIndexWriter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.data.writer

import org.apache.accumulo.core.data.Mutation
import org.locationtech.geomesa.accumulo.data.AccumuloDataStore
import org.locationtech.geomesa.index.api.IndexAdapter.BaseIndexWriter
import org.locationtech.geomesa.index.api.WritableFeature.FeatureWrapper
import org.locationtech.geomesa.index.api._

/**
  * Accumulo index writer implementation
  *
  * @param ds data store
  * @param indices indices to write to
  * @param wrapper feature wrapper
  * @param partition partition to write to (if partitioned schema)
  */
<span class="nc" id="L25">class AccumuloIndexWriter(</span>
    ds: AccumuloDataStore,
    indices: Seq[GeoMesaFeatureIndex[_, _]],
    wrapper: FeatureWrapper[WritableFeature],
<span class="nc" id="L29">    partition: Option[String]</span>
<span class="nc" id="L30">  ) extends BaseIndexWriter[WritableFeature](indices, wrapper) {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L34">  private val multiWriter = ds.client.createMultiTableBatchWriter()</span>
<span class="nc" id="L35">  private val writers = indices.toArray.map { index =&gt;</span>
    // should always be writing to a single table here
<span class="nc" id="L37">    multiWriter.getBatchWriter(index.getTableName(partition))</span>
  }

<span class="nc" id="L40">  private val colFamilyMappings = indices.map(ColumnFamilyMapper.apply).toArray</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">  private val timestamps = indices.exists(i =&gt; !i.sft.isLogicalTime)</span>
<span class="nc" id="L42">  private val visCache = new VisibilityCache()</span>

  override protected def append(feature: WritableFeature, values: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L45">    var i = 0</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">    while (i &lt; values.length) {</span>
<span class="nc" id="L47">      values(i) match {</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">        case kv: SingleRowKeyValue[_] =&gt;</span>
<span class="nc" id="L49">          val mutation = new Mutation(kv.row)</span>
<span class="nc" id="L50">          kv.values.foreach { v =&gt;</span>
<span class="nc" id="L51">            mutation.put(colFamilyMappings(i)(v.cf), v.cq, visCache(v.vis), v.value)</span>
          }
<span class="nc" id="L53">          writers(i).addMutation(mutation)</span>

<span class="nc bnc" id="L55" title="All 2 branches missed.">        case mkv: MultiRowKeyValue[_] =&gt;</span>
<span class="nc" id="L56">          mkv.rows.foreach { row =&gt;</span>
<span class="nc" id="L57">            val mutation = new Mutation(row)</span>
<span class="nc" id="L58">            mkv.values.foreach { v =&gt;</span>
<span class="nc" id="L59">              mutation.put(colFamilyMappings(i)(v.cf), v.cq, visCache(v.vis), v.value)</span>
            }
<span class="nc" id="L61">            writers(i).addMutation(mutation)</span>
          }
      }
<span class="nc" id="L64">      i += 1</span>
    }
  }

  override protected def update(
      feature: WritableFeature,
      values: Array[RowKeyValue[_]],
      previous: WritableFeature,
      previousValues: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L73">    delete(previous, previousValues)</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">    if (timestamps) {</span>
      // for updates, ensure that our timestamps don't clobber each other
<span class="nc" id="L76">      multiWriter.flush()</span>
<span class="nc" id="L77">      Thread.sleep(1)</span>
    }
<span class="nc" id="L79">    append(feature, values)</span>
  }

  override protected def delete(feature: WritableFeature, values: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L83">    var i = 0</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">    while (i &lt; values.length) {</span>
<span class="nc" id="L85">      values(i) match {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        case kv: SingleRowKeyValue[_] =&gt;</span>
<span class="nc" id="L87">          val mutation = new Mutation(kv.row)</span>
<span class="nc" id="L88">          kv.values.foreach { v =&gt;</span>
<span class="nc" id="L89">            mutation.putDelete(colFamilyMappings(i)(v.cf), v.cq, visCache(v.vis))</span>
          }
<span class="nc" id="L91">          writers(i).addMutation(mutation)</span>

<span class="nc bnc" id="L93" title="All 2 branches missed.">        case kv: MultiRowKeyValue[_] =&gt;</span>
<span class="nc" id="L94">          kv.rows.foreach { row =&gt;</span>
<span class="nc" id="L95">            val mutation = new Mutation(row)</span>
<span class="nc" id="L96">            kv.values.foreach { v =&gt;</span>
<span class="nc" id="L97">              mutation.putDelete(colFamilyMappings(i)(v.cf), v.cq, visCache(v.vis))</span>
            }
<span class="nc" id="L99">            writers(i).addMutation(mutation)</span>
          }
      }
<span class="nc" id="L102">      i += 1</span>
    }
  }

<span class="nc" id="L106">  override def flush(): Unit = multiWriter.flush()</span>

<span class="nc" id="L108">  override def close(): Unit = multiWriter.close()</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>