<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumuloQueryPlan.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.data</a> &gt; <span class="el_source">AccumuloQueryPlan.scala</span></div><h1>AccumuloQueryPlan.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.data

import com.typesafe.scalalogging.LazyLogging
import org.apache.accumulo.core.client.ScannerBase.ConsistencyLevel
import org.apache.accumulo.core.client.{AccumuloClient, IteratorSetting, ScannerBase}
import org.apache.accumulo.core.data.{Key, Value}
import org.apache.accumulo.core.security.Authorizations
import org.apache.hadoop.io.Text
import org.geotools.api.feature.simple.SimpleFeature
import org.locationtech.geomesa.accumulo.data.AccumuloIndexAdapter.AccumuloResultsToFeatures
import org.locationtech.geomesa.accumulo.util.BatchMultiScanner
import org.locationtech.geomesa.index.api.QueryPlan.{FeatureReducer, QueryStrategyPlan, ResultsToFeatures}
import org.locationtech.geomesa.index.api.QueryStrategy
import org.locationtech.geomesa.index.planning.LocalQueryRunner.{LocalProcessor, LocalProcessorPlan}
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.index.utils.Reprojection.QueryReferenceSystems
import org.locationtech.geomesa.index.utils.ThreadManagement.{LowLevelScanner, ManagedScan, Timeout}
import org.locationtech.geomesa.utils.collection.CloseableIterator

import java.util.Map.Entry

/**
  * Accumulo-specific query plan
  */
<span class="nc" id="L33">sealed trait AccumuloQueryPlan extends QueryStrategyPlan {</span>

  def tables: Seq[String]
  def columnFamily: Option[Text]
  def ranges: Seq[org.apache.accumulo.core.data.Range]
  def iterators: Seq[IteratorSetting]
  def numThreads: Int

<span class="nc" id="L41">  def join: Option[(AccumuloQueryPlan.JoinFunction, AccumuloQueryPlan)] = None</span>

<span class="nc" id="L43">  override def explain(explainer: Explainer): Unit = AccumuloQueryPlan.explain(this, explainer)</span>
}

<span class="nc bnc" id="L46" title="All 4 branches missed.">object AccumuloQueryPlan extends LazyLogging {</span>

  import scala.collection.JavaConverters._

  // scan result =&gt; range
  type JoinFunction = Entry[Key, Value] =&gt; org.apache.accumulo.core.data.Range

<span class="nc" id="L53">  def explain(plan: AccumuloQueryPlan, explainer: Explainer, prefix: String = &quot;&quot;): Unit = {</span>
<span class="nc" id="L54">    explainer.pushLevel(s&quot;${prefix}Plan: ${plan.getClass.getSimpleName}&quot;)</span>
<span class="nc" id="L55">    explainer(s&quot;Tables: ${plan.tables.mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L56">    explainer(s&quot;Column Families: ${plan.columnFamily.getOrElse(&quot;all&quot;)}&quot;)</span>
<span class="nc" id="L57">    explainer(s&quot;Ranges (${plan.ranges.size}): ${plan.ranges.take(5).map(rangeToString).mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L58">    explainer(s&quot;Iterators (${plan.iterators.size}):&quot;, plan.iterators.map(i =&gt; () =&gt; i.toString))</span>
<span class="nc" id="L59">    plan.join.foreach { j =&gt; explain(j._2, explainer, &quot;Join &quot;) }</span>
<span class="nc" id="L60">    explainer(s&quot;Reduce: ${plan.reducer.getOrElse(&quot;none&quot;)}&quot;)</span>
<span class="nc" id="L61">    explainer.popLevel()</span>
  }

  // converts a range to a printable string - only includes the row
  private def rangeToString(r: org.apache.accumulo.core.data.Range): String = {
<span class="nc bnc" id="L66" title="All 2 branches missed.">    val a = if (r.isStartKeyInclusive) &quot;[&quot; else &quot;(&quot;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    val z = if (r.isEndKeyInclusive) &quot;]&quot; else &quot;)&quot;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">    val start = if (r.isInfiniteStartKey) &quot;-inf&quot; else keyToString(r.getStartKey)</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">    val stop = if (r.isInfiniteStopKey) &quot;+inf&quot; else keyToString(r.getEndKey)</span>
<span class="nc" id="L70">    s&quot;$a$start::$stop$z&quot;</span>
  }

  // converts a key to a printable string - only includes the row
  private def keyToString(k: Key): String =
<span class="nc" id="L75">    Key.toPrintableString(k.getRow.getBytes, 0, k.getRow.getLength, k.getRow.getLength)</span>

  // plan that will not actually scan anything
<span class="nc bnc" id="L78" title="All 25 branches missed.">  case class EmptyPlan(strategy: QueryStrategy, reducer: Option[FeatureReducer] = None) extends AccumuloQueryPlan {</span>
    override type Results = Entry[Key, Value]
<span class="nc" id="L80">    override def tables: Seq[String] = Seq.empty</span>
<span class="nc" id="L81">    override def iterators: Seq[IteratorSetting] = Seq.empty</span>
<span class="nc" id="L82">    override def ranges: Seq[org.apache.accumulo.core.data.Range] = Seq.empty</span>
<span class="nc" id="L83">    override def columnFamily: Option[Text] = None</span>
<span class="nc" id="L84">    override def numThreads: Int = 0</span>
<span class="nc" id="L85">    override def resultsToFeatures: ResultsToFeatures[Entry[Key, Value]] = ResultsToFeatures.empty</span>
<span class="nc" id="L86">    override def sort: Option[Seq[(String, Boolean)]] = None</span>
<span class="nc" id="L87">    override def maxFeatures: Option[Int] = None</span>
<span class="nc" id="L88">    override def projection: Option[QueryReferenceSystems] = None</span>
<span class="nc" id="L89">    override def scan(): CloseableIterator[Entry[Key, Value]] = CloseableIterator.empty</span>
  }


  // batch scan plan
<span class="nc" id="L94">  abstract class AbstractBatchScanPlan(</span>
<span class="nc" id="L95">      tables: Seq[String],</span>
<span class="nc" id="L96">      ranges: Seq[org.apache.accumulo.core.data.Range],</span>
<span class="nc" id="L97">      iterators: Seq[IteratorSetting],</span>
<span class="nc" id="L98">      columnFamily: Option[Text],</span>
<span class="nc" id="L99">      numThreads: Int</span>
<span class="nc" id="L100">    ) extends AccumuloQueryPlan {</span>

    /**
     * Scan with pre-computed auths
     *
     * @param helper scan helper
     * @return
     */
    private[AccumuloQueryPlan] def scan(helper: ScanHelper): CloseableIterator[Entry[Key, Value]] = {
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (helper.parallel) {</span>
        // kick off all the scans at once
<span class="nc" id="L111">        tables.map(scanner(_, helper)).foldLeft(CloseableIterator.empty[Entry[Key, Value]])(_ concat _)</span>
      } else {
        // kick off the scans sequentially as they finish
<span class="nc" id="L114">        CloseableIterator(tables.iterator).flatMap(scanner(_, helper))</span>
      }
    }

    /**
     * Scan a table
     *
     * @param table table
     * @param helper scan helper
     * @return
     */
    private def scanner(table: String, helper: ScanHelper): CloseableIterator[Entry[Key, Value]] = {
<span class="nc" id="L126">      val scanner = helper.client.createBatchScanner(table, helper.auths, numThreads)</span>
<span class="nc" id="L127">      scanner.setRanges(ranges.asJava)</span>
<span class="nc" id="L128">      iterators.foreach(scanner.addScanIterator)</span>
<span class="nc" id="L129">      columnFamily.foreach(scanner.fetchColumnFamily)</span>
<span class="nc" id="L130">      helper.consistency.foreach(scanner.setConsistencyLevel)</span>
<span class="nc" id="L131">      helper.timeout match {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        case None =&gt; new ScanIterator(scanner)</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        case Some(t) =&gt; new ManagedScan(new AccumuloScanner(scanner), t, this)</span>
      }
    }
  }

  // batch scan plan
<span class="nc bnc" id="L139" title="All 91 branches missed.">  case class BatchScanPlan(</span>
<span class="nc" id="L140">      ds: AccumuloDataStore,</span>
<span class="nc" id="L141">      strategy: QueryStrategy,</span>
<span class="nc" id="L142">      tables: Seq[String],</span>
<span class="nc" id="L143">      ranges: Seq[org.apache.accumulo.core.data.Range],</span>
<span class="nc" id="L144">      iterators: Seq[IteratorSetting],</span>
<span class="nc" id="L145">      columnFamily: Option[Text],</span>
<span class="nc" id="L146">      resultsToFeatures: ResultsToFeatures[Entry[Key, Value]],</span>
<span class="nc" id="L147">      reducer: Option[FeatureReducer],</span>
<span class="nc" id="L148">      sort: Option[Seq[(String, Boolean)]],</span>
<span class="nc" id="L149">      maxFeatures: Option[Int],</span>
<span class="nc" id="L150">      projection: Option[QueryReferenceSystems],</span>
<span class="nc" id="L151">      numThreads: Int</span>
<span class="nc" id="L152">    ) extends AbstractBatchScanPlan(tables, ranges, iterators, columnFamily, numThreads) {</span>

    override type Results = Entry[Key, Value]

    override def scan(): CloseableIterator[Entry[Key, Value]] = {
      // query guard hook - also handles full table scan checks
<span class="nc" id="L158">      ds.interceptors.runGuards(strategy)</span>
      // note: calculate auths and convert the relative timeout to an absolute timeout up front
<span class="nc" id="L160">      scan(ScanHelper(ds))</span>
    }
  }

  // batch scan plan with local processing steps
<span class="nc bnc" id="L165" title="All 70 branches missed.">  case class BatchScanLocalProcessorPlan(</span>
<span class="nc" id="L166">      ds: AccumuloDataStore,</span>
<span class="nc" id="L167">      strategy: QueryStrategy,</span>
<span class="nc" id="L168">      tables: Seq[String],</span>
<span class="nc" id="L169">      ranges: Seq[org.apache.accumulo.core.data.Range],</span>
<span class="nc" id="L170">      iterators: Seq[IteratorSetting],</span>
<span class="nc" id="L171">      columnFamily: Option[Text],</span>
<span class="nc" id="L172">      processor: LocalProcessor,</span>
<span class="nc" id="L173">      projection: Option[QueryReferenceSystems],</span>
<span class="nc" id="L174">      numThreads: Int</span>
<span class="nc" id="L175">    ) extends AbstractBatchScanPlan(tables, ranges, iterators, columnFamily, numThreads) with LocalProcessorPlan {</span>

    override def scan(): CloseableIterator[SimpleFeature] = {
      // query guard hook - also handles full table scan checks
<span class="nc" id="L179">      ds.interceptors.runGuards(strategy)</span>
<span class="nc" id="L180">      val toFeatures = AccumuloResultsToFeatures(strategy.index, processor.sft)</span>
      // note: calculate auths and convert the relative timeout to an absolute timeout up front
<span class="nc" id="L182">      processor(scan(ScanHelper(ds)).map(toFeatures.apply))</span>
    }
  }

  // join on multiple tables - requires multiple scans
<span class="nc bnc" id="L187" title="All 84 branches missed.">  case class JoinPlan(</span>
<span class="nc" id="L188">      ds: AccumuloDataStore,</span>
<span class="nc" id="L189">      strategy: QueryStrategy,</span>
<span class="nc" id="L190">      tables: Seq[String],</span>
<span class="nc" id="L191">      ranges: Seq[org.apache.accumulo.core.data.Range],</span>
<span class="nc" id="L192">      iterators: Seq[IteratorSetting],</span>
<span class="nc" id="L193">      columnFamily: Option[Text],</span>
<span class="nc" id="L194">      numThreads: Int,</span>
<span class="nc" id="L195">      joinFunction: JoinFunction,</span>
<span class="nc" id="L196">      joinQuery: BatchScanPlan,</span>
<span class="nc" id="L197">      processor: LocalProcessor,</span>
<span class="nc" id="L198">      projection: Option[QueryReferenceSystems],</span>
<span class="nc" id="L199">    ) extends AccumuloQueryPlan with LocalProcessorPlan {</span>

<span class="nc" id="L201">    override val join: Some[(JoinFunction, BatchScanPlan)] = Some((joinFunction, joinQuery))</span>

    override def scan(): CloseableIterator[SimpleFeature] = {
      // query guard hook - also handles full table scan checks
<span class="nc" id="L205">      ds.interceptors.runGuards(strategy)</span>
      // calculate auths and convert the relative timeout to an absolute timeout up front
<span class="nc" id="L207">      val helper = ScanHelper(ds)</span>
<span class="nc" id="L208">      val joinTables = joinQuery.tables.iterator</span>
      val entries =
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (helper.parallel) {</span>
          // kick off all the scans at once
<span class="nc" id="L212">          tables.map(scanner( _, joinTables.next, helper)).foldLeft(CloseableIterator.empty[Entry[Key, Value]])(_ concat _)</span>
        } else {
          // kick off the scans sequentially as they finish
<span class="nc" id="L215">          CloseableIterator(tables.iterator).flatMap(scanner(_, joinTables.next, helper))</span>
        }
<span class="nc" id="L217">      processor(entries.map(joinQuery.resultsToFeatures.apply))</span>
    }

    private def scanner(table: String, joinTable: String, helper: ScanHelper): CloseableIterator[Entry[Key, Value]] = {
<span class="nc bnc" id="L221" title="All 2 branches missed.">      val primary = if (ranges.lengthCompare(1) == 0) {</span>
<span class="nc" id="L222">        val scanner = helper.client.createScanner(table, helper.auths)</span>
<span class="nc" id="L223">        scanner.setRange(ranges.head)</span>
<span class="nc" id="L224">        scanner</span>
      } else {
<span class="nc" id="L226">        val scanner = helper.client.createBatchScanner(table, helper.auths, numThreads)</span>
<span class="nc" id="L227">        scanner.setRanges(ranges.asJava)</span>
<span class="nc" id="L228">        scanner</span>
      }
<span class="nc" id="L230">      iterators.foreach(primary.addScanIterator)</span>
<span class="nc" id="L231">      columnFamily.foreach(primary.fetchColumnFamily)</span>
<span class="nc" id="L232">      helper.consistency.foreach(primary.setConsistencyLevel)</span>
      val join: Seq[Entry[Key, Value]] =&gt; CloseableIterator[Entry[Key, Value]] =
<span class="nc" id="L234">        entries =&gt; joinQuery.copy(tables = Seq(joinTable), ranges = entries.map(joinFunction)).scan(helper)</span>
<span class="nc" id="L235">      new BatchMultiScanner(primary, join)</span>
    }
  }

<span class="nc bnc" id="L239" title="All 44 branches missed.">  private case class ScanHelper(</span>
<span class="nc" id="L240">    client: AccumuloClient, auths: Authorizations, timeout: Option[Timeout], parallel: Boolean, consistency: Option[ConsistencyLevel])</span>

<span class="nc" id="L242">  private object ScanHelper {</span>
    def apply(ds: AccumuloDataStore): ScanHelper = {
      // convert the relative timeout to an absolute timeout up front
<span class="nc" id="L245">      val timeout = ds.config.queries.timeout.map(Timeout.apply)</span>
      // calculate authorizations up front so that multi-threading doesn't mess up auth providers
<span class="nc" id="L247">      ScanHelper(ds.client, ds.auths, timeout, ds.config.queries.parallelPartitionScans, ds.config.queries.consistency)</span>
    }
  }

<span class="nc" id="L251">  private class ScanIterator(scanner: ScannerBase) extends CloseableIterator[Entry[Key, Value]] {</span>
<span class="nc" id="L252">    private val iter = scanner.iterator.asScala</span>
<span class="nc" id="L253">    override def hasNext: Boolean = iter.hasNext</span>
<span class="nc" id="L254">    override def next(): Entry[Key, Value] = iter.next()</span>
<span class="nc" id="L255">    override def close(): Unit = scanner.close()</span>
  }

<span class="nc" id="L258">  private class AccumuloScanner(scanner: ScannerBase) extends LowLevelScanner[Entry[Key, Value]] {</span>
<span class="nc" id="L259">    override def iterator: Iterator[Entry[Key, Value]] = scanner.iterator.asScala</span>
<span class="nc" id="L260">    override def close(): Unit = scanner.close()</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>