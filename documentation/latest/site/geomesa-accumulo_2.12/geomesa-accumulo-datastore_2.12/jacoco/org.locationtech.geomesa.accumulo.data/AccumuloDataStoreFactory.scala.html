<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumuloDataStoreFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.data</a> &gt; <span class="el_source">AccumuloDataStoreFactory.scala</span></div><h1>AccumuloDataStoreFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * Portions Crown Copyright (c) 2016-2025 Dstl
 * Portions Copyright (c) 2021 The MITRE Corporation
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 * This software was produced for the U. S. Government under Basic
 * Contract No. W56KGU-18-D-0004, and is subject to the Rights in
 * Noncommercial Computer Software and Noncommercial Computer Software
 * Documentation Clause 252.227-7014 (FEB 2012)
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.data


import org.apache.accumulo.core.client.ScannerBase.ConsistencyLevel
import org.apache.accumulo.core.client.security.tokens.{KerberosToken, PasswordToken}
import org.apache.accumulo.core.client.{Accumulo, AccumuloClient}
import org.apache.accumulo.core.conf.ClientProperty
import org.apache.hadoop.security.UserGroupInformation
import org.geotools.api.data.DataAccessFactory.Param
import org.geotools.api.data.{DataStoreFactorySpi, Parameter}
import org.locationtech.geomesa.accumulo.AccumuloProperties.BatchWriterProperties
import org.locationtech.geomesa.accumulo.audit.{AccumuloAuditWriter, ParamsAuditProvider}
import org.locationtech.geomesa.index.audit.AuditWriter
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.geotools.GeoMesaDataStoreFactory._
import org.locationtech.geomesa.security.{AuthUtils, AuthorizationsProvider}
import org.locationtech.geomesa.utils.audit.AuditProvider
import org.locationtech.geomesa.utils.geotools.GeoMesaParam

import java.awt.RenderingHints
import java.io.IOException
import java.nio.charset.StandardCharsets
import java.util.{Locale, Properties}

<span class="nc" id="L39">class AccumuloDataStoreFactory extends DataStoreFactorySpi {</span>

  // this is a pass-through required of the ancestor interface
  override def createNewDataStore(params: java.util.Map[String, _]): AccumuloDataStore =
<span class="nc" id="L43">    createDataStore(params)</span>

  override def createDataStore(params: java.util.Map[String, _]): AccumuloDataStore = {
<span class="nc" id="L46">    val client = AccumuloDataStoreFactory.buildAccumuloClient(params)</span>
<span class="nc" id="L47">    val config = AccumuloDataStoreFactory.buildConfig(client, params)</span>
<span class="nc" id="L48">    val ds = new AccumuloDataStore(client, config)</span>
<span class="nc" id="L49">    GeoMesaDataStore.initRemoteVersion(ds)</span>
<span class="nc" id="L50">    ds</span>
  }

<span class="nc" id="L53">  override def isAvailable = true</span>

<span class="nc" id="L55">  override def getDisplayName: String = AccumuloDataStoreFactory.DisplayName</span>

<span class="nc" id="L57">  override def getDescription: String = AccumuloDataStoreFactory.Description</span>

  override def getParametersInfo: Array[Param] =
<span class="nc" id="L60">    AccumuloDataStoreFactory.ParameterInfo ++</span>
<span class="nc" id="L61">        Array(AccumuloDataStoreParams.NamespaceParam, AccumuloDataStoreFactory.DeprecatedGeoServerPasswordParam)</span>

  override def canProcess(params: java.util.Map[String, _]): Boolean =
<span class="nc" id="L64">    AccumuloDataStoreFactory.canProcess(params)</span>

<span class="nc" id="L66">  override def getImplementationHints: java.util.Map[RenderingHints.Key, _] = null</span>
}

<span class="nc" id="L69">object AccumuloDataStoreFactory extends GeoMesaDataStoreInfo {</span>

  import AccumuloDataStoreParams._

  import scala.collection.JavaConverters._

<span class="nc" id="L75">  override val DisplayName = &quot;Accumulo (GeoMesa)&quot;</span>
<span class="nc" id="L76">  override val Description = &quot;Apache Accumulo\u2122 distributed key/value store&quot;</span>

<span class="nc" id="L78">  override val ParameterInfo: Array[GeoMesaParam[_ &lt;: AnyRef]] =</span>
<span class="nc" id="L79">    Array(</span>
<span class="nc" id="L80">      InstanceNameParam,</span>
<span class="nc" id="L81">      ZookeepersParam,</span>
<span class="nc" id="L82">      CatalogParam,</span>
<span class="nc" id="L83">      UserParam,</span>
<span class="nc" id="L84">      PasswordParam,</span>
<span class="nc" id="L85">      KeytabPathParam,</span>
<span class="nc" id="L86">      QueryThreadsParam,</span>
<span class="nc" id="L87">      RecordThreadsParam,</span>
<span class="nc" id="L88">      WriteThreadsParam,</span>
<span class="nc" id="L89">      QueryTimeoutParam,</span>
<span class="nc" id="L90">      ZookeeperTimeoutParam,</span>
<span class="nc" id="L91">      RemoteArrowParam,</span>
<span class="nc" id="L92">      RemoteBinParam,</span>
<span class="nc" id="L93">      RemoteDensityParam,</span>
<span class="nc" id="L94">      RemoteStatsParam,</span>
<span class="nc" id="L95">      GenerateStatsParam,</span>
<span class="nc" id="L96">      AuditQueriesParam,</span>
<span class="nc" id="L97">      MetricsRegistryParam,</span>
<span class="nc" id="L98">      MetricsRegistryConfigParam,</span>
<span class="nc" id="L99">      LooseBBoxParam,</span>
<span class="nc" id="L100">      PartitionParallelScansParam,</span>
<span class="nc" id="L101">      QueryConsistencyParam,</span>
<span class="nc" id="L102">      AuthsParam,</span>
<span class="nc" id="L103">      AuthProviderParam,</span>
<span class="nc" id="L104">      ForceEmptyAuthsParam</span>
    )

  // used to handle geoserver password encryption in persisted ds params
<span class="nc" id="L108">  private val DeprecatedGeoServerPasswordParam =</span>
<span class="nc" id="L109">    new Param(</span>
<span class="nc" id="L110">      &quot;password&quot;,</span>
<span class="nc" id="L111">      classOf[String],</span>
<span class="nc" id="L112">      &quot;&quot;,</span>
<span class="nc" id="L113">      false,</span>
<span class="nc" id="L114">      null,</span>
<span class="nc" id="L115">      Map(Parameter.DEPRECATED -&gt; true, Parameter.IS_PASSWORD -&gt; true).asJava)</span>

  override def canProcess(params: java.util.Map[String, _]): Boolean =
<span class="nc" id="L118">    CatalogParam.exists(params)</span>

  @deprecated(&quot;Replaced with buildAccumuloClient&quot;)
<span class="nc" id="L121">  def buildAccumuloConnector(params: java.util.Map[String, _]): AccumuloClient = buildAccumuloClient(params)</span>

  /**
   * Build an accumulo client
   *
   * @param params data store params
   * @return
   */
  def buildAccumuloClient(params: java.util.Map[String, _]): AccumuloClient =
<span class="nc" id="L130">    Accumulo.newClient().from(AccumuloDataStoreFactory.buildAccumuloClientConfig(params)).build()</span>

  /**
   * Build an Accumulo client configuration, based on passed in parameters and any accumulo-client.properties
   * file on the classpath
   *
   * @param params data store params
   * @return
   */
  def buildAccumuloClientConfig(params: java.util.Map[String, _]): Properties = {
<span class="nc" id="L140">    val config = AccumuloClientConfig.load()</span>

    def setRequired(param: GeoMesaParam[String], key: ClientProperty): String = {
<span class="nc" id="L143">      param.lookupOpt(params) match {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        case Some(v) =&gt; config.put(key.getKey, v); v</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        case None =&gt;</span>
<span class="nc" id="L146">          Option(config.getProperty(key.getKey)).getOrElse {</span>
<span class="nc" id="L147">            throw new IOException(s&quot;Parameter ${param.key} is required: ${param.description}&quot;)</span>
          }
      }
    }

    def setOptional(param: GeoMesaParam[String], key: ClientProperty): Unit =
<span class="nc" id="L153">      param.lookupOpt(params).foreach(config.put(key.getKey, _))</span>

    def getRequired(param: GeoMesaParam[String], key: ClientProperty): String = {
<span class="nc" id="L156">      param.lookupOpt(params).orElse(Option(config.getProperty(key.getKey))).getOrElse {</span>
<span class="nc" id="L157">        throw new IOException(s&quot;Parameter ${param.key} is required: ${param.description}&quot;)</span>
      }
    }

<span class="nc" id="L161">    setRequired(InstanceNameParam, ClientProperty.INSTANCE_NAME)</span>
<span class="nc" id="L162">    setRequired(ZookeepersParam, ClientProperty.INSTANCE_ZOOKEEPERS)</span>
<span class="nc" id="L163">    setOptional(ZookeeperTimeoutParam, ClientProperty.INSTANCE_ZOOKEEPERS_TIMEOUT)</span>

<span class="nc" id="L165">    val user = setRequired(UserParam, ClientProperty.AUTH_PRINCIPAL)</span>

<span class="nc bnc" id="L167" title="All 4 branches missed.">    if (PasswordParam.exists(params) &amp;&amp; KeytabPathParam.exists(params)) {</span>
<span class="nc" id="L168">      throw new IllegalArgumentException(</span>
<span class="nc" id="L169">        s&quot;'${PasswordParam.key}' and '${KeytabPathParam.key}' are mutually exclusive, but are both set&quot;)</span>
    }

    val authType =
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (PasswordParam.exists(params)) {</span>
<span class="nc" id="L174">        AccumuloClientConfig.PasswordAuthType</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">      } else if (KeytabPathParam.exists(params)) {</span>
<span class="nc" id="L176">        AccumuloClientConfig.KerberosAuthType</span>
      } else {
<span class="nc" id="L178">        ClientProperty.AUTH_TYPE.getValue(config).toLowerCase(Locale.US)</span>
      }

    val token =
<span class="nc bnc" id="L182" title="All 6 branches missed.">      if (authType == AccumuloClientConfig.PasswordAuthType) {</span>
<span class="nc" id="L183">        new PasswordToken(getRequired(PasswordParam, ClientProperty.AUTH_TOKEN).getBytes(StandardCharsets.UTF_8))</span>
<span class="nc bnc" id="L184" title="All 6 branches missed.">      } else if (authType == AccumuloClientConfig.KerberosAuthType) {</span>
<span class="nc" id="L185">        val file = new java.io.File(getRequired(KeytabPathParam, ClientProperty.AUTH_TOKEN))</span>
        // mimic behavior from accumulo 1.9 and earlier:
        // `public KerberosToken(String principal, File keytab, boolean replaceCurrentUser)`
<span class="nc" id="L188">        UserGroupInformation.loginUserFromKeytab(user, file.getAbsolutePath)</span>
<span class="nc" id="L189">        new KerberosToken(user, file)</span>
      } else {
<span class="nc" id="L191">         throw new IllegalArgumentException(</span>
<span class="nc" id="L192">           s&quot;Unsupported auth type: $authType - supported values are &quot; +</span>
<span class="nc" id="L193">             s&quot;${AccumuloClientConfig.PasswordAuthType}, ${AccumuloClientConfig.KerberosAuthType}&quot;)</span>
      }
<span class="nc" id="L195">    ClientProperty.setAuthenticationToken(config, token)</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">    if (WriteThreadsParam.exists(params)) {</span>
<span class="nc" id="L198">      config.put(ClientProperty.BATCH_WRITER_THREADS_MAX.getKey, WriteThreadsParam.lookup(params).toString)</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    } else if (ClientProperty.BATCH_WRITER_THREADS_MAX.isEmpty(config)) {</span>
<span class="nc" id="L200">      BatchWriterProperties.WRITER_THREADS.option.foreach { threads =&gt;</span>
<span class="nc" id="L201">        config.put(ClientProperty.BATCH_WRITER_THREADS_MAX.getKey, String.valueOf(threads))</span>
      }
    }
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (ClientProperty.BATCH_WRITER_MEMORY_MAX.isEmpty(config)) {</span>
<span class="nc" id="L205">      BatchWriterProperties.WRITER_MEMORY_BYTES.toBytes.foreach { memory =&gt;</span>
<span class="nc" id="L206">        config.put(ClientProperty.BATCH_WRITER_MEMORY_MAX.getKey, String.valueOf(memory))</span>
      }
    }
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (ClientProperty.BATCH_WRITER_LATENCY_MAX.isEmpty(config)) {</span>
<span class="nc" id="L210">      BatchWriterProperties.WRITER_LATENCY.toDuration.foreach { duration =&gt;</span>
<span class="nc" id="L211">        config.put(ClientProperty.BATCH_WRITER_LATENCY_MAX.getKey, s&quot;${duration.toMillis}ms&quot;)</span>
      }
    }
<span class="nc bnc" id="L214" title="All 2 branches missed.">    if (ClientProperty.BATCH_WRITER_TIMEOUT_MAX.isEmpty(config)) {</span>
<span class="nc" id="L215">      BatchWriterProperties.WRITE_TIMEOUT.toDuration.foreach { duration =&gt;</span>
<span class="nc" id="L216">        config.put(ClientProperty.BATCH_WRITER_TIMEOUT_MAX.getKey, s&quot;${duration.toMillis}ms&quot;)</span>
      }
    }

<span class="nc" id="L220">    config</span>
  }

  /**
   * Build the data store config
   *
   * @param client accumulo client
   * @param params data store params
   * @return
   */
  def buildConfig(client: AccumuloClient, params: java.util.Map[String, _]): AccumuloDataStoreConfig = {
<span class="nc" id="L231">    val catalog = CatalogParam.lookup(params)</span>

<span class="nc" id="L233">    val authProvider = buildAuthsProvider(client, params)</span>
<span class="nc" id="L234">    val auditProvider = buildAuditProvider(params)</span>
    val auditWriter =
<span class="nc" id="L236">      new AccumuloAuditWriter(client, s&quot;${catalog}_queries&quot;, auditProvider, AuditQueriesParam.lookup(params).booleanValue())</span>
<span class="nc" id="L237">    val metrics = MetricsRegistryParam.lookupRegistry(params)</span>

<span class="nc" id="L239">    val queries = AccumuloQueryConfig(</span>
<span class="nc" id="L240">      threads = QueryThreadsParam.lookup(params),</span>
<span class="nc" id="L241">      recordThreads = RecordThreadsParam.lookup(params),</span>
<span class="nc" id="L242">      timeout = QueryTimeoutParam.lookupOpt(params).map(_.toMillis),</span>
<span class="nc" id="L243">      looseBBox = LooseBBoxParam.lookup(params),</span>
<span class="nc" id="L244">      parallelPartitionScans = PartitionParallelScansParam.lookup(params),</span>
<span class="nc" id="L245">      consistency = QueryConsistencyParam.lookupOpt(params).map(n =&gt; ConsistencyLevel.valueOf(n.toUpperCase(Locale.US)))</span>
    )

<span class="nc" id="L248">    val remote = RemoteScansEnabled(</span>
<span class="nc" id="L249">      arrow = RemoteArrowParam.lookup(params),</span>
<span class="nc" id="L250">      bin = RemoteBinParam.lookup(params),</span>
<span class="nc" id="L251">      density = RemoteDensityParam.lookup(params),</span>
<span class="nc" id="L252">      stats = RemoteStatsParam.lookup(params)</span>
    )

<span class="nc" id="L255">    AccumuloDataStoreConfig(</span>
<span class="nc" id="L256">      catalog = catalog,</span>
<span class="nc" id="L257">      generateStats = GenerateStatsParam.lookup(params),</span>
<span class="nc" id="L258">      authProvider = authProvider,</span>
<span class="nc" id="L259">      auditWriter = auditWriter,</span>
<span class="nc" id="L260">      metrics = metrics,</span>
<span class="nc" id="L261">      queries = queries,</span>
<span class="nc" id="L262">      remote = remote,</span>
<span class="nc" id="L263">      writeThreads = WriteThreadsParam.lookup(params),</span>
<span class="nc" id="L264">      namespace = NamespaceParam.lookupOpt(params)</span>
    )
  }

  def buildAuditProvider(params: java.util.Map[String, _]): AuditProvider = {
<span class="nc" id="L269">    Option(AuditProvider.Loader.load(params)).getOrElse {</span>
<span class="nc" id="L270">      val provider = new ParamsAuditProvider</span>
<span class="nc" id="L271">      provider.configure(params)</span>
<span class="nc" id="L272">      provider</span>
    }
  }

  def buildAuthsProvider(client: AccumuloClient, params: java.util.Map[String, _]): AuthorizationsProvider = {
    // convert the connector authorizations into a string array - this is the maximum auths this connector can support
<span class="nc" id="L278">    val securityOps = client.securityOperations</span>
<span class="nc" id="L279">    val masterAuths = securityOps.getUserAuthorizations(client.whoami).asScala.toSeq.map(b =&gt; new String(b))</span>

    // get the auth params passed in as a comma-delimited string
<span class="nc" id="L282">    val configuredAuths = AuthsParam.lookupOpt(params).getOrElse(&quot;&quot;).split(&quot;,&quot;).filterNot(_.isEmpty).toSeq</span>

    // verify that the configured auths are valid for the connector we are using (fail-fast)
<span class="nc" id="L285">    val invalidAuths = configuredAuths.filterNot(masterAuths.contains)</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">    if (invalidAuths.nonEmpty) {</span>
<span class="nc" id="L287">      throw new IllegalArgumentException(s&quot;The authorizations '${invalidAuths.mkString(&quot;', '&quot;)}' &quot; +</span>
<span class="nc" id="L288">        &quot;are not valid for the Accumulo connection being used&quot;)</span>
    }

<span class="nc" id="L291">    val forceEmptyAuths = ForceEmptyAuthsParam.lookup(params)</span>

    // if the caller provided any non-null string for authorizations, use it;
    // otherwise, grab all authorizations to which the Accumulo user is entitled
<span class="nc bnc" id="L295" title="All 4 branches missed.">    if (configuredAuths.nonEmpty &amp;&amp; forceEmptyAuths) {</span>
<span class="nc" id="L296">      throw new IllegalArgumentException(&quot;Forcing empty auths is checked, but explicit auths are provided&quot;)</span>
    }
<span class="nc bnc" id="L298" title="All 4 branches missed.">    val auths = if (forceEmptyAuths || configuredAuths.nonEmpty) { configuredAuths } else { masterAuths }</span>

<span class="nc" id="L300">    AuthUtils.getProvider(params, auths)</span>
  }

  /**
   * Configuration options for AccumuloDataStore
   *
   * @param catalog table in Accumulo used to store feature type metadata
   * @param generateStats write stats on data during ingest
   * @param authProvider provides the authorizations used to access data
   * @param auditWriter to audit queries
   * @param metrics registry factory for metrics
   * @param queries query config
   * @param remote remote query configs
   * @param writeThreads number of threads used for writing
   */
<span class="nc bnc" id="L315" title="All 68 branches missed.">  case class AccumuloDataStoreConfig(</span>
<span class="nc" id="L316">      catalog: String,</span>
<span class="nc" id="L317">      generateStats: Boolean,</span>
<span class="nc" id="L318">      authProvider: AuthorizationsProvider,</span>
<span class="nc" id="L319">      auditWriter: AccumuloAuditWriter,</span>
<span class="nc" id="L320">      metrics: Option[MetricsConfig],</span>
<span class="nc" id="L321">      queries: AccumuloQueryConfig,</span>
<span class="nc" id="L322">      remote: RemoteScansEnabled,</span>
<span class="nc" id="L323">      writeThreads: Int,</span>
<span class="nc" id="L324">      namespace: Option[String]</span>
<span class="nc" id="L325">    ) extends GeoMesaDataStoreConfig {</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">    lazy val audit: Option[AuditWriter] = Some(auditWriter)</span>
  }

<span class="nc bnc" id="L329" title="All 41 branches missed.">  case class AccumuloQueryConfig(</span>
<span class="nc" id="L330">      threads: Int,</span>
<span class="nc" id="L331">      recordThreads: Int,</span>
<span class="nc" id="L332">      timeout: Option[Long],</span>
<span class="nc" id="L333">      looseBBox: Boolean,</span>
<span class="nc" id="L334">      parallelPartitionScans: Boolean,</span>
<span class="nc" id="L335">      consistency: Option[ConsistencyLevel],</span>
<span class="nc" id="L336">    ) extends DataStoreQueryConfig</span>

<span class="nc bnc" id="L338" title="All 31 branches missed.">  case class RemoteScansEnabled(arrow: Boolean, bin: Boolean, density: Boolean, stats: Boolean)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>