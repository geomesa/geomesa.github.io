<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumuloAuditWriter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.audit</a> &gt; <span class="el_source">AccumuloAuditWriter.scala</span></div><h1>AccumuloAuditWriter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.audit

import com.typesafe.scalalogging.StrictLogging
import org.apache.accumulo.core.client.{AccumuloClient, BatchWriter}
import org.geotools.api.filter.Filter
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.accumulo.audit.AccumuloAuditWriter.ShutdownTimeout
import org.locationtech.geomesa.accumulo.data.AccumuloQueryPlan
import org.locationtech.geomesa.accumulo.util.{GeoMesaBatchWriterConfig, TableManager}
import org.locationtech.geomesa.index.api.QueryPlan
import org.locationtech.geomesa.index.audit.AuditWriter
import org.locationtech.geomesa.index.audit.AuditedEvent.QueryEvent
import org.locationtech.geomesa.utils.audit.AuditProvider
import org.locationtech.geomesa.utils.concurrent.ExitingExecutor
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty

import java.io.Closeable
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock
import java.util.concurrent.{ScheduledThreadPoolExecutor, TimeUnit}
import scala.concurrent.{Future, Promise}
import scala.util.Try
import scala.util.control.NonFatal

/**
 * Audit writer that persists log entries to a table in Accumulo
 *
 * @param client accumulo client
 * @param table table to write to
 * @param auditProvider audit provider
 * @param enabled enable table writes (entries will always be written to logs)
 */
<span class="nc" id="L41">class AccumuloAuditWriter(</span>
<span class="nc" id="L42">    client: AccumuloClient,</span>
<span class="nc" id="L43">    val table: String,</span>
    auditProvider: AuditProvider,
<span class="nc" id="L45">    enabled: Boolean</span>
<span class="nc" id="L46">  ) extends AuditWriter(StoreType, auditProvider) with Runnable with Closeable with StrictLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L50">  private var writer: BatchWriter = _</span>

<span class="nc" id="L52">  private val queue = new java.util.concurrent.ConcurrentLinkedQueue[(Promise[Unit], QueryEvent, Seq[AccumuloQueryPlan])]</span>

<span class="nc" id="L54">  private val running = new AtomicBoolean(true)</span>
<span class="nc" id="L55">  private val writeLock = new ReentrantLock()</span>

<span class="nc" id="L57">  private val timeout = ShutdownTimeout.toDuration.get.toMillis</span>

<span class="nc" id="L59">  private val scheduledRun = {</span>
<span class="nc" id="L60">    val millis = AccumuloAuditWriter.WriteInterval.toDuration.get.toMillis</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">    logger.debug(s&quot;Scheduling audit writer for ${millis}ms&quot;)</span>
<span class="nc" id="L62">    AccumuloAuditWriter.executor.scheduleWithFixedDelay(this, millis, millis, TimeUnit.MILLISECONDS)</span>
  }

  override def writeQueryEvent(
      typeName: String,
      user: String,
      filter: Filter,
      hints: Hints,
      plans: Seq[QueryPlan],
      startTime: Long,
      endTime: Long,
      planTime: Long,
      scanTime: Long,
      hits: Long): Future[Unit] = {
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (running.get()) {</span>
<span class="nc" id="L77">      val promise = Promise[Unit]()</span>
      // note: we populate the metadata in the asynchronous thread
<span class="nc" id="L79">      val eventNoMeta = QueryEvent(storeType, typeName, user, filter, hints, startTime, endTime, planTime, scanTime, hits)</span>
<span class="nc" id="L80">      queue.offer((promise, eventNoMeta, plans.asInstanceOf[Seq[AccumuloQueryPlan]])) // unbounded queue so will never fail</span>
<span class="nc" id="L81">      promise.future</span>
    } else {
<span class="nc" id="L83">      Future.failed(new RuntimeException(&quot;This AuditWriter instance has been closed&quot;))</span>
    }
  }

  override def run(): Unit = {
<span class="nc bnc" id="L88" title="All 4 branches missed.">    if (running.get() &amp;&amp; writeLock.tryLock()) {</span>
<span class="nc" id="L89">      try { writeQueuedEvents() } finally {</span>
<span class="nc" id="L90">        writeLock.unlock()</span>
      }
    }
  }

  private def writeQueuedEvents(): Unit = {
<span class="nc" id="L96">    try {</span>
<span class="nc" id="L97">      var promiseAndEvent = queue.poll()</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">      if (promiseAndEvent != null) {</span>
<span class="nc" id="L99">        val stopTime = System.currentTimeMillis() + timeout</span>
<span class="nc bnc" id="L100" title="All 4 branches missed.">        if (enabled &amp;&amp; writer == null) {</span>
<span class="nc" id="L101">          new TableManager(client).ensureTableExists(table)</span>
<span class="nc" id="L102">          val writeConfig = GeoMesaBatchWriterConfig().setMaxMemory(10000L).setMaxWriteThreads(5)</span>
<span class="nc" id="L103">          writer = client.createBatchWriter(table, writeConfig)</span>
        }
<span class="nc bnc" id="L105" title="All 2 branches missed.">        while (promiseAndEvent != null) {</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">          val (promise, eventNoMeta, plans) = promiseAndEvent</span>
          val write =
<span class="nc" id="L108">            Try {</span>
<span class="nc" id="L109">              val event = eventNoMeta.copy(metadata = createMetadata(plans))</span>
<span class="nc" id="L110">              AuditWriter.log(event)</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">              if (enabled) {</span>
<span class="nc" id="L112">                writer.addMutation(AccumuloQueryEventTransform.toMutation(event))</span>
              }
            }
<span class="nc" id="L115">          promise.complete(write)</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">          promiseAndEvent = if (running.get() || System.currentTimeMillis() &lt; stopTime) { queue.poll() } else { null }</span>
        }
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (enabled) {</span>
<span class="nc" id="L119">          writer.flush()</span>
        }
      }
    } catch {
<span class="nc bnc" id="L123" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.error(&quot;Error writing audit logs:&quot;, e)</span>
    }
  }

  private def createMetadata(plans: Seq[AccumuloQueryPlan]): java.util.Map[String, AnyRef] = {
    // note: use tree maps for consistent ordering in json output
<span class="nc" id="L129">    val planMeta = plans.map { plan =&gt;</span>
<span class="nc" id="L130">      val planData = new java.util.TreeMap[String, AnyRef]()</span>
<span class="nc" id="L131">      planData.put(&quot;index&quot;, plan.filter.index.identifier)</span>
<span class="nc" id="L132">      val tables = new java.util.TreeMap[String, String]()</span>
<span class="nc" id="L133">      planData.put(&quot;tables&quot;, tables)</span>
<span class="nc" id="L134">      val locations = new java.util.TreeMap[String, java.util.Set[String]]()</span>
<span class="nc" id="L135">      planData.put(&quot;locations&quot;, locations)</span>
<span class="nc" id="L136">      plan.tables.foreach { table =&gt;</span>
<span class="nc" id="L137">        tables.put(table, client.tableOperations().tableIdMap().get(table))</span>
<span class="nc" id="L138">        val locate = client.tableOperations().locate(table, plan.ranges.asJava)</span>
<span class="nc" id="L139">        locate.groupByTablet().asScala.keys.foreach { tablet =&gt;</span>
<span class="nc" id="L140">          val location = locate.getTabletLocation(tablet)</span>
<span class="nc" id="L141">          var tablets = locations.get(location)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">          if (tablets == null) {</span>
<span class="nc" id="L143">            tablets = new java.util.TreeSet[String]()</span>
<span class="nc" id="L144">            locations.put(location, tablets)</span>
          }
<span class="nc" id="L146">          tablets.add(tablet.toString)</span>
        }
      }
<span class="nc" id="L149">      planData.put(&quot;iterators&quot;, plan.iterators.map(_.toString).sorted.asJava)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">      plan.join.foreach { case (_, join) =&gt; planData.put(&quot;join&quot;, join.filter.index.identifier) }</span>
<span class="nc" id="L151">      plan.sort.foreach { sort =&gt;</span>
<span class="nc bnc" id="L152" title="All 4 branches missed.">        planData.put(&quot;sort&quot;, sort.map { case (field, descending) =&gt; s&quot;$field:${if (descending) { &quot;desc&quot; } else { &quot;asc&quot; }}&quot;}.asJava)</span>
      }
<span class="nc" id="L154">      plan.maxFeatures.foreach(m =&gt; planData.put(&quot;limit&quot;, Int.box(m)))</span>
<span class="nc" id="L155">      planData</span>
    }
<span class="nc" id="L157">    java.util.Map.of(&quot;queryPlans&quot;, planMeta.asJava)</span>
  }

  override def close(): Unit = {
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (running.compareAndSet(true, false)) {</span>
<span class="nc" id="L162">      scheduledRun.cancel(false)</span>
      try {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (writeLock.tryLock()) {</span>
          // not currently running, so clean up any remaining events
<span class="nc" id="L166">          writeQueuedEvents()</span>
        } else {
          // currently running, wait for run to end
<span class="nc" id="L169">          writeLock.lock()</span>
        }
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (writer != null) {</span>
<span class="nc" id="L172">          writer.close()</span>
        }
      } finally {
<span class="nc" id="L175">        writeLock.unlock()</span>
      }
    }
  }
}

<span class="nc" id="L181">object AccumuloAuditWriter {</span>

<span class="nc" id="L183">  val WriteInterval: SystemProperty = SystemProperty(&quot;geomesa.accumulo.audit.interval&quot;, &quot;5 seconds&quot;)</span>
<span class="nc" id="L184">  val ShutdownTimeout: SystemProperty = SystemProperty(&quot;geomesa.accumulo.audit.shutdown.timeout&quot;, &quot;5 seconds&quot;)</span>

<span class="nc" id="L186">  private val executor = ExitingExecutor(new ScheduledThreadPoolExecutor(5), force = true)</span>
<span class="nc" id="L187">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>