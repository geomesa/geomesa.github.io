<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumuloEventTransform.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.audit</a> &gt; <span class="el_source">AccumuloEventTransform.scala</span></div><h1>AccumuloEventTransform.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.audit

import com.typesafe.scalalogging.LazyLogging
import org.apache.accumulo.core.client.Scanner
import org.apache.accumulo.core.data.{Key, Mutation, Range, Value}
import org.apache.hadoop.io.Text
import org.locationtech.geomesa.accumulo.audit.AccumuloEventTransform.RowGrouper
import org.locationtech.geomesa.index.audit.AuditedEvent
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.io.CloseQuietly
import org.locationtech.geomesa.utils.text.DateParsing

import java.time.format.DateTimeFormatter
import java.time.{ZoneOffset, ZonedDateTime}
import java.util.Map.Entry
import scala.util.Random
import scala.util.control.NonFatal

/**
 * Trait for mapping stats to accumulo and back
 */
<span class="nc" id="L30">trait AccumuloEventTransform[T &lt;: AuditedEvent] extends LazyLogging {</span>

  import AccumuloEventTransform.toRowKey

  /**
   * Convert an event to a mutation
   *
   * @param event event
   * @return
   */
  def toMutation(event: T): Mutation

  /**
   * Convert accumulo scan results into an event
   *
   * @param entries scan entries from a single row
   * @return
   */
  def toEvent(entries: Iterable[Entry[Key, Value]]): T

  /**
   * Creates an iterator that returns Stats from accumulo scans
   *
   * @param scanner accumulo scanner over stored events
   * @param typeName type name to scan
   * @param dates dates to scan
   * @return
   */
  def iterator(scanner: Scanner, typeName: String, dates: (ZonedDateTime, ZonedDateTime)): CloseableIterator[T] = {
<span class="nc" id="L59">    try {</span>
<span class="nc" id="L60">      scanner.setRange(new Range(toRowKey(typeName, dates._1), true, toRowKey(typeName, dates._2), false))</span>
<span class="nc" id="L61">      new RowGrouper(scanner).flatMap(_.groupBy(_.getKey.getColumnFamily).values).map(toEvent)</span>
    } catch {
<span class="nc bnc" id="L63" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc" id="L64">        CloseQuietly(scanner).foreach(e.addSuppressed)</span>
<span class="nc" id="L65">        throw e</span>
    }
  }
}

<span class="nc" id="L70">object AccumuloEventTransform {</span>

<span class="nc" id="L72">  val DateFormat: DateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyyMMdd-HH:mm:ss.SSS&quot;).withZone(ZoneOffset.UTC)</span>

<span class="nc" id="L74">  private val RowId = &quot;(.*)~(.*)&quot;.r</span>

  /**
   * Extract type name and date from a row key
   *
   * @param key row key
   * @return
   */
  private[audit] def typeNameAndDate(key: Key): (String, Long) = {
<span class="nc bnc" id="L83" title="All 6 branches missed.">    val RowId(typeName, dateString) = key.getRow.toString</span>
<span class="nc" id="L84">    val date = ZonedDateTime.parse(dateString, DateFormat).toInstant.toEpochMilli</span>
<span class="nc" id="L85">    (typeName, date)</span>
  }

  /**
   * Create a row key from a type name and date
   *
   * @param typeName feature type name
   * @param date event date
   * @return
   */
  private[audit] def toRowKey(typeName: String, date: Long): String =
<span class="nc" id="L96">    s&quot;$typeName~${DateParsing.formatMillis(date, DateFormat)}&quot;</span>

  /**
   * Create a row key from a type name and date
   *
   * @param typeName feature type name
   * @param date event date
   * @return
   */
  private[audit] def toRowKey(typeName: String, date: ZonedDateTime): String =
<span class="nc" id="L106">    s&quot;$typeName~${DateParsing.format(date, DateFormat)}&quot;</span>

  /**
   * Create a random col family
   *
   * @return
   */
<span class="nc" id="L113">  private[audit] def createRandomColumnFamily: Text = new Text(&quot;%1$04d&quot;.format(Random.nextInt(10000)))</span>

  /**
   * Groups scan entries by row
   *
   * @param scanner scanner
   */
<span class="nc" id="L120">  private class RowGrouper(scanner: Scanner) extends CloseableIterator[Seq[Entry[Key, Value]]] {</span>

<span class="nc" id="L122">    private val iter = scanner.iterator()</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">    private var nextEntry: Entry[Key, Value] = if (iter.hasNext) { iter.next() } else { null }</span>

<span class="nc bnc" id="L125" title="All 2 branches missed.">    override def hasNext: Boolean = nextEntry != null</span>

    override def next(): Seq[Entry[Key, Value]] = {
<span class="nc bnc" id="L128" title="All 2 branches missed.">      if (nextEntry == null) {</span>
<span class="nc" id="L129">        return null</span>
      }
<span class="nc" id="L131">      val currentRowKey = nextEntry.getKey.getRow.toString</span>
<span class="nc" id="L132">      val entries = Seq.newBuilder[Entry[Key, Value]]</span>
<span class="nc" id="L133">      entries += nextEntry</span>
<span class="nc" id="L134">      var currentEntry: Entry[Key, Value] = null</span>
<span class="nc bnc" id="L135" title="All 8 branches missed.">      while (iter.hasNext &amp;&amp; { currentEntry = iter.next(); currentEntry.getKey.getRow.toString == currentRowKey }) {</span>
<span class="nc" id="L136">        entries += currentEntry</span>
<span class="nc" id="L137">        currentEntry = null</span>
      }
<span class="nc" id="L139">      nextEntry = currentEntry</span>
<span class="nc" id="L140">      entries.result()</span>
    }

<span class="nc" id="L143">    override def close(): Unit = scanner.close()</span>
  }
<span class="nc" id="L145">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>