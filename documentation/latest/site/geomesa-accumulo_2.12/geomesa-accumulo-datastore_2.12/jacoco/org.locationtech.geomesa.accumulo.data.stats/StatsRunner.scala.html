<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatsRunner.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.data.stats</a> &gt; <span class="el_source">StatsRunner.scala</span></div><h1>StatsRunner.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.data.stats

import org.apache.accumulo.core.conf.ClientProperty
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.accumulo.data.AccumuloDataStore
import org.locationtech.geomesa.index.metadata.GeoMesaMetadata
import org.locationtech.geomesa.index.zk.ZookeeperLocking
import org.locationtech.geomesa.utils.geotools._
import org.locationtech.geomesa.utils.text.StringSerialization

import java.io.Closeable
import java.time.temporal.ChronoUnit
import java.time.{Clock, Instant}
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.{Callable, Executors, Future, TimeUnit}

/**
  * Update stats for a data store in a background thread. Uses distributed locking to ensure
  * that work isn't being duplicated.
  *
  * Note: currently we do not schedule stats to automatically run. Instead, we can use the
  * command line tools and OS scheduling (e.g. cron).
  *
  * @param ds data store to collect stats for
  */
<span class="nc" id="L34">class StatsRunner(ds: AccumuloDataStore) extends Runnable with Closeable {</span>

<span class="nc" id="L36">  private val es = Executors.newSingleThreadScheduledExecutor()</span>
<span class="nc" id="L37">  private val scheduled = new AtomicBoolean(false)</span>
<span class="nc" id="L38">  private val shutdown  = new AtomicBoolean(false)</span>

  /**
    * Runs updates asynchronously. Will continue scheduling itself until 'close' is called.
    *
    * @param initialDelay initial delay, in minutes
    */
<span class="nc" id="L45">  def scheduleRepeating(initialDelay: Int = 0): Unit = {</span>
<span class="nc" id="L46">    scheduled.set(true)</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">    if (initialDelay &gt; 0) {</span>
<span class="nc" id="L48">      es.schedule(this, initialDelay, TimeUnit.MINUTES)</span>
    } else {
<span class="nc" id="L50">      es.submit(this)</span>
    }
  }

  /**
    * Submits a stat run for the given sft
    *
    * @param sft simple feature type
    * @param delay delay, in minutes before executing
    * @return
    */
<span class="nc" id="L61">  def submit(sft: SimpleFeatureType, delay: Int = 0): Future[Instant] = {</span>
<span class="nc" id="L62">    val runner = new StatRunner(ds, sft)</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">    if (delay &gt; 0) {</span>
<span class="nc" id="L64">      es.schedule(runner, delay, TimeUnit.MINUTES)</span>
    } else {
<span class="nc" id="L66">      es.submit(runner)</span>
    }
  }

  /**
    * Checks for the last time stats were run, and runs if needed.
    * Updates metadata accordingly.
    */
  override def run(): Unit = {
    // convert to iterator so we check shutdown before each update
<span class="nc bnc" id="L76" title="All 2 branches missed.">    val sfts = ds.getTypeNames.map(ds.getSchema).iterator.filter(_ =&gt; !shutdown.get())</span>
    // try to get an exclusive lock on the sft - if not, don't wait just move along
<span class="nc" id="L78">    val lockTimeout = Some(1000L)</span>
    // force execution of iterator
<span class="nc bnc" id="L80" title="All 2 branches missed.">    val minUpdate = if (sfts.isEmpty) { None } else {</span>
<span class="nc" id="L81">      Some(sfts.map(new StatRunner(ds, _, lockTimeout).call()).map(_.toEpochMilli).min)</span>
    }
    // wait at least one minute before running again
<span class="nc" id="L84">    val minWait = 60000L</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">    val nextRun = minUpdate.map(_ - Instant.now(Clock.systemUTC()).toEpochMilli).filter(_ &gt; minWait).getOrElse(minWait)</span>

<span class="nc bnc" id="L87" title="All 4 branches missed.">    if (scheduled.get() &amp;&amp; !shutdown.get()) {</span>
<span class="nc" id="L88">      es.schedule(this, nextRun, TimeUnit.MILLISECONDS)</span>
    }
  }

  override def close(): Unit = {
<span class="nc" id="L93">    shutdown.getAndSet(true)</span>
<span class="nc" id="L94">    es.shutdown()</span>
  }
}

/**
  * Callable to check and update if necessary stats for a single sft
  *
  * @param ds accumulo data store
  * @param sft simple feature type to check stats for
  * @param lockTimeout timeout for how long to wait for distributed lock, in millis.
  *                    If none, will wait indefinitely
  */
<span class="nc" id="L106">class StatRunner(ds: AccumuloDataStore, sft: SimpleFeatureType, lockTimeout: Option[Long] = None)</span>
<span class="nc" id="L107">    extends Callable[Instant] with ZookeeperLocking {</span>

  override protected def zookeepers: String =
<span class="nc" id="L110">    ds.client.properties().getProperty(ClientProperty.INSTANCE_ZOOKEEPERS.getKey)</span>

  /**
    * Runs stats for the simple feature type
    *
    * @return time of the next scheduled update
    */
  override def call(): Instant = {
    // do a quick check on the last time stats were updated
<span class="nc" id="L119">    val updateInterval = getUpdateInterval</span>
<span class="nc" id="L120">    val unsafeUpdate = getLastUpdate.plus(updateInterval, ChronoUnit.MINUTES)</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">    if (unsafeUpdate.isAfter(Instant.now(Clock.systemUTC()))) {</span>
<span class="nc" id="L123">      unsafeUpdate</span>
    } else {
      // get the lock and re-check, in case stats have been updated by another thread
<span class="nc" id="L126">      val lockOption = lockTimeout match {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        case None =&gt; Some(acquireDistributedLock(lockKey))</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        case Some(timeout) =&gt; acquireDistributedLock(lockKey, timeout)</span>
      }
<span class="nc" id="L130">      lockOption match {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        case None =&gt; Instant.now(Clock.systemUTC()).plus(5, ChronoUnit.MINUTES) // default to check again in 5 minutes</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        case Some(lock) =&gt;</span>
          try {
            // reload next update now that we have the lock
<span class="nc" id="L135">            val nextUpdate = getLastUpdate.plus(updateInterval, ChronoUnit.MINUTES)</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (nextUpdate.isAfter(Instant.now(Clock.systemUTC()))) {</span>
<span class="nc" id="L137">              nextUpdate</span>
            } else {
              // run the update - this updates the last update time too
<span class="nc" id="L140">              ds.stats.writer.analyze(sft)</span>
<span class="nc" id="L141">              Instant.now(Clock.systemUTC()).plus(updateInterval, ChronoUnit.MINUTES)</span>
            }
          } finally {
<span class="nc" id="L144">            lock.close()</span>
          }
      }
    }
  }

  /**
    * Reads the time of the last update
    *
    * @return last update
    */
  private def getLastUpdate: Instant = {
<span class="nc" id="L156">    ds.metadata.read(sft.getTypeName, GeoMesaMetadata.StatsGenerationKey, cache = false) match {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">      case Some(dt) =&gt; Instant.from(GeoToolsDateFormat.parse(dt))</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      case None     =&gt; Instant.ofEpochSecond(0)</span>
    }
  }

  /**
    * Reads the update interval.
    *
    * @return update interval, in minutes
    */
  private def getUpdateInterval: Long =
    // note: default is 1440 minutes (one day)
<span class="nc" id="L169">    ds.metadata.read(sft.getTypeName, GeoMesaMetadata.StatsIntervalKey).map(_.toLong).getOrElse(1440)</span>

  private def lockKey: String = {
<span class="nc" id="L172">    val ca = StringSerialization.alphaNumericSafeString(ds.config.catalog)</span>
<span class="nc" id="L173">    val tn = StringSerialization.alphaNumericSafeString(sft.getTypeName)</span>
<span class="nc" id="L174">    s&quot;/org.locationtech.geomesa/accumulo/stats/$ca/$tn&quot;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>