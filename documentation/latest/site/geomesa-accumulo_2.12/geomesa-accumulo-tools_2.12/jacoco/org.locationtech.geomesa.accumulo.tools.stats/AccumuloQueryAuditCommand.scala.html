<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumuloQueryAuditCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.tools.stats</a> &gt; <span class="el_source">AccumuloQueryAuditCommand.scala</span></div><h1>AccumuloQueryAuditCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.tools.stats

import com.beust.jcommander.{IParameterValidator, Parameter, ParameterException, Parameters}
import org.apache.commons.csv.{CSVFormat, CSVPrinter}
import org.geotools.api.feature.simple.SimpleFeature
import org.geotools.api.filter.Filter
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.accumulo.audit.AccumuloAuditReader
import org.locationtech.geomesa.accumulo.data.AccumuloDataStore
import org.locationtech.geomesa.accumulo.tools.stats.AccumuloQueryAuditCommand.{AccumuloQueryAuditParams, CsvWriter, JsonWriter}
import org.locationtech.geomesa.accumulo.tools.{AccumuloDataStoreCommand, AccumuloDataStoreParams}
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.filter.{FilterHelper, andOption}
import org.locationtech.geomesa.index.audit.AuditWriter
import org.locationtech.geomesa.index.audit.AuditedEvent.QueryEvent
import org.locationtech.geomesa.tools.utils.ParameterConverters.{DateConverter, FilterConverter}
import org.locationtech.geomesa.tools.{Command, RequiredTypeNameParam}
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.io.WithClose
import org.locationtech.geomesa.utils.text.DateParsing

import java.time.{Instant, ZoneOffset}
import java.util.Date

/**
 * Queries audit logs
 */
<span class="nc" id="L36">class AccumuloQueryAuditCommand extends AccumuloDataStoreCommand {</span>

<span class="nc" id="L38">  override val name = &quot;query-audit-logs&quot;</span>
<span class="nc" id="L39">  override val params = new AccumuloQueryAuditParams()</span>

<span class="nc" id="L41">  override def execute(): Unit = withDataStore(exec)</span>

  private def exec(ds: AccumuloDataStore): Unit = {
<span class="nc bnc" id="L44" title="All 2 branches missed.">    if (ds.getSchema(params.featureName) == null) {</span>
<span class="nc" id="L45">      throw new ParameterException(s&quot;SimpleFeatureType '${params.featureName}' does not exist in the data store&quot;)</span>
    }

<span class="nc bnc" id="L48" title="All 6 branches missed.">    val cql = Option(params.cqlFilter).filter(_ != Filter.INCLUDE)</span>
    val dateRanges = {
      import FilterHelper.ff
<span class="nc" id="L51">      val startFilter = Option(params.start).map(d =&gt; ff.greaterOrEqual(ff.property(&quot;end&quot;), ff.literal(d)))</span>
<span class="nc" id="L52">      val endFilter = Option(params.end).map(d =&gt; ff.less(ff.property(&quot;end&quot;), ff.literal(d)))</span>
<span class="nc" id="L53">      val dateFilter = andOption(cql.toSeq ++ startFilter ++ endFilter)</span>
<span class="nc" id="L54">      val intervals = dateFilter.map { f =&gt;</span>
<span class="nc" id="L55">        val intervals = FilterHelper.extractIntervals(f, &quot;end&quot;)</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">        if (intervals.disjoint) {</span>
<span class="nc" id="L57">          throw new ParameterException(s&quot;Invalid disjoint date filter: ${ECQL.toCQL(f)}&quot;)</span>
        }
<span class="nc" id="L59">        intervals.values</span>
      }
<span class="nc" id="L61">      val bounds = intervals.toSeq.flatten</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">      if (bounds.isEmpty) {</span>
<span class="nc" id="L63">        Seq((Instant.EPOCH.atZone(ZoneOffset.UTC), Instant.now().atZone(ZoneOffset.UTC)))</span>
      } else {
<span class="nc" id="L65">        val now = Instant.now().atZone(ZoneOffset.UTC)</span>
<span class="nc" id="L66">        bounds.map { bound =&gt;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">          val start = bound.lower.value.map(d =&gt; if (bound.lower.inclusive) { d } else { d.plusNanos(1000000) })</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">          val end = bound.upper.value.map(d =&gt; if (bound.upper.exclusive) { d } else { d.plusNanos(1000000) })</span>
<span class="nc" id="L69">          (start.getOrElse(Instant.EPOCH.atZone(ZoneOffset.UTC)), end.getOrElse(now))</span>
        }
      }
    }

<span class="nc" id="L74">    WithClose(new AccumuloAuditReader(ds)) { reader=&gt;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">      val writer = if (&quot;json&quot;.equalsIgnoreCase(params.outputFormat)) { new JsonWriter() } else { new CsvWriter() }</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      writer.header().foreach(h =&gt; Command.output.info(h))</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      dateRanges.foreach { case (start, end) =&gt;</span>
<span class="nc" id="L78">        WithClose(reader.getQueryEvents(params.featureName, (start, end))) { events =&gt;</span>
<span class="nc" id="L79">          val out = cql match {</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">            case None =&gt; events</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">            case Some(f) =&gt; events.filter(e =&gt; f.evaluate(AccumuloQueryAuditCommand.toFeature(e)))</span>
          }
<span class="nc" id="L83">          out.foreach { event =&gt;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">            Command.output.info(writer.output(event))</span>
          }
        }
      }
    }
  }
}

<span class="nc" id="L92">object AccumuloQueryAuditCommand {</span>

  private final val CqlDescription =
    &quot;CQL predicate to filter log entries. Schema is: &quot; +
      &quot;user:String,filter:String,hints:String:json=true,metadata:String:json=true,start:Date,end:Date,planTimeMillis:Long,scanTimeMillis:Long,hits:Long&quot;

  // note: the cql description needs to be a final string constant to work with annotations, so we extract the spec
  // from there instead of building it up as we might normally do
<span class="nc" id="L100">  private val Spec = CqlDescription.substring(CqlDescription.indexOf(&quot;: &quot;) + 2)</span>
<span class="nc" id="L101">  private val Sft = SimpleFeatureTypes.createType(&quot;audit-logs&quot;, Spec)</span>

  /**
   * Convert an audit event to a simple feature
   *
   * @param event event
   * @return
   */
  private def toFeature(event: QueryEvent): SimpleFeature = {
<span class="nc" id="L110">    val hints = AuditWriter.Gson.toJson(event.hints)</span>
<span class="nc" id="L111">    val metadata = AuditWriter.Gson.toJson(event.metadata)</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">    val start = if (event.start == -1) { null } else { new Date(event.start) }</span>
<span class="nc" id="L113">    val end = new Date(event.end)</span>
<span class="nc" id="L114">    val planTime = Long.box(event.planTime)</span>
<span class="nc" id="L115">    val scanTime = Long.box(event.scanTime)</span>
<span class="nc" id="L116">    val hits = Long.box(event.hits)</span>
<span class="nc" id="L117">    new ScalaSimpleFeature(Sft, &quot;&quot;, Array(event.user, event.filter, hints, metadata, start, end, planTime, scanTime, hits))</span>
  }

  @Parameters(commandDescription = &quot;Search query audit logs for a GeoMesa feature type&quot;)
<span class="nc" id="L121">  class AccumuloQueryAuditParams extends AccumuloDataStoreParams with RequiredTypeNameParam {</span>

    @Parameter(
      names = Array(&quot;-b&quot;, &quot;--begin&quot;),
      description = &quot;Lower bound (inclusive) on the date of log entries to return, in ISO 8601 format&quot;,
      converter = classOf[DateConverter])
<span class="nc" id="L127">    var start: Date = _</span>

    @Parameter(
      names = Array(&quot;-e&quot;, &quot;--end&quot;),
      description = &quot;Upper bound (exclusive) on the date of log entries to return, in ISO 8601 format&quot;,
      converter = classOf[DateConverter])
<span class="nc" id="L133">    var end: Date = _</span>

    @Parameter(
      names = Array(&quot;--output-format&quot;),
      description = &quot;Output format, either 'json' or 'csv'&quot;,
      validateWith = Array(classOf[OutputFormatValidator]))
<span class="nc" id="L139">    var outputFormat: String = &quot;csv&quot;</span>

    @Parameter(
      names = Array(&quot;-q&quot;, &quot;--cql&quot;),
      description = CqlDescription,
      converter = classOf[FilterConverter])
<span class="nc" id="L145">    var cqlFilter: Filter = _</span>
  }

<span class="nc" id="L148">  class OutputFormatValidator extends IParameterValidator {</span>
    override def validate(name: String, value: String): Unit =
<span class="nc" id="L150">      Seq(&quot;json&quot;, &quot;csv&quot;).find(_.equalsIgnoreCase(value)).getOrElse(throw new ParameterException(s&quot;Invalid output format '$value'&quot;))</span>
  }

  private trait OutputWriter {
    def header(): Option[String]
    def output(event: QueryEvent): String
  }

<span class="nc" id="L158">  private class CsvWriter extends OutputWriter {</span>
<span class="nc" id="L159">    private val out = new java.lang.StringBuilder()</span>
    // note: don't need to close the printer, as it just closes the underlying stream (i.e. our StringBuilder)
<span class="nc" id="L161">    private val printer = new CSVPrinter(out, CSVFormat.DEFAULT)</span>

<span class="nc" id="L163">    override def header(): Option[String] = Some(Spec.replaceAll(&quot;:\\w+&quot;, &quot;&quot;))</span>
    override def output(event: QueryEvent): String = {
<span class="nc" id="L165">      printer.println() // reset new record</span>
<span class="nc" id="L166">      out.setLength(0)</span>
<span class="nc" id="L167">      printer.print(event.user)</span>
<span class="nc" id="L168">      printer.print(event.filter)</span>
<span class="nc" id="L169">      printer.print(AuditWriter.Gson.toJson(event.hints))</span>
<span class="nc" id="L170">      printer.print(AuditWriter.Gson.toJson(event.metadata))</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      printer.print(if (event.start == -1) { null } else { DateParsing.formatMillis(event.start) })</span>
<span class="nc" id="L172">      printer.print(DateParsing.formatMillis(event.end))</span>
<span class="nc" id="L173">      printer.print(Long.box(event.planTime))</span>
<span class="nc" id="L174">      printer.print(Long.box(event.scanTime))</span>
<span class="nc" id="L175">      printer.print(Long.box(event.hits))</span>
      // note: we don't want to end the record as that inserts a newline, which our logger output is already doing
<span class="nc" id="L177">      out.toString</span>
    }
  }

<span class="nc" id="L181">  private class JsonWriter extends OutputWriter {</span>
<span class="nc" id="L182">    override def header(): Option[String] = None</span>
    override def output(event: QueryEvent): String = {
<span class="nc" id="L184">      val model = new java.util.LinkedHashMap[String, AnyRef]()</span>
<span class="nc" id="L185">      model.put(&quot;user&quot;, event.user)</span>
<span class="nc" id="L186">      model.put(&quot;filter&quot;, event.filter)</span>
<span class="nc" id="L187">      model.put(&quot;hints&quot;, event.hints)</span>
<span class="nc" id="L188">      model.put(&quot;metadata&quot;, event.metadata)</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">      if (event.start != -1) {</span>
<span class="nc" id="L190">        model.put(&quot;start&quot;, DateParsing.formatMillis(event.start))</span>
      }
<span class="nc" id="L192">      model.put(&quot;end&quot;, DateParsing.formatMillis(event.end))</span>
<span class="nc" id="L193">      model.put(&quot;planTimeMillis&quot;, Long.box(event.planTime))</span>
<span class="nc" id="L194">      model.put(&quot;scanTimeMillis&quot;, Long.box(event.scanTime))</span>
<span class="nc" id="L195">      model.put(&quot;hits&quot;, Long.box(event.hits))</span>
<span class="nc" id="L196">      AuditWriter.Gson.toJson(model)</span>
    }
  }
<span class="nc" id="L199">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>