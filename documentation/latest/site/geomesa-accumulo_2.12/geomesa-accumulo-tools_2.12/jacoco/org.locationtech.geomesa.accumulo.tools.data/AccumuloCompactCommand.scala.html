<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccumuloCompactCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Accumulo Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.accumulo.tools.data</a> &gt; <span class="el_source">AccumuloCompactCommand.scala</span></div><h1>AccumuloCompactCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.accumulo.tools.data

import com.beust.jcommander.{Parameter, ParameterException, Parameters}
import org.apache.accumulo.core.client.admin.TableOperations
import org.apache.accumulo.core.data.Key
import org.apache.hadoop.io.Text
import org.locationtech.geomesa.accumulo.tools.data.AccumuloCompactCommand.{CompactParams, RangeCompaction}
import org.locationtech.geomesa.accumulo.tools.{AccumuloDataStoreCommand, AccumuloDataStoreParams}
import org.locationtech.geomesa.curve.BinnedTime
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.index.id.IdIndex
import org.locationtech.geomesa.index.index.z3.Z3Index
import org.locationtech.geomesa.tools.utils.ParameterConverters.DurationConverter
import org.locationtech.geomesa.tools.{Command, RequiredTypeNameParam}
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.text.TextTools
import org.locationtech.geomesa.utils.uuid.Z3UuidGenerator

import java.nio.charset.StandardCharsets
import java.time.{Instant, ZoneOffset, ZonedDateTime}
import java.util.concurrent.{Executors, TimeUnit}
import java.util.{Date, UUID}
import scala.concurrent.duration.Duration
import scala.util.control.NonFatal

<span class="nc" id="L34">class AccumuloCompactCommand extends AccumuloDataStoreCommand {</span>

  import org.locationtech.geomesa.filter.ff
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

<span class="nc" id="L41">  override val name = &quot;compact&quot;</span>
<span class="nc" id="L42">  override val params = new CompactParams</span>

<span class="nc" id="L44">  override def execute(): Unit = withDataStore { ds =&gt;</span>
<span class="nc" id="L45">    val sft = ds.getSchema(params.featureName)</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">    if (sft == null) {</span>
<span class="nc" id="L47">      throw new ParameterException(s&quot;Schema '${params.featureName}' does not exist in the data store&quot;)</span>
    }

<span class="nc" id="L50">    val start = System.currentTimeMillis()</span>

<span class="nc" id="L52">    val executor = Executors.newFixedThreadPool(params.threads)</span>

<span class="nc" id="L54">    val ops = ds.client.tableOperations()</span>

<span class="nc" id="L56">    val msg = new StringBuilder(s&quot;Starting incremental compaction using ${params.threads} simultaneous threads&quot;)</span>

<span class="nc" id="L58">    val interval = Option(params.from).map { from =&gt;</span>
<span class="nc" id="L59">      val now = System.currentTimeMillis()</span>
<span class="nc" id="L60">      val start = now - from.toMillis</span>
<span class="nc" id="L61">      val end = Option(params.duration).map(d =&gt; start + d.toMillis).getOrElse(now)</span>
<span class="nc" id="L62">      def toString(millis: Long) = ZonedDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneOffset.UTC).toString</span>
<span class="nc" id="L63">      msg.append(s&quot; from ${toString(start)}/${toString(end)}&quot;)</span>
<span class="nc" id="L64">      (start, end)</span>
    }

<span class="nc bnc" id="L67" title="All 2 branches missed.">    val z3Bins = interval.map { case (s, e) =&gt;</span>
<span class="nc" id="L68">      val toBin = BinnedTime.timeToBinnedTime(sft.getZ3Interval)</span>
<span class="nc" id="L69">      (toBin(s).bin, toBin(e).bin)</span>
    }

<span class="nc bnc" id="L72" title="All 2 branches missed.">    val filter = interval.flatMap { case (s, e) =&gt;</span>
<span class="nc" id="L73">      sft.getDtgField.map { dtg =&gt;</span>
<span class="nc" id="L74">        ff.between(ff.property(dtg), ff.literal(new Date(s)), ff.literal(new Date(e)))</span>
      }
    }

<span class="nc bnc" id="L78" title="All 2 branches missed.">    Command.user.info(msg.toString)</span>

    def filterSplits(index: GeoMesaFeatureIndex[_, _]): Iterator[Seq[Text]] =&gt; Iterator[Seq[Text]] = {
<span class="nc" id="L81">      z3Bins match {</span>
<span class="nc bnc" id="L82" title="All 10 branches missed.">        case Some((min, max)) if index.name == Z3Index.name =&gt;</span>
<span class="nc" id="L83">          val offset = index.keySpace.sharding.length + index.keySpace.sharing.length</span>

          def compareStart(s: Text): Boolean =
<span class="nc bnc" id="L86" title="All 6 branches missed.">            s == null || s.getLength &lt; offset + 2 || ByteArrays.readShort(s.getBytes, offset) &lt;= max</span>
          def compareEnd(e: Text): Boolean =
<span class="nc bnc" id="L88" title="All 6 branches missed.">            e == null || e.getLength &lt; offset + 2 || ByteArrays.readShort(e.getBytes, offset) &gt;= min</span>

<span class="nc bnc" id="L90" title="All 10 branches missed.">          iter =&gt; iter.filter { case Seq(s, e) =&gt; compareStart(s) &amp;&amp; compareEnd(e) }</span>

<span class="nc bnc" id="L92" title="All 12 branches missed.">        case Some((min, max)) if params.z3Ids &amp;&amp; index.name == IdIndex.name =&gt;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">          val offset = if (sft.isTableSharing) { 1 } else { 0 }</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">          if (sft.isUuidEncoded) {</span>
            // uuid is already stored in correct binary format
            def compareStart(s: Text): Boolean =
<span class="nc bnc" id="L97" title="All 6 branches missed.">              s == null || s.getLength &lt; offset + 3 || Z3UuidGenerator.timeBin(s.getBytes, offset) &lt;= max</span>
            def compareEnd(e: Text): Boolean =
<span class="nc bnc" id="L99" title="All 6 branches missed.">              e == null || e.getLength &lt; offset + 3 || Z3UuidGenerator.timeBin(e.getBytes, offset) &gt;= min</span>

<span class="nc bnc" id="L101" title="All 10 branches missed.">            iter =&gt; iter.filter { case Seq(s, e) =&gt; compareStart(s) &amp;&amp; compareEnd(e) }</span>
          } else {
            // uuid is stored as a string, must be parsed into a uuid and converted to bytes
            def compareStart(s: Text): Boolean = {
<span class="nc bnc" id="L105" title="All 2 branches missed.">              if (s == null) { true } else {</span>
<span class="nc" id="L106">                try {</span>
<span class="nc" id="L107">                  val uuidString = new String(s.getBytes, offset, s.getLength - offset, StandardCharsets.UTF_8)</span>
<span class="nc" id="L108">                  val uuid = UUID.fromString(uuidString)</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">                  Z3UuidGenerator.timeBin(ByteArrays.toBytes(uuid.getMostSignificantBits)) &lt;= max</span>
                } catch {
<span class="nc bnc" id="L111" title="All 2 branches missed.">                  case NonFatal(_) =&gt; true // split doesn't contain a whole row key</span>
                }
              }
            }
            def compareEnd(e: Text): Boolean = {
<span class="nc bnc" id="L116" title="All 2 branches missed.">              if (e == null) { true } else {</span>
<span class="nc" id="L117">                try {</span>
<span class="nc" id="L118">                  val uuidString = new String(e.getBytes, offset, e.getLength - offset, StandardCharsets.UTF_8)</span>
<span class="nc" id="L119">                  val uuid = UUID.fromString(uuidString)</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                  Z3UuidGenerator.timeBin(ByteArrays.toBytes(uuid.getMostSignificantBits)) &gt;= min</span>
                } catch {
<span class="nc bnc" id="L122" title="All 2 branches missed.">                  case NonFatal(_) =&gt; true // split doesn't contain a whole row key</span>
                }
              }
            }

<span class="nc bnc" id="L127" title="All 10 branches missed.">            iter =&gt; iter.filter { case Seq(s, e) =&gt; compareStart(s) &amp;&amp; compareEnd(e) }</span>
          }

        case _ =&gt;
<span class="nc" id="L131">          iter =&gt; iter</span>
      }
    }

<span class="nc" id="L135">    ds.manager.indices(sft).foreach { index =&gt;</span>
<span class="nc" id="L136">      val filtering = filterSplits(index)</span>

<span class="nc" id="L138">      index.getTablesForQuery(filter).foreach { table =&gt;</span>
<span class="nc" id="L139">        val tableSplits = ops.listSplits(table).asScala.toList</span>

<span class="nc" id="L141">        var count = 0</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (tableSplits.isEmpty) {</span>
<span class="nc" id="L144">          executor.submit(new RangeCompaction(ops, table, null, null))</span>
<span class="nc" id="L145">          count += 1</span>
        } else {
<span class="nc" id="L147">          val head = Iterator.single(Seq(null, tableSplits.head))</span>
<span class="nc" id="L148">          val last = Iterator.single(Seq(tableSplits.last, null))</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">          val middle = if (tableSplits.lengthCompare(1) == 0) { Iterator.empty } else { tableSplits.sliding(2) }</span>

          // filter out ranges by table sharing, if possible
<span class="nc bnc" id="L152" title="All 2 branches missed.">          val splits = if (sft.isTableSharing) {</span>
<span class="nc bnc" id="L153" title="All 6 branches missed.">            val Array(prefix) = sft.getTableSharingBytes // should be one byte</span>
<span class="nc bnc" id="L154" title="All 6 branches missed.">            (head ++ middle ++ last).filter { case Seq(s, e) =&gt;</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">              (s == null || ByteArrays.UnsignedByteOrdering.compare(s.getBytes.apply(0), prefix) &lt;= 0) &amp;&amp;</span>
<span class="nc bnc" id="L156" title="All 4 branches missed.">                  (e == null || ByteArrays.UnsignedByteOrdering.compare(e.getBytes.apply(0), prefix) &gt;= 0)</span>
            }
          } else {
<span class="nc" id="L159">            head ++ middle ++ last</span>
          }

          // filter out ranges based on our time interval, if possible
<span class="nc bnc" id="L163" title="All 6 branches missed.">          filtering(splits).foreach { case Seq(s, e)  =&gt;</span>
<span class="nc" id="L164">            executor.submit(new RangeCompaction(ops, table, s, e))</span>
<span class="nc" id="L165">            count += 1</span>
          }
        }
<span class="nc bnc" id="L168" title="All 2 branches missed.">        Command.user.info(s&quot;Found $count splits for table $table&quot;)</span>
      }
    }

<span class="nc" id="L172">    executor.shutdown()</span>
<span class="nc" id="L173">    executor.awaitTermination(Long.MaxValue, TimeUnit.MILLISECONDS)</span>

<span class="nc bnc" id="L175" title="All 2 branches missed.">    Command.user.info(s&quot;Compactions complete in ${TextTools.getTime(start)}&quot;)</span>
  }
}

<span class="nc" id="L179">object AccumuloCompactCommand {</span>

  @Parameters(commandDescription = &quot;Incrementally compact tables for a GeoMesa feature type&quot;)
<span class="nc" id="L182">  class CompactParams extends RequiredTypeNameParam with AccumuloDataStoreParams {</span>

    @Parameter(names = Array(&quot;--threads&quot;), description = &quot;Number of ranges to compact simultaneously&quot;)
<span class="nc" id="L185">    var threads: Integer = Int.box(4)</span>

    @Parameter(names = Array(&quot;--from&quot;), description = &quot;How long ago to compact data, based on the default date attribute, relative to current time. E.g. '1 day', '2 weeks and 1 hour', etc&quot;, converter = classOf[DurationConverter])
<span class="nc" id="L188">    var from: Duration = _</span>

    @Parameter(names = Array(&quot;--duration&quot;), description = &quot;Amount of time to compact data, based on the default date attribute, relative to '--from'. E.g. '1 day', '2 weeks and 1 hour', etc&quot;, converter = classOf[DurationConverter])
<span class="nc" id="L191">    var duration: Duration = _</span>

    @Parameter(names = Array(&quot;--z3-feature-ids&quot;), description = &quot;Will only compact ID records that correspond with the time period, based on features being written with the Z3FeatureIdGenerator&quot;)
<span class="nc" id="L194">    var z3Ids: Boolean = false</span>
  }

<span class="nc" id="L197">  class RangeCompaction(ops: TableOperations, table: String, start: Text, end: Text) extends Runnable {</span>
    override def run(): Unit = {
<span class="nc bnc" id="L199" title="All 2 branches missed.">      Command.user.info(s&quot;Starting compaction of $table [ ${rowToString(start)} :: ${rowToString(end)} ]&quot;)</span>
<span class="nc" id="L200">      ops.compact(table, start, end, false, true)</span>
    }
  }

  private def rowToString(row: Text): String = {
<span class="nc bnc" id="L205" title="All 2 branches missed.">    if (row == null) { &quot;null&quot; } else { Key.toPrintableString(row.getBytes, 0, row.getLength, row.getLength) }</span>
  }
<span class="nc" id="L207">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>