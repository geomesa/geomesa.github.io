<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JoinProcess.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Vector Processes</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.process.query</a> &gt; <span class="el_source">JoinProcess.scala</span></div><h1>JoinProcess.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.process.query

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.util.ProgressListener
import org.geotools.data.collection.ListFeatureCollection
import org.geotools.data.simple.{SimpleFeatureCollection, SimpleFeatureIterator}
import org.geotools.feature.AttributeTypeBuilder
import org.geotools.feature.collection.DecoratingSimpleFeatureCollection
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.geotools.process.ProcessException
import org.geotools.process.factory.{DescribeParameter, DescribeProcess, DescribeResult}
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureCollection
import org.locationtech.geomesa.process.GeoMesaProcess
import org.locationtech.geomesa.utils.collection.CloseableIterator

/**
  * Returns features from a feature type based on a join against a second feature type.
  */
@DescribeProcess(
  title = &quot;Join Process&quot;,
  description = &quot;Queries a feature type based on attributes from a second feature type&quot;
)
<span class="nc bnc" id="L34" title="All 4 branches missed.">class JoinProcess extends GeoMesaProcess with LazyLogging {</span>

  /**
    *
    * @param primary main feature collection to query
    * @param secondary secondary feature collection to query with results from first feature collection
    * @param joinAttribute attribute to join on
    * @param joinFilter additional filter to apply to joined features
    * @param attributes attributes to return, from both collections, qualified by schema name
    * @param monitor listener to monitor progress
    * @throws org.geotools.process.ProcessException if something goes wrong
    * @return
    */
  @throws(classOf[ProcessException])
  @DescribeResult(name = &quot;result&quot;, description = &quot;Output features&quot;)
  def execute(@DescribeParameter(name = &quot;primary&quot;, description = &quot;Primary feature collection being queried&quot;, min = 1)
              primary: SimpleFeatureCollection,
              @DescribeParameter(name = &quot;secondary&quot;, description = &quot;Secondary feature collection to be joined&quot;, min = 1)
              secondary: SimpleFeatureCollection,
              @DescribeParameter(name = &quot;joinAttribute&quot;, description = &quot;Attribute field to join on&quot;, min = 1)
<span class="nc" id="L54">              joinAttribute: String,</span>
              @DescribeParameter(name = &quot;joinFilter&quot;, description = &quot;Additional filter to apply to joined features&quot;, min = 0)
              joinFilter: Filter,
              @DescribeParameter(name = &quot;attributes&quot;, description = &quot;Attributes to return. Attribute names should be qualified with the schema name, e.g. foo.bar&quot;, min = 0, max = 128, collectionType = classOf[String])
              attributes: java.util.List[String],
              monitor: ProgressListener): SimpleFeatureCollection = {

    import org.locationtech.geomesa.filter.ff

    import scala.collection.JavaConverters._

<span class="nc bnc" id="L65" title="All 2 branches missed.">    logger.trace(s&quot;Attempting join query on ${joinAttribute.getClass.getName}&quot;)</span>

<span class="nc bnc" id="L67" title="All 2 branches missed.">    require(primary.getSchema.getDescriptor(joinAttribute) != null,</span>
<span class="nc" id="L68">      s&quot;Attribute '$joinAttribute' does not exist in the primary feature collection&quot;)</span>

<span class="nc" id="L70">    val joinDescriptor = secondary.getSchema.getDescriptor(joinAttribute)</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">    require(joinDescriptor != null, s&quot;Attribute '$joinAttribute' does not exist in the joined feature collection&quot;)</span>

    // create the return sft based on the input attributes, or by combining the qualified names from each schema
<span class="nc bnc" id="L74" title="All 4 branches missed.">    val returnSft = if (attributes != null &amp;&amp; attributes.asScala.nonEmpty) {</span>
<span class="nc" id="L75">      getCombinedSft(primary.getSchema, secondary.getSchema, attributes.asScala.toSeq, joinAttribute)</span>
    } else {
      def toAttributes(schema: SimpleFeatureType): Seq[String] = {
<span class="nc" id="L78">        val names = schema.getAttributeDescriptors.asScala.map(_.getLocalName)</span>
<span class="nc bnc" id="L79" title="All 6 branches missed.">        names.filter(_ != joinAttribute).map(d =&gt; s&quot;${schema.getTypeName}.$d&quot;).toSeq</span>
      }
<span class="nc" id="L81">      val primaryAttributes = toAttributes(primary.getSchema)</span>
<span class="nc" id="L82">      val secondaryAttributes = toAttributes(secondary.getSchema)</span>
<span class="nc" id="L83">      val attributes = Seq(joinAttribute) ++ primaryAttributes ++ secondaryAttributes</span>
<span class="nc" id="L84">      getCombinedSft(primary.getSchema, secondary.getSchema, attributes, joinAttribute)</span>
    }

    // check for too many features coming back - limit is somewhat arbitrary, but this
    // class is mainly intended for a single feature lookup
<span class="nc" id="L89">    val primaryFeatures = CloseableIterator(primary.features()).toList</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">    require(primaryFeatures.length &lt; 129,</span>
<span class="nc" id="L91">      s&quot;Too many features returned from primary query - got ${primaryFeatures.length}, max 128&quot;)</span>

<span class="nc" id="L93">    val joinProperty = ff.property(joinAttribute)</span>
    val joinFilters = {
<span class="nc" id="L95">      val values = primaryFeatures.map(_.getAttribute(joinAttribute)).distinct</span>
<span class="nc" id="L96">      values.map(p =&gt; ff.equals(joinProperty, ff.literal(p)).asInstanceOf[Filter])</span>
    }

<span class="nc bnc" id="L99" title="All 2 branches missed.">    val result = if (joinFilters.isEmpty) {</span>
<span class="nc" id="L100">      new ListFeatureCollection(returnSft)</span>
    } else {
<span class="nc" id="L102">      val or = ff.or(joinFilters.toList.asJava)</span>
<span class="nc bnc" id="L103" title="All 8 branches missed.">      val filter = if (joinFilter != null &amp;&amp; joinFilter != Filter.INCLUDE) { ff.and(or, joinFilter) } else { or }</span>
<span class="nc" id="L104">      val visitor = new QueryVisitor(secondary, filter, null)</span>
<span class="nc" id="L105">      GeoMesaFeatureCollection.visit(secondary, visitor)</span>
<span class="nc" id="L106">      val results = visitor.getResult.results</span>

      // mappings from the secondary feature result to the return schema
      // (return sft index, result sft index, is from primary result (or secondary result))
<span class="nc" id="L110">      val attributeMappings: Seq[(Int, Int, Boolean)] = returnSft.getAttributeDescriptors.asScala.map { d =&gt;</span>
<span class="nc" id="L111">        val toAttribute = d.getLocalName</span>
<span class="nc" id="L112">        val dot = toAttribute.indexOf('.')</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (dot == -1) {</span>
<span class="nc bnc" id="L114" title="All 6 branches missed.">          val fromPrimary = secondary.getSchema.getAttributeDescriptors.asScala.exists(_.getLocalName == toAttribute)</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">          val from = if (fromPrimary) {</span>
<span class="nc" id="L116">            primary.getSchema.indexOf(toAttribute)</span>
          } else {
<span class="nc" id="L118">            secondary.getSchema.indexOf(toAttribute)</span>
          }
<span class="nc" id="L120">          (returnSft.indexOf(toAttribute), from, fromPrimary)</span>
        } else {
<span class="nc bnc" id="L122" title="All 6 branches missed.">          val fromPrimary = primary.getSchema.getTypeName == toAttribute.substring(0, dot)</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">          val from = if (fromPrimary) {</span>
<span class="nc" id="L124">            primary.getSchema.indexOf(toAttribute.substring(dot + 1))</span>
          } else {
<span class="nc" id="L126">            secondary.getSchema.indexOf(toAttribute.substring(dot + 1))</span>
          }
<span class="nc" id="L128">          (returnSft.indexOf(toAttribute), from, fromPrimary)</span>
        }
      }.toSeq

<span class="nc" id="L132">      new DecoratingSimpleFeatureCollection(results) {</span>
<span class="nc" id="L133">        override def getSchema: SimpleFeatureType = returnSft</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        override def features(): SimpleFeatureIterator = new SimpleFeatureIterator {</span>
<span class="nc" id="L135">          private val delegate = results.features</span>
          override def next(): SimpleFeature = {
<span class="nc" id="L137">            val secondarySf = delegate.next()</span>
<span class="nc" id="L138">            val toJoin = secondarySf.getAttribute(joinAttribute)</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            val primarySf = primaryFeatures.find(_.getAttribute(joinAttribute) == toJoin).getOrElse {</span>
<span class="nc" id="L140">              throw new RuntimeException(&quot;No feature joined from attribute query&quot;)</span>
            }
<span class="nc" id="L142">            val sf = new ScalaSimpleFeature(returnSft, s&quot;${primarySf.getID}-${secondarySf.getID}&quot;)</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            attributeMappings.foreach { case (to, from, fromPrimary) =&gt;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">              val a = if (fromPrimary) { primarySf.getAttribute(from) } else { secondarySf.getAttribute(from) }</span>
<span class="nc" id="L145">              sf.setAttribute(to, a)</span>
            }
<span class="nc" id="L147">            sf</span>
          }
<span class="nc" id="L149">          override def hasNext: Boolean = delegate.hasNext</span>
<span class="nc" id="L150">          override def close(): Unit = delegate.close()</span>
        }
      }
    }

<span class="nc" id="L155">    result</span>
  }

  /**
    * Builds a combined sft
    *
    * @param primary primary sft being joined
    * @param secondary secondary sft being joined
    * @param attributes attributes to include - must be sft qualified if ambiguous
    * @param join attribute being joined on - this will always be unqualified and should exist in both sfts
    * @return
    */
  private def getCombinedSft(primary: SimpleFeatureType,
                             secondary: SimpleFeatureType,
                             attributes: Seq[String],
                             join: String): SimpleFeatureType = {
<span class="nc" id="L171">    val builder = new SimpleFeatureTypeBuilder()</span>
<span class="nc" id="L172">    builder.setName(s&quot;${primary.getTypeName}_join_${secondary.getTypeName}&quot;)</span>

<span class="nc" id="L174">    val descriptorBuilder = new AttributeTypeBuilder()</span>

<span class="nc" id="L176">    attributes.foreach { attribute =&gt;</span>
<span class="nc" id="L177">      val dot = attribute.indexOf('.')</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">      val descriptor = if (dot == -1) {</span>
<span class="nc" id="L179">        val primaryDescriptor = primary.getDescriptor(attribute)</span>
<span class="nc" id="L180">        val secondaryDescriptor = secondary.getDescriptor(attribute)</span>
<span class="nc bnc" id="L181" title="All 8 branches missed.">        if (primaryDescriptor == null || attribute == join) {</span>
<span class="nc" id="L182">          secondaryDescriptor</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        } else if (secondaryDescriptor == null) {</span>
<span class="nc" id="L184">          primaryDescriptor</span>
        } else {
<span class="nc" id="L186">          throw new IllegalArgumentException(s&quot;Ambiguous property requested: $attribute exists in both schemas&quot;)</span>
        }
      } else {
<span class="nc" id="L189">        val typeName = attribute.substring(0, dot)</span>
<span class="nc bnc" id="L190" title="All 6 branches missed.">        if (typeName == primary.getTypeName) {</span>
<span class="nc" id="L191">          primary.getDescriptor(attribute.substring(dot + 1))</span>
<span class="nc bnc" id="L192" title="All 6 branches missed.">        } else if (typeName == secondary.getTypeName) {</span>
<span class="nc" id="L193">          secondary.getDescriptor(attribute.substring(dot + 1))</span>
        } else {
<span class="nc" id="L195">          null</span>
        }
      }

<span class="nc bnc" id="L199" title="All 2 branches missed.">      if (descriptor != null) {</span>
<span class="nc" id="L200">        descriptorBuilder.init(descriptor)</span>
<span class="nc" id="L201">        val toAdd = descriptorBuilder.buildDescriptor(attribute)</span>
<span class="nc" id="L202">        builder.add(toAdd)</span>
<span class="nc bnc" id="L203" title="All 6 branches missed.">        if (descriptor == secondary.getGeometryDescriptor) {</span>
<span class="nc" id="L204">          builder.setDefaultGeometry(toAdd.getLocalName)</span>
        }
      }
    }

<span class="nc" id="L209">    builder.buildFeatureType()</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>