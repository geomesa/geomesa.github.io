<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KNearestNeighborSearchProcess.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Vector Processes</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.process.query</a> &gt; <span class="el_source">KNearestNeighborSearchProcess.scala</span></div><h1>KNearestNeighborSearchProcess.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.process.query

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.{Query, SimpleFeatureSource}
import org.geotools.api.feature.Feature
import org.geotools.api.feature.simple.SimpleFeature
import org.geotools.api.filter.Filter
import org.geotools.api.filter.expression.PropertyName
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.feature.DefaultFeatureCollection
import org.geotools.filter.text.ecql.ECQL
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.process.factory.{DescribeParameter, DescribeProcess, DescribeResult}
import org.geotools.referencing.GeodeticCalculator
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.filter.ff
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureCollection
import org.locationtech.geomesa.index.process.{FeatureResult, GeoMesaProcessVisitor}
import org.locationtech.geomesa.process.GeoMesaProcess
import org.locationtech.geomesa.process.query.KNearestNeighborSearchProcess.KNNVisitor
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.concurrent.CachedThreadPool
import org.locationtech.geomesa.utils.geotools.{CRS_EPSG_4326, GeometryUtils}
import org.locationtech.geomesa.utils.io.WithClose
import org.locationtech.jts.geom.Point

@DescribeProcess(
  title = &quot;Geomesa-enabled K Nearest Neighbor Search&quot;,
  description = &quot;Performs a K-nearest-neighbor search on a feature collection using a second feature collection as input&quot;
)
<span class="nc bnc" id="L39" title="All 4 branches missed.">class KNearestNeighborSearchProcess extends GeoMesaProcess with LazyLogging {</span>

  @DescribeResult(description = &quot;Output feature collection&quot;)
  def execute(
               @DescribeParameter(
                 name = &quot;inputFeatures&quot;,
                 description = &quot;Feature collection that defines the points to search&quot;)
               inputFeatures: SimpleFeatureCollection,

               @DescribeParameter(
                 name = &quot;dataFeatures&quot;,
                 description = &quot;Feature collection to query for nearest neighbors&quot;)
               dataFeatures: SimpleFeatureCollection,

               @DescribeParameter(
                 name = &quot;numDesired&quot;,
                 description = &quot;k, the number of nearest neighbors to return&quot;)
               numDesired: java.lang.Integer,

               @DescribeParameter(
                 name = &quot;estimatedDistance&quot;,
                 description = &quot;Estimate of the distance in meters for the k-th nearest neighbor, used for the initial query window&quot;)
               estimatedDistance: java.lang.Double,

               @DescribeParameter(
                 name = &quot;maxSearchDistance&quot;,
                 description = &quot;Maximum search distance in meters, used to prevent runaway queries of the entire data set&quot;)
               maxSearchDistance: java.lang.Double
               ): SimpleFeatureCollection = {

<span class="nc bnc" id="L69" title="All 2 branches missed.">    logger.debug(</span>
<span class="nc" id="L70">      s&quot;Running KNN query for ${dataFeatures.getClass.getName} with k = $numDesired, &quot; +</span>
<span class="nc" id="L71">        s&quot;initial distance = $estimatedDistance, max distance = $maxSearchDistance&quot;)</span>

<span class="nc" id="L73">    val visitor = new KNNVisitor(inputFeatures, numDesired, estimatedDistance, maxSearchDistance)</span>
<span class="nc" id="L74">    GeoMesaFeatureCollection.visit(dataFeatures, visitor)</span>
<span class="nc" id="L75">    visitor.getResult.results</span>
  }
}

<span class="nc" id="L79">object KNearestNeighborSearchProcess {</span>

<span class="nc" id="L81">  private val WholeWorldEnvelope = Envelope(-180d, 180d, -90d, 90d)</span>

  /**
    * Main visitor class for the KNN search process
    *
    * @param query query features - geometries will be used as the inputs
    * @param k number of neighbors to find
    * @param start initial distance to search
    * @param threshold max distance to search
    */
<span class="nc bnc" id="L91" title="All 4 branches missed.">  class KNNVisitor(query: SimpleFeatureCollection, k: Int, start: Double, threshold: Double)</span>
<span class="nc" id="L92">      extends GeoMesaProcessVisitor with LazyLogging {</span>

    import org.locationtech.geomesa.filter.ff
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc bnc" id="L97" title="All 4 branches missed.">    private lazy val queries: Seq[Point] = CloseableIterator(query.features()).toList.flatMap { f =&gt;</span>
<span class="nc" id="L98">      f.getDefaultGeometry match {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        case p: Point =&gt; Some(p)</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        case g =&gt; logger.warn(s&quot;KNN query not implemented for non-point geometries, skipping this feature: $g&quot;); None</span>
      }
    }

<span class="nc bnc" id="L104" title="All 4 branches missed.">    private lazy val results = Seq.fill(queries.length)(Array.ofDim[FeatureWithDistance](k))</span>
<span class="nc bnc" id="L105" title="All 6 branches missed.">    private lazy val calculators = queries.zip(results).map { case (p, r) =&gt; new KnnCalculator(p, k, threshold, r) }</span>

<span class="nc" id="L107">    private var result: FeatureResult = _</span>

    // called for non-optimized visits
<span class="nc" id="L110">    override def visit(feature: Feature): Unit = calculators.foreach(_.visit(feature.asInstanceOf[SimpleFeature]))</span>

    override def getResult: FeatureResult = {
<span class="nc bnc" id="L113" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L114">        val collection = new DefaultFeatureCollection()</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        results.foreach(_.foreach(r =&gt; if (r != null) { collection.add(r.sf) }))</span>
<span class="nc" id="L116">        result = FeatureResult(collection)</span>
      }
<span class="nc" id="L118">      result</span>
    }

    override def execute(source: SimpleFeatureSource, query: Query): Unit = {
<span class="nc bnc" id="L122" title="All 2 branches missed.">      logger.debug(s&quot;Running Geomesa KNN process on source type ${source.getClass.getName}&quot;)</span>

      // create a new feature collection to hold the results of the KNN search around each point
<span class="nc" id="L125">      val collection = new DefaultFeatureCollection()</span>
<span class="nc" id="L126">      val geom = ff.property(source.getSchema.getGeomField)</span>

      // for each entry in the inputFeatures collection:
      def run(p: Point): Unit = {
        // tracks our nearest neighbors
<span class="nc" id="L131">        val results = Array.ofDim[FeatureWithDistance](k)</span>
        // tracks features are in our search envelope but that aren't within our current search distance
        // we use a java linked list as scala doesn't have anything with 'iterate and remove' functionality
<span class="nc" id="L134">        val overflow = new java.util.LinkedList[FeatureWithDistance]()</span>

        // calculator for expanding window queries
<span class="nc" id="L137">        val window = new KnnWindow(query, geom, p, k, start, threshold)</span>
<span class="nc" id="L138">        var found = 0 // tracks the number of neighbors we've found so far</span>

<span class="nc" id="L140">        val initial = window.next(None)</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        logger.trace(s&quot;Current query window:\n  ${window.window.debug.mkString(&quot;\n  &quot;)}&quot;)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        logger.trace(s&quot;Current filter: ${ECQL.toCQL(initial.getFilter)}&quot;)</span>

        // run our first query against the estimated distance
<span class="nc" id="L145">        WithClose(source.getFeatures(initial).features()) { iter =&gt;</span>
          // note: the calculator will populate our results array
<span class="nc" id="L147">          val knn = new KnnCalculator(p, k, window.radius, results)</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">          while (iter.hasNext) {</span>
<span class="nc" id="L149">            val sf = iter.next</span>
            // features that aren't within our query distance are added to the overflow for the next iteration
<span class="nc" id="L151">            knn.visit(sf).foreach(d =&gt; overflow.add(FeatureWithDistance(sf, d)))</span>
          }
<span class="nc" id="L153">          found = knn.size</span>
        }

<span class="nc" id="L156">        var iteration = 1 // tracks the number of queries we've run</span>

        // if we haven't found k features, start expanding the search distance
<span class="nc bnc" id="L159" title="All 4 branches missed.">        while (found &lt; k &amp;&amp; window.hasNext) {</span>
<span class="nc" id="L160">          val last = window.radius</span>
          // calculate the next query to search, based on how many we've found so far
<span class="nc" id="L162">          val next = window.next(Some(found))</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">          logger.debug(</span>
<span class="nc" id="L164">            s&quot;Expanding search at (${p.getX} ${p.getY}) from $last to ${window.radius} meters &quot; +</span>
<span class="nc" id="L165">                s&quot;based on finding $found/$k neighbors&quot;)</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">          logger.trace(s&quot;Current query window:\n  ${window.window.debug.mkString(&quot;\n  &quot;)}&quot;)</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">          logger.trace(s&quot;Current filter: ${ECQL.toCQL(next.getFilter)}&quot;)</span>

          // calculator for our new distance, initialized with the neighbors we've already found
<span class="nc" id="L170">          val knn = new KnnCalculator(p, k, window.radius, results, found)</span>
          // re-visit any features that were outside our distance but inside our last envelope
<span class="nc" id="L172">          val iter = overflow.iterator()</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">          while (iter.hasNext) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            val FeatureWithDistance(sf, d) = iter.next()</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (d &lt;= window.radius) {</span>
<span class="nc" id="L176">              knn.visit(sf, d)</span>
<span class="nc" id="L177">              iter.remove()</span>
            }
          }

          // run the new query
<span class="nc" id="L182">          WithClose(source.getFeatures(next).features()) { iter =&gt;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            while (iter.hasNext) {</span>
<span class="nc" id="L184">              val sf = iter.next</span>
              // features that aren't within our query distance are added to the overflow for the next iteration
<span class="nc" id="L186">              knn.visit(sf).foreach(d =&gt; overflow.add(FeatureWithDistance(sf, d)))</span>
            }
<span class="nc" id="L188">            found = knn.size</span>
          }

<span class="nc" id="L191">          iteration += 1</span>
        }

<span class="nc bnc" id="L194" title="All 2 branches missed.">        logger.debug(</span>
<span class="nc" id="L195">          s&quot;Found $found/$k neighbors at (${p.getX} ${p.getY}) after $iteration iteration(s) with final search &quot; +</span>
<span class="nc" id="L196">              s&quot;distance of ${window.radius} (initial $start, max $threshold)&quot;)</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        logger.trace(results.take(found).map(_.sf).mkString(&quot;; &quot;))</span>

<span class="nc" id="L199">        collection.synchronized {</span>
<span class="nc" id="L200">          var i = 0</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">          while (i &lt; found) {</span>
<span class="nc" id="L202">            collection.add(results(i).sf)</span>
<span class="nc" id="L203">            i += 1</span>
          }
        }
      }

<span class="nc" id="L208">      queries.toList.map(p =&gt; CachedThreadPool.submit(() =&gt; run(p))).foreach(_.get)</span>

<span class="nc" id="L210">      this.result = FeatureResult(collection)</span>
    }
  }

  /**
    * Class for finding window queries around a central point
    *
    * @param base base query
    * @param geom geometry attribute being queried
    * @param p central query point
    * @param k number of features to find
    * @param start initial search distance
    * @param threshold max distance to query
    */
<span class="nc" id="L224">  class KnnWindow(base: Query, geom: PropertyName, p: Point, k: Int, start: Double, threshold: Double) {</span>

<span class="nc" id="L226">    private val calc = new GeodeticCalculator()</span>
<span class="nc" id="L227">    private var distance = start</span>

    // our query envelope - this is purely cartesian and not constrained by world bounds
<span class="nc" id="L230">    private var envelope = QueryEnvelope(Envelope(p, distance, calc), None)</span>

    /**
      * Current search radius, in meters
      *
      * @return
      */
<span class="nc" id="L237">    def radius: Double = distance</span>

    /**
      * Current search envelope
      *
      * @return envelope
      */
<span class="nc" id="L244">    def window: QueryEnvelope = envelope</span>

    /**
      * Whether there are more window queries within the threshold
      *
      * @return
      */
<span class="nc bnc" id="L251" title="All 2 branches missed.">    def hasNext: Boolean = distance &lt; threshold</span>

    /**
      * Get the next query window
      *
      * @param found number of features found so far, if the query has already been run
      * @return
      */
    def next(found: Option[Int]): Query = {
<span class="nc" id="L260">      found.foreach(expand) // expand our window if we've already run a query</span>

<span class="nc" id="L262">      val query = new Query(base)</span>
<span class="nc" id="L263">      query.setHints(new Hints(base.getHints)) // prevent sharing of hints between queries</span>

      // remove the hole from our query envelopes so that we don't scan the same area more than once
<span class="nc" id="L266">      val filter = org.locationtech.geomesa.filter.orFilters(envelope.query.map(_.toFilter(geom)))</span>
<span class="nc" id="L267">      base.getFilter match {</span>
<span class="nc bnc" id="L268" title="All 10 branches missed.">        case null | Filter.INCLUDE =&gt; query.setFilter(filter)</span>
<span class="nc" id="L269">        case f =&gt; query.setFilter(ff.and(f, filter))</span>
      }

<span class="nc" id="L272">      query</span>
    }

    /**
      * Find the next window to search in an attempt to find the knn
      *
      * @param found number of neighbors found within the previous distance
      */
    private def expand(found: Int): Unit = {
      // expand the window radius. algorithm derived from:
      //    Efficient k Nearest Neighbor Queries on Remote Spatial Databases Using Range Estimation
      //    Danzhou Liu, Ee-Peng Lim, Wee-Keong Ng
      //    Centre for Advanced Information Systems, School of Computer Engineering
      //    Nanyang Technological University, Singapore 639798
      //    {P149571472, aseplim, awkng}@ntu.edu.sg
      //  Available at: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.507.4109&amp;rep=rep1&amp;type=pdf

      // note that this algorithm is fairly conservative - in their testing (using TIGER road data), it
      // generally required 2-3 window expansions after the initial query in order to find the knn

<span class="nc bnc" id="L292" title="All 2 branches missed.">      distance = if (found == 0) { distance * 2 } else {</span>
<span class="nc" id="L293">        val density = found / math.pow(2 * distance, 2)</span>
<span class="nc" id="L294">        math.sqrt(k / (math.Pi * density))</span>
      }
<span class="nc bnc" id="L296" title="All 2 branches missed.">      if (distance &gt; threshold) {</span>
<span class="nc" id="L297">        distance = threshold</span>
      }

<span class="nc" id="L300">      val hole = Some(envelope.envelope)</span>
<span class="nc" id="L301">      envelope = QueryEnvelope(Envelope(p, distance, calc), hole)</span>
    }
  }

  /**
    * Calculator for finding the k-nearest features
    *
    * @param query point to find neighbors for
    * @param k number of neighbors to find
    * @param threshold limit results to within a certain distance in meters
    * @param results array of length k, used to hold results
    * @param i number of features found so far, maxes out at k
    */
<span class="nc bnc" id="L314" title="All 4 branches missed.">  class KnnCalculator(</span>
<span class="nc" id="L315">      query: Point,</span>
<span class="nc" id="L316">      k: Int,</span>
<span class="nc" id="L317">      threshold: Double,</span>
<span class="nc" id="L318">      results: Array[FeatureWithDistance],</span>
<span class="nc" id="L319">      private var i: Int = 0</span>
<span class="nc" id="L320">    ) extends LazyLogging {</span>

<span class="nc" id="L322">    private val calculator = new GeodeticCalculator()</span>

    // tracks the index of our current farthest value
<span class="nc bnc" id="L325" title="All 2 branches missed.">    private var fi = if (i &lt; k) { 0 } else { farthest }</span>

    /**
      * Number of features found so far
      *
      * @return
      */
<span class="nc" id="L332">    def size: Int = i</span>

    /**
      * Visit a feature, checking the distance to the query point
      *
      * @param feature feature
      * @return None if the feature is within the threshold, otherwise Some(distance to query point)
      */
    def visit(feature: SimpleFeature): Option[Double] = {
<span class="nc" id="L341">      feature.getDefaultGeometry match {</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        case p: Point =&gt;</span>
          val meters = {
<span class="nc" id="L344">            calculator.setStartingGeographicPoint(query.getX, query.getY)</span>
<span class="nc" id="L345">            calculator.setDestinationGeographicPoint(p.getX, p.getY)</span>
<span class="nc" id="L346">            calculator.getOrthodromicDistance</span>
          }
<span class="nc bnc" id="L348" title="All 2 branches missed.">          if (meters &gt; threshold) {</span>
<span class="nc" id="L349">            Some(meters)</span>
          } else {
<span class="nc" id="L351">            visit(feature, meters)</span>
<span class="nc" id="L352">            None</span>
          }

<span class="nc bnc" id="L355" title="All 2 branches missed.">        case g =&gt; logger.warn(s&quot;KNN query not implemented for non-point geometries, skipping this feature: $g&quot;); None</span>
      }
    }

    /**
      * Visit a feature with a known distance
      *
      * @param feature feature
      * @param distance distance from the query point, in meters (assumed to be within the threshold)
      */
    def visit(feature: SimpleFeature, distance: Double): Unit = {
<span class="nc bnc" id="L366" title="All 2 branches missed.">      if (i &lt; k) {</span>
        // if we haven't seen k features yet, then by definition we have a nearest neighbor
<span class="nc" id="L368">        results(i) = FeatureWithDistance(feature, distance)</span>
<span class="nc" id="L369">        i += 1</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (i == k) {</span>
          // if we have k elements, find the farthest feature so that we can easily check it going forward
<span class="nc" id="L372">          fi = farthest</span>
        }
<span class="nc bnc" id="L374" title="All 2 branches missed.">      } else if (distance &lt; results(fi).meters) {</span>
        // we have found a new nearest - replace the farthest, then find the new farthest
<span class="nc" id="L376">        results(fi) = FeatureWithDistance(feature, distance)</span>
<span class="nc" id="L377">        fi = farthest</span>
      }
    }

    /**
      * Gets the array index of the farthest feature. Note: assumes the result array does not contain nulls
      *
      * @return
      */
    private def farthest: Int = {
<span class="nc" id="L387">      var max = results.head.meters</span>
<span class="nc" id="L388">      var result = 0</span>
<span class="nc" id="L389">      var i = 1</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">      while (i &lt; results.length) {</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (results(i).meters &gt; max) {</span>
<span class="nc" id="L392">          max = results(i).meters</span>
<span class="nc" id="L393">          result = i</span>
        }
<span class="nc" id="L395">        i += 1</span>
      }
<span class="nc" id="L397">      result</span>
    }
  }

  /**
    * Holder for our ordered features
    *
    * @param sf simple feature
    * @param meters distance in meters from the query point
    */
<span class="nc bnc" id="L407" title="All 21 branches missed.">  case class FeatureWithDistance(sf: SimpleFeature, meters: Double) extends Comparable[FeatureWithDistance] {</span>
<span class="nc" id="L408">    override def compareTo(o: FeatureWithDistance): Int = java.lang.Double.compare(meters, o.meters)</span>
  }

  /**
    * Holder for a query envelope
    *
    * @param envelope query envelope, in cartesian space
    * @param hole hole covering any previously queried space
    */
<span class="nc bnc" id="L417" title="All 25 branches missed.">  case class QueryEnvelope(envelope: Envelope, hole: Option[Envelope]) {</span>

    /**
      * Get the envelopes for a query filter. The envelopes will exclude the hole, if present, to avoid
      * returning duplicate results
      *
      * @return
      */
    def query: Seq[Envelope] = {
<span class="nc" id="L426">      hole match {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        case None =&gt; envelope.toWorld</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        case Some(h) =&gt;</span>
<span class="nc" id="L429">          val holes = h.toWorld</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">          envelope.toWorld.flatMap(e =&gt; holes.foldLeft(Seq(e)) { case (r, h) =&gt; r.flatMap(_.minus(h)) })</span>
      }
    }

    /**
      * Gets a string useful for debugging
      *
      * @return
      */
<span class="nc" id="L439">    def debug: Seq[String] = hole match {</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">      case None =&gt; Seq(envelope.debug)</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">      case Some(h) =&gt;</span>
<span class="nc" id="L442">        val diff = envelope.minus(h)</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (diff.isEmpty) { Seq(&quot;[empty]&quot;) } else { diff.map(_.debug) }</span>
    }
  }

  /**
    * Simple envelope class - unlike the jts envelope, does not swap min/max values on creation
    *
    * @param xmin min x value
    * @param xmax max x value
    * @param ymin min y value
    * @param ymax max y value
    */
<span class="nc bnc" id="L455" title="All 23 branches missed.">  case class Envelope(xmin: Double, xmax: Double, ymin: Double, ymax: Double) {</span>

<span class="nc bnc" id="L457" title="All 4 branches missed.">    require(xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax, s&quot;Envelope is inverted: [$xmin, $xmax, $ymin, $ymax]&quot;)</span>

<span class="nc bnc" id="L459" title="All 4 branches missed.">    lazy val width: Double = xmax - xmin</span>
<span class="nc bnc" id="L460" title="All 4 branches missed.">    lazy val height: Double = ymax - ymin</span>

    /**
      * Intersection of two envelopes
      *
      * @param other other envelope
      * @return
      */
    def intersection(other: Envelope): Option[Envelope] = {
<span class="nc" id="L469">      val ixmin = math.max(xmin, other.xmin)</span>
<span class="nc" id="L470">      val ixmax = math.min(xmax, other.xmax)</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">      if (ixmin &gt; ixmax) { None } else {</span>
<span class="nc" id="L472">        val iymin = math.max(ymin, other.ymin)</span>
<span class="nc" id="L473">        val iymax = math.min(ymax, other.ymax)</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (iymin &gt; iymax) { None } else {</span>
<span class="nc" id="L475">          Some(Envelope(ixmin, ixmax, iymin, iymax))</span>
        }
      }
    }

    /**
      * Do the two envelopes intersect?
      *
      * @param other other envelope
      * @return
      */
    def intersects(other: Envelope): Boolean =
<span class="nc bnc" id="L487" title="All 8 branches missed.">      other.xmin &lt;= xmax &amp;&amp; other.xmax &gt;= xmin &amp;&amp; other.ymin &lt;= ymax &amp;&amp; other.ymax &gt;= ymin</span>

    /**
      * Subtract an envelope from this one.
      *
      * The result will be 0 to 4 new envelopes. The 'top' and 'bottom' envelopes will contain corner
      * intersections, if any, while the 'left' and 'right' envelopes will be trimmed around the top/bottom ones.
      *
      * @param other envelope to subtract
      * @return
      */
    def minus(other: Envelope): Seq[Envelope] = {
<span class="nc bnc" id="L499" title="All 2 branches missed.">      if (!intersects(other)) { Seq(this) } else {</span>
<span class="nc" id="L500">        val builder = Seq.newBuilder[Envelope]</span>
        // conditionally add top envelope, and determine ymax for left/right envelopes
<span class="nc bnc" id="L502" title="All 2 branches missed.">        val sidemax = if (other.ymax &gt;= ymax) { ymax } else {</span>
<span class="nc" id="L503">          builder += copy(ymin = other.ymax)</span>
<span class="nc" id="L504">          other.ymax</span>
        }
        // conditionally add bottom envelope, and determine ymin for left/right envelopes
<span class="nc bnc" id="L507" title="All 2 branches missed.">        val sidemin = if (other.ymin &lt;= ymin) { ymin } else {</span>
<span class="nc" id="L508">          builder += copy(ymax = other.ymin)</span>
<span class="nc" id="L509">          other.ymin</span>
        }
        // conditionally add left/right envelopes
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (other.xmin &gt; xmin) {</span>
<span class="nc" id="L513">          builder += copy(xmax = other.xmin, ymin = sidemin, ymax = sidemax)</span>
        }
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (other.xmax &lt; xmax) {</span>
<span class="nc" id="L516">          builder += copy(xmin = other.xmax, ymin = sidemin, ymax = sidemax)</span>
        }
<span class="nc" id="L518">        builder.result</span>
      }
    }

    /**
      * Converts any part of this envelope that extends past [-180,180,-90,90] to handle the anti-meridian and poles.
      *
      * Envelopes that cross the poles end up wrapping the whole longitude. Envelopes that cross the anti-meridian
      * are wrapped to the other side.
      *
      * @return
      */
    def toWorld: Seq[Envelope] = {
<span class="nc bnc" id="L531" title="All 2 branches missed.">      if (ymin &lt; -90d) {</span>
<span class="nc" id="L532">        Seq(Envelope(-180d, 180d, -90, math.min(ymax, 90d)))</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">      } else if (ymax &gt; 90d) {</span>
<span class="nc" id="L534">        Seq(Envelope(-180d, 180d, math.max(ymin, -90), 90d))</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      } else if (width &gt;= 360d) {</span>
<span class="nc" id="L536">        Seq(copy(xmin = -180d, xmax = 180d))</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">      } else if (xmin &lt; -180d) {</span>
<span class="nc" id="L538">        intersection(WholeWorldEnvelope) match {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">          case None =&gt; Seq(copy(xmin = xmin + 360d, xmax = xmax + 360d))</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">          case Some(trimmed) =&gt; Seq(trimmed, copy(xmin = xmin + 360d, xmax = 180d))</span>
        }
<span class="nc bnc" id="L542" title="All 2 branches missed.">      } else if (xmax &gt; 180d) {</span>
<span class="nc" id="L543">        intersection(WholeWorldEnvelope) match {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">          case None =&gt; Seq(copy(xmin = xmin - 360d, xmax = xmax - 360d))</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">          case Some(trimmed) =&gt; Seq(trimmed, copy(xmin = -180d, xmax = xmax - 360d))</span>
        }
      } else {
<span class="nc" id="L548">        Seq(this)</span>
      }
    }

    /**
      * Create a geotools filter
      *
      * @param geom geometry expression
      * @return
      */
    def toFilter(geom: PropertyName): Filter =
<span class="nc" id="L559">      ff.bbox(geom, new ReferencedEnvelope(xmin, xmax, ymin, ymax, CRS_EPSG_4326))</span>

    /**
      * Convert to a JTS envelope
      *
      * @return
      */
<span class="nc" id="L566">    def toJts: org.locationtech.jts.geom.Envelope = new org.locationtech.jts.geom.Envelope(xmin, xmax, ymin, ymax)</span>

    /**
      * Debug string
      *
      * @return
      */
<span class="nc" id="L573">    def debug: String = s&quot;[$xmin, $xmax, $ymin, $ymax]&quot;</span>
  }

<span class="nc" id="L576">  object Envelope {</span>

    /**
      * Create an envelope by buffering a point to an inscribed circle
      *
      * @param point center point
      * @param buffer buffer distance, in meters
      * @param calc geodetic calculator
      * @return
      */
    def apply(point: Point, buffer: Double, calc: GeodeticCalculator): Envelope = {
<span class="nc bnc" id="L587" title="All 2 branches missed.">      val (east, north) = GeometryUtils.directionalDegrees(point, buffer, calc)</span>
<span class="nc" id="L588">      Envelope(point.getX - east, point.getX + east, point.getY - north, point.getY + north)</span>
    }
  }
<span class="nc" id="L591">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>