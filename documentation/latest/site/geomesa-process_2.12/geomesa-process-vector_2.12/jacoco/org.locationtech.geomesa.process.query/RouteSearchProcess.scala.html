<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RouteSearchProcess.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Vector Processes</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.process.query</a> &gt; <span class="el_source">RouteSearchProcess.scala</span></div><h1>RouteSearchProcess.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.process.query

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.{Query, SimpleFeatureSource}
import org.geotools.api.feature.Feature
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.data.collection.ListFeatureCollection
import org.geotools.data.simple.{SimpleFeatureCollection, SimpleFeatureIterator}
import org.geotools.feature.collection.DecoratingSimpleFeatureCollection
import org.geotools.process.factory.{DescribeParameter, DescribeProcess, DescribeResult}
import org.geotools.referencing.GeodeticCalculator
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.filter.{ff, orFilters}
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureCollection
import org.locationtech.geomesa.index.process.{FeatureResult, GeoMesaProcessVisitor}
import org.locationtech.geomesa.process.GeoMesaProcess
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.io.WithClose
import org.locationtech.geomesa.utils.text.WKTUtils
import org.locationtech.jts.geom._
import org.locationtech.jts.operation.distance.DistanceOp

import java.util.concurrent.ConcurrentHashMap

@DescribeProcess(
  title = &quot;Route Search&quot;,
  description = &quot;Performs a search based on a route&quot;
)
<span class="nc bnc" id="L39" title="All 4 branches missed.">class RouteSearchProcess extends GeoMesaProcess with LazyLogging {</span>

  /**
    * Finds features around a route that are heading along the route and not just crossing over it
    *
    * @param features input features to query
    * @param routes routes to match
    * @param bufferSize buffer around the routes to search, in meters
    * @param headingThreshold threshold to match the heading of the route, in degrees
    * @param routeGeomField geometry attribute in the route features that contains the route, optional
    *                       will use default geometry if not provided
    * @param geomField geometry attribute in input features to match with the route, optional
    *                  will use default geometry if not provided
    * @param bidirectional consider the direction of the route or just the path of the route
    * @param headingField heading attribute in input features, required unless input geometries are linestrings
    * @return
    */
  @DescribeResult(description = &quot;Output feature collection&quot;)
  def execute(
              @DescribeParameter(name = &quot;features&quot;, description = &quot;Input feature collection to query &quot;)
              features: SimpleFeatureCollection,
              @DescribeParameter(name = &quot;routes&quot;, description = &quot;Routes to search along. Features must have a geometry of LineString&quot;)
              routes: SimpleFeatureCollection,
              @DescribeParameter(name = &quot;bufferSize&quot;, description = &quot;Buffer size (in meters) to search around the route&quot;)
              bufferSize: java.lang.Double,
              @DescribeParameter(name = &quot;headingThreshold&quot;, description = &quot;Threshold for comparing headings, in degrees&quot;)
              headingThreshold: java.lang.Double,
              @DescribeParameter(name = &quot;routeGeomField&quot;, description = &quot;Attribute that will be examined for routes to match. Must be a LineString&quot;, min = 0)
              routeGeomField: String,
              @DescribeParameter(name = &quot;geomField&quot;, description = &quot;Attribute that will be examined for route matching. Must be a LineString&quot;, min = 0)
              geomField: String,
              @DescribeParameter(name = &quot;bidirectional&quot;, description = &quot;Match the route direction or match just the route path&quot;, min = 0)
              bidirectional: java.lang.Boolean,
              @DescribeParameter(name = &quot;headingField&quot;, description = &quot;Attribute that will be examined for heading in the input features. If not provided, input features geometries must be LineStrings&quot;, min = 0)
              headingField: String
             ): SimpleFeatureCollection = {

<span class="nc bnc" id="L76" title="All 2 branches missed.">    logger.debug(s&quot;Route searching on collection type ${features.getClass.getName}&quot;)</span>

<span class="nc" id="L78">    val bi = Option(bidirectional).getOrElse(java.lang.Boolean.FALSE)</span>

<span class="nc" id="L80">    val sft = features.getSchema</span>

    // pull out attributes and validate inputs

<span class="nc bnc" id="L84" title="All 2 branches missed.">    val (geomAttribute, isPoints) = {</span>
<span class="nc" id="L85">      val name = Option(geomField).getOrElse(sft.getGeometryDescriptor.getLocalName)</span>
<span class="nc" id="L86">      val descriptor = sft.getDescriptor(name)</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">      if (descriptor == null) {</span>
<span class="nc" id="L88">        throw new IllegalArgumentException(s&quot;Geometry field '$name' does not exist in input feature collection&quot;)</span>
      }
<span class="nc" id="L90">      val binding = descriptor.getType.getBinding</span>
<span class="nc" id="L91">      val isPoints = classOf[Point].isAssignableFrom(binding)</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">      if (!isPoints &amp;&amp; !classOf[LineString].isAssignableFrom(binding)) {</span>
<span class="nc" id="L93">        throw new IllegalArgumentException(s&quot;Geometry field '$name' must be a Point or LineString&quot;)</span>
      }
<span class="nc" id="L95">      (name, isPoints)</span>
    }

<span class="nc bnc" id="L98" title="All 4 branches missed.">    if (headingField == null &amp;&amp; isPoints) {</span>
<span class="nc" id="L99">      throw new IllegalArgumentException(&quot;Heading must be specified unless input feature collection geometry is a LineString&quot;)</span>
<span class="nc bnc" id="L100" title="All 4 branches missed.">    } else if (headingField != null &amp;&amp; sft.indexOf(headingField) == -1) {</span>
<span class="nc" id="L101">      throw new IllegalArgumentException(s&quot;Heading field '$headingField' does not exist in input feature collection&quot;)</span>
    }

    // extract the route geometries
    val routeGeoms = {
<span class="nc" id="L106">      val sft = routes.getSchema</span>
<span class="nc" id="L107">      val name = Option(routeGeomField).getOrElse(sft.getGeometryDescriptor.getLocalName)</span>
<span class="nc" id="L108">      val index = sft.indexOf(name)</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (index == -1) {</span>
<span class="nc" id="L110">        throw new IllegalArgumentException(s&quot;Geometry field '$name' does not exist in route feature collection&quot;)</span>
      }
<span class="nc bnc" id="L112" title="All 2 branches missed.">      if (!classOf[LineString].isAssignableFrom(sft.getDescriptor(index).getType.getBinding)) {</span>
<span class="nc" id="L113">        throw new IllegalArgumentException(s&quot;Route geometry field '$name' must be a LineString&quot;)</span>
      }
<span class="nc" id="L115">      CloseableIterator(routes.features()).map(_.getAttribute(index).asInstanceOf[LineString]).toList</span>
    }

<span class="nc" id="L118">    val visitor = new RouteVisitor(sft, routeGeoms, bufferSize, headingThreshold, bi,</span>
<span class="nc" id="L119">      geomAttribute, isPoints, Option(headingField))</span>
<span class="nc" id="L120">    GeoMesaFeatureCollection.visit(features, visitor)</span>
<span class="nc" id="L121">    visitor.getResult.results</span>
  }
}

<span class="nc bnc" id="L125" title="All 4 branches missed.">class RouteVisitor(sft: SimpleFeatureType,</span>
<span class="nc" id="L126">                   routes: Seq[LineString],</span>
<span class="nc" id="L127">                   routeBuffer: Double,</span>
<span class="nc" id="L128">                   threshold: Double,</span>
<span class="nc" id="L129">                   bidirectional: Boolean,</span>
<span class="nc" id="L130">                   geomAttribute: String,</span>
<span class="nc" id="L131">                   isPoints: Boolean,</span>
<span class="nc" id="L132">                   headingAttribute: Option[String]) extends GeoMesaProcessVisitor with LazyLogging {</span>

<span class="nc" id="L134">  private var resultCalc: FeatureResult = _</span>

<span class="nc" id="L136">  private val routeFilter =</span>
<span class="nc" id="L137">    orFilters(routes.map(ls =&gt; ff.dwithin(ff.property(geomAttribute), ff.literal(ls), routeBuffer, &quot;meters&quot;)))</span>

  // for manual check, rewrite the filter to handle meters
  // normally handled in our query planner, but we are going to use the filter directly here
<span class="nc bnc" id="L141" title="All 4 branches missed.">  private lazy val manualRouteFilter = FastFilterFactory.optimize(sft, routeFilter)</span>

  // for collecting results manually
<span class="nc" id="L144">  private var manualCollection: ListFeatureCollection = _</span>

<span class="nc" id="L146">  override def getResult: FeatureResult = resultCalc</span>

  // manually called for non-accumulo feature collections
  override def visit(feature: Feature): Unit = {
<span class="nc" id="L150">    val sf = feature.asInstanceOf[SimpleFeature]</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">    if (manualCollection == null) {</span>
<span class="nc" id="L153">      manualCollection = new ListFeatureCollection(sf.getFeatureType)</span>
<span class="nc" id="L154">      resultCalc = FeatureResult(matchRoutes(manualCollection))</span>
    }

<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (manualRouteFilter.evaluate(sf)) {</span>
<span class="nc" id="L158">      manualCollection.add(sf)</span>
    }
  }

  override def execute(source: SimpleFeatureSource, query: Query): Unit = {
<span class="nc bnc" id="L163" title="All 2 branches missed.">    logger.debug(s&quot;Visiting source type: ${source.getClass.getName}&quot;)</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">    val result = if (routes.isEmpty) { source.getFeatures(Filter.EXCLUDE) } else {</span>
      import org.locationtech.geomesa.filter._
<span class="nc bnc" id="L166" title="All 8 branches missed.">      val filter = if (query == null || query.getFilter == Filter.INCLUDE) { routeFilter } else {</span>
<span class="nc" id="L167">        andFilters(Seq(query.getFilter, routeFilter))</span>
      }
<span class="nc" id="L169">      matchRoutes(source.getFeatures(filter))</span>
    }
<span class="nc" id="L171">    resultCalc = FeatureResult(result)</span>
  }

  /**
    * Filters a feature collection by comparing routes
    *
    * @param input input feature collection
    * @return
    */
  private def matchRoutes(input: SimpleFeatureCollection): SimpleFeatureCollection = {
<span class="nc" id="L181">    val sft = input.getSchema</span>
<span class="nc" id="L182">    val geomIndex = sft.indexOf(geomAttribute)</span>
<span class="nc" id="L183">    val headingIndex = headingAttribute.map(sft.indexOf)</span>

<span class="nc bnc" id="L185" title="All 2 branches missed.">    logger.debug(s&quot;Searching routes: ${routes.map(WKTUtils.write).mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">    logger.debug(s&quot;Buffer (meters): $routeBuffer&quot;)</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">    logger.debug(s&quot;Geometry attribute: $geomAttribute&quot;)</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">    logger.debug(s&quot;Heading attribute: ${headingAttribute.getOrElse(&quot;none&quot;)}&quot;)</span>

<span class="nc" id="L190">    RouteVisitor.matchRoutes(input, routes, geomIndex, isPoints, headingIndex, threshold, bidirectional)</span>
  }
}

<span class="nc" id="L194">object RouteVisitor {</span>

  /**
    * Match features to routes.
    *
    * @param input input features
    * @param routes routes to match against
    * @param geomIndex geometry attribute index of the input features
    * @param isPoints are the input feature geometries points (or linestrings)
    * @param headingIndex attribute index of the heading in the input features, not required if they are linestrings
    * @param threshold threshold to consider when matching route heading, in degrees
    * @param bidirectional match the route direction or just the path
    * @return
    */
<span class="nc" id="L208">  def matchRoutes(input: SimpleFeatureCollection,</span>
<span class="nc" id="L209">                  routes: Seq[LineString],</span>
<span class="nc" id="L210">                  geomIndex: Int,</span>
                  isPoints: Boolean,
                  headingIndex: Option[Int],
<span class="nc" id="L213">                  threshold: Double,</span>
<span class="nc" id="L214">                  bidirectional: Boolean): SimpleFeatureCollection = {</span>

    // just in case the features are operated on in parallel...
<span class="nc" id="L217">    val calculator = new ThreadLocal[GeodeticCalculator] {</span>
<span class="nc" id="L218">      override def initialValue(): GeodeticCalculator = new GeodeticCalculator</span>
    }
<span class="nc" id="L220">    val headingCache = {</span>
      import scala.collection.JavaConverters._
<span class="nc" id="L222">      new ConcurrentHashMap[(LineString, Int), Double].asScala</span>
    }

    // gets the heading for an input feature
<span class="nc" id="L226">    val getFeatureHeading: (SimpleFeature) =&gt; Double = headingIndex match {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      case Some(index) =&gt; (sf) =&gt; FastConverter.convert(sf.getAttribute(index), classOf[Double])</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">      case None =&gt;</span>
<span class="nc" id="L229">      (sf) =&gt; {</span>
<span class="nc" id="L230">        val geom = sf.getAttribute(geomIndex).asInstanceOf[LineString]</span>
        // use the last two points in the line to find it's current heading - we don't care about history
<span class="nc" id="L232">        getRouteHeading(geom, geom.getNumPoints - 2, calculator.get)</span>
      }
    }

    // gets the point from a geometry that we want to match against routes
<span class="nc bnc" id="L237" title="All 2 branches missed.">    val getComparisonPoint: (Geometry) =&gt; Point = if (isPoints) {</span>
<span class="nc" id="L238">      (g) =&gt; g.asInstanceOf[Point]</span>
    } else {
      // match the most recent point
<span class="nc" id="L241">      (g) =&gt; g.asInstanceOf[LineString].getEndPoint</span>
    }

    // matches a feature against the routes
    def matchRoute(sf: SimpleFeature): Boolean = {
<span class="nc" id="L246">      val geom = sf.getAttribute(geomIndex).asInstanceOf[Geometry]</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">      val (route, closestLocation) = getClosestRoute(getComparisonPoint(geom), routes)</span>
<span class="nc" id="L248">      val routeHeading = headingCache.getOrElseUpdate((route, closestLocation),</span>
<span class="nc" id="L249">        getRouteHeading(route, closestLocation, calculator.get))</span>
<span class="nc" id="L250">      val featureHeading = getFeatureHeading(sf)</span>

      // compare the headings
<span class="nc" id="L253">      var diff = math.abs(routeHeading - featureHeading)</span>
      // compass problem - correct for headings on either side of 0/360
<span class="nc bnc" id="L255" title="All 2 branches missed.">      if (diff &gt; 180.0) {</span>
<span class="nc" id="L256">        diff = math.abs(diff - 360.0)</span>
      }
<span class="nc bnc" id="L258" title="All 6 branches missed.">      diff &lt;= threshold || (bidirectional &amp;&amp; math.abs(diff - 180.0) &lt;= threshold)</span>
    }

    // delegate feature collection that filters the results based on route matching
<span class="nc" id="L262">    new DecoratingSimpleFeatureCollection(input) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">      override def features(): SimpleFeatureIterator = new SimpleFeatureIterator() {</span>
<span class="nc" id="L264">        private val delegate = CloseableIterator(input.features()).filter(matchRoute)</span>
<span class="nc" id="L265">        override def next(): SimpleFeature = delegate.next()</span>
<span class="nc" id="L266">        override def hasNext: Boolean = delegate.hasNext</span>
<span class="nc" id="L267">        override def close(): Unit = delegate.close()</span>
      }
    }
  }

  /**
    * Gets the closest route to the input point
    *
    * @param geom input point
    * @param routes routes to check
    * @return route and index of start of line segment in the route that is closest to the point
    */
  private def getClosestRoute(geom: Point, routes: Seq[LineString]): (LineString, Int) = {
    def closestPoint(ls: LineString): (Double, LineString, Int) = {
<span class="nc" id="L281">      val op = new DistanceOp(ls, geom)</span>
<span class="nc" id="L282">      (op.distance(), ls, op.nearestLocations()(0).getSegmentIndex)</span>
    }
<span class="nc bnc" id="L284" title="All 2 branches missed.">    val (_, route, location) = routes.map(closestPoint).minBy(_._1)</span>
<span class="nc" id="L285">    (route, location)</span>
  }

  /**
    * Gets the heading of a route at a particular line segment
    *
    * @param route route
    * @param index index of the start of the line segment we want to consider
    * @param calculator geodetic calculator instance
    * @return heading between 0-360
    */
  private def getRouteHeading(route: LineString, index: Int, calculator: GeodeticCalculator): Double = {
<span class="nc" id="L297">    val coords = route.getCoordinates</span>
    // the closest point falls somewhere along this line segment - calculate the heading for the segment
<span class="nc" id="L299">    val segment0 = coords(index)</span>
<span class="nc" id="L300">    val segment1 = coords(index + 1)</span>
<span class="nc" id="L301">    calculator.setStartingGeographicPoint(segment0.x, segment0.y)</span>
<span class="nc" id="L302">    calculator.setDestinationGeographicPoint(segment1.x, segment1.y)</span>
<span class="nc" id="L303">    val azimuth = calculator.getAzimuth</span>
    // azimuth is between -180 and +180, where 0 corresponds to north - convert to degrees 0-360
<span class="nc bnc" id="L305" title="All 2 branches missed.">    if (azimuth &lt; 0.0) {</span>
<span class="nc" id="L306">      360.0 + azimuth</span>
    } else {
<span class="nc" id="L308">      azimuth</span>
    }
  }
<span class="nc" id="L311">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>