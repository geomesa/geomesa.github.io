<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DensityProcess.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Vector Processes</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.process.analytic</a> &gt; <span class="el_source">DensityProcess.scala</span></div><h1>DensityProcess.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.process.analytic

import org.eclipse.imagen.RasterFactory
import org.geotools.api.coverage.grid.GridGeometry
import org.geotools.api.data.Query
import org.geotools.api.filter.Filter
import org.geotools.api.util.ProgressListener
import org.geotools.coverage.CoverageFactoryFinder
import org.geotools.coverage.grid.GridCoverage2D
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.process.ProcessException
import org.geotools.process.factory.{DescribeParameter, DescribeProcess, DescribeResult}
import org.geotools.process.vector.{BBOXExpandingFilterVisitor, HeatmapSurface}
import org.geotools.util.factory.GeoTools
import org.locationtech.geomesa.index.conf.QueryHints
import org.locationtech.geomesa.index.iterators.DensityScan
import org.locationtech.geomesa.process.GeoMesaProcess
import org.locationtech.geomesa.utils.io.WithClose

import java.awt.image.DataBuffer

/**
 * Stripped down version of org.geotools.process.vector.HeatmapProcess
 */
@DescribeProcess(
  title = &quot;Density Map&quot;,
  description = &quot;Computes a density map over a set of features stored in Geomesa&quot;
)
<span class="nc" id="L38">class DensityProcess extends GeoMesaProcess {</span>

  import DensityProcess.DefaultRadiusPixels

  @throws(classOf[ProcessException])
  @DescribeResult(name = &quot;result&quot;, description = &quot;Output raster&quot;)
  def execute(
      @DescribeParameter(name = &quot;data&quot;, description = &quot;Input features&quot;)
      obsFeatures: SimpleFeatureCollection,
      @DescribeParameter(name = &quot;radiusPixels&quot;, description = &quot;Radius of the density kernel in pixels&quot;)
      argRadiusPixels: Integer,
      @DescribeParameter(name = &quot;geomAttr&quot;, description = &quot;Name of the geometry attribute to render&quot;, min = 0, max = 1)
      argGeomAttr: String,
      @DescribeParameter(name = &quot;weightAttr&quot;, description = &quot;Name of the attribute to use for data point weight&quot;, min = 0, max = 1)
      argWeightAttr: String,
      @DescribeParameter(name = &quot;outputBBOX&quot;, description = &quot;Bounding box of the output&quot;)
      argOutputEnv: ReferencedEnvelope,
      @DescribeParameter(name = &quot;outputWidth&quot;, description = &quot;Width of output raster in pixels&quot;)
      argOutputWidth: Integer,
      @DescribeParameter(name = &quot;outputHeight&quot;, description = &quot;Height of output raster in pixels&quot;)
      argOutputHeight: Integer,
      monitor: ProgressListener): GridCoverage2D = {

<span class="nc" id="L61">    val pixels = Option(argRadiusPixels).map(_.intValue).getOrElse(DefaultRadiusPixels)</span>

    // buffer our calculations based on the pixel radius to avoid edge artifacts
<span class="nc" id="L64">    val outputWidth  = argOutputWidth + 2 * pixels</span>
<span class="nc" id="L65">    val outputHeight = argOutputHeight + 2 * pixels</span>
<span class="nc" id="L66">    val bufferWidth  = pixels * argOutputEnv.getWidth / argOutputWidth</span>
<span class="nc" id="L67">    val bufferHeight = pixels * argOutputEnv.getHeight / argOutputHeight</span>
<span class="nc" id="L68">    val envelope = new ReferencedEnvelope(argOutputEnv)</span>
<span class="nc" id="L69">    envelope.expandBy(bufferWidth, bufferHeight)</span>

<span class="nc" id="L71">    val decode = DensityScan.decodeResult(envelope, outputWidth, outputHeight)</span>

<span class="nc" id="L73">    val heatMap = new HeatmapSurface(pixels, envelope, outputWidth, outputHeight)</span>

    try {
<span class="nc" id="L76">      WithClose(obsFeatures.features()) { features =&gt;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        while (features.hasNext) {</span>
<span class="nc" id="L78">          val pts = decode(features.next())</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">          while (pts.hasNext) {</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">            val (x, y, weight) = pts.next()</span>
<span class="nc" id="L81">            heatMap.addPoint(x, y, weight)</span>
          }
        }
      }
    } catch {
<span class="nc" id="L86">      case e: Exception =&gt; throw new ProcessException(&quot;Error processing heatmap&quot;, e)</span>
    }

<span class="nc" id="L89">    val heatMapGrid = DensityProcess.flipXY(heatMap.computeSurface)</span>

    // create the raster from our unbuffered envelope and discard the buffered pixels in our final image
<span class="nc" id="L92">    val raster = RasterFactory.createBandedRaster(DataBuffer.TYPE_FLOAT, argOutputWidth, argOutputHeight, 1, null)</span>

<span class="nc" id="L94">    var i, j = pixels</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">    while (j &lt; heatMapGrid.length - pixels) {</span>
<span class="nc" id="L96">      val row = heatMapGrid(j)</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      while (i &lt; row.length - pixels) {</span>
<span class="nc" id="L98">        raster.setSample(i - pixels, j - pixels, 0, row(i))</span>
<span class="nc" id="L99">        i += 1</span>
      }
<span class="nc" id="L101">      j += 1</span>
<span class="nc" id="L102">      i = pixels</span>
    }

<span class="nc" id="L105">    val gcf = CoverageFactoryFinder.getGridCoverageFactory(GeoTools.getDefaultHints)</span>
<span class="nc" id="L106">    gcf.create(&quot;Process Results&quot;, raster, argOutputEnv)</span>
  }

  /**
   * Given a target query and a target grid geometry returns the query to be used to read the
   * input data of the process involved in rendering. In this process this method is used to:
   * &lt;ul&gt;
   * &lt;li&gt;determine the extent &amp; CRS of the output grid
   * &lt;li&gt;expand the query envelope to ensure stable surface generation
   * &lt;li&gt;modify the query hints to ensure point features are returned
   * &lt;/ul&gt;
   * Note that in order to pass validation, all parameters named here must also appear in the
   * parameter list of the `execute` method, even if they are not used there.
   *
   * @param argRadiusPixels the feature type attribute that contains the observed surface value
   * @param targetQuery the query used against the data source
   * @param targetGridGeometry the grid geometry of the destination image
   * @return The transformed query
   */
  @throws(classOf[ProcessException])
  def invertQuery(
      @DescribeParameter(name = &quot;radiusPixels&quot;, description = &quot;Radius to use for the kernel&quot;, min = 0, max = 1)
      argRadiusPixels: Integer,
      @DescribeParameter(name = &quot;geomAttr&quot;, description = &quot;Name of the geometry attribute to render&quot;, min = 0, max = 1)
      argGeomAttr: String,
      @DescribeParameter(name = &quot;weightAttr&quot;, description = &quot;Name of the attribute to use for data point weight&quot;, min = 0, max = 1)
      argWeightAttr: String,
      @DescribeParameter(name = &quot;outputBBOX&quot;, description = &quot;Georeferenced bounding box of the output&quot;)
      argOutputEnv: ReferencedEnvelope,
      @DescribeParameter(name = &quot;outputWidth&quot;, description = &quot;Width of the output raster&quot;)
      argOutputWidth: Integer,
      @DescribeParameter(name = &quot;outputHeight&quot;, description = &quot;Height of the output raster&quot;)
      argOutputHeight: Integer,
      targetQuery: Query,
      targetGridGeometry: GridGeometry): Query = {
<span class="nc bnc" id="L141" title="All 4 branches missed.">    if (argOutputWidth == null || argOutputHeight == null) {</span>
<span class="nc" id="L142">      throw new IllegalArgumentException(&quot;outputWidth and/or outputHeight not specified&quot;)</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">    } else if (argOutputWidth &lt; 0 || argOutputHeight &lt; 0) {</span>
<span class="nc" id="L144">      throw new IllegalArgumentException(&quot;outputWidth and outputHeight must both be positive&quot;)</span>
    }

<span class="nc" id="L147">    val pixels = Option(argRadiusPixels).map(_.intValue).getOrElse(DefaultRadiusPixels)</span>

    // buffer our calculations based on the pixel radius to avoid edge artifacts
<span class="nc" id="L150">    val outputWidth  = argOutputWidth + 2 * pixels</span>
<span class="nc" id="L151">    val outputHeight = argOutputHeight + 2 * pixels</span>

<span class="nc" id="L153">    val bufferWidth  = pixels * argOutputEnv.getWidth / argOutputWidth</span>
<span class="nc" id="L154">    val bufferHeight = pixels * argOutputEnv.getHeight / argOutputHeight</span>

<span class="nc" id="L156">    val envelope = new ReferencedEnvelope(argOutputEnv)</span>
<span class="nc" id="L157">    envelope.expandBy(bufferWidth, bufferHeight)</span>

    val filter = {
<span class="nc" id="L160">      val buf = math.max(bufferWidth, bufferHeight)</span>
<span class="nc" id="L161">      targetQuery.getFilter.accept(new BBOXExpandingFilterVisitor(buf, buf, buf, buf), null).asInstanceOf[Filter]</span>
    }

<span class="nc" id="L164">    val invertedQuery = new Query(targetQuery)</span>
<span class="nc" id="L165">    invertedQuery.setFilter(filter)</span>
<span class="nc" id="L166">    invertedQuery.setProperties(null)</span>
<span class="nc" id="L167">    invertedQuery.getHints.put(QueryHints.DENSITY_BBOX, envelope)</span>
<span class="nc" id="L168">    invertedQuery.getHints.put(QueryHints.DENSITY_WIDTH, outputWidth)</span>
<span class="nc" id="L169">    invertedQuery.getHints.put(QueryHints.DENSITY_HEIGHT, outputHeight)</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">    if (argGeomAttr != null) {</span>
<span class="nc" id="L171">      invertedQuery.getHints.put(QueryHints.DENSITY_GEOM, argGeomAttr)</span>
    }
<span class="nc bnc" id="L173" title="All 2 branches missed.">    if (argWeightAttr != null) {</span>
<span class="nc" id="L174">      invertedQuery.getHints.put(QueryHints.DENSITY_WEIGHT, argWeightAttr)</span>
    }
<span class="nc" id="L176">    invertedQuery</span>
  }
}

<span class="nc" id="L180">object DensityProcess {</span>

<span class="nc" id="L182">  val DefaultRadiusPixels: Int = 10</span>

  /**
   * Flips an XY matrix along the X=Y axis, and inverts the Y axis. Used to convert from
   * &quot;map orientation&quot; into the &quot;image orientation&quot; used by GridCoverageFactory. The surface
   * interpolation is done on an XY grid, with Y=0 being the bottom of the space. GridCoverages
   * are stored in an image format, in a YX grid with Y=0 being the top.
   *
   * @param grid the grid to flip
   * @return the flipped grid
   */
  def flipXY(grid: Array[Array[Float]]): Array[Array[Float]] = {
<span class="nc" id="L194">    val length_x = grid.length</span>
<span class="nc" id="L195">    val length_y = grid(0).length</span>

<span class="nc" id="L197">    val res = Array.fill(length_y,length_x)(0f)</span>

<span class="nc" id="L199">    for ( x &lt;- 0 until length_x ; y &lt;- 0 until length_y ) {</span>
<span class="nc" id="L200">      val x1 = length_y - 1 - y</span>
<span class="nc" id="L201">      val y1 = x</span>
<span class="nc" id="L202">      res(x1)(y1) = grid(x)(y)</span>
    }

<span class="nc" id="L205">    res</span>
  }
<span class="nc" id="L207">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>