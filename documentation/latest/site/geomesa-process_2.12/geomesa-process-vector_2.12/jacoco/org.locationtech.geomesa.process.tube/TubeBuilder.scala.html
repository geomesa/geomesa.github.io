<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TubeBuilder.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Vector Processes</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.process.tube</a> &gt; <span class="el_source">TubeBuilder.scala</span></div><h1>TubeBuilder.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.process.tube

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.feature.simple.SimpleFeatureBuilder
import org.geotools.referencing.GeodeticCalculator
import org.locationtech.geomesa.features.ScalaSimpleFeatureFactory
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType._
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.geotools.{GeometryUtils, SimpleFeatureTypes}
import org.locationtech.geomesa.utils.text.WKTUtils
import org.locationtech.jts.geom._
import org.locationtech.jts.geom.impl.CoordinateArraySequence

import java.util.Date
import java.util.concurrent.atomic.AtomicInteger
import scala.collection.immutable.NumericRange

<span class="nc" id="L29">object TubeBuilder {</span>
<span class="nc" id="L30">  val DefaultDtgField = &quot;dtg&quot;</span>
}

/**
 * Build a tube for input to a TubeSelect by buffering and binning the input
 * tubeFeatures into SimpleFeatures that can be used as inputs to Geomesa queries
 */
<span class="nc bnc" id="L37" title="All 4 branches missed.">abstract class TubeBuilder(val tubeFeatures: SimpleFeatureCollection,</span>
<span class="nc" id="L38">                           val bufferDistance: Double,</span>
<span class="nc" id="L39">                           val maxBins: Int) extends LazyLogging {</span>

<span class="nc" id="L41">  protected val calc = new GeodeticCalculator()</span>
<span class="nc" id="L42">  protected val dtgField: String = tubeFeatures.getSchema.getDtgField.getOrElse(TubeBuilder.DefaultDtgField)</span>
<span class="nc" id="L43">  protected val geoFac = new GeometryFactory</span>

<span class="nc" id="L45">  private val tubeType: SimpleFeatureType = SimpleFeatureTypes.createType(&quot;tubeType&quot;, &quot;geom:Geometry:srid=4326,start:Date,end:Date&quot;)</span>
<span class="nc" id="L46">  protected val builder: SimpleFeatureBuilder = ScalaSimpleFeatureFactory.featureBuilder(tubeType)</span>

<span class="nc" id="L48">  def getGeom(sf: SimpleFeature): Geometry = sf.getAttribute(0).asInstanceOf[Geometry]</span>
<span class="nc" id="L49">  def getStartTime(sf: SimpleFeature): Date = sf.getAttribute(1).asInstanceOf[Date]</span>
<span class="nc" id="L50">  def getEndTime(sf: SimpleFeature): Date = sf.getAttribute(2).asInstanceOf[Date]</span>

  private def bufferGeom(geom: Geometry, meters: Double): Geometry = {
    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
<span class="nc" id="L54">    geom.buffer(metersToDegrees(meters, geom.safeCentroid()))</span>
  }

  // visible for testing
  private[geomesa] def metersToDegrees(meters: Double, point: Point): Double = {
<span class="nc bnc" id="L59" title="All 2 branches missed.">    logger.debug(&quot;Buffering: &quot;+meters.toString + &quot; &quot;+WKTUtils.write(point))</span>

<span class="nc" id="L61">    calc.setStartingGeographicPoint(point.getX, point.getY)</span>
<span class="nc" id="L62">    calc.setDirection(0, meters)</span>
<span class="nc" id="L63">    val dest2D = calc.getDestinationGeographicPoint</span>
<span class="nc" id="L64">    val destPoint = geoFac.createPoint(new Coordinate(dest2D.getX, dest2D.getY))</span>
<span class="nc" id="L65">    point.distance(destPoint)</span>
  }

  protected def buffer(sf: SimpleFeature, meters: Double): SimpleFeature = {
<span class="nc" id="L69">    val bufferedGeom = bufferGeom(getGeom(sf), meters)</span>
<span class="nc" id="L70">    builder.reset()</span>
<span class="nc" id="L71">    builder.init(sf)</span>
<span class="nc" id="L72">    builder.set(0, bufferedGeom)</span>
<span class="nc" id="L73">    builder.buildFeature(sf.getID)</span>
  }

  // transform the input tubeFeatures into the intermediate SF used by the
  // tubing code consisting of three attributes (geom, startTime, endTime)
  // handle date parsing from input -&gt; TODO revisit date parsing...
  protected def transform(tubeFeatures: SimpleFeatureCollection, dtgField: String): List[SimpleFeature] = {
<span class="nc" id="L80">    val features = CloseableIterator(tubeFeatures.features).map { sf =&gt;</span>
<span class="nc" id="L81">      val date = FastConverter.convert(sf.getAttribute(dtgField), classOf[Date])</span>

<span class="nc bnc" id="L83" title="All 2 branches missed.">      if (date == null) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        logger.error(&quot;Unable to retrieve date field from input tubeFeatures...ensure there a field named &quot; + dtgField)</span>
<span class="nc" id="L85">        throw new IllegalArgumentException(&quot;Unable to retrieve date field from input tubeFeatures...ensure there a field named \&quot;&quot; + dtgField + &quot;\&quot;&quot;)</span>
      }

<span class="nc" id="L88">      builder.reset()</span>
<span class="nc" id="L89">      builder.buildFeature(sf.getID, sf.getDefaultGeometry, date, null)</span>
    }
<span class="nc" id="L91">    features.toList</span>
  }

  /**
    * Return an Array containing either 1 or 2 LineStrings that straddle but
    * do not cross the IDL.
    * @param input1 The first point in the segment
    * @param input2 The second point in the segment
    * @return an array of LineString containing either 1 or 2 LineStrings that do not
    *         span the IDL.
    */
  protected def makeIDLSafeLineString(input1:Coordinate, input2:Coordinate): Geometry = {
    //If the points cross the IDL we must generate two line segments
<span class="nc bnc" id="L104" title="All 2 branches missed.">    if (GeometryUtils.crossesIDL(input1, input2)) {</span>
      //Find the latitude where the segment intercepts the IDL
<span class="nc" id="L106">      val latIntercept = GeometryUtils.calcIDLIntercept(input1, input2)</span>
<span class="nc" id="L107">      val p1 = new Coordinate(-180, latIntercept)</span>
<span class="nc" id="L108">      val p2 = new Coordinate(180, latIntercept)</span>
      //This orders the points so that point1 is always the east-most point
<span class="nc bnc" id="L110" title="All 4 branches missed.">      val (point1, point2) = if (input1.x &gt; 0) (input1, input2) else (input2, input1)</span>
<span class="nc" id="L111">      val westLine = new LineString(new CoordinateArraySequence(Array(p1, point2)), geoFac)</span>
<span class="nc" id="L112">      val eastLine = new LineString(new CoordinateArraySequence(Array(point1, p2)), geoFac)</span>
<span class="nc" id="L113">      new MultiLineString(Array[LineString](westLine,eastLine), geoFac)</span>
    } else {
<span class="nc" id="L115">      new LineString(new CoordinateArraySequence(Array(input1, input2)), geoFac)</span>
    }
  }

  def createTube(): Iterator[SimpleFeature]
}

/**
 * Build a tube with no gap filling - only buffering and binning
 */
<span class="nc" id="L125">class NoGapFill(tubeFeatures: SimpleFeatureCollection,</span>
                bufferDistance: Double,
<span class="nc" id="L127">                maxBins: Int) extends TubeBuilder(tubeFeatures, bufferDistance, maxBins) with LazyLogging {</span>

  // Bin ordered features into maxBins that retain order by date then union by geometry
  private def timeBinAndUnion(features: Iterable[SimpleFeature], maxBins: Int): Iterator[SimpleFeature] = {
<span class="nc" id="L131">    val numFeatures = features.size</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">    if (numFeatures == 0) { Iterator.empty } else {</span>
      //If 0 is passed in then don't bin the features, if 1 then make one bin, otherwise calculate number
      //of bins based on numFeatures and maxBins
<span class="nc bnc" id="L136" title="All 3 branches missed.">      val binSize = maxBins match {</span>
<span class="nc" id="L137">        case 0 =&gt; 1</span>
<span class="nc" id="L138">        case 1 =&gt; numFeatures</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        case _ =&gt; numFeatures / maxBins + (if (numFeatures % maxBins == 0 ) 0 else 1)</span>
      }
<span class="nc bnc" id="L141" title="All 2 branches missed.">      features.grouped(binSize).zipWithIndex.map { case(bin, idx) =&gt; unionFeatures(bin.toSeq, idx.toString) }</span>
    }
  }

  // Union features to create a single geometry and single combined time range
  private def unionFeatures(orderedFeatures: Seq[SimpleFeature], id: String): SimpleFeature = {
    import scala.collection.JavaConverters._
<span class="nc" id="L148">    val geoms = orderedFeatures.map { sf =&gt; getGeom(sf) }</span>
<span class="nc" id="L149">    val unionGeom = geoFac.buildGeometry(geoms.asJava).union</span>
<span class="nc" id="L150">    val min = getStartTime(orderedFeatures.head)</span>
<span class="nc" id="L151">    val max = getStartTime(orderedFeatures.last)</span>

<span class="nc" id="L153">    builder.reset()</span>
<span class="nc" id="L154">    builder.buildFeature(id, unionGeom, min, max)</span>
  }

  override def createTube(): Iterator[SimpleFeature] = {
<span class="nc bnc" id="L158" title="All 2 branches missed.">    logger.debug(&quot;Creating tube with no gap filling&quot;)</span>

<span class="nc" id="L160">    val transformed = transform(tubeFeatures, dtgField)</span>
<span class="nc" id="L161">    val buffered = transformed.map(buffer(_, bufferDistance))</span>
<span class="nc" id="L162">    val sortedTube = buffered.sortBy(sf =&gt; getStartTime(sf).getTime)</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">    logger.debug(s&quot;sorted tube size: ${sortedTube.size}&quot;)</span>
<span class="nc" id="L165">    timeBinAndUnion(sortedTube, maxBins)</span>
  }
}




/**
 * Build a tube with gap filling that draws a line between time-ordered features
 * from the given tubeFeatures
 */
<span class="nc" id="L176">class LineGapFill(tubeFeatures: SimpleFeatureCollection,</span>
                  bufferDistance: Double,
<span class="nc" id="L178">                  maxBins: Int) extends TubeBuilder(tubeFeatures, bufferDistance, maxBins) with LazyLogging {</span>

<span class="nc" id="L180">  private val id = new AtomicInteger(0)</span>

<span class="nc" id="L182">  private def nextId: String = id.getAndIncrement.toString</span>

  override def createTube(): Iterator[SimpleFeature] = {
    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry

<span class="nc bnc" id="L187" title="All 2 branches missed.">    logger.debug(&quot;Creating tube with line gap fill&quot;)</span>

<span class="nc" id="L189">    val transformed = transform(tubeFeatures, dtgField)</span>
<span class="nc" id="L190">    val sortedTube = transformed.sortBy(sf =&gt; getStartTime(sf).getTime)</span>
<span class="nc" id="L191">    val pointsAndTimes = sortedTube.map(sf =&gt; (getGeom(sf).safeCentroid(), getStartTime(sf)))</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    val lineFeatures = if (pointsAndTimes.lengthCompare(1) == 0) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">      val (p1, t1) = pointsAndTimes.head</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      logger.debug(&quot;Only a single result - can't create a line&quot;)</span>
<span class="nc" id="L195">      Iterator(builder.buildFeature(nextId, p1, t1, t1))</span>
    } else {
<span class="nc bnc" id="L197" title="All 10 branches missed.">      pointsAndTimes.sliding(2).map { case Seq((p1, t1), (p2, t2)) =&gt;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        val geo = if (p1.equals(p2)) p1 else makeIDLSafeLineString(p1.getCoordinate,p2.getCoordinate)</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        logger.debug(s&quot;Created Line-filled Geometry: ${WKTUtils.write(geo)} From ${WKTUtils.write(p1)} and ${WKTUtils.write(p2)}&quot;)</span>
<span class="nc" id="L200">        builder.buildFeature(nextId, geo, t1, t2)</span>
      }
    }
<span class="nc" id="L203">    lineFeatures.map(buffer(_, bufferDistance))</span>
  }
}

/**
  * Class to create an interpolated line-gap filled tube
  * @param tubeFeatures features
  * @param bufferDistance distance
  * @param maxBins max bins
  */
<span class="nc" id="L213">class InterpolatedGapFill(tubeFeatures: SimpleFeatureCollection,</span>
                          bufferDistance: Double,
<span class="nc" id="L215">                          maxBins: Int) extends TubeBuilder(tubeFeatures, bufferDistance, maxBins) with LazyLogging {</span>

<span class="nc" id="L217">  private val id = new AtomicInteger(0)</span>

<span class="nc" id="L219">  private def nextId: String = id.getAndIncrement.toString</span>

  override def createTube(): Iterator[SimpleFeature] = {
    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry

<span class="nc bnc" id="L224" title="All 2 branches missed.">    logger.debug(&quot;Creating tube with line interpolated line gap fill&quot;)</span>

<span class="nc" id="L226">    val transformed = transform(tubeFeatures, dtgField)</span>
<span class="nc" id="L227">    val sortedTube = transformed.sortBy(sf =&gt; getStartTime(sf).getTime)</span>
<span class="nc" id="L228">    val pointsAndTimes = sortedTube.map(sf =&gt; (getGeom(sf).safeCentroid(), getStartTime(sf)))</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">    val lineFeatures = if (pointsAndTimes.lengthCompare(1) == 0) {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">      val (p1, t1) = pointsAndTimes.head</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      logger.debug(&quot;Only a single result - can't create a line&quot;)</span>
<span class="nc" id="L232">      Iterator(builder.buildFeature(nextId, p1, t1, t1))</span>
    } else {
<span class="nc bnc" id="L234" title="All 10 branches missed.">      pointsAndTimes.sliding(2).flatMap { case Seq((p1, t1), (p2, t2)) =&gt;</span>
<span class="nc" id="L235">        calc.setStartingGeographicPoint(p1.getX, p1.getY)</span>
<span class="nc" id="L236">        calc.setDestinationGeographicPoint(p2.getX, p2.getY)</span>
<span class="nc" id="L237">        val dist = calc.getOrthodromicDistance</span>
        //If the distance between points is greater than the buffer distance, segment the line
        //So that no segment is larger than the buffer. This ensures that each segment has an
        //times and distance. Also ensure that features do not share a time value.
<span class="nc" id="L241">        val timeDiffMillis = t2.getTime - t1.getTime</span>
<span class="nc" id="L242">        val segCount = (dist / bufferDistance).toInt</span>
<span class="nc" id="L243">        val segDuration = timeDiffMillis / segCount</span>
<span class="nc" id="L244">        val timeSteps = NumericRange.inclusive(t1.getTime, t2.getTime, segDuration)</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">        if (dist &gt; bufferDistance &amp;&amp; timeSteps.lengthCompare(1) &gt; 0) {</span>
<span class="nc" id="L246">          val heading = calc.getAzimuth</span>
<span class="nc" id="L247">          var segStep = new Coordinate(p1.getX, p1.getY, 0)</span>
<span class="nc bnc" id="L248" title="All 6 branches missed.">          timeSteps.sliding(2).map { case Seq(time0, time1) =&gt;</span>
<span class="nc" id="L249">            val segP1 = segStep</span>
<span class="nc" id="L250">            calc.setStartingGeographicPoint(segP1.x, segP1.y)</span>
<span class="nc" id="L251">            calc.setDirection(heading, bufferDistance)</span>
<span class="nc" id="L252">            val destPoint = calc.getDestinationGeographicPoint</span>
<span class="nc" id="L253">            segStep = new Coordinate(destPoint.getX, destPoint.getY, 0)</span>
<span class="nc" id="L254">            val geo = makeIDLSafeLineString(segP1, segStep)</span>
<span class="nc" id="L255">            builder.buildFeature(nextId, geo, new Date(time0), new Date(time1))</span>
          }
        } else {
<span class="nc bnc" id="L258" title="All 2 branches missed.">          val geo = if (p1.equals(p2)) { p1 } else { makeIDLSafeLineString(p1.getCoordinate, p2.getCoordinate) }</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">          logger.debug(s&quot;Created line-filled geometry: ${WKTUtils.write(geo)} &quot; +</span>
<span class="nc" id="L260">              s&quot;from ${WKTUtils.write(p1)} and ${WKTUtils.write(p2)}&quot;)</span>
<span class="nc" id="L261">          Seq(builder.buildFeature(nextId, geo, t1, t2))</span>
        }
      }
    }
<span class="nc" id="L265">    lineFeatures.map(buffer(_, bufferDistance))</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>