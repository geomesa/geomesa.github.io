<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TubeSelectProcess.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Vector Processes</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.process.tube</a> &gt; <span class="el_source">TubeSelectProcess.scala</span></div><h1>TubeSelectProcess.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.process.tube

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.{Query, SimpleFeatureSource}
import org.geotools.api.feature.Feature
import org.geotools.api.filter.Filter
import org.geotools.data.collection.ListFeatureCollection
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.data.store.EmptyFeatureCollection
import org.geotools.feature.visitor._
import org.geotools.process.factory.{DescribeParameter, DescribeProcess, DescribeResult}
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureCollection
import org.locationtech.geomesa.index.process.GeoMesaProcessVisitor
import org.locationtech.geomesa.process.GeoMesaProcess
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.io.WithClose
import org.locationtech.geomesa.utils.iterators.DeduplicatingSimpleFeatureIterator
import org.locationtech.jts.geom._

import java.util.Date
import scala.collection.JavaConverters._

@DescribeProcess(
  title = &quot;Tube Select&quot;,
  description = &quot;Performs a tube select on a Geomesa feature collection based on another feature collection&quot;
)
<span class="nc bnc" id="L36" title="All 4 branches missed.">class TubeSelectProcess extends GeoMesaProcess with LazyLogging {</span>

  @DescribeResult(description = &quot;Output feature collection&quot;)
  def execute(
               @DescribeParameter(
                 name = &quot;tubeFeatures&quot;,
                 description = &quot;Input feature collection (must have geometry and datetime)&quot;)
               tubeFeatures: SimpleFeatureCollection,

               @DescribeParameter(
                 name = &quot;featureCollection&quot;,
                 description = &quot;The data set to query for matching features&quot;)
               featureCollection: SimpleFeatureCollection,

               @DescribeParameter(
                 name = &quot;filter&quot;,
                 min = 0,
                 description = &quot;The filter to apply to the featureCollection&quot;)
               filter: Filter,

               @DescribeParameter(
                 name = &quot;maxSpeed&quot;,
                 min = 0,
                 description = &quot;Max speed of the object in m/s for nofill &amp; line gapfill methods&quot;)
               maxSpeed: java.lang.Long,

               @DescribeParameter(
                 name = &quot;maxTime&quot;,
                 min = 0,
                 description = &quot;Time as seconds for nofill &amp; line gapfill methods&quot;)
               maxTime: java.lang.Long,

               @DescribeParameter(
                 name = &quot;bufferSize&quot;,
                 min = 0,
                 description = &quot;Buffer size in meters to use instead of maxSpeed/maxTime calculation&quot;)
               bufferSize: java.lang.Double,

               @DescribeParameter(
                 name = &quot;maxBins&quot;,
                 min = 0,
                 description = &quot;Number of bins to use for breaking up query into individual queries&quot;)
               maxBins: java.lang.Integer,

               @DescribeParameter(
                 name = &quot;gapFill&quot;,
                 min = 0,
                 description = &quot;Method of filling gap (nofill, line)&quot;)
               gapFill: String

               ): SimpleFeatureCollection = {

<span class="nc bnc" id="L88" title="All 2 branches missed.">    logger.debug(&quot;Tube selecting on collection type &quot;+featureCollection.getClass.getName)</span>

    // assume for now that firstFeatures is a singleton collection
<span class="nc" id="L91">    val tubeVisitor = new TubeVisitor(</span>
<span class="nc" id="L92">                                      tubeFeatures,</span>
<span class="nc" id="L93">                                      featureCollection,</span>
<span class="nc" id="L94">                                      Option(filter).getOrElse(Filter.INCLUDE),</span>
<span class="nc" id="L95">                                      Option(maxSpeed).getOrElse(0L).asInstanceOf[Long],</span>
<span class="nc" id="L96">                                      Option(maxTime).getOrElse(0L).asInstanceOf[Long],</span>
<span class="nc" id="L97">                                      Option(bufferSize).getOrElse(0.0).asInstanceOf[Double],</span>
<span class="nc" id="L98">                                      Option(maxBins).getOrElse(0).asInstanceOf[Int],</span>
<span class="nc" id="L99">                                      Option(gapFill).map(GapFill.withName).getOrElse(GapFill.NOFILL))</span>

<span class="nc" id="L101">    GeoMesaFeatureCollection.visit(featureCollection, tubeVisitor)</span>

<span class="nc" id="L103">    tubeVisitor.getResult.asInstanceOf[TubeResult].results</span>
  }
}

<span class="nc" id="L107">object GapFill extends Enumeration{</span>
  type GapFill = Value
<span class="nc" id="L109">  val NOFILL: Value       = Value(&quot;nofill&quot;)</span>
<span class="nc" id="L110">  val LINE: Value         = Value(&quot;line&quot;)</span>
<span class="nc" id="L111">  val INTERPOLATED: Value = Value(&quot;interpolated&quot;)</span>
}

<span class="nc bnc" id="L114" title="All 4 branches missed.">class TubeVisitor(val tubeFeatures: SimpleFeatureCollection,</span>
<span class="nc" id="L115">                  val featureCollection: SimpleFeatureCollection,</span>
<span class="nc" id="L116">                  val filter: Filter = Filter.INCLUDE,</span>
<span class="nc" id="L117">                  val maxSpeed: Long,</span>
<span class="nc" id="L118">                  val maxTime: Long,</span>
<span class="nc" id="L119">                  val bufferSize: Double,</span>
<span class="nc" id="L120">                  val maxBins: Int,</span>
<span class="nc" id="L121">                  val gapFill: GapFill.GapFill = GapFill.NOFILL)</span>
<span class="nc" id="L122">    extends GeoMesaProcessVisitor with LazyLogging {</span>

<span class="nc" id="L124">  var resultCalc: TubeResult = TubeResult(new EmptyFeatureCollection(featureCollection.getSchema))</span>

<span class="nc" id="L126">  def visit(feature: Feature): Unit = {}</span>

<span class="nc" id="L128">  override def getResult: CalcResult = resultCalc</span>

<span class="nc bnc" id="L130" title="All 2 branches missed.">  private val bufferDistance = if (bufferSize &gt; 0) { bufferSize } else { maxSpeed * maxTime }</span>

  override def execute(source: SimpleFeatureSource, query: Query): Unit = {

    import org.locationtech.geomesa.filter.ff

<span class="nc bnc" id="L136" title="All 2 branches missed.">    logger.debug(&quot;Visiting source type: &quot;+source.getClass.getName)</span>

<span class="nc" id="L138">    val geomProperty = ff.property(source.getSchema.getGeometryDescriptor.getName)</span>
<span class="nc" id="L139">    val dateProperty = ff.property(source.getSchema.getUserData.get(SimpleFeatureTypes.Configs.DefaultDtgField).asInstanceOf[String])</span>

<span class="nc bnc" id="L141" title="All 2 branches missed.">    logger.debug(&quot;Querying with date property: &quot;+dateProperty)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    logger.debug(&quot;Querying with geometry property: &quot;+geomProperty)</span>

    // Create a time binned set of tube features with no gap filling

<span class="nc" id="L146">    val tubeBuilder = gapFill match {</span>
<span class="nc bnc" id="L147" title="All 6 branches missed.">      case GapFill.LINE =&gt; new LineGapFill(tubeFeatures, bufferDistance, maxBins)</span>
<span class="nc bnc" id="L148" title="All 6 branches missed.">      case GapFill.INTERPOLATED =&gt; new InterpolatedGapFill(tubeFeatures, bufferDistance, maxBins)</span>
<span class="nc" id="L149">      case _ =&gt; new NoGapFill(tubeFeatures, bufferDistance, maxBins)</span>
    }

<span class="nc" id="L152">    val tube = tubeBuilder.createTube()</span>

<span class="nc" id="L154">    val queryResults = CloseableIterator(tube).flatMap { sf =&gt;</span>
<span class="nc" id="L155">      val sfMin = tubeBuilder.getStartTime(sf).getTime</span>
<span class="nc" id="L156">      val minDate = new Date(sfMin - maxTime*1000)</span>

<span class="nc" id="L158">      val sfMax = tubeBuilder.getEndTime(sf).getTime</span>
<span class="nc" id="L159">      val maxDate = new Date(sfMax + maxTime*1000)</span>

<span class="nc" id="L161">      val dtg1 = ff.greater(dateProperty, ff.literal(minDate))</span>
<span class="nc" id="L162">      val dtg2 = ff.less(dateProperty, ff.literal(maxDate))</span>

<span class="nc" id="L164">      val geom = sf.getDefaultGeometry.asInstanceOf[Geometry]</span>

      // Eventually these can be combined into OR queries and the QueryPlanner can create multiple Accumulo Ranges
      // Buf for now we issue multiple queries
<span class="nc" id="L168">      val geoms = Iterator.tabulate(geom.getNumGeometries)(geom.getGeometryN)</span>
<span class="nc" id="L169">      CloseableIterator(geoms).flatMap { g =&gt;</span>
<span class="nc" id="L170">        val geomFilter = ff.intersects(geomProperty, ff.literal(g))</span>
<span class="nc" id="L171">        val combinedFilter = ff.and(List(query.getFilter, geomFilter, dtg1, dtg2, filter).asJava)</span>
<span class="nc" id="L172">        CloseableIterator(source.getFeatures(combinedFilter).features)</span>
      }
    }

    // Time slices may not be disjoint so we have to buffer results and dedupe for now
<span class="nc" id="L177">    val collection = new ListFeatureCollection(source.getSchema)</span>
<span class="nc" id="L178">    WithClose(new DeduplicatingSimpleFeatureIterator(queryResults))(_.foreach(collection.add))</span>

<span class="nc" id="L180">    resultCalc = TubeResult(collection)</span>
  }
}

<span class="nc bnc" id="L184" title="All 18 branches missed.">case class TubeResult(results: SimpleFeatureCollection) extends AbstractCalcResult</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>