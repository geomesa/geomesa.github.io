<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          org/locationtech/geomesa/utils/stats/Frequency.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier, monospace;'>1 <span style=''>/***********************************************************************
</span>2 <span style=''> * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
</span>3 <span style=''> * All rights reserved. This program and the accompanying materials
</span>4 <span style=''> * are made available under the terms of the Apache License, Version 2.0
</span>5 <span style=''> * which accompanies this distribution and is available at
</span>6 <span style=''> * https://www.apache.org/licenses/LICENSE-2.0
</span>7 <span style=''> ***********************************************************************/
</span>8 <span style=''>
</span>9 <span style=''>package org.locationtech.geomesa.utils.stats
</span>10 <span style=''>
</span>11 <span style=''>import com.clearspring.analytics.stream.frequency.IFrequency
</span>12 <span style=''>import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
</span>13 <span style=''>import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
</span>14 <span style=''>import org.locationtech.geomesa.curve.{BinnedTime, Z2SFC}
</span>15 <span style=''>import org.locationtech.geomesa.utils.clearspring.CountMinSketch
</span>16 <span style=''>import org.locationtech.geomesa.zorder.sfcurve.IndexRange
</span>17 <span style=''>import org.locationtech.jts.geom.Geometry
</span>18 <span style=''>
</span>19 <span style=''>import java.util.{Date, Locale}
</span>20 <span style=''>import scala.collection.immutable.ListMap
</span>21 <span style=''>import scala.reflect.ClassTag
</span>22 <span style=''>
</span>23 <span style=''>/**
</span>24 <span style=''>  *  Estimates frequency counts at scale
</span>25 <span style=''>  *
</span>26 <span style=''>  * @param sft simple feature type
</span>27 <span style=''>  * @param property attribute the sketch is being made for
</span>28 <span style=''>  * @param dtg primary date attribute of the sft, if there is one
</span>29 <span style=''>  * @param period time period to use for splitting by date
</span>30 <span style=''>  * @param eps (epsilon) with probability at least @see confidence, estimates will be within eps * N
</span>31 <span style=''>  * @param confidence percent - with probability at least confidence, estimates will be within @see eps * N
</span>32 <span style=''>  * @param precision for geometry types, this is the number of bits of z-index to keep (max of 64)
</span>33 <span style=''>  *                  (note: first 2 bits do not hold any info)
</span>34 <span style=''>  *                  for date types, this is the number of milliseconds to group for binning
</span>35 <span style=''>  *                  for number types, this is the number of digits that will be grouped together
</span>36 <span style=''>  *                  for floating point types, this is the number of decimal places that will be considered
</span>37 <span style=''>  *                  for string types, this is the number of characters that will be considered
</span>38 <span style=''>  * @param ct class tag
</span>39 <span style=''>  * @tparam T type parameter, should match the type binding of the attribute
</span>40 <span style=''>  */
</span>41 <span style=''>class Frequency[T](
</span>42 <span style=''>    val sft: SimpleFeatureType,
</span>43 <span style=''>    val property: String,
</span>44 <span style=''>    val dtg: Option[String],
</span>45 <span style=''>    val period: TimePeriod,
</span>46 <span style=''>    val precision: Int,
</span>47 <span style=''>    val eps: Double = 0.005,
</span>48 <span style=''>    val confidence: Double = 0.95
</span>49 <span style=''>  )(
</span>50 <span style=''>    implicit val ct: ClassTag[T]
</span>51 <span style=''>  ) extends Stat {
</span>52 <span style=''>
</span>53 <span style=''>  override type S = Frequency[T]
</span>54 <span style=''>
</span>55 <span style=''>  private val i = </span><span style='background: #AEF1AE'>sft.indexOf(property)</span><span style=''>
</span>56 <span style=''>  private val d = </span><span style='background: #AEF1AE'>dtg.map(sft.indexOf).getOrElse(-1)</span><span style=''>
</span>57 <span style=''>
</span>58 <span style=''>  private [stats] val sketchMap = </span><span style='background: #AEF1AE'>scala.collection.mutable.Map.empty[Short, CountMinSketch]</span><span style=''>
</span>59 <span style=''>  private [stats] def newSketch = </span><span style='background: #AEF1AE'>CountMinSketch(eps, confidence, Frequency.Seed)</span><span style=''>
</span>60 <span style=''>  private val timeToBin = </span><span style='background: #AEF1AE'>BinnedTime.timeToBinnedTime(period)</span><span style=''>
</span>61 <span style=''>
</span>62 <span style=''>  private val addAttribute = </span><span style='background: #AEF1AE'>Frequency.add[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span><span style=''>
</span>63 <span style=''>  private val getCount = </span><span style='background: #AEF1AE'>Frequency.count[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span><span style=''>
</span>64 <span style=''>
</span>65 <span style=''>  /**
</span>66 <span style=''>    * Gets the time bins covered by this frequency
</span>67 <span style=''>    *
</span>68 <span style=''>    * @return
</span>69 <span style=''>    */
</span>70 <span style=''>  def timeBins: Seq[Short] = </span><span style='background: #F0ADAD'>sketchMap.keys.toSeq.sorted</span><span style=''>
</span>71 <span style=''>
</span>72 <span style=''>  /**
</span>73 <span style=''>    * Gets the count for a given value, across all time bins
</span>74 <span style=''>    *
</span>75 <span style=''>    * @param value value to consider
</span>76 <span style=''>    * @return count of the value
</span>77 <span style=''>    */
</span>78 <span style=''>  def count(value: T): Long = if (</span><span style='background: #AEF1AE'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #AEF1AE'>sketchMap.values.map(getCount(_, value)).sum</span><span style=''> }
</span>79 <span style=''>
</span>80 <span style=''>  /**
</span>81 <span style=''>    * Gets the count for a given value in a particular time bin
</span>82 <span style=''>    *
</span>83 <span style=''>    * @param timeBin period since the epoch
</span>84 <span style=''>    * @param value value to consider
</span>85 <span style=''>    * @return count of the value
</span>86 <span style=''>    */
</span>87 <span style=''>  def count(timeBin: Short, value: T): Long = </span><span style='background: #AEF1AE'>sketchMap.get(timeBin).map(getCount(_, value)).getOrElse(0L)</span><span style=''>
</span>88 <span style=''>
</span>89 <span style=''>  /**
</span>90 <span style=''>    * Gets the count for a given value, which has already been converted into a string, across all time bins.
</span>91 <span style=''>    * Useful if you know the string key space ahead of time.
</span>92 <span style=''>    *
</span>93 <span style=''>    * @param value value to consider, converted into an appropriate string key
</span>94 <span style=''>    * @return count of the value
</span>95 <span style=''>    */
</span>96 <span style=''>  def countDirect(value: String): Long =
</span>97 <span style=''>    if (</span><span style='background: #F0ADAD'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #F0ADAD'>sketchMap.values.map(_.estimateCount(value)).sum</span><span style=''> }
</span>98 <span style=''>
</span>99 <span style=''>  /**
</span>100 <span style=''>    * Gets the count for a given value, which has already been converted into a string. Useful
</span>101 <span style=''>    * if you know the string key space ahead of time.
</span>102 <span style=''>    *
</span>103 <span style=''>    * @param timeBin period since the epoch
</span>104 <span style=''>    * @param value value to consider, converted into an appropriate string key
</span>105 <span style=''>    * @return count of the value
</span>106 <span style=''>    */
</span>107 <span style=''>  def countDirect(timeBin: Short, value: String): Long =
</span>108 <span style=''>    </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span><span style=''>
</span>109 <span style=''>
</span>110 <span style=''>  /**
</span>111 <span style=''>    * Gets the count for a given value, which has already been converted into a long, across all time bins.
</span>112 <span style=''>    * Useful if you know the long key space ahead of time (e.g. with z-values).
</span>113 <span style=''>    *
</span>114 <span style=''>    * @param value value to consider, converted into an appropriate long key
</span>115 <span style=''>    * @return count of the value
</span>116 <span style=''>    */
</span>117 <span style=''>  def countDirect(value: Long): Long =
</span>118 <span style=''>    if (</span><span style='background: #F0ADAD'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #F0ADAD'>sketchMap.values.map(_.estimateCount(value)).sum</span><span style=''> }
</span>119 <span style=''>
</span>120 <span style=''>  /**
</span>121 <span style=''>    * Gets the count for a given value, which has already been converted into a long. Useful
</span>122 <span style=''>    * if you know the long key space ahead of time (e.g. with z-values).
</span>123 <span style=''>    *
</span>124 <span style=''>    * @param timeBin period since the epoch
</span>125 <span style=''>    * @param value value to consider, converted into an appropriate long key
</span>126 <span style=''>    * @return count of the value
</span>127 <span style=''>    */
</span>128 <span style=''>  def countDirect(timeBin: Short, value: Long): Long =
</span>129 <span style=''>    </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span><span style=''>
</span>130 <span style=''>
</span>131 <span style=''>  /**
</span>132 <span style=''>    * Number of observations in the frequency map
</span>133 <span style=''>    *
</span>134 <span style=''>    * @return number of observations
</span>135 <span style=''>    */
</span>136 <span style=''>  def size: Long = if (</span><span style='background: #AEF1AE'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #AEF1AE'>0L</span><span style=''> } else { </span><span style='background: #AEF1AE'>sketchMap.values.map(_.size).sum</span><span style=''> }
</span>137 <span style=''>
</span>138 <span style=''>  /**
</span>139 <span style=''>    * Number of observations in the frequency map
</span>140 <span style=''>    *
</span>141 <span style=''>    * @return number of observations
</span>142 <span style=''>    */
</span>143 <span style=''>  def size(timeBin: Short): Long = </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.size).getOrElse(0L)</span><span style=''>
</span>144 <span style=''>
</span>145 <span style=''>  /**
</span>146 <span style=''>    * Split the stat into a separate stat per time bin of z data. Allows for separate handling of the reduced
</span>147 <span style=''>    * data set.
</span>148 <span style=''>    *
</span>149 <span style=''>    * @return
</span>150 <span style=''>    */
</span>151 <span style=''>  def splitByTime: Seq[(Short, Frequency[T])] = {
</span>152 <span style=''>    </span><span style='background: #AEF1AE'>sketchMap.toSeq.map { case (w, sketch) =&gt;
</span>153 <span style=''></span><span style='background: #AEF1AE'>      val freq = new Frequency[T](sft, property, dtg, period, precision, eps, confidence)
</span>154 <span style=''></span><span style='background: #AEF1AE'>      freq.sketchMap.put(w, sketch)
</span>155 <span style=''></span><span style='background: #AEF1AE'>      (w, freq)
</span>156 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>157 <span style=''>  }
</span>158 <span style=''>
</span>159 <span style=''>  override def observe(sf: SimpleFeature): Unit = {
</span>160 <span style=''>    val value = </span><span style='background: #AEF1AE'>sf.getAttribute(i).asInstanceOf[T]</span><span style=''>
</span>161 <span style=''>    if (</span><span style='background: #AEF1AE'>value != null</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>162 <span style=''></span><span style='background: #AEF1AE'>      val timeBin: Short = if (d == -1) { Frequency.DefaultTimeBin } else {
</span>163 <span style=''></span><span style='background: #AEF1AE'>        val dtg = sf.getAttribute(d).asInstanceOf[Date]
</span>164 <span style=''></span><span style='background: #AEF1AE'>        if (dtg == null) { </span><span style='background: #F0ADAD'>Frequency.DefaultTimeBin</span><span style='background: #AEF1AE'> } else { timeToBin(dtg.getTime).bin }
</span>165 <span style=''></span><span style='background: #AEF1AE'>      }
</span>166 <span style=''></span><span style='background: #AEF1AE'>      addAttribute(sketchMap.getOrElseUpdate(timeBin, newSketch), value)
</span>167 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>168 <span style=''>  }
</span>169 <span style=''>
</span>170 <span style=''>  // no-op
</span>171 <span style=''>  override def unobserve(sf: SimpleFeature): Unit = </span><span style='background: #AEF1AE'>{}</span><span style=''>
</span>172 <span style=''>
</span>173 <span style=''>  override def +(other: Frequency[T]): Frequency[T] = {
</span>174 <span style=''>    val plus = </span><span style='background: #AEF1AE'>new Frequency[T](sft, property, dtg, period, precision, eps, confidence)</span><span style=''>
</span>175 <span style=''>    </span><span style='background: #AEF1AE'>plus += this</span><span style=''>
</span>176 <span style=''>    </span><span style='background: #AEF1AE'>plus += other</span><span style=''>
</span>177 <span style=''>    plus
</span>178 <span style=''>  }
</span>179 <span style=''>
</span>180 <span style=''>  override def +=(other: Frequency[T]): Unit = {
</span>181 <span style=''>    </span><span style='background: #AEF1AE'>other.sketchMap.foreach { case (w, sketch) =&gt;
</span>182 <span style=''></span><span style='background: #AEF1AE'>      sketchMap.get(w) match {
</span>183 <span style=''></span><span style='background: #AEF1AE'>        case None =&gt; sketchMap.put(w, sketch) // note: sharing a reference now
</span>184 <span style=''></span><span style='background: #AEF1AE'>        case Some(s) =&gt; s += sketch
</span>185 <span style=''></span><span style='background: #AEF1AE'>      }
</span>186 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>187 <span style=''>  }
</span>188 <span style=''>
</span>189 <span style=''>  override def clear(): Unit = </span><span style='background: #AEF1AE'>sketchMap.values.foreach(_.clear())</span><span style=''>
</span>190 <span style=''>
</span>191 <span style=''>  override def isEmpty: Boolean = </span><span style='background: #AEF1AE'>sketchMap.isEmpty || sketchMap.values.forall(_.size == 0)</span><span style=''>
</span>192 <span style=''>
</span>193 <span style=''>  override def toJsonObject = </span><span style='background: #AEF1AE'>ListMap(&quot;epsilon&quot; -&gt; eps, &quot;confidence&quot; -&gt; confidence, &quot;size&quot; -&gt; size)</span><span style=''>
</span>194 <span style=''>
</span>195 <span style=''>  override def isEquivalent(other: Stat): Boolean = {
</span>196 <span style=''>    other match {
</span>197 <span style=''>      case s: Frequency[T] =&gt;
</span>198 <span style=''>        </span><span style='background: #AEF1AE'>property == s.property &amp;&amp; dtg == s.dtg &amp;&amp; period == s.period &amp;&amp; precision == s.precision &amp;&amp; {
</span>199 <span style=''></span><span style='background: #AEF1AE'>          val sketches = sketchMap.filter(_._2.size != 0)
</span>200 <span style=''></span><span style='background: #AEF1AE'>          val otherSketches = s.sketchMap.filter(_._2.size != 0)
</span>201 <span style=''></span><span style='background: #AEF1AE'>          sketches.keySet == otherSketches.keySet &amp;&amp; sketches.forall {
</span>202 <span style=''></span><span style='background: #AEF1AE'>            case (w, sketch) =&gt; sketch.isEquivalent(otherSketches(w))
</span>203 <span style=''></span><span style='background: #AEF1AE'>          }
</span>204 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>205 <span style=''>      case _ =&gt; </span><span style='background: #F0ADAD'>false</span><span style=''>
</span>206 <span style=''>    }
</span>207 <span style=''>  }
</span>208 <span style=''>}
</span>209 <span style=''>
</span>210 <span style=''>object Frequency {
</span>211 <span style=''>
</span>212 <span style=''>  // the seed for our frequencies - frequencies can only be combined if they have the same seed.
</span>213 <span style=''>  val Seed: Int = </span><span style='background: #AEF1AE'>-27</span><span style=''>
</span>214 <span style=''>
</span>215 <span style=''>  // default time bin we use for features without a date
</span>216 <span style=''>  val DefaultTimeBin: Short = </span><span style='background: #AEF1AE'>0</span><span style=''>
</span>217 <span style=''>
</span>218 <span style=''>  /**
</span>219 <span style=''>    * Enumerate all the values contained in a sequence of ranges, using the supplied precision.
</span>220 <span style=''>    * Because frequency can only do point lookups, this can be used to convert a range into a sequence
</span>221 <span style=''>    * of points.
</span>222 <span style=''>    *
</span>223 <span style=''>    * For example, [1, 4] would be converted into Seq(1, 2, 3, 4)
</span>224 <span style=''>    *
</span>225 <span style=''>    * @param ranges ranges to enumerate
</span>226 <span style=''>    * @param precision precision of the ranges, in bits [1, 64]
</span>227 <span style=''>    * @return the enumerated values
</span>228 <span style=''>    */
</span>229 <span style=''>  def enumerate(ranges: Seq[IndexRange], precision: Long): Iterator[Long] = {
</span>230 <span style=''>    val shift = </span><span style='background: #AEF1AE'>64 - precision</span><span style=''>
</span>231 <span style=''>    </span><span style='background: #AEF1AE'>ranges.toIterator.flatMap { r =&gt;
</span>232 <span style=''></span><span style='background: #AEF1AE'>      val c = (r.upper &gt;&gt; shift) - (r.lower &gt;&gt; shift)
</span>233 <span style=''></span><span style='background: #AEF1AE'>      new Iterator[Long] {
</span>234 <span style=''></span><span style='background: #AEF1AE'>        var i = 0L
</span>235 <span style=''></span><span style='background: #AEF1AE'>        override def hasNext: Boolean = i &lt;= c
</span>236 <span style=''></span><span style='background: #AEF1AE'>        override def next(): Long = try { r.lower + (i &lt;&lt; shift) } finally { i += 1 }
</span>237 <span style=''></span><span style='background: #AEF1AE'>      }
</span>238 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>239 <span style=''>  }
</span>240 <span style=''>
</span>241 <span style=''>  private def add[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Unit = {
</span>242 <span style=''>    if (</span><span style='background: #AEF1AE'>classOf[Geometry].isAssignableFrom(clas)</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>243 <span style=''></span><span style='background: #AEF1AE'>      val mask = getMask(precision)
</span>244 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(geomToKey(value.asInstanceOf[Geometry], mask), 1L)
</span>245 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else </span><span style='background: #AEF1AE'>if (classOf[Date].isAssignableFrom(clas)) {
</span>246 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(dateToKey(value.asInstanceOf[Date], precision), 1L)
</span>247 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[String]) {
</span>248 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(stringToKey(value.asInstanceOf[String], precision), 1L)
</span>249 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Long]) {
</span>250 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(longToKey(value.asInstanceOf[Long], precision), 1L)
</span>251 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[Integer]) {
</span>252 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(intToKey(value.asInstanceOf[Int], precision), 1L)
</span>253 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Float]) {
</span>254 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(floatToKey(value.asInstanceOf[Float], precision), 1L)
</span>255 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Double]) {
</span>256 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(doubleToKey(value.asInstanceOf[Double], precision), 1L)
</span>257 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>258 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span><span style='background: #AEF1AE'>
</span>259 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>260 <span style=''>  }
</span>261 <span style=''>
</span>262 <span style=''>  private def count[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Long = {
</span>263 <span style=''>    if (</span><span style='background: #AEF1AE'>classOf[Geometry].isAssignableFrom(clas)</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>264 <span style=''></span><span style='background: #AEF1AE'>      val mask = getMask(precision)
</span>265 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(geomToKey(value.asInstanceOf[Geometry], mask))
</span>266 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else </span><span style='background: #AEF1AE'>if (classOf[Date].isAssignableFrom(clas)) {
</span>267 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(dateToKey(value.asInstanceOf[Date], precision))
</span>268 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[String]) {
</span>269 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(stringToKey(value.asInstanceOf[String], precision))
</span>270 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Long]) {
</span>271 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(longToKey(value.asInstanceOf[Long], precision))
</span>272 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[Integer]) {
</span>273 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(intToKey(value.asInstanceOf[Int], precision))
</span>274 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Float]) {
</span>275 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(floatToKey(value.asInstanceOf[Float], precision))
</span>276 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Double]) {
</span>277 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(doubleToKey(value.asInstanceOf[Double], precision))
</span>278 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>279 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span><span style='background: #AEF1AE'>
</span>280 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>281 <span style=''>  }
</span>282 <span style=''>
</span>283 <span style=''>  // mask for right-zeroing bits
</span>284 <span style=''>  private [stats] def getMask(precision: Int): Long = {
</span>285 <span style=''>    </span><span style='background: #AEF1AE'>require(precision &gt;= 0 &amp;&amp; precision &lt;= 64, </span><span style='background: #F0ADAD'>&quot;Precision must be in the range [0, 64]&quot;</span><span style='background: #AEF1AE'>)</span><span style=''>
</span>286 <span style=''>    </span><span style='background: #AEF1AE'>Long.MaxValue &lt;&lt; (64 - precision)</span><span style=''>
</span>287 <span style=''>  }
</span>288 <span style=''>
</span>289 <span style=''>  private [stats] def geomToKey(value: Geometry, mask: Long): Long = {
</span>290 <span style=''>    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
</span>291 <span style=''>    val centroid = </span><span style='background: #AEF1AE'>value.safeCentroid()</span><span style=''>
</span>292 <span style=''>    </span><span style='background: #AEF1AE'>Z2SFC.index(centroid.getX, centroid.getY) &amp; mask</span><span style=''>
</span>293 <span style=''>  }
</span>294 <span style=''>
</span>295 <span style=''>  private [stats] def stringToKey(value: String, precision: Int): String = {
</span>296 <span style=''>    if (</span><span style='background: #AEF1AE'>value.length &gt; precision</span><span style=''>) {
</span>297 <span style=''>      </span><span style='background: #AEF1AE'>value.substring(0, precision).toLowerCase(Locale.US)</span><span style=''>
</span>298 <span style=''>    } else {
</span>299 <span style=''>      </span><span style='background: #AEF1AE'>value.toLowerCase(Locale.US)</span><span style=''>
</span>300 <span style=''>    }
</span>301 <span style=''>  }
</span>302 <span style=''>  private [stats] def dateToKey(value: Date, precision: Int): Long = </span><span style='background: #AEF1AE'>value.getTime / precision</span><span style=''>
</span>303 <span style=''>  private [stats] def longToKey(value: Long, precision: Int): Long = </span><span style='background: #AEF1AE'>value / precision</span><span style=''>
</span>304 <span style=''>  private [stats] def intToKey(value: Int, precision: Int): Long = </span><span style='background: #AEF1AE'>value / precision</span><span style=''>
</span>305 <span style=''>  private [stats] def floatToKey(value: Float, precision: Int): Long = </span><span style='background: #AEF1AE'>math.round(value * precision)</span><span style=''>
</span>306 <span style=''>  private [stats] def doubleToKey(value: Double, precision: Int): Long = </span><span style='background: #AEF1AE'>math.round(value * precision)</span><span style=''>
</span>307 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Tests</th>
        <th>Code</th>
      </tr><tr>
        <td>
          55
        </td>
        <td>
          13448
        </td>
        <td>
          2522
          -
          2530
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          55
        </td>
        <td>
          13449
        </td>
        <td>
          2510
          -
          2531
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.feature.simple.SimpleFeatureType.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft.indexOf(Frequency.this.property)
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          13450
        </td>
        <td>
          2550
          -
          2584
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg.map[Int]({
  ((x$1: String) =&gt; Frequency.this.sft.indexOf(x$1))
}).getOrElse[Int](-1)
        </td>
      </tr><tr>
        <td>
          58
        </td>
        <td>
          13451
        </td>
        <td>
          2620
          -
          2677
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Map.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.mutable.Map.empty[Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch]
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          13452
        </td>
        <td>
          2727
          -
          2730
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          13453
        </td>
        <td>
          2732
          -
          2742
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          13454
        </td>
        <td>
          2744
          -
          2758
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.Seed
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.Seed
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          13455
        </td>
        <td>
          2712
          -
          2759
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.apply(Frequency.this.eps, Frequency.this.confidence, Frequency.Seed)
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          13456
        </td>
        <td>
          2814
          -
          2820
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          13457
        </td>
        <td>
          2786
          -
          2821
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.timeToBinnedTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.BinnedTime.timeToBinnedTime(Frequency.this.period)
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          13458
        </td>
        <td>
          2869
          -
          2907
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]]
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          13459
        </td>
        <td>
          2909
          -
          2918
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          13460
        </td>
        <td>
          2852
          -
          2919
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.add[T](Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]], Frequency.this.precision)
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          13461
        </td>
        <td>
          2964
          -
          3002
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]]
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          13462
        </td>
        <td>
          3004
          -
          3013
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          13463
        </td>
        <td>
          2945
          -
          3014
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.count[T](Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]], Frequency.this.precision)
        </td>
      </tr><tr>
        <td>
          70
        </td>
        <td>
          13464
        </td>
        <td>
          3150
          -
          3150
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Ordering.Short
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Ordering.Short
        </td>
      </tr><tr>
        <td>
          70
        </td>
        <td>
          13465
        </td>
        <td>
          3129
          -
          3156
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.sorted
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.keys.toSeq.sorted[Short](math.this.Ordering.Short)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13466
        </td>
        <td>
          3342
          -
          3359
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13467
        </td>
        <td>
          3363
          -
          3365
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13468
        </td>
        <td>
          3363
          -
          3365
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13469
        </td>
        <td>
          3396
          -
          3414
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getCount.apply(x$1, value)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13470
        </td>
        <td>
          3395
          -
          3395
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13471
        </td>
        <td>
          3416
          -
          3416
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13472
        </td>
        <td>
          3375
          -
          3419
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$1: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$1, value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          13473
        </td>
        <td>
          3375
          -
          3419
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$1: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$1, value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          87
        </td>
        <td>
          13474
        </td>
        <td>
          3666
          -
          3726
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$2: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$2, value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13475
        </td>
        <td>
          4079
          -
          4096
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13476
        </td>
        <td>
          4100
          -
          4102
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13477
        </td>
        <td>
          4100
          -
          4102
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13478
        </td>
        <td>
          4133
          -
          4155
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          x$3.estimateCount(value)
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13479
        </td>
        <td>
          4132
          -
          4132
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13480
        </td>
        <td>
          4157
          -
          4157
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13481
        </td>
        <td>
          4112
          -
          4160
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$3: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$3.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          13482
        </td>
        <td>
          4112
          -
          4160
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$3: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$3.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          13483
        </td>
        <td>
          4549
          -
          4613
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$4: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$4.estimateCount(value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13484
        </td>
        <td>
          4979
          -
          4996
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13485
        </td>
        <td>
          5000
          -
          5002
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13486
        </td>
        <td>
          5000
          -
          5002
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13487
        </td>
        <td>
          5033
          -
          5055
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          x$5.estimateCount(value)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13488
        </td>
        <td>
          5032
          -
          5032
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13489
        </td>
        <td>
          5057
          -
          5057
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13490
        </td>
        <td>
          5012
          -
          5060
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$5: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$5.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          13491
        </td>
        <td>
          5012
          -
          5060
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$5: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$5.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          129
        </td>
        <td>
          13492
        </td>
        <td>
          5462
          -
          5526
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$6: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$6.estimateCount(value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13493
        </td>
        <td>
          5657
          -
          5674
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13494
        </td>
        <td>
          5678
          -
          5680
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13495
        </td>
        <td>
          5678
          -
          5680
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13496
        </td>
        <td>
          5711
          -
          5717
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7.size()
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13497
        </td>
        <td>
          5710
          -
          5710
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13498
        </td>
        <td>
          5719
          -
          5719
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13499
        </td>
        <td>
          5690
          -
          5722
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$7: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$7.size()))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          13500
        </td>
        <td>
          5690
          -
          5722
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$7: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$7.size()))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          143
        </td>
        <td>
          13501
        </td>
        <td>
          5867
          -
          5915
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$8: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$8.size())).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          13513
        </td>
        <td>
          6169
          -
          6313
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val freq: org.locationtech.geomesa.utils.stats.Frequency[T] = new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct);
  freq.sketchMap.put(w, sketch);
  scala.Tuple2.apply[Short, org.locationtech.geomesa.utils.stats.Frequency[T]](w, freq)
}
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          13514
        </td>
        <td>
          6150
          -
          6150
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Short, org.locationtech.geomesa.utils.stats.Frequency[T])]
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          13515
        </td>
        <td>
          6130
          -
          6319
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.toSeq.map[(Short, org.locationtech.geomesa.utils.stats.Frequency[T]), Seq[(Short, org.locationtech.geomesa.utils.stats.Frequency[T])]](((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; {
    val freq: org.locationtech.geomesa.utils.stats.Frequency[T] = new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct);
    freq.sketchMap.put(w, sketch);
    scala.Tuple2.apply[Short, org.locationtech.geomesa.utils.stats.Frequency[T]](w, freq)
  }
}))(collection.this.Seq.canBuildFrom[(Short, org.locationtech.geomesa.utils.stats.Frequency[T])])
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13502
        </td>
        <td>
          6206
          -
          6209
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.sft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13503
        </td>
        <td>
          6211
          -
          6219
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13504
        </td>
        <td>
          6221
          -
          6224
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13505
        </td>
        <td>
          6226
          -
          6232
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13506
        </td>
        <td>
          6234
          -
          6243
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13507
        </td>
        <td>
          6245
          -
          6248
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13508
        </td>
        <td>
          6250
          -
          6260
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13509
        </td>
        <td>
          6189
          -
          6189
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.ct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          13510
        </td>
        <td>
          6189
          -
          6261
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct)
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          13511
        </td>
        <td>
          6268
          -
          6297
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          155
        </td>
        <td>
          13512
        </td>
        <td>
          6304
          -
          6313
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Short, org.locationtech.geomesa.utils.stats.Frequency[T]](w, freq)
        </td>
      </tr><tr>
        <td>
          160
        </td>
        <td>
          13516
        </td>
        <td>
          6409
          -
          6410
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.i
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.i
        </td>
      </tr><tr>
        <td>
          160
        </td>
        <td>
          13517
        </td>
        <td>
          6393
          -
          6427
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sf.getAttribute(Frequency.this.i).asInstanceOf[T]
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          13518
        </td>
        <td>
          6436
          -
          6449
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.!=(null)
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          13534
        </td>
        <td>
          6451
          -
          6761
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val timeBin: Short = if (Frequency.this.d.==(-1))
    Frequency.DefaultTimeBin
  else
    {
      val dtg: java.util.Date = sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date];
      if (dtg.==(null))
        Frequency.DefaultTimeBin
      else
        Frequency.this.timeToBin.apply(dtg.getTime()).bin
    };
  Frequency.this.addAttribute.apply(Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch), value)
}
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          13535
        </td>
        <td>
          6432
          -
          6432
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          13536
        </td>
        <td>
          6432
          -
          6432
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          13519
        </td>
        <td>
          6484
          -
          6491
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.d.==(-1)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          13520
        </td>
        <td>
          6495
          -
          6519
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          13521
        </td>
        <td>
          6495
          -
          6519
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          13530
        </td>
        <td>
          6527
          -
          6682
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val dtg: java.util.Date = sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date];
  if (dtg.==(null))
    Frequency.DefaultTimeBin
  else
    Frequency.this.timeToBin.apply(dtg.getTime()).bin
}
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          13522
        </td>
        <td>
          6563
          -
          6564
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.d
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.d
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          13523
        </td>
        <td>
          6547
          -
          6584
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          13524
        </td>
        <td>
          6597
          -
          6608
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          dtg.==(null)
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          13525
        </td>
        <td>
          6612
          -
          6636
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          13526
        </td>
        <td>
          6612
          -
          6636
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          13527
        </td>
        <td>
          6656
          -
          6667
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          dtg.getTime()
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          13528
        </td>
        <td>
          6646
          -
          6672
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.bin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.timeToBin.apply(dtg.getTime()).bin
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          13529
        </td>
        <td>
          6646
          -
          6672
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.bin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.timeToBin.apply(dtg.getTime()).bin
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          13531
        </td>
        <td>
          6737
          -
          6746
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.newSketch
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.newSketch
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          13532
        </td>
        <td>
          6702
          -
          6747
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.getOrElseUpdate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch)
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          13533
        </td>
        <td>
          6689
          -
          6755
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.addAttribute.apply(Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch), value)
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          13537
        </td>
        <td>
          6830
          -
          6832
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13538
        </td>
        <td>
          6922
          -
          6925
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.sft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13539
        </td>
        <td>
          6927
          -
          6935
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13540
        </td>
        <td>
          6937
          -
          6940
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13541
        </td>
        <td>
          6942
          -
          6948
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13542
        </td>
        <td>
          6950
          -
          6959
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13543
        </td>
        <td>
          6961
          -
          6964
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13544
        </td>
        <td>
          6966
          -
          6976
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13545
        </td>
        <td>
          6905
          -
          6905
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.ct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          13546
        </td>
        <td>
          6905
          -
          6977
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct)
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          13547
        </td>
        <td>
          6982
          -
          6994
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          plus.+=(this)
        </td>
      </tr><tr>
        <td>
          176
        </td>
        <td>
          13548
        </td>
        <td>
          6999
          -
          7012
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          plus.+=(other)
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          13555
        </td>
        <td>
          7080
          -
          7285
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          other.sketchMap.foreach[Any](((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; Frequency.this.sketchMap.get(w) match {
    case scala.None =&gt; Frequency.this.sketchMap.put(w, sketch)
    case (value: org.locationtech.geomesa.utils.clearspring.CountMinSketch)Some[org.locationtech.geomesa.utils.clearspring.CountMinSketch]((s @ _)) =&gt; s.+=(sketch)
  }
}))
        </td>
      </tr><tr>
        <td>
          182
        </td>
        <td>
          13549
        </td>
        <td>
          7132
          -
          7148
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.get
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(w)
        </td>
      </tr><tr>
        <td>
          182
        </td>
        <td>
          13554
        </td>
        <td>
          7132
          -
          7279
        </td>
        <td>
          Match
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(w) match {
  case scala.None =&gt; Frequency.this.sketchMap.put(w, sketch)
  case (value: org.locationtech.geomesa.utils.clearspring.CountMinSketch)Some[org.locationtech.geomesa.utils.clearspring.CountMinSketch]((s @ _)) =&gt; s.+=(sketch)
}
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          13550
        </td>
        <td>
          7178
          -
          7202
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          13551
        </td>
        <td>
          7178
          -
          7202
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          13552
        </td>
        <td>
          7260
          -
          7271
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.+=(sketch)
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          13553
        </td>
        <td>
          7260
          -
          7271
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.+=(sketch)
        </td>
      </tr><tr>
        <td>
          189
        </td>
        <td>
          13556
        </td>
        <td>
          7347
          -
          7356
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.clear
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9.clear()
        </td>
      </tr><tr>
        <td>
          189
        </td>
        <td>
          13557
        </td>
        <td>
          7322
          -
          7357
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.foreach[Unit](((x$9: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$9.clear()))
        </td>
      </tr><tr>
        <td>
          191
        </td>
        <td>
          13558
        </td>
        <td>
          7438
          -
          7449
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10.size().==(0)
        </td>
      </tr><tr>
        <td>
          191
        </td>
        <td>
          13559
        </td>
        <td>
          7414
          -
          7450
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.forall(((x$10: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$10.size().==(0)))
        </td>
      </tr><tr>
        <td>
          191
        </td>
        <td>
          13560
        </td>
        <td>
          7393
          -
          7450
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty.||(Frequency.this.sketchMap.values.forall(((x$10: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$10.size().==(0))))
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13561
        </td>
        <td>
          7490
          -
          7499
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;epsilon&quot;
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13562
        </td>
        <td>
          7503
          -
          7506
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13563
        </td>
        <td>
          7490
          -
          7506
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;epsilon&quot;).-&gt;[Double](Frequency.this.eps)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13564
        </td>
        <td>
          7508
          -
          7520
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;confidence&quot;
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13565
        </td>
        <td>
          7524
          -
          7534
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13566
        </td>
        <td>
          7508
          -
          7534
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;confidence&quot;).-&gt;[Double](Frequency.this.confidence)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13567
        </td>
        <td>
          7536
          -
          7542
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;size&quot;
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13568
        </td>
        <td>
          7546
          -
          7550
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.size
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13569
        </td>
        <td>
          7536
          -
          7550
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;size&quot;).-&gt;[Long](Frequency.this.size)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          13570
        </td>
        <td>
          7482
          -
          7551
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenMapFactory.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.ListMap.apply[String, AnyVal](scala.Predef.ArrowAssoc[String](&quot;epsilon&quot;).-&gt;[Double](Frequency.this.eps), scala.Predef.ArrowAssoc[String](&quot;confidence&quot;).-&gt;[Double](Frequency.this.confidence), scala.Predef.ArrowAssoc[String](&quot;size&quot;).-&gt;[Long](Frequency.this.size))
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13571
        </td>
        <td>
          7675
          -
          7685
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.property
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13572
        </td>
        <td>
          7696
          -
          7701
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.dtg
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13573
        </td>
        <td>
          7689
          -
          7701
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg.==(s.dtg)
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13574
        </td>
        <td>
          7715
          -
          7723
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.period
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13575
        </td>
        <td>
          7705
          -
          7723
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period.==(s.period)
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13576
        </td>
        <td>
          7740
          -
          7751
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.precision
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13577
        </td>
        <td>
          7727
          -
          7751
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision.==(s.precision)
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13588
        </td>
        <td>
          7663
          -
          8042
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property.==(s.property).&amp;&amp;(Frequency.this.dtg.==(s.dtg)).&amp;&amp;(Frequency.this.period.==(s.period)).&amp;&amp;(Frequency.this.precision.==(s.precision)).&amp;&amp;({
  val sketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)));
  val otherSketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)));
  sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
    case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
  })))
})
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          13589
        </td>
        <td>
          7663
          -
          8042
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property.==(s.property).&amp;&amp;(Frequency.this.dtg.==(s.dtg)).&amp;&amp;(Frequency.this.period.==(s.period)).&amp;&amp;(Frequency.this.precision.==(s.precision)).&amp;&amp;({
  val sketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)));
  val otherSketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)));
  sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
    case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
  })))
})
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          13578
        </td>
        <td>
          7799
          -
          7813
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._2.size().!=(0)
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          13579
        </td>
        <td>
          7782
          -
          7814
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)))
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          13580
        </td>
        <td>
          7864
          -
          7878
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$12._2.size().!=(0)
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          13581
        </td>
        <td>
          7845
          -
          7879
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)))
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          13582
        </td>
        <td>
          7909
          -
          7929
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.keySet
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          otherSketches.keySet
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          13586
        </td>
        <td>
          7933
          -
          8032
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
}))
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          13587
        </td>
        <td>
          7890
          -
          8032
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
})))
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          13583
        </td>
        <td>
          8003
          -
          8019
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          otherSketches.apply(w)
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          13584
        </td>
        <td>
          7983
          -
          8020
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.isEquivalent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.isEquivalent(otherSketches.apply(w))
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          13585
        </td>
        <td>
          7983
          -
          8020
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.isEquivalent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.isEquivalent(otherSketches.apply(w))
        </td>
      </tr><tr>
        <td>
          205
        </td>
        <td>
          13590
        </td>
        <td>
          8059
          -
          8064
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          205
        </td>
        <td>
          13591
        </td>
        <td>
          8059
          -
          8064
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          213
        </td>
        <td>
          13592
        </td>
        <td>
          8213
          -
          8216
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          -27
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          13593
        </td>
        <td>
          8305
          -
          8306
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          230
        </td>
        <td>
          13594
        </td>
        <td>
          8849
          -
          8863
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          64.-(precision)
        </td>
      </tr><tr>
        <td>
          231
        </td>
        <td>
          13606
        </td>
        <td>
          8868
          -
          9147
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.Iterator.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ranges.toIterator.flatMap[Long](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
  val c: Long = r.upper.&gt;&gt;(shift).-(r.lower.&gt;&gt;(shift));
  {
    final class $anon extends AnyRef with Iterator[Long] {
      def &lt;init&gt;(): &lt;$anon: Iterator[Long]&gt; = {
        $anon.super.&lt;init&gt;();
        ()
      };
      private[this] var i: Long = 0L;
      &lt;accessor&gt; private def i: Long = $anon.this.i;
      &lt;accessor&gt; private def i_=(x$1: Long): Unit = $anon.this.i = x$1;
      override def hasNext: Boolean = $anon.this.i.&lt;=(c);
      override def next(): Long = try {
        r.lower.+($anon.this.i.&lt;&lt;(shift))
      } finally $anon.this.i_=($anon.this.i.+(1))
    };
    new $anon()
  }
}))
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          13595
        </td>
        <td>
          8937
          -
          8953
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.&gt;&gt;(shift)
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          13596
        </td>
        <td>
          8915
          -
          8954
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.upper.&gt;&gt;(shift).-(r.lower.&gt;&gt;(shift))
        </td>
      </tr><tr>
        <td>
          233
        </td>
        <td>
          13605
        </td>
        <td>
          8961
          -
          8964
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anon.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new $anon()
        </td>
      </tr><tr>
        <td>
          234
        </td>
        <td>
          13597
        </td>
        <td>
          8998
          -
          9000
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          235
        </td>
        <td>
          13598
        </td>
        <td>
          9041
          -
          9047
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.&lt;=(c)
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          13599
        </td>
        <td>
          9101
          -
          9111
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.&lt;&lt;(shift)
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          13600
        </td>
        <td>
          9090
          -
          9112
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.+($anon.this.i.&lt;&lt;(shift))
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          13601
        </td>
        <td>
          9090
          -
          9112
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.+($anon.this.i.&lt;&lt;(shift))
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          13602
        </td>
        <td>
          9125
          -
          9131
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.+(1)
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          13603
        </td>
        <td>
          9125
          -
          9131
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anon.i_=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i_=($anon.this.i.+(1))
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          13604
        </td>
        <td>
          9125
          -
          9131
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anon.i_=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i_=($anon.this.i.+(1))
        </td>
      </tr><tr>
        <td>
          242
        </td>
        <td>
          13607
        </td>
        <td>
          9243
          -
          9283
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[org.locationtech.jts.geom.Geometry].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          242
        </td>
        <td>
          13613
        </td>
        <td>
          9285
          -
          9415
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val mask: Long = Frequency.this.getMask(precision);
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask), 1L))
}
        </td>
      </tr><tr>
        <td>
          243
        </td>
        <td>
          13608
        </td>
        <td>
          9304
          -
          9322
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.getMask
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getMask(precision)
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          13609
        </td>
        <td>
          9369
          -
          9397
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          13610
        </td>
        <td>
          9359
          -
          9404
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.geomToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          13611
        </td>
        <td>
          9406
          -
          9408
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          13612
        </td>
        <td>
          9348
          -
          9409
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask), 1L)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          13614
        </td>
        <td>
          9425
          -
          9461
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[java.util.Date].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          13657
        </td>
        <td>
          9421
          -
          10369
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (classOf[java.util.Date].isAssignableFrom(clas))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L))
else
  if (clas.==(classOf[java.lang.String]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Long]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Integer]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
      else
        if (clas.==(classOf[java.lang.Float]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
        else
          if (clas.==(classOf[java.lang.Double]))
            ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
          else
            throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          13615
        </td>
        <td>
          9511
          -
          9535
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          13616
        </td>
        <td>
          9501
          -
          9547
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dateToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          13617
        </td>
        <td>
          9549
          -
          9551
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          13618
        </td>
        <td>
          9490
          -
          9552
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L)
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          13619
        </td>
        <td>
          9471
          -
          9552
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L))
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          13620
        </td>
        <td>
          9568
          -
          9591
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.String])
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          13656
        </td>
        <td>
          9564
          -
          10369
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.String]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
else
  if (clas.==(classOf[java.lang.Long]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Integer]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Float]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
      else
        if (clas.==(classOf[java.lang.Double]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
        else
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          13621
        </td>
        <td>
          9643
          -
          9669
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[String]
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          13622
        </td>
        <td>
          9631
          -
          9681
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.stringToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.stringToKey(value.asInstanceOf[String], precision)
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          13623
        </td>
        <td>
          9683
          -
          9685
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          13624
        </td>
        <td>
          9620
          -
          9686
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L)
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          13625
        </td>
        <td>
          9601
          -
          9686
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          13626
        </td>
        <td>
          9702
          -
          9733
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Long])
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          13655
        </td>
        <td>
          9698
          -
          10369
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Long]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
else
  if (clas.==(classOf[java.lang.Integer]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Float]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Double]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
      else
        throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          13627
        </td>
        <td>
          9783
          -
          9807
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Long]
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          13628
        </td>
        <td>
          9773
          -
          9819
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.longToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.longToKey(value.asInstanceOf[Long], precision)
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          13629
        </td>
        <td>
          9821
          -
          9823
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          13630
        </td>
        <td>
          9762
          -
          9824
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L)
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          13631
        </td>
        <td>
          9743
          -
          9824
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          13632
        </td>
        <td>
          9840
          -
          9864
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Integer])
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          13654
        </td>
        <td>
          9836
          -
          10369
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Integer]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
else
  if (clas.==(classOf[java.lang.Float]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Double]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
    else
      throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          13633
        </td>
        <td>
          9913
          -
          9936
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Int]
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          13634
        </td>
        <td>
          9904
          -
          9948
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.intToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.intToKey(value.asInstanceOf[Int], precision)
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          13635
        </td>
        <td>
          9950
          -
          9952
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          13636
        </td>
        <td>
          9893
          -
          9953
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L)
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          13637
        </td>
        <td>
          9874
          -
          9953
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          13638
        </td>
        <td>
          9969
          -
          10001
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Float])
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          13653
        </td>
        <td>
          9965
          -
          10369
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Float]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
else
  if (clas.==(classOf[java.lang.Double]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
  else
    throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          13639
        </td>
        <td>
          10052
          -
          10077
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Float]
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          13640
        </td>
        <td>
          10041
          -
          10089
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.floatToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.floatToKey(value.asInstanceOf[Float], precision)
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          13641
        </td>
        <td>
          10091
          -
          10093
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          13642
        </td>
        <td>
          10030
          -
          10094
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L)
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          13643
        </td>
        <td>
          10011
          -
          10094
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          13644
        </td>
        <td>
          10110
          -
          10143
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Double])
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          13652
        </td>
        <td>
          10106
          -
          10369
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Double]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
else
  throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          13645
        </td>
        <td>
          10195
          -
          10221
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Double]
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          13646
        </td>
        <td>
          10183
          -
          10233
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.doubleToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          13647
        </td>
        <td>
          10235
          -
          10237
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          13648
        </td>
        <td>
          10172
          -
          10238
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L)
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          13649
        </td>
        <td>
          10153
          -
          10238
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          13650
        </td>
        <td>
          10258
          -
          10363
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          13651
        </td>
        <td>
          10258
          -
          10363
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          263
        </td>
        <td>
          13658
        </td>
        <td>
          10467
          -
          10507
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[org.locationtech.jts.geom.Geometry].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          263
        </td>
        <td>
          13663
        </td>
        <td>
          10509
          -
          10645
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val mask: Long = Frequency.this.getMask(precision);
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)))
}
        </td>
      </tr><tr>
        <td>
          264
        </td>
        <td>
          13659
        </td>
        <td>
          10528
          -
          10546
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.getMask
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getMask(precision)
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          13660
        </td>
        <td>
          10603
          -
          10631
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          13661
        </td>
        <td>
          10593
          -
          10638
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.geomToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          13662
        </td>
        <td>
          10572
          -
          10639
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask))
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          13664
        </td>
        <td>
          10655
          -
          10691
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[java.util.Date].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          13701
        </td>
        <td>
          10651
          -
          11635
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (classOf[java.util.Date].isAssignableFrom(clas))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)))
else
  if (clas.==(classOf[java.lang.String]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
  else
    if (clas.==(classOf[java.lang.Long]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
    else
      if (clas.==(classOf[java.lang.Integer]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
      else
        if (clas.==(classOf[java.lang.Float]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
        else
          if (clas.==(classOf[java.lang.Double]))
            ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
          else
            throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          13665
        </td>
        <td>
          10751
          -
          10775
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          13666
        </td>
        <td>
          10741
          -
          10787
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dateToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          13667
        </td>
        <td>
          10720
          -
          10788
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision))
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          13668
        </td>
        <td>
          10701
          -
          10788
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          13669
        </td>
        <td>
          10804
          -
          10827
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.String])
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          13700
        </td>
        <td>
          10800
          -
          11635
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.String]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
else
  if (clas.==(classOf[java.lang.Long]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
  else
    if (clas.==(classOf[java.lang.Integer]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
    else
      if (clas.==(classOf[java.lang.Float]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
      else
        if (clas.==(classOf[java.lang.Double]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
        else
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          13670
        </td>
        <td>
          10889
          -
          10915
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[String]
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          13671
        </td>
        <td>
          10877
          -
          10927
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.stringToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.stringToKey(value.asInstanceOf[String], precision)
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          13672
        </td>
        <td>
          10856
          -
          10928
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision))
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          13673
        </td>
        <td>
          10837
          -
          10928
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          13674
        </td>
        <td>
          10944
          -
          10975
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Long])
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          13699
        </td>
        <td>
          10940
          -
          11635
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Long]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
else
  if (clas.==(classOf[java.lang.Integer]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
  else
    if (clas.==(classOf[java.lang.Float]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
    else
      if (clas.==(classOf[java.lang.Double]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
      else
        throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          13675
        </td>
        <td>
          11035
          -
          11059
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Long]
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          13676
        </td>
        <td>
          11025
          -
          11071
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.longToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.longToKey(value.asInstanceOf[Long], precision)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          13677
        </td>
        <td>
          11004
          -
          11072
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision))
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          13678
        </td>
        <td>
          10985
          -
          11072
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          13679
        </td>
        <td>
          11088
          -
          11112
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Integer])
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          13698
        </td>
        <td>
          11084
          -
          11635
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Integer]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
else
  if (clas.==(classOf[java.lang.Float]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
  else
    if (clas.==(classOf[java.lang.Double]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
    else
      throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          13680
        </td>
        <td>
          11171
          -
          11194
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Int]
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          13681
        </td>
        <td>
          11162
          -
          11206
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.intToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.intToKey(value.asInstanceOf[Int], precision)
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          13682
        </td>
        <td>
          11141
          -
          11207
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision))
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          13683
        </td>
        <td>
          11122
          -
          11207
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          13684
        </td>
        <td>
          11223
          -
          11255
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Float])
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          13697
        </td>
        <td>
          11219
          -
          11635
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Float]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
else
  if (clas.==(classOf[java.lang.Double]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
  else
    throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          13685
        </td>
        <td>
          11316
          -
          11341
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Float]
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          13686
        </td>
        <td>
          11305
          -
          11353
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.floatToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.floatToKey(value.asInstanceOf[Float], precision)
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          13687
        </td>
        <td>
          11284
          -
          11354
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision))
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          13688
        </td>
        <td>
          11265
          -
          11354
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          13689
        </td>
        <td>
          11370
          -
          11403
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Double])
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          13696
        </td>
        <td>
          11366
          -
          11635
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Double]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
else
  throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          13690
        </td>
        <td>
          11465
          -
          11491
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Double]
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          13691
        </td>
        <td>
          11453
          -
          11503
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.doubleToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          13692
        </td>
        <td>
          11432
          -
          11504
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision))
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          13693
        </td>
        <td>
          11413
          -
          11504
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
        </td>
      </tr><tr>
        <td>
          279
        </td>
        <td>
          13694
        </td>
        <td>
          11524
          -
          11629
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          279
        </td>
        <td>
          13695
        </td>
        <td>
          11524
          -
          11629
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          13702
        </td>
        <td>
          11755
          -
          11756
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          13703
        </td>
        <td>
          11760
          -
          11775
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          precision.&lt;=(64)
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          13704
        </td>
        <td>
          11742
          -
          11775
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          precision.&gt;=(0).&amp;&amp;(precision.&lt;=(64))
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          13705
        </td>
        <td>
          11777
          -
          11817
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Precision must be in the range [0, 64]&quot;
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          13706
        </td>
        <td>
          11734
          -
          11818
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.require
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.require(precision.&gt;=(0).&amp;&amp;(precision.&lt;=(64)), &quot;Precision must be in the range [0, 64]&quot;)
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          13707
        </td>
        <td>
          11823
          -
          11836
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          9223372036854775807L
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          13708
        </td>
        <td>
          11841
          -
          11855
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          64.-(precision)
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          13709
        </td>
        <td>
          11823
          -
          11856
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          9223372036854775807L.&lt;&lt;(64.-(precision))
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          13710
        </td>
        <td>
          12028
          -
          12048
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry.safeCentroid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(value).safeCentroid()
        </td>
      </tr><tr>
        <td>
          292
        </td>
        <td>
          13711
        </td>
        <td>
          12053
          -
          12101
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.Z2SFC.index(centroid.getX(), centroid.getY(), org.locationtech.geomesa.curve.Z2SFC.index$default$3).&amp;(mask)
        </td>
      </tr><tr>
        <td>
          296
        </td>
        <td>
          13712
        </td>
        <td>
          12192
          -
          12216
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.length().&gt;(precision)
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          13713
        </td>
        <td>
          12242
          -
          12243
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          13714
        </td>
        <td>
          12268
          -
          12277
        </td>
        <td>
          Select
        </td>
        <td>
          java.util.Locale.US
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Locale.US
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          13715
        </td>
        <td>
          12226
          -
          12278
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.substring(0, precision).toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          13716
        </td>
        <td>
          12226
          -
          12278
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.substring(0, precision).toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          13717
        </td>
        <td>
          12316
          -
          12325
        </td>
        <td>
          Select
        </td>
        <td>
          java.util.Locale.US
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Locale.US
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          13718
        </td>
        <td>
          12298
          -
          12326
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          13719
        </td>
        <td>
          12298
          -
          12326
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          302
        </td>
        <td>
          13720
        </td>
        <td>
          12406
          -
          12431
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.getTime()./(precision)
        </td>
      </tr><tr>
        <td>
          303
        </td>
        <td>
          13721
        </td>
        <td>
          12501
          -
          12518
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value./(precision)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          13722
        </td>
        <td>
          12586
          -
          12603
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value./(precision).toLong
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          13723
        </td>
        <td>
          12686
          -
          12703
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Float.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.*(precision)
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          13724
        </td>
        <td>
          12675
          -
          12704
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.round(value.*(precision)).toLong
        </td>
      </tr><tr>
        <td>
          306
        </td>
        <td>
          13725
        </td>
        <td>
          12789
          -
          12806
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.*(precision)
        </td>
      </tr><tr>
        <td>
          306
        </td>
        <td>
          13726
        </td>
        <td>
          12778
          -
          12807
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.round
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.round(value.*(precision))
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>