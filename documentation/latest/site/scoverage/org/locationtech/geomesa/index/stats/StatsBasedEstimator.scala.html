<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          org/locationtech/geomesa/index/stats/StatsBasedEstimator.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier, monospace;'>1 <span style=''>/***********************************************************************
</span>2 <span style=''> * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
</span>3 <span style=''> * All rights reserved. This program and the accompanying materials
</span>4 <span style=''> * are made available under the terms of the Apache License, Version 2.0
</span>5 <span style=''> * which accompanies this distribution and is available at
</span>6 <span style=''> * https://www.apache.org/licenses/LICENSE-2.0
</span>7 <span style=''> ***********************************************************************/
</span>8 <span style=''>
</span>9 <span style=''>package org.locationtech.geomesa.index.stats
</span>10 <span style=''>
</span>11 <span style=''>import org.geotools.api.feature.simple.SimpleFeatureType
</span>12 <span style=''>import org.geotools.api.filter._
</span>13 <span style=''>import org.geotools.api.filter.expression.PropertyName
</span>14 <span style=''>import org.locationtech.geomesa.curve.{BinnedTime, Z2SFC, Z3SFC}
</span>15 <span style=''>import org.locationtech.geomesa.filter.Bounds.Bound
</span>16 <span style=''>import org.locationtech.geomesa.filter._
</span>17 <span style=''>import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
</span>18 <span style=''>import org.locationtech.geomesa.utils.geotools._
</span>19 <span style=''>import org.locationtech.geomesa.zorder.sfcurve.IndexRange
</span>20 <span style=''>import org.locationtech.jts.geom.Geometry
</span>21 <span style=''>
</span>22 <span style=''>import java.time.ZonedDateTime
</span>23 <span style=''>import java.util.Date
</span>24 <span style=''>import scala.collection.JavaConverters._
</span>25 <span style=''>
</span>26 <span style=''>/**
</span>27 <span style=''>  * Estimate query counts based on cached stats.
</span>28 <span style=''>  *
</span>29 <span style=''>  * Although this trait only requires a generic GeoMesaStats implementation mixin, it has been written based
</span>30 <span style=''>  * on `MetadataBackedStats`. In particular, getCount(Filter.INCLUDE) is expected to look up the stat and
</span>31 <span style=''>  * not invoke any methods in this trait. Also, only Frequency and Z3Histograms are split out by time interval,
</span>32 <span style=''>  * so filters are only passed in when reading those two types.
</span>33 <span style=''>  */
</span>34 <span style=''>trait StatsBasedEstimator {
</span>35 <span style=''>
</span>36 <span style=''>  stats: GeoMesaStats =&gt;
</span>37 <span style=''>
</span>38 <span style=''>  import StatsBasedEstimator.{ErrorThresholds, ZHistogramPrecision}
</span>39 <span style=''>
</span>40 <span style=''>  /**
</span>41 <span style=''>    * Estimates the count for a given filter, based off the per-attribute metadata we have stored
</span>42 <span style=''>    *
</span>43 <span style=''>    * @param sft simple feature type
</span>44 <span style=''>    * @param filter filter to apply - should have been run through QueryPlanFilterVisitor so all props are right
</span>45 <span style=''>    * @return estimated count, if available
</span>46 <span style=''>    */
</span>47 <span style=''>  protected def estimateCount(sft: SimpleFeatureType, filter: Filter): Option[Long] = {
</span>48 <span style=''>    filter match {
</span>49 <span style=''>      case Filter.INCLUDE =&gt; </span><span style='background: #AEF1AE'>getCount(sft)</span><span style=''>
</span>50 <span style=''>      case Filter.EXCLUDE =&gt; </span><span style='background: #F0ADAD'>Some(0L)</span><span style=''>
</span>51 <span style=''>
</span>52 <span style=''>      case a: And =&gt; </span><span style='background: #AEF1AE'>estimateAndCount(sft, a)</span><span style=''>
</span>53 <span style=''>      case o: Or  =&gt; </span><span style='background: #AEF1AE'>estimateOrCount(sft, o)</span><span style=''>
</span>54 <span style=''>      case n: Not =&gt; </span><span style='background: #AEF1AE'>estimateNotCount(sft, n)</span><span style=''>
</span>55 <span style=''>
</span>56 <span style=''>      case i: Id =&gt; </span><span style='background: #AEF1AE'>Some(i.getIdentifiers.size)</span><span style=''>
</span>57 <span style=''>      case _ </span><span style='background: #AEF1AE'>=&gt;
</span>58 <span style=''></span><span style='background: #AEF1AE'>        // single filter - equals, between, less than, etc
</span>59 <span style=''></span><span style='background: #AEF1AE'>        val attribute = FilterHelper.propertyNames(filter, sft).headOption
</span>60 <span style=''></span><span style='background: #AEF1AE'>        attribute.flatMap(estimateAttributeCount(sft, filter, _))</span><span style=''>
</span>61 <span style=''>    }
</span>62 <span style=''>  }
</span>63 <span style=''>
</span>64 <span style=''>  /**
</span>65 <span style=''>    * Estimate counts for AND filters. Since it's an AND, we calculate the child counts and
</span>66 <span style=''>    * return the minimum.
</span>67 <span style=''>    *
</span>68 <span style=''>    * We check for spatio-temporal filters first, as those are the only ones that operate on 2+ properties.
</span>69 <span style=''>    *
</span>70 <span style=''>    * @param sft simple feature type
</span>71 <span style=''>    * @param filter AND filter
</span>72 <span style=''>    * @return estimated count, if available
</span>73 <span style=''>    */
</span>74 <span style=''>  private def estimateAndCount(sft: SimpleFeatureType, filter: And): Option[Long] = {
</span>75 <span style=''>    val stCount = </span><span style='background: #AEF1AE'>estimateSpatioTemporalCount(sft, filter)</span><span style=''>
</span>76 <span style=''>    // note: we might over count if we get bbox1 AND bbox2, as we don't intersect them
</span>77 <span style=''>    val individualCounts = </span><span style='background: #AEF1AE'>filter.getChildren.asScala.flatMap(estimateCount(sft, _))</span><span style=''>
</span>78 <span style=''>    val counts = (</span><span style='background: #AEF1AE'>stCount ++ individualCounts</span><span style=''>)
</span>79 <span style=''>    if (</span><span style='background: #AEF1AE'>counts.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>None</span><span style=''> } else { </span><span style='background: #AEF1AE'>Some(counts.min)</span><span style=''> }
</span>80 <span style=''>  }
</span>81 <span style=''>
</span>82 <span style=''>  /**
</span>83 <span style=''>    * Estimate counts for OR filters. Because this is an OR, we sum up the child counts
</span>84 <span style=''>    *
</span>85 <span style=''>    * @param sft simple feature type
</span>86 <span style=''>    * @param filter OR filter
</span>87 <span style=''>    * @return estimated count, if available
</span>88 <span style=''>    */
</span>89 <span style=''>  private def estimateOrCount(sft: SimpleFeatureType, filter: Or): Option[Long] = {
</span>90 <span style=''>    // estimate for each child separately and sum
</span>91 <span style=''>    // note that we might double count some values if the filter is complex
</span>92 <span style=''>    val counts = </span><span style='background: #AEF1AE'>filter.getChildren.asScala.flatMap(estimateCount(sft, _))</span><span style=''>
</span>93 <span style=''>    if (</span><span style='background: #AEF1AE'>counts.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>None</span><span style=''> } else { </span><span style='background: #AEF1AE'>Some(counts.sum)</span><span style=''> }
</span>94 <span style=''>  }
</span>95 <span style=''>
</span>96 <span style=''>  /**
</span>97 <span style=''>    * Estimates the count for NOT filters
</span>98 <span style=''>    *
</span>99 <span style=''>    * @param sft simple feature type
</span>100 <span style=''>    * @param filter filter
</span>101 <span style=''>    * @return count, if available
</span>102 <span style=''>    */
</span>103 <span style=''>  private def estimateNotCount(sft: SimpleFeatureType, filter: Not): Option[Long] = {
</span>104 <span style=''>    </span><span style='background: #AEF1AE'>filter.getFilter</span><span style=''> match {
</span>105 <span style=''>      case f: PropertyIsNull =&gt;
</span>106 <span style=''>        // special handling for 'is not null'
</span>107 <span style=''>        </span><span style='background: #AEF1AE'>f.getExpression match {
</span>108 <span style=''></span><span style='background: #AEF1AE'>          case p: PropertyName =&gt; estimateRangeCount(sft, p.getPropertyName, Seq((None, None)))
</span>109 <span style=''></span><span style='background: #AEF1AE'>          case _ =&gt; </span><span style='background: #F0ADAD'>estimateCount(sft, Filter.INCLUDE)</span><span style='background: #AEF1AE'> // not something we can handle...
</span>110 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>111 <span style=''>
</span>112 <span style=''>      case f =&gt;
</span>113 <span style=''>        </span><span style='background: #AEF1AE'>for {
</span>114 <span style=''></span><span style='background: #AEF1AE'>          all &lt;- estimateCount(sft, Filter.INCLUDE)
</span>115 <span style=''></span><span style='background: #AEF1AE'>          neg &lt;- estimateCount(sft, f)
</span>116 <span style=''></span><span style='background: #AEF1AE'>        } yield {
</span>117 <span style=''></span><span style='background: #AEF1AE'>          math.max(0, all - neg)</span><span style=''>
</span>118 <span style=''>        }
</span>119 <span style=''>    }
</span>120 <span style=''>  }
</span>121 <span style=''>
</span>122 <span style=''>  /**
</span>123 <span style=''>    * Estimate spatio-temporal counts for an AND filter.
</span>124 <span style=''>    *
</span>125 <span style=''>    * @param sft simple feature type
</span>126 <span style=''>    * @param filter complex filter
</span>127 <span style=''>    * @return count, if available
</span>128 <span style=''>    */
</span>129 <span style=''>  private def estimateSpatioTemporalCount(sft: SimpleFeatureType, filter: And): Option[Long] = {
</span>130 <span style=''>    // currently we don't consider if the spatial predicate is actually AND'd with the temporal predicate...
</span>131 <span style=''>    // TODO add filterhelper method that accurately pulls out the st values
</span>132 <span style=''>    </span><span style='background: #AEF1AE'>for {
</span>133 <span style=''></span><span style='background: #AEF1AE'>      geomField  &lt;- Option(sft.getGeomField)
</span>134 <span style=''></span><span style='background: #AEF1AE'>      dateField  &lt;- sft.getDtgField
</span>135 <span style=''></span><span style='background: #AEF1AE'>      geometries =  FilterHelper.extractGeometries(filter, geomField, sft.isPoints)
</span>136 <span style=''></span><span style='background: #AEF1AE'>      if geometries.nonEmpty
</span>137 <span style=''></span><span style='background: #AEF1AE'>      intervals  =  FilterHelper.extractIntervals(filter, dateField)
</span>138 <span style=''></span><span style='background: #AEF1AE'>      if intervals.nonEmpty
</span>139 <span style=''></span><span style='background: #AEF1AE'>      bounds     &lt;- stats.getMinMax[Date](sft, dateField)
</span>140 <span style=''></span><span style='background: #AEF1AE'>    } yield {
</span>141 <span style=''></span><span style='background: #AEF1AE'>      if (geometries.disjoint || intervals.disjoint) { </span><span style='background: #F0ADAD'>0L</span><span style='background: #AEF1AE'> } else {
</span>142 <span style=''></span><span style='background: #AEF1AE'>        val inRangeIntervals = {
</span>143 <span style=''></span><span style='background: #AEF1AE'>          val minTime = bounds.min.getTime
</span>144 <span style=''></span><span style='background: #AEF1AE'>          val maxTime = bounds.max.getTime
</span>145 <span style=''></span><span style='background: #AEF1AE'>          intervals.values.filter { i =&gt;
</span>146 <span style=''></span><span style='background: #AEF1AE'>            i.lower.value.forall(_.toInstant.toEpochMilli &lt;= maxTime) &amp;&amp;
</span>147 <span style=''></span><span style='background: #AEF1AE'>                i.upper.value.forall(_.toInstant.toEpochMilli &gt;= minTime)
</span>148 <span style=''></span><span style='background: #AEF1AE'>          }
</span>149 <span style=''></span><span style='background: #AEF1AE'>        }
</span>150 <span style=''></span><span style='background: #AEF1AE'>        val period = sft.getZ3Interval
</span>151 <span style=''></span><span style='background: #AEF1AE'>        stats.getZ3Histogram(sft, geomField, dateField, period, 0, filter) match {
</span>152 <span style=''></span><span style='background: #AEF1AE'>          case None =&gt; 0L
</span>153 <span style=''></span><span style='background: #AEF1AE'>          case Some(histogram) =&gt;
</span>154 <span style=''></span><span style='background: #AEF1AE'>            // time range for a chunk is 0 to 1 week (in seconds)
</span>155 <span style=''></span><span style='background: #AEF1AE'>            val sfc = Z3SFC(period)
</span>156 <span style=''></span><span style='background: #AEF1AE'>            val (tmin, tmax) = (sfc.time.min.toLong, sfc.time.max.toLong)
</span>157 <span style=''></span><span style='background: #AEF1AE'>            val xy = geometries.values.map(GeometryUtils.bounds)
</span>158 <span style=''></span><span style='background: #AEF1AE'>
</span>159 <span style=''></span><span style='background: #AEF1AE'>            def getIndices(t1: Long, t2: Long): Seq[Int] = {
</span>160 <span style=''></span><span style='background: #AEF1AE'>              val w = histogram.timeBins.head // z3 histogram bounds are fixed, so indices should be the same
</span>161 <span style=''></span><span style='background: #AEF1AE'>              val zs = sfc.ranges(xy, Seq((t1, t2)), ZHistogramPrecision)
</span>162 <span style=''></span><span style='background: #AEF1AE'>              zs.flatMap(r =&gt; histogram.directIndex(w, r.lower) to histogram.directIndex(w, r.upper))
</span>163 <span style=''></span><span style='background: #AEF1AE'>            }
</span>164 <span style=''></span><span style='background: #AEF1AE'>            lazy val middleIndices = getIndices(tmin, tmax)
</span>165 <span style=''></span><span style='background: #AEF1AE'>
</span>166 <span style=''></span><span style='background: #AEF1AE'>            // build up our indices by week so that we can deduplicate them afterwards
</span>167 <span style=''></span><span style='background: #AEF1AE'>            val timeBinsAndIndices = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(Seq.empty)
</span>168 <span style=''></span><span style='background: #AEF1AE'>
</span>169 <span style=''></span><span style='background: #AEF1AE'>            val dateToBins = BinnedTime.dateToBinnedTime(period)
</span>170 <span style=''></span><span style='background: #AEF1AE'>            val boundsToDates = BinnedTime.boundsToIndexableDates(period)
</span>171 <span style=''></span><span style='background: #AEF1AE'>            val binnedTimes = inRangeIntervals.map { interval =&gt;
</span>172 <span style=''></span><span style='background: #AEF1AE'>              val (lower, upper) = boundsToDates(interval.bounds)
</span>173 <span style=''></span><span style='background: #AEF1AE'>              val BinnedTime(lb, lt) = dateToBins(lower)
</span>174 <span style=''></span><span style='background: #AEF1AE'>              val BinnedTime(ub, ut) = dateToBins(upper)
</span>175 <span style=''></span><span style='background: #AEF1AE'>              (Range.inclusive(lb, ub).map(_.toShort), lt, ut)
</span>176 <span style=''></span><span style='background: #AEF1AE'>            }
</span>177 <span style=''></span><span style='background: #AEF1AE'>
</span>178 <span style=''></span><span style='background: #AEF1AE'>            // the z3 index breaks time into 1 week chunks, so create a range for each week in our range
</span>179 <span style=''></span><span style='background: #AEF1AE'>            binnedTimes.foreach { case (bins, lt, ut) =&gt;
</span>180 <span style=''></span><span style='background: #AEF1AE'>              if (bins.length == 1) {
</span>181 <span style=''></span><span style='background: #AEF1AE'>                timeBinsAndIndices(bins.head) ++= getIndices(lt, ut)
</span>182 <span style=''></span><span style='background: #AEF1AE'>              } else {
</span>183 <span style=''></span><span style='background: #AEF1AE'>                val head +: middle :+ last = bins.toList
</span>184 <span style=''></span><span style='background: #AEF1AE'>                timeBinsAndIndices(head) ++= getIndices(lt, tmax)
</span>185 <span style=''></span><span style='background: #AEF1AE'>                timeBinsAndIndices(last) ++= getIndices(tmin, ut)
</span>186 <span style=''></span><span style='background: #AEF1AE'>                middle.foreach(m =&gt; </span><span style='background: #F0ADAD'>timeBinsAndIndices(m) ++= middleIndices</span><span style='background: #AEF1AE'>)
</span>187 <span style=''></span><span style='background: #AEF1AE'>              }
</span>188 <span style=''></span><span style='background: #AEF1AE'>            }
</span>189 <span style=''></span><span style='background: #AEF1AE'>
</span>190 <span style=''></span><span style='background: #AEF1AE'>            timeBinsAndIndices.map { case (b, indices) =&gt; indices.distinct.map(histogram.count(b, _)).sum }.sum
</span>191 <span style=''></span><span style='background: #AEF1AE'>        }
</span>192 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>193 <span style=''>    }
</span>194 <span style=''>  }
</span>195 <span style=''>
</span>196 <span style=''>  /**
</span>197 <span style=''>    * Estimates the count for attribute filters (equals, less than, during, etc)
</span>198 <span style=''>    *
</span>199 <span style=''>    * @param sft simple feature type
</span>200 <span style=''>    * @param filter filter
</span>201 <span style=''>    * @param attribute attribute name to estimate
</span>202 <span style=''>    * @return count, if available
</span>203 <span style=''>    */
</span>204 <span style=''>  private def estimateAttributeCount(sft: SimpleFeatureType, filter: Filter, attribute: String): Option[Long] = {
</span>205 <span style=''>    import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor
</span>206 <span style=''>
</span>207 <span style=''>    if (</span><span style='background: #AEF1AE'>attribute == sft.getGeomField</span><span style=''>) {
</span>208 <span style=''>      </span><span style='background: #AEF1AE'>estimateSpatialCount(sft, filter)</span><span style=''>
</span>209 <span style=''>    } else </span><span style='background: #AEF1AE'>if (sft.getDtgField.contains(attribute)) {
</span>210 <span style=''></span><span style='background: #AEF1AE'>      estimateTemporalCount(sft, filter)
</span>211 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>212 <span style=''></span><span style='background: #AEF1AE'>      // we have an attribute filter
</span>213 <span style=''></span><span style='background: #AEF1AE'>      val extractedBounds = for {
</span>214 <span style=''></span><span style='background: #AEF1AE'>        descriptor &lt;- Option(sft.getDescriptor(attribute))
</span>215 <span style=''></span><span style='background: #AEF1AE'>        binding    =  if (descriptor.isList) { </span><span style='background: #F0ADAD'>descriptor.getListType()</span><span style='background: #AEF1AE'> } else { descriptor.getType.getBinding }
</span>216 <span style=''></span><span style='background: #AEF1AE'>      } yield {
</span>217 <span style=''></span><span style='background: #AEF1AE'>        FilterHelper.extractAttributeBounds(filter, attribute, binding.asInstanceOf[Class[Any]])
</span>218 <span style=''></span><span style='background: #AEF1AE'>      }
</span>219 <span style=''></span><span style='background: #AEF1AE'>      extractedBounds.flatMap { bounds =&gt;
</span>220 <span style=''></span><span style='background: #AEF1AE'>        if (bounds.disjoint) {
</span>221 <span style=''></span><span style='background: #AEF1AE'>          </span><span style='background: #F0ADAD'>Some(0L)</span><span style='background: #AEF1AE'> // disjoint range
</span>222 <span style=''></span><span style='background: #AEF1AE'>        } else if (!bounds.values.exists(_.isBounded)) {
</span>223 <span style=''></span><span style='background: #AEF1AE'>          </span><span style='background: #F0ADAD'>estimateCount(sft, Filter.INCLUDE)</span><span style='background: #AEF1AE'> // inclusive filter
</span>224 <span style=''></span><span style='background: #AEF1AE'>        } else {
</span>225 <span style=''></span><span style='background: #AEF1AE'>          val boundsValues = bounds.values.map(b =&gt; (b.lower.value, b.upper.value))
</span>226 <span style=''></span><span style='background: #AEF1AE'>          val (equalsBounds, rangeBounds) = boundsValues.partition { case (l, r) =&gt; l == r }
</span>227 <span style=''></span><span style='background: #AEF1AE'>          val equalsCount = if (equalsBounds.isEmpty) { Some(0L) } else {
</span>228 <span style=''></span><span style='background: #AEF1AE'>            // compare equals estimate with range estimate and take the smaller
</span>229 <span style=''></span><span style='background: #AEF1AE'>            val equals = estimateEqualsCount(sft, filter, attribute, equalsBounds.map(_._1.get))
</span>230 <span style=''></span><span style='background: #AEF1AE'>            val range  = estimateRangeCount(sft, attribute, equalsBounds)
</span>231 <span style=''></span><span style='background: #AEF1AE'>            (equals, range) match {
</span>232 <span style=''></span><span style='background: #AEF1AE'>              case (Some(e), Some(r)) =&gt; Some(math.min(e, r))
</span>233 <span style=''></span><span style='background: #AEF1AE'>              case (None, r) =&gt; r
</span>234 <span style=''></span><span style='background: #AEF1AE'>              case (e, None) =&gt; e
</span>235 <span style=''></span><span style='background: #AEF1AE'>            }
</span>236 <span style=''></span><span style='background: #AEF1AE'>          }
</span>237 <span style=''></span><span style='background: #AEF1AE'>          val rangeCount = if (rangeBounds.isEmpty) { Some(0L) } else {
</span>238 <span style=''></span><span style='background: #AEF1AE'>            estimateRangeCount(sft, attribute, rangeBounds)
</span>239 <span style=''></span><span style='background: #AEF1AE'>          }
</span>240 <span style=''></span><span style='background: #AEF1AE'>          for { e &lt;- equalsCount; r &lt;- rangeCount } yield { e + r }
</span>241 <span style=''></span><span style='background: #AEF1AE'>        }
</span>242 <span style=''></span><span style='background: #AEF1AE'>      }
</span>243 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>244 <span style=''>  }
</span>245 <span style=''>
</span>246 <span style=''>  /**
</span>247 <span style=''>    * Estimates counts from spatial predicates. Non-spatial predicates will be ignored.
</span>248 <span style=''>    *
</span>249 <span style=''>    * @param filter filter to evaluate
</span>250 <span style=''>    * @return estimated count, if available
</span>251 <span style=''>    */
</span>252 <span style=''>  private def estimateSpatialCount(sft: SimpleFeatureType, filter: Filter): Option[Long] = {
</span>253 <span style=''>    val geometries = </span><span style='background: #AEF1AE'>FilterHelper.extractGeometries(filter, sft.getGeomField, sft.isPoints)</span><span style=''>
</span>254 <span style=''>    if (</span><span style='background: #AEF1AE'>geometries.isEmpty</span><span style=''>) {
</span>255 <span style=''>      </span><span style='background: #F0ADAD'>None</span><span style=''>
</span>256 <span style=''>    } else </span><span style='background: #AEF1AE'>if (geometries.disjoint) {
</span>257 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>Some(0L)</span><span style='background: #AEF1AE'>
</span>258 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>259 <span style=''></span><span style='background: #AEF1AE'>      val zero = GeometryUtils.zeroPoint
</span>260 <span style=''></span><span style='background: #AEF1AE'>      stats.getHistogram[Geometry](sft, sft.getGeomField, 0, zero, zero).map { histogram =&gt;
</span>261 <span style=''></span><span style='background: #AEF1AE'>        val (zLo, zHi) = {
</span>262 <span style=''></span><span style='background: #AEF1AE'>          val (xmin, ymin, _, _) = GeometryUtils.bounds(histogram.min)
</span>263 <span style=''></span><span style='background: #AEF1AE'>          val (_, _, xmax, ymax) = GeometryUtils.bounds(histogram.max)
</span>264 <span style=''></span><span style='background: #AEF1AE'>          (Z2SFC.index(xmin, ymin), Z2SFC.index(xmax, ymax))
</span>265 <span style=''></span><span style='background: #AEF1AE'>        }
</span>266 <span style=''></span><span style='background: #AEF1AE'>        def inRange(r: IndexRange) = r.lower &lt; zHi &amp;&amp; r.upper &gt; zLo
</span>267 <span style=''></span><span style='background: #AEF1AE'>
</span>268 <span style=''></span><span style='background: #AEF1AE'>        val ranges = Z2SFC.ranges(geometries.values.map(GeometryUtils.bounds), ZHistogramPrecision)
</span>269 <span style=''></span><span style='background: #AEF1AE'>        val indices = ranges.filter(inRange).flatMap { range =&gt;
</span>270 <span style=''></span><span style='background: #AEF1AE'>          val loIndex = Some(histogram.directIndex(range.lower)).filter(_ != -1).getOrElse(0)
</span>271 <span style=''></span><span style='background: #AEF1AE'>          val hiIndex = Some(histogram.directIndex(range.upper)).filter(_ != -1).getOrElse(histogram.length - 1)
</span>272 <span style=''></span><span style='background: #AEF1AE'>          loIndex to hiIndex
</span>273 <span style=''></span><span style='background: #AEF1AE'>        }
</span>274 <span style=''></span><span style='background: #AEF1AE'>        if (indices.isEmpty) { 0L } else { indices.distinct.map(histogram.count).sum }
</span>275 <span style=''></span><span style='background: #AEF1AE'>      }
</span>276 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>277 <span style=''>  }
</span>278 <span style=''>
</span>279 <span style=''>  /**
</span>280 <span style=''>    * Estimates counts from temporal predicates. Non-temporal predicates will be ignored.
</span>281 <span style=''>    *
</span>282 <span style=''>    * @param sft simple feature type
</span>283 <span style=''>    * @param filter filter to evaluate
</span>284 <span style=''>    * @return estimated count, if available
</span>285 <span style=''>    */
</span>286 <span style=''>  private def estimateTemporalCount(sft: SimpleFeatureType, filter: Filter): Option[Long] = {
</span>287 <span style=''>    </span><span style='background: #AEF1AE'>for {
</span>288 <span style=''></span><span style='background: #AEF1AE'>      dateField &lt;- sft.getDtgField
</span>289 <span style=''></span><span style='background: #AEF1AE'>      intervals =  FilterHelper.extractIntervals(filter, dateField)
</span>290 <span style=''></span><span style='background: #AEF1AE'>      if intervals.nonEmpty
</span>291 <span style=''></span><span style='background: #AEF1AE'>      histogram &lt;- stats.getHistogram[Date](sft, dateField, 0, new Date(), new Date())
</span>292 <span style=''></span><span style='background: #AEF1AE'>    } yield {
</span>293 <span style=''></span><span style='background: #AEF1AE'>      def inRange(interval: Bounds[ZonedDateTime]) = {
</span>294 <span style=''></span><span style='background: #AEF1AE'>        interval.lower.value.forall(_.toInstant.toEpochMilli &lt;= histogram.max.getTime) &amp;&amp;
</span>295 <span style=''></span><span style='background: #AEF1AE'>            interval.upper.value.forall(_.toInstant.toEpochMilli &gt;= histogram.min.getTime)
</span>296 <span style=''></span><span style='background: #AEF1AE'>      }
</span>297 <span style=''></span><span style='background: #AEF1AE'>
</span>298 <span style=''></span><span style='background: #AEF1AE'>      if (intervals.disjoint) { </span><span style='background: #F0ADAD'>0L</span><span style='background: #AEF1AE'> } else {
</span>299 <span style=''></span><span style='background: #AEF1AE'>        val indices = intervals.values.filter(inRange).flatMap { interval =&gt;
</span>300 <span style=''></span><span style='background: #AEF1AE'>          val loIndex = interval.lower.value.map(i =&gt; histogram.indexOf(Date.from(i.toInstant))).filter(_ != -1).getOrElse(0)
</span>301 <span style=''></span><span style='background: #AEF1AE'>          val hiIndex = interval.upper.value.map(i =&gt; histogram.indexOf(Date.from(i.toInstant))).filter(_ != -1).getOrElse(</span><span style='background: #F0ADAD'>histogram.length - 1</span><span style='background: #AEF1AE'>)
</span>302 <span style=''></span><span style='background: #AEF1AE'>          loIndex to hiIndex
</span>303 <span style=''></span><span style='background: #AEF1AE'>        }
</span>304 <span style=''></span><span style='background: #AEF1AE'>        if (indices.isEmpty) { 0L } else { indices.distinct.map(histogram.count).sum }
</span>305 <span style=''></span><span style='background: #AEF1AE'>      }
</span>306 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>307 <span style=''>  }
</span>308 <span style=''>
</span>309 <span style=''>  /**
</span>310 <span style=''>    * Estimates an equals predicate. Uses frequency (count min sketch) for estimated value.
</span>311 <span style=''>    *
</span>312 <span style=''>    * @param sft simple feature type
</span>313 <span style=''>    * @param attribute attribute to evaluate
</span>314 <span style=''>    * @param values values to be estimated
</span>315 <span style=''>    * @return estimated count, if available.
</span>316 <span style=''>    */
</span>317 <span style=''>  private def estimateEqualsCount(
</span>318 <span style=''>      sft: SimpleFeatureType,
</span>319 <span style=''>      filter: Filter,
</span>320 <span style=''>      attribute: String,
</span>321 <span style=''>      values: Seq[Any]): Option[Long] = {
</span>322 <span style=''>    </span><span style='background: #AEF1AE'>stats.getFrequency[Any](sft, attribute, 0, filter).map { freq =&gt;
</span>323 <span style=''></span><span style='background: #AEF1AE'>      // frequency estimates will never return less than the actual number, but will often return more
</span>324 <span style=''></span><span style='background: #AEF1AE'>      // frequency has ~0.5% error rate based on the total number of features in the data set
</span>325 <span style=''></span><span style='background: #AEF1AE'>      // we adjust the raw estimate based on the absolute error rate
</span>326 <span style=''></span><span style='background: #AEF1AE'>
</span>327 <span style=''></span><span style='background: #AEF1AE'>      val absoluteError = math.floor(freq.size * freq.eps)
</span>328 <span style=''></span><span style='background: #AEF1AE'>      val counts = if (absoluteError &lt; 1.0) { values.map(freq.count) } else {
</span>329 <span style=''></span><span style='background: #AEF1AE'>        values.map { v =&gt;
</span>330 <span style=''></span><span style='background: #AEF1AE'>          val estimate = freq.count(v)
</span>331 <span style=''></span><span style='background: #AEF1AE'>          if (estimate == 0L) {
</span>332 <span style=''></span><span style='background: #AEF1AE'>            </span><span style='background: #F0ADAD'>0L</span><span style='background: #AEF1AE'>
</span>333 <span style=''></span><span style='background: #AEF1AE'>          } else if (estimate &gt; absoluteError) {
</span>334 <span style=''></span><span style='background: #AEF1AE'>            val relativeError = absoluteError / estimate
</span>335 <span style=''></span><span style='background: #AEF1AE'>            estimate - (ErrorThresholds.dropWhile(_ &lt;= relativeError).head * 0.5 * absoluteError).toLong
</span>336 <span style=''></span><span style='background: #AEF1AE'>          } else {
</span>337 <span style=''></span><span style='background: #AEF1AE'>            val relativeError = estimate / absoluteError
</span>338 <span style=''></span><span style='background: #AEF1AE'>            (ErrorThresholds.dropWhile(_ &lt; relativeError).head * 0.5 * estimate).toLong
</span>339 <span style=''></span><span style='background: #AEF1AE'>          }
</span>340 <span style=''></span><span style='background: #AEF1AE'>        }
</span>341 <span style=''></span><span style='background: #AEF1AE'>      }
</span>342 <span style=''></span><span style='background: #AEF1AE'>      counts.sum
</span>343 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>344 <span style=''>  }
</span>345 <span style=''>
</span>346 <span style=''>  /**
</span>347 <span style=''>    * Estimates a potentially unbounded range predicate. Uses a binned histogram for estimated value.
</span>348 <span style=''>    *
</span>349 <span style=''>    * @param sft simple feature type
</span>350 <span style=''>    * @param attribute attribute to evaluate
</span>351 <span style=''>    * @param ranges ranges of values - may be unbounded (indicated by a None)
</span>352 <span style=''>    * @return estimated count, if available
</span>353 <span style=''>    */
</span>354 <span style=''>  private def estimateRangeCount(
</span>355 <span style=''>      sft: SimpleFeatureType,
</span>356 <span style=''>      attribute: String,
</span>357 <span style=''>      ranges: Seq[(Option[Any], Option[Any])]): Option[Long] = {
</span>358 <span style=''>    </span><span style='background: #AEF1AE'>stats.getHistogram[Any](sft, attribute, 0, 0, 0).map { histogram =&gt;
</span>359 <span style=''></span><span style='background: #AEF1AE'>      val inRangeRanges = ranges.filter {
</span>360 <span style=''></span><span style='background: #AEF1AE'>        case (None, None)         =&gt; true // inclusive filter
</span>361 <span style=''></span><span style='background: #AEF1AE'>        case (Some(lo), None)     =&gt; histogram.defaults.min(lo, histogram.max) == lo
</span>362 <span style=''></span><span style='background: #AEF1AE'>        case (None, Some(up))     =&gt; histogram.defaults.max(up, histogram.min) == up
</span>363 <span style=''></span><span style='background: #AEF1AE'>        case (Some(lo), Some(up)) =&gt;
</span>364 <span style=''></span><span style='background: #AEF1AE'>          histogram.defaults.min(lo, histogram.max) == lo &amp;&amp; histogram.defaults.max(up, histogram.min) == up
</span>365 <span style=''></span><span style='background: #AEF1AE'>      }
</span>366 <span style=''></span><span style='background: #AEF1AE'>      val indices = inRangeRanges.flatMap { case (lower, upper) =&gt;
</span>367 <span style=''></span><span style='background: #AEF1AE'>        val lowerIndex = lower.map(histogram.indexOf).filter(_ != -1).getOrElse(0)
</span>368 <span style=''></span><span style='background: #AEF1AE'>        val upperIndex = upper.map(histogram.indexOf).filter(_ != -1).getOrElse(histogram.length - 1)
</span>369 <span style=''></span><span style='background: #AEF1AE'>        lowerIndex to upperIndex
</span>370 <span style=''></span><span style='background: #AEF1AE'>      }
</span>371 <span style=''></span><span style='background: #AEF1AE'>      if (indices.isEmpty) { 0L } else { indices.distinct.map(histogram.count).sum }
</span>372 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>373 <span style=''>  }
</span>374 <span style=''>}
</span>375 <span style=''>
</span>376 <span style=''>object StatsBasedEstimator {
</span>377 <span style=''>
</span>378 <span style=''>  // we only need enough precision to cover the number of bins (e.g. 2^n == bins), plus 2 for unused bits
</span>379 <span style=''>  val ZHistogramPrecision: Int = </span><span style='background: #AEF1AE'>math.ceil(math.log(GeoMesaStats.MaxHistogramSize) / math.log(2)).toInt + 2</span><span style=''>
</span>380 <span style=''>
</span>381 <span style=''>  val ErrorThresholds: Seq[Double] = </span><span style='background: #AEF1AE'>Seq(0.1, 0.3, 0.5, 0.7, 0.9, 1.0)</span><span style=''>
</span>382 <span style=''>
</span>383 <span style=''>  /**
</span>384 <span style=''>    * Extracts date bounds from a filter. None is used to indicate a disjoint date range, otherwise
</span>385 <span style=''>    * there will be a bounds object (which may be unbounded).
</span>386 <span style=''>    *
</span>387 <span style=''>    * @param sft simple feature type
</span>388 <span style=''>    * @param filter filter
</span>389 <span style=''>    * @return None, if disjoint filters, otherwise date bounds (which may be unbounded)
</span>390 <span style=''>    */
</span>391 <span style=''>  private [stats] def extractDates(sft: SimpleFeatureType, filter: Filter): Option[Bounds[Date]] = {
</span>392 <span style=''>    </span><span style='background: #F0ADAD'>sft.getDtgField</span><span style=''> match {
</span>393 <span style=''>      case None =&gt; </span><span style='background: #F0ADAD'>Some(Bounds.everything)</span><span style=''>
</span>394 <span style=''>      case Some(dtg) </span><span style='background: #F0ADAD'>=&gt;
</span>395 <span style=''></span><span style='background: #F0ADAD'>        val intervals = FilterHelper.extractIntervals(filter, dtg)
</span>396 <span style=''></span><span style='background: #F0ADAD'>        if (intervals.disjoint) { None } else {
</span>397 <span style=''></span><span style='background: #F0ADAD'>          // don't consider gaps, just get the endpoints of the intervals
</span>398 <span style=''></span><span style='background: #F0ADAD'>          val dateTimes = intervals.values.reduceOption[Bounds[ZonedDateTime]] { case (left, right) =&gt;
</span>399 <span style=''></span><span style='background: #F0ADAD'>            val lower = Bounds.smallerLowerBound(left.lower, right.lower)
</span>400 <span style=''></span><span style='background: #F0ADAD'>            val upper = Bounds.largerUpperBound(left.upper, right.upper)
</span>401 <span style=''></span><span style='background: #F0ADAD'>            Bounds(lower, upper)
</span>402 <span style=''></span><span style='background: #F0ADAD'>          }
</span>403 <span style=''></span><span style='background: #F0ADAD'>          val lower = dateTimes.map(d =&gt; Bound(d.lower.value.map(i =&gt; Date.from(i.toInstant)), d.lower.inclusive))
</span>404 <span style=''></span><span style='background: #F0ADAD'>          val upper = dateTimes.map(d =&gt; Bound(d.upper.value.map(i =&gt; Date.from(i.toInstant)), d.upper.inclusive))
</span>405 <span style=''></span><span style='background: #F0ADAD'>          Some(Bounds(lower.getOrElse(Bound.unbounded[Date]), upper.getOrElse(Bound.unbounded[Date])))
</span>406 <span style=''></span><span style='background: #F0ADAD'>        }</span><span style=''>
</span>407 <span style=''>    }
</span>408 <span style=''>  }
</span>409 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Tests</th>
        <th>Code</th>
      </tr><tr>
        <td>
          49
        </td>
        <td>
          43275
        </td>
        <td>
          2177
          -
          2190
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getCount(sft, StatsBasedEstimator.this.getCount$default$2, StatsBasedEstimator.this.getCount$default$3, StatsBasedEstimator.this.getCount$default$4)
        </td>
      </tr><tr>
        <td>
          49
        </td>
        <td>
          43276
        </td>
        <td>
          2177
          -
          2190
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getCount(sft, StatsBasedEstimator.this.getCount$default$2, StatsBasedEstimator.this.getCount$default$3, StatsBasedEstimator.this.getCount$default$4)
        </td>
      </tr><tr>
        <td>
          50
        </td>
        <td>
          43277
        </td>
        <td>
          2220
          -
          2228
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          50
        </td>
        <td>
          43278
        </td>
        <td>
          2220
          -
          2228
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          52
        </td>
        <td>
          43279
        </td>
        <td>
          2251
          -
          2275
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateAndCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateAndCount(sft, a)
        </td>
      </tr><tr>
        <td>
          52
        </td>
        <td>
          43280
        </td>
        <td>
          2251
          -
          2275
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateAndCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateAndCount(sft, a)
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          43281
        </td>
        <td>
          2297
          -
          2320
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateOrCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateOrCount(sft, o)
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          43282
        </td>
        <td>
          2297
          -
          2320
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateOrCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateOrCount(sft, o)
        </td>
      </tr><tr>
        <td>
          54
        </td>
        <td>
          43283
        </td>
        <td>
          2342
          -
          2366
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateNotCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateNotCount(sft, n)
        </td>
      </tr><tr>
        <td>
          54
        </td>
        <td>
          43284
        </td>
        <td>
          2342
          -
          2366
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateNotCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateNotCount(sft, n)
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          43285
        </td>
        <td>
          2393
          -
          2414
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.getIdentifiers().size().toLong
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          43286
        </td>
        <td>
          2388
          -
          2415
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](i.getIdentifiers().size().toLong)
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          43287
        </td>
        <td>
          2388
          -
          2415
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](i.getIdentifiers().size().toLong)
        </td>
      </tr><tr>
        <td>
          57
        </td>
        <td>
          43291
        </td>
        <td>
          2429
          -
          2631
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val attribute: Option[String] = org.locationtech.geomesa.filter.FilterHelper.propertyNames(filter, sft).headOption;
  attribute.flatMap[Long](((x$1: String) =&gt; StatsBasedEstimator.this.estimateAttributeCount(sft, filter, x$1)))
}
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          43288
        </td>
        <td>
          2515
          -
          2565
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableLike.headOption
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.propertyNames(filter, sft).headOption
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          43289
        </td>
        <td>
          2592
          -
          2630
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateAttributeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateAttributeCount(sft, filter, x$1)
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          43290
        </td>
        <td>
          2574
          -
          2631
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          attribute.flatMap[Long](((x$1: String) =&gt; StatsBasedEstimator.this.estimateAttributeCount(sft, filter, x$1)))
        </td>
      </tr><tr>
        <td>
          75
        </td>
        <td>
          43292
        </td>
        <td>
          3110
          -
          3150
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateSpatioTemporalCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateSpatioTemporalCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          43293
        </td>
        <td>
          3265
          -
          3283
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.BinaryLogicOperator.getChildren
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          filter.getChildren()
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          43294
        </td>
        <td>
          3300
          -
          3321
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, x$2)
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          43295
        </td>
        <td>
          3300
          -
          3321
        </td>
        <td>
          ApplyImplicitView
        </td>
        <td>
          scala.Option.option2Iterable
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$2))
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          43296
        </td>
        <td>
          3299
          -
          3299
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Buffer.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          mutable.this.Buffer.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          43297
        </td>
        <td>
          3265
          -
          3322
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.JavaConverters.asScalaBufferConverter[org.geotools.api.filter.Filter](filter.getChildren()).asScala.flatMap[Long, scala.collection.mutable.Buffer[Long]](((x$2: org.geotools.api.filter.Filter) =&gt; scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$2))))(mutable.this.Buffer.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          43298
        </td>
        <td>
          3349
          -
          3349
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          43299
        </td>
        <td>
          3341
          -
          3368
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Option.option2Iterable[Long](stCount).++[Long, Iterable[Long]](individualCounts)(collection.this.Iterable.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          43300
        </td>
        <td>
          3378
          -
          3392
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.IterableLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.isEmpty
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          43301
        </td>
        <td>
          3396
          -
          3400
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          43302
        </td>
        <td>
          3396
          -
          3400
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          43303
        </td>
        <td>
          3422
          -
          3422
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Ordering.Long
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Ordering.Long
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          43304
        </td>
        <td>
          3415
          -
          3425
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.min[Long](math.this.Ordering.Long)
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          43305
        </td>
        <td>
          3410
          -
          3426
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.min[Long](math.this.Ordering.Long))
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          43306
        </td>
        <td>
          3410
          -
          3426
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.min[Long](math.this.Ordering.Long))
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          43307
        </td>
        <td>
          3879
          -
          3897
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.BinaryLogicOperator.getChildren
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          filter.getChildren()
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          43308
        </td>
        <td>
          3914
          -
          3935
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, x$3)
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          43309
        </td>
        <td>
          3914
          -
          3935
        </td>
        <td>
          ApplyImplicitView
        </td>
        <td>
          scala.Option.option2Iterable
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$3))
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          43310
        </td>
        <td>
          3913
          -
          3913
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Buffer.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          mutable.this.Buffer.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          92
        </td>
        <td>
          43311
        </td>
        <td>
          3879
          -
          3936
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.JavaConverters.asScalaBufferConverter[org.geotools.api.filter.Filter](filter.getChildren()).asScala.flatMap[Long, scala.collection.mutable.Buffer[Long]](((x$3: org.geotools.api.filter.Filter) =&gt; scala.this.Option.option2Iterable[Long](StatsBasedEstimator.this.estimateCount(sft, x$3))))(mutable.this.Buffer.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          43312
        </td>
        <td>
          3945
          -
          3959
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.isEmpty
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          43313
        </td>
        <td>
          3963
          -
          3967
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          43314
        </td>
        <td>
          3963
          -
          3967
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          43315
        </td>
        <td>
          3989
          -
          3989
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          43316
        </td>
        <td>
          3982
          -
          3992
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          43317
        </td>
        <td>
          3977
          -
          3993
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.sum[Long](math.this.Numeric.LongIsIntegral))
        </td>
      </tr><tr>
        <td>
          93
        </td>
        <td>
          43318
        </td>
        <td>
          3977
          -
          3993
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](counts.sum[Long](math.this.Numeric.LongIsIntegral))
        </td>
      </tr><tr>
        <td>
          104
        </td>
        <td>
          43319
        </td>
        <td>
          4250
          -
          4266
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.Not.getFilter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          filter.getFilter()
        </td>
      </tr><tr>
        <td>
          107
        </td>
        <td>
          43320
        </td>
        <td>
          4361
          -
          4376
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.PropertyIsNull.getExpression
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          f.getExpression()
        </td>
      </tr><tr>
        <td>
          107
        </td>
        <td>
          43331
        </td>
        <td>
          4361
          -
          4579
        </td>
        <td>
          Match
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          f.getExpression() match {
  case (p @ (_: org.geotools.api.filter.expression.PropertyName)) =&gt; StatsBasedEstimator.this.estimateRangeCount(sft, p.getPropertyName(), scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)))
  case _ =&gt; StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
}
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          43321
        </td>
        <td>
          4443
          -
          4460
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.filter.expression.PropertyName.getPropertyName
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          p.getPropertyName()
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          43322
        </td>
        <td>
          4467
          -
          4471
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          43323
        </td>
        <td>
          4473
          -
          4477
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.None
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          43324
        </td>
        <td>
          4466
          -
          4478
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          43325
        </td>
        <td>
          4462
          -
          4479
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None))
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          43326
        </td>
        <td>
          4419
          -
          4480
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, p.getPropertyName(), scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)))
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          43327
        </td>
        <td>
          4419
          -
          4480
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, p.getPropertyName(), scala.collection.Seq.apply[(None.type, None.type)](scala.Tuple2.apply[None.type, None.type](scala.None, scala.None)))
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          43328
        </td>
        <td>
          4520
          -
          4534
        </td>
        <td>
          Select
        </td>
        <td>
          org.geotools.api.filter.Filter.INCLUDE
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.geotools.api.filter.Filter.INCLUDE
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          43329
        </td>
        <td>
          4501
          -
          4535
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          43330
        </td>
        <td>
          4501
          -
          4535
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          43332
        </td>
        <td>
          4647
          -
          4661
        </td>
        <td>
          Select
        </td>
        <td>
          org.geotools.api.filter.Filter.INCLUDE
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.geotools.api.filter.Filter.INCLUDE
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          43337
        </td>
        <td>
          4605
          -
          4752
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE).flatMap[Long](((all: Long) =&gt; StatsBasedEstimator.this.estimateCount(sft, f).map[Long](((neg: Long) =&gt; scala.math.`package`.max(0L, all.-(neg))))))
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          43338
        </td>
        <td>
          4605
          -
          4752
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE).flatMap[Long](((all: Long) =&gt; StatsBasedEstimator.this.estimateCount(sft, f).map[Long](((neg: Long) =&gt; scala.math.`package`.max(0L, all.-(neg))))))
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          43336
        </td>
        <td>
          4673
          -
          4752
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateCount(sft, f).map[Long](((neg: Long) =&gt; scala.math.`package`.max(0L, all.-(neg))))
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          43333
        </td>
        <td>
          4739
          -
          4740
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          43334
        </td>
        <td>
          4742
          -
          4751
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          all.-(neg)
        </td>
      </tr><tr>
        <td>
          117
        </td>
        <td>
          43335
        </td>
        <td>
          4730
          -
          4752
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.max
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.max(0L, all.-(neg))
        </td>
      </tr><tr>
        <td>
          133
        </td>
        <td>
          43339
        </td>
        <td>
          5275
          -
          5291
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          133
        </td>
        <td>
          43441
        </td>
        <td>
          5242
          -
          8238
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Option.apply[String](org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField).flatMap[Long](((geomField: String) =&gt; org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.map[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])](((dateField: String) =&gt; {
  val geometries: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry] = org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, geomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints);
  scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]](dateField, geometries)
})).withFilter(((x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)) =&gt; geometries.nonEmpty
})).map[((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])](((x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (x$14 @ (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _))) =&gt; {
    val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3);
    scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
  }
})).withFilter(((x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; intervals.nonEmpty
})).flatMap[Long](((x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
    0L
  else
    {
      val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
        val minTime: Long = bounds.min.getTime();
        val maxTime: Long = bounds.max.getTime();
        intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
      };
      val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
      StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
        case scala.None =&gt; 0L
        case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
          val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
            case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
          };
          val tmin: Long = x$6._1;
          val tmax: Long = x$6._2;
          val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
            ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
          })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
          def getIndices(t1: Long, t2: Long): Seq[Int] = {
            val w: Short = histogram.timeBins.head;
            val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
            zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
          };
          &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
          val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
          val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
          val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
          val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
              case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
            };
            val lower: java.time.ZonedDateTime = x$7._1;
            val upper: java.time.ZonedDateTime = x$7._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
            };
            val lb: Short = x$8._1;
            val lt: Long = x$8._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
            };
            val ub: Short = x$9._1;
            val ut: Long = x$9._2;
            scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
          }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
          binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
            case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
              {
                &lt;synthetic&gt; val ev$1: Short = bins.head;
                timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
              }
            else
              {
                &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                  case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
                };
                val head: Short = x$11._1;
                val middle: List[Short] = x$11._2;
                val last: Short = x$11._3;
                timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
                timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
                middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
              }
          }));
          timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        }
      }
    }))
}))))
        </td>
      </tr><tr>
        <td>
          134
        </td>
        <td>
          43342
        </td>
        <td>
          5299
          -
          5299
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]](dateField, geometries)
        </td>
      </tr><tr>
        <td>
          134
        </td>
        <td>
          43346
        </td>
        <td>
          5299
          -
          5299
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
        </td>
      </tr><tr>
        <td>
          134
        </td>
        <td>
          43440
        </td>
        <td>
          5299
          -
          8238
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.WithFilter.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.map[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])](((dateField: String) =&gt; {
  val geometries: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry] = org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, geomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints);
  scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]](dateField, geometries)
})).withFilter(((x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$13: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)) =&gt; geometries.nonEmpty
})).map[((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])](((x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])) =&gt; (x$15: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]) @unchecked) match {
  case (x$14 @ (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _))) =&gt; {
    val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3);
    scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
  }
})).withFilter(((x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$16: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; intervals.nonEmpty
})).flatMap[Long](((x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$17: ((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry])((dateField @ _), (geometries @ _)), (intervals @ _)) =&gt; StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
    0L
  else
    {
      val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
        val minTime: Long = bounds.min.getTime();
        val maxTime: Long = bounds.max.getTime();
        intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
      };
      val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
      StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
        case scala.None =&gt; 0L
        case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
          val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
            case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
          };
          val tmin: Long = x$6._1;
          val tmax: Long = x$6._2;
          val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
            ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
          })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
          def getIndices(t1: Long, t2: Long): Seq[Int] = {
            val w: Short = histogram.timeBins.head;
            val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
            zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
          };
          &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
          val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
          val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
          val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
          val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
              case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
            };
            val lower: java.time.ZonedDateTime = x$7._1;
            val upper: java.time.ZonedDateTime = x$7._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
            };
            val lb: Short = x$8._1;
            val lt: Long = x$8._2;
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
              case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
            };
            val ub: Short = x$9._1;
            val ut: Long = x$9._2;
            scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
          }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
          binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
            case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
              {
                &lt;synthetic&gt; val ev$1: Short = bins.head;
                timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
              }
            else
              {
                &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                  case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
                };
                val head: Short = x$11._1;
                val middle: List[Short] = x$11._2;
                val last: Short = x$11._3;
                timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
                timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
                middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
              }
          }));
          timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        }
      }
    }))
}))
        </td>
      </tr><tr>
        <td>
          135
        </td>
        <td>
          43340
        </td>
        <td>
          5399
          -
          5411
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.isPoints
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints
        </td>
      </tr><tr>
        <td>
          135
        </td>
        <td>
          43341
        </td>
        <td>
          5349
          -
          5412
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, geomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints)
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          43343
        </td>
        <td>
          5422
          -
          5441
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.nonEmpty
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          43344
        </td>
        <td>
          5422
          -
          5441
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.nonEmpty
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          43345
        </td>
        <td>
          5462
          -
          5510
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3)
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          43347
        </td>
        <td>
          5448
          -
          5510
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3);
  scala.Tuple2.apply[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.jts.geom.Geometry]), org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](x$14, intervals)
}
        </td>
      </tr><tr>
        <td>
          138
        </td>
        <td>
          43348
        </td>
        <td>
          5520
          -
          5538
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          138
        </td>
        <td>
          43349
        </td>
        <td>
          5520
          -
          5538
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          43350
        </td>
        <td>
          5574
          -
          5574
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getMinMax$default$3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax$default$3[java.util.Date]
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          43351
        </td>
        <td>
          5574
          -
          5574
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getMinMax$default$4
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          43438
        </td>
        <td>
          5545
          -
          8238
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
  0L
else
  {
    val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
      val minTime: Long = bounds.min.getTime();
      val maxTime: Long = bounds.max.getTime();
      intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
    };
    val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
    StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
      case scala.None =&gt; 0L
      case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
        val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
          case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
        };
        val tmin: Long = x$6._1;
        val tmax: Long = x$6._2;
        val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
          ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
        })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
        def getIndices(t1: Long, t2: Long): Seq[Int] = {
          val w: Short = histogram.timeBins.head;
          val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
          zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
        };
        &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
        val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
        val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
        val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
        val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
            case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
          };
          val lower: java.time.ZonedDateTime = x$7._1;
          val upper: java.time.ZonedDateTime = x$7._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
          };
          val lb: Short = x$8._1;
          val lt: Long = x$8._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
          };
          val ub: Short = x$9._1;
          val ut: Long = x$9._2;
          scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
        }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
        binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
          case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
            {
              &lt;synthetic&gt; val ev$1: Short = bins.head;
              timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
            }
          else
            {
              &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
              };
              val head: Short = x$11._1;
              val middle: List[Short] = x$11._2;
              val last: Short = x$11._3;
              timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
              timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
              middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
            }
        }));
        timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
      }
    }
  }))
        </td>
      </tr><tr>
        <td>
          139
        </td>
        <td>
          43439
        </td>
        <td>
          5545
          -
          8238
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getMinMax[java.util.Date](sft, dateField, StatsBasedEstimator.this.getMinMax$default$3[java.util.Date], StatsBasedEstimator.this.getMinMax$default$4[java.util.Date]).map[Long](((bounds: org.locationtech.geomesa.utils.stats.MinMax[java.util.Date]) =&gt; if (geometries.disjoint.||(intervals.disjoint))
  0L
else
  {
    val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
      val minTime: Long = bounds.min.getTime();
      val maxTime: Long = bounds.max.getTime();
      intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
    };
    val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
    StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
      case scala.None =&gt; 0L
      case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
        val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
          case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
        };
        val tmin: Long = x$6._1;
        val tmax: Long = x$6._2;
        val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
          ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
        })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
        def getIndices(t1: Long, t2: Long): Seq[Int] = {
          val w: Short = histogram.timeBins.head;
          val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
          zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
        };
        &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
        val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
        val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
        val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
        val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
            case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
          };
          val lower: java.time.ZonedDateTime = x$7._1;
          val upper: java.time.ZonedDateTime = x$7._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
          };
          val lb: Short = x$8._1;
          val lt: Long = x$8._2;
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
            case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
          };
          val ub: Short = x$9._1;
          val ut: Long = x$9._2;
          scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
        }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
        binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
          case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
            {
              &lt;synthetic&gt; val ev$1: Short = bins.head;
              timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
            }
          else
            {
              &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
                case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
              };
              val head: Short = x$11._1;
              val middle: List[Short] = x$11._2;
              val last: Short = x$11._3;
              timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
              timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
              middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
            }
        }));
        timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
      }
    }
  }))
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          43352
        </td>
        <td>
          5644
          -
          5662
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.disjoint
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          43353
        </td>
        <td>
          5621
          -
          5662
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.disjoint.||(intervals.disjoint)
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          43354
        </td>
        <td>
          5666
          -
          5668
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          43355
        </td>
        <td>
          5666
          -
          5668
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          141
        </td>
        <td>
          43437
        </td>
        <td>
          5676
          -
          8238
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val inRangeIntervals: Seq[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = {
    val minTime: Long = bounds.min.getTime();
    val maxTime: Long = bounds.max.getTime();
    intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
  };
  val period: org.locationtech.geomesa.curve.TimePeriod.TimePeriod = org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval;
  StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7) match {
    case scala.None =&gt; 0L
    case (value: org.locationtech.geomesa.utils.stats.Z3Histogram)Some[org.locationtech.geomesa.utils.stats.Z3Histogram]((histogram @ _)) =&gt; {
      val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
        case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
      };
      val tmin: Long = x$6._1;
      val tmax: Long = x$6._2;
      val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
        ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
      })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
      def getIndices(t1: Long, t2: Long): Seq[Int] = {
        val w: Short = histogram.timeBins.head;
        val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
        zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
      };
      &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
      val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
      val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
      val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
      val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
          case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
        };
        val lower: java.time.ZonedDateTime = x$7._1;
        val upper: java.time.ZonedDateTime = x$7._2;
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
          case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
        };
        val lb: Short = x$8._1;
        val lt: Long = x$8._2;
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
          case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
        };
        val ub: Short = x$9._1;
        val ut: Long = x$9._2;
        scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
      }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
      binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
        case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
          {
            &lt;synthetic&gt; val ev$1: Short = bins.head;
            timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
          }
        else
          {
            &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
              case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
            };
            val head: Short = x$11._1;
            val middle: List[Short] = x$11._2;
            val last: Short = x$11._3;
            timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
            timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
            middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
          }
      }));
      timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }
  }
}
        </td>
      </tr><tr>
        <td>
          143
        </td>
        <td>
          43356
        </td>
        <td>
          5735
          -
          5753
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.min.getTime()
        </td>
      </tr><tr>
        <td>
          144
        </td>
        <td>
          43357
        </td>
        <td>
          5778
          -
          5796
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.max.getTime()
        </td>
      </tr><tr>
        <td>
          145
        </td>
        <td>
          43362
        </td>
        <td>
          5807
          -
          5996
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.values.filter(((i: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))))
        </td>
      </tr><tr>
        <td>
          146
        </td>
        <td>
          43358
        </td>
        <td>
          5871
          -
          5906
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$4.toInstant().toEpochMilli().&lt;=(maxTime)
        </td>
      </tr><tr>
        <td>
          146
        </td>
        <td>
          43361
        </td>
        <td>
          5850
          -
          5984
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.lower.value.forall(((x$4: java.time.ZonedDateTime) =&gt; x$4.toInstant().toEpochMilli().&lt;=(maxTime))).&amp;&amp;(i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime))))
        </td>
      </tr><tr>
        <td>
          147
        </td>
        <td>
          43359
        </td>
        <td>
          5948
          -
          5983
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$5.toInstant().toEpochMilli().&gt;=(minTime)
        </td>
      </tr><tr>
        <td>
          147
        </td>
        <td>
          43360
        </td>
        <td>
          5927
          -
          5984
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.upper.value.forall(((x$5: java.time.ZonedDateTime) =&gt; x$5.toInstant().toEpochMilli().&gt;=(minTime)))
        </td>
      </tr><tr>
        <td>
          150
        </td>
        <td>
          43363
        </td>
        <td>
          6028
          -
          6045
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getZ3Interval
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getZ3Interval
        </td>
      </tr><tr>
        <td>
          151
        </td>
        <td>
          43364
        </td>
        <td>
          6110
          -
          6111
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          151
        </td>
        <td>
          43365
        </td>
        <td>
          6054
          -
          6120
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getZ3Histogram
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getZ3Histogram(sft, geomField, dateField, period, 0, filter, StatsBasedEstimator.this.getZ3Histogram$default$7)
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          43366
        </td>
        <td>
          6152
          -
          6154
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          43367
        </td>
        <td>
          6152
          -
          6154
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          43436
        </td>
        <td>
          6186
          -
          8220
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val sfc: org.locationtech.geomesa.curve.Z3SFC = org.locationtech.geomesa.curve.Z3SFC.apply(period);
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (Long, Long) = (scala.Tuple2.apply[Long, Long](sfc.time.min.toLong, sfc.time.max.toLong): (Long, Long) @unchecked) match {
    case (_1: Long, _2: Long)(Long, Long)((tmin @ _), (tmax @ _)) =&gt; scala.Tuple2.apply[Long, Long](tmin, tmax)
  };
  val tmin: Long = x$6._1;
  val tmax: Long = x$6._2;
  val xy: Seq[(Double, Double, Double, Double)] = geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
    ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
  })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]);
  def getIndices(t1: Long, t2: Long): Seq[Int] = {
    val w: Short = histogram.timeBins.head;
    val zs: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4);
    zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
  };
  &lt;stable&gt; &lt;accessor&gt; lazy val middleIndices: Seq[Int] = getIndices(tmin, tmax);
  val timeBinsAndIndices: scala.collection.mutable.Map[Short,Seq[Int]] = scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing]);
  val dateToBins: org.locationtech.geomesa.curve.BinnedTime.DateToBinnedTime = org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period);
  val boundsToDates: ((Option[java.time.ZonedDateTime], Option[java.time.ZonedDateTime])) =&gt; (java.time.ZonedDateTime, java.time.ZonedDateTime) = org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period);
  val binnedTimes: Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)] = inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
      case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
    };
    val lower: java.time.ZonedDateTime = x$7._1;
    val upper: java.time.ZonedDateTime = x$7._2;
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
      case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
    };
    val lb: Short = x$8._1;
    val lt: Long = x$8._2;
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
      case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
    };
    val ub: Short = x$9._1;
    val ut: Long = x$9._2;
    scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
  }))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]);
  binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
    case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
      {
        &lt;synthetic&gt; val ev$1: Short = bins.head;
        timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
      }
    else
      {
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
          case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
        };
        val head: Short = x$11._1;
        val middle: List[Short] = x$11._2;
        val last: Short = x$11._3;
        timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
        timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
        middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
      }
  }));
  timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}
        </td>
      </tr><tr>
        <td>
          155
        </td>
        <td>
          43368
        </td>
        <td>
          6277
          -
          6290
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.Z3SFC.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.Z3SFC.apply(period)
        </td>
      </tr><tr>
        <td>
          156
        </td>
        <td>
          43369
        </td>
        <td>
          6308
          -
          6308
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$6._1
        </td>
      </tr><tr>
        <td>
          156
        </td>
        <td>
          43370
        </td>
        <td>
          6314
          -
          6314
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$6._2
        </td>
      </tr><tr>
        <td>
          157
        </td>
        <td>
          43371
        </td>
        <td>
          6408
          -
          6428
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry)
        </td>
      </tr><tr>
        <td>
          157
        </td>
        <td>
          43372
        </td>
        <td>
          6407
          -
          6407
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]
        </td>
      </tr><tr>
        <td>
          157
        </td>
        <td>
          43373
        </td>
        <td>
          6386
          -
          6429
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
  ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
})(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)])
        </td>
      </tr><tr>
        <td>
          160
        </td>
        <td>
          43374
        </td>
        <td>
          6514
          -
          6537
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.IterableLike.head
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.timeBins.head
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          43375
        </td>
        <td>
          6644
          -
          6652
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Long, Long](t1, t2)
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          43376
        </td>
        <td>
          6640
          -
          6653
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2))
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          43377
        </td>
        <td>
          6655
          -
          6674
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.ZHistogramPrecision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ZHistogramPrecision
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          43378
        </td>
        <td>
          6625
          -
          6675
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.Z3SFC.ranges
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sfc.ranges(xy, scala.collection.Seq.apply[(Long, Long)](scala.Tuple2.apply[Long, Long](t1, t2)), StatsBasedEstimator.ZHistogramPrecision, sfc.ranges$default$4)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          43379
        </td>
        <td>
          6731
          -
          6738
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.zorder.sfcurve.IndexRange.lower
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          43380
        </td>
        <td>
          6706
          -
          6739
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Z3Histogram.directIndex
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.directIndex(w, r.lower)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          43381
        </td>
        <td>
          6768
          -
          6775
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.zorder.sfcurve.IndexRange.upper
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.upper
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          43382
        </td>
        <td>
          6743
          -
          6776
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Z3Histogram.directIndex
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.directIndex(w, r.upper)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          43383
        </td>
        <td>
          6706
          -
          6776
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          43384
        </td>
        <td>
          6700
          -
          6700
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          43385
        </td>
        <td>
          6690
          -
          6777
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          zs.flatMap[Int, Seq[Int]](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; scala.Predef.intWrapper(histogram.directIndex(w, r.lower)).to(histogram.directIndex(w, r.upper))))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          167
        </td>
        <td>
          43386
        </td>
        <td>
          7046
          -
          7055
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.empty[Nothing]
        </td>
      </tr><tr>
        <td>
          167
        </td>
        <td>
          43387
        </td>
        <td>
          6977
          -
          7056
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.Map.withDefaultValue
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.mutable.Map.empty[Short, Seq[Int]].withDefaultValue(scala.collection.Seq.empty[Nothing])
        </td>
      </tr><tr>
        <td>
          169
        </td>
        <td>
          43388
        </td>
        <td>
          7087
          -
          7122
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.BinnedTime.dateToBinnedTime(period)
        </td>
      </tr><tr>
        <td>
          170
        </td>
        <td>
          43389
        </td>
        <td>
          7155
          -
          7196
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.BinnedTime.boundsToIndexableDates(period)
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          43402
        </td>
        <td>
          7248
          -
          7248
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          43403
        </td>
        <td>
          7227
          -
          7518
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRangeIntervals.map[(scala.collection.immutable.IndexedSeq[Short], Long, Long), Seq[(scala.collection.immutable.IndexedSeq[Short], Long, Long)]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$7: (java.time.ZonedDateTime, java.time.ZonedDateTime) = (boundsToDates.apply(interval.bounds): (java.time.ZonedDateTime, java.time.ZonedDateTime) @unchecked) match {
    case (_1: java.time.ZonedDateTime, _2: java.time.ZonedDateTime)(java.time.ZonedDateTime, java.time.ZonedDateTime)((lower @ _), (upper @ _)) =&gt; scala.Tuple2.apply[java.time.ZonedDateTime, java.time.ZonedDateTime](lower, upper)
  };
  val lower: java.time.ZonedDateTime = x$7._1;
  val upper: java.time.ZonedDateTime = x$7._2;
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$8: (Short, Long) = (dateToBins.apply(lower): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
    case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((lb @ _), (lt @ _)) =&gt; scala.Tuple2.apply[Short, Long](lb, lt)
  };
  val lb: Short = x$8._1;
  val lt: Long = x$8._2;
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$9: (Short, Long) = (dateToBins.apply(upper): org.locationtech.geomesa.curve.BinnedTime @unchecked) match {
    case (bin: Short, offset: Long)org.locationtech.geomesa.curve.BinnedTime((ub @ _), (ut @ _)) =&gt; scala.Tuple2.apply[Short, Long](ub, ut)
  };
  val ub: Short = x$9._1;
  val ut: Long = x$9._2;
  scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
}))(collection.this.Seq.canBuildFrom[(scala.collection.immutable.IndexedSeq[Short], Long, Long)])
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          43390
        </td>
        <td>
          7281
          -
          7281
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7._1
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          43391
        </td>
        <td>
          7288
          -
          7288
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7._2
        </td>
      </tr><tr>
        <td>
          173
        </td>
        <td>
          43392
        </td>
        <td>
          7357
          -
          7357
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._1
        </td>
      </tr><tr>
        <td>
          173
        </td>
        <td>
          43393
        </td>
        <td>
          7361
          -
          7361
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$8._2
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          43394
        </td>
        <td>
          7414
          -
          7414
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._1
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          43395
        </td>
        <td>
          7418
          -
          7418
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9._2
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          43396
        </td>
        <td>
          7473
          -
          7475
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Short.toInt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          lb.toInt
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          43397
        </td>
        <td>
          7477
          -
          7479
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Short.toInt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ub.toInt
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          43398
        </td>
        <td>
          7485
          -
          7494
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toShort
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10.toShort
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          43399
        </td>
        <td>
          7484
          -
          7484
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[Short]
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          43400
        </td>
        <td>
          7457
          -
          7495
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short])
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          43401
        </td>
        <td>
          7456
          -
          7504
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple3.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple3.apply[scala.collection.immutable.IndexedSeq[Short], Long, Long](scala.`package`.Range.inclusive(lb.toInt, ub.toInt).map[Short, scala.collection.immutable.IndexedSeq[Short]](((x$10: Int) =&gt; x$10.toShort))(immutable.this.IndexedSeq.canBuildFrom[Short]), lt, ut)
        </td>
      </tr><tr>
        <td>
          179
        </td>
        <td>
          43427
        </td>
        <td>
          7637
          -
          8107
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          binnedTimes.foreach[Unit](((x0$1: (scala.collection.immutable.IndexedSeq[Short], Long, Long)) =&gt; x0$1 match {
  case (_1: scala.collection.immutable.IndexedSeq[Short], _2: Long, _3: Long)(scala.collection.immutable.IndexedSeq[Short], Long, Long)((bins @ _), (lt @ _), (ut @ _)) =&gt; if (bins.length.==(1))
    {
      &lt;synthetic&gt; val ev$1: Short = bins.head;
      timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
    }
  else
    {
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
        case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
      };
      val head: Short = x$11._1;
      val middle: List[Short] = x$11._2;
      val last: Short = x$11._3;
      timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
      timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
      middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
    }
}))
        </td>
      </tr><tr>
        <td>
          180
        </td>
        <td>
          43404
        </td>
        <td>
          7700
          -
          7716
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bins.length.==(1)
        </td>
      </tr><tr>
        <td>
          180
        </td>
        <td>
          43426
        </td>
        <td>
          7696
          -
          8093
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (bins.length.==(1))
  {
    &lt;synthetic&gt; val ev$1: Short = bins.head;
    timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
  }
else
  {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
      case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
    };
    val head: Short = x$11._1;
    val middle: List[Short] = x$11._2;
    val last: Short = x$11._3;
    timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
    timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
    middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
  }
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          43405
        </td>
        <td>
          7770
          -
          7788
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.getIndices
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          getIndices(lt, ut)
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          43406
        </td>
        <td>
          7766
          -
          7766
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          43407
        </td>
        <td>
          7736
          -
          7788
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          43408
        </td>
        <td>
          7736
          -
          7788
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          43409
        </td>
        <td>
          7736
          -
          7788
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; val ev$1: Short = bins.head;
  timeBinsAndIndices.update(ev$1, timeBinsAndIndices.apply(ev$1).++[Int, Seq[Int]](getIndices(lt, ut))(collection.this.Seq.canBuildFrom[Int]))
}
        </td>
      </tr><tr>
        <td>
          182
        </td>
        <td>
          43425
        </td>
        <td>
          7810
          -
          8093
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$11: (Short, List[Short], Short) = (bins.toList: List[Short] @unchecked) match {
    case scala.`package`.:+.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; (scala.`package`.+:.unapply[Short, List[Short]](&lt;unapply-selector&gt;) &lt;unapply&gt; ((head @ _), (middle @ _)), (last @ _)) =&gt; scala.Tuple3.apply[Short, List[Short], Short](head, middle, last)
  };
  val head: Short = x$11._1;
  val middle: List[Short] = x$11._2;
  val last: Short = x$11._3;
  timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]));
  timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]));
  middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
}
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          43410
        </td>
        <td>
          7832
          -
          7832
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._1
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          43411
        </td>
        <td>
          7840
          -
          7840
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._2
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          43412
        </td>
        <td>
          7850
          -
          7850
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple3._3
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._3
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          43413
        </td>
        <td>
          7914
          -
          7934
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.getIndices
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          getIndices(lt, tmax)
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          43414
        </td>
        <td>
          7910
          -
          7910
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          43415
        </td>
        <td>
          7885
          -
          7934
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          43416
        </td>
        <td>
          7885
          -
          7934
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.update(head, timeBinsAndIndices.apply(head).++[Int, Seq[Int]](getIndices(lt, tmax))(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          43417
        </td>
        <td>
          7980
          -
          8000
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.getIndices
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          getIndices(tmin, ut)
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          43418
        </td>
        <td>
          7976
          -
          7976
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          43419
        </td>
        <td>
          7951
          -
          8000
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          43420
        </td>
        <td>
          7951
          -
          8000
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.update(last, timeBinsAndIndices.apply(last).++[Int, Seq[Int]](getIndices(tmin, ut))(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          43421
        </td>
        <td>
          8059
          -
          8059
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          43422
        </td>
        <td>
          8037
          -
          8076
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          43423
        </td>
        <td>
          8037
          -
          8076
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.update
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))
        </td>
      </tr><tr>
        <td>
          186
        </td>
        <td>
          43424
        </td>
        <td>
          8017
          -
          8077
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.List.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          middle.foreach[Unit](((m: Short) =&gt; timeBinsAndIndices.update(m, timeBinsAndIndices.apply(m).++[Int, Seq[Int]](middleIndices)(collection.this.Seq.canBuildFrom[Int]))))
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43428
        </td>
        <td>
          8188
          -
          8209
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Z3Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(b, x$12)
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43429
        </td>
        <td>
          8187
          -
          8187
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43430
        </td>
        <td>
          8211
          -
          8211
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43431
        </td>
        <td>
          8167
          -
          8214
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43432
        </td>
        <td>
          8167
          -
          8214
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43433
        </td>
        <td>
          8144
          -
          8144
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          mutable.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43434
        </td>
        <td>
          8217
          -
          8217
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          43435
        </td>
        <td>
          8121
          -
          8220
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          timeBinsAndIndices.map[Long, scala.collection.mutable.Iterable[Long]](((x0$2: (Short, Seq[Int])) =&gt; x0$2 match {
  case (_1: Short, _2: Seq[Int])(Short, Seq[Int])((b @ _), (indices @ _)) =&gt; indices.distinct.map[Long, Seq[Long]](((x$12: Int) =&gt; histogram.count(b, x$12)))(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))(mutable.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          207
        </td>
        <td>
          43442
        </td>
        <td>
          8734
          -
          8750
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          207
        </td>
        <td>
          43443
        </td>
        <td>
          8721
          -
          8750
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          attribute.==(org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField)
        </td>
      </tr><tr>
        <td>
          208
        </td>
        <td>
          43444
        </td>
        <td>
          8760
          -
          8793
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateSpatialCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateSpatialCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          208
        </td>
        <td>
          43445
        </td>
        <td>
          8760
          -
          8793
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateSpatialCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateSpatialCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          209
        </td>
        <td>
          43446
        </td>
        <td>
          8809
          -
          8844
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.contains
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.contains[String](attribute)
        </td>
      </tr><tr>
        <td>
          209
        </td>
        <td>
          43498
        </td>
        <td>
          8805
          -
          10444
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.contains[String](attribute))
  StatsBasedEstimator.this.estimateTemporalCount(sft, filter)
else
  {
    val extractedBounds: Option[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]] = scala.Option.apply[org.geotools.api.feature.type.AttributeDescriptor](sft.getDescriptor(attribute)).map[(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }](((descriptor: org.geotools.api.feature.type.AttributeDescriptor) =&gt; {
  val binding: Class[_] = if (org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList)
    org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
  else
    descriptor.getType().getBinding();
  scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
})).map[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]](((x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }) =&gt; (x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) @unchecked) match {
      case (_1: org.geotools.api.feature.type.AttributeDescriptor, _2: Class[_$2])(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2])((descriptor @ _), (binding @ _)) =&gt; org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
    }));
    extractedBounds.flatMap[Long](((bounds: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]) =&gt; if (bounds.disjoint)
      scala.Some.apply[Long](0L)
    else
      if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
        StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
      else
        {
          val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
            case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
          })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
            case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
          };
          val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
          val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
          val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
            scala.Some.apply[Long](0L)
          else
            {
              val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
              val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
              scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
                case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
                case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
                case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
              }
            };
          val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
            scala.Some.apply[Long](0L)
          else
            StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
          equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
        }))
  }
        </td>
      </tr><tr>
        <td>
          210
        </td>
        <td>
          43447
        </td>
        <td>
          8854
          -
          8888
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateTemporalCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateTemporalCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          210
        </td>
        <td>
          43448
        </td>
        <td>
          8854
          -
          8888
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateTemporalCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateTemporalCount(sft, filter)
        </td>
      </tr><tr>
        <td>
          211
        </td>
        <td>
          43497
        </td>
        <td>
          8900
          -
          10444
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val extractedBounds: Option[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]] = scala.Option.apply[org.geotools.api.feature.type.AttributeDescriptor](sft.getDescriptor(attribute)).map[(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }](((descriptor: org.geotools.api.feature.type.AttributeDescriptor) =&gt; {
  val binding: Class[_] = if (org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList)
    org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
  else
    descriptor.getType().getBinding();
  scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
})).map[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]](((x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }) =&gt; (x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) @unchecked) match {
    case (_1: org.geotools.api.feature.type.AttributeDescriptor, _2: Class[_$2])(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2])((descriptor @ _), (binding @ _)) =&gt; org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
  }));
  extractedBounds.flatMap[Long](((bounds: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]) =&gt; if (bounds.disjoint)
    scala.Some.apply[Long](0L)
  else
    if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
      StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
    else
      {
        val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
          case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
        })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
          case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
        };
        val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
        val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
        val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
          scala.Some.apply[Long](0L)
        else
          {
            val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
            val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
            scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
              case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
              case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
              case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
            }
          };
        val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
          scala.Some.apply[Long](0L)
        else
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
        equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
      }))
}
        </td>
      </tr><tr>
        <td>
          214
        </td>
        <td>
          43449
        </td>
        <td>
          9002
          -
          9030
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.feature.simple.SimpleFeatureType.getDescriptor
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sft.getDescriptor(attribute)
        </td>
      </tr><tr>
        <td>
          214
        </td>
        <td>
          43455
        </td>
        <td>
          8981
          -
          8981
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
        </td>
      </tr><tr>
        <td>
          214
        </td>
        <td>
          43459
        </td>
        <td>
          8967
          -
          9257
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Option.apply[org.geotools.api.feature.type.AttributeDescriptor](sft.getDescriptor(attribute)).map[(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }](((descriptor: org.geotools.api.feature.type.AttributeDescriptor) =&gt; {
  val binding: Class[_] = if (org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList)
    org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
  else
    descriptor.getType().getBinding();
  scala.Tuple2.apply[org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]](descriptor, binding)
})).map[org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]](((x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) forSome { type _$2 }) =&gt; (x$18: (org.geotools.api.feature.type.AttributeDescriptor, Class[_$2]) @unchecked) match {
  case (_1: org.geotools.api.feature.type.AttributeDescriptor, _2: Class[_$2])(org.geotools.api.feature.type.AttributeDescriptor, Class[_$2])((descriptor @ _), (binding @ _)) =&gt; org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
}))
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          43450
        </td>
        <td>
          9058
          -
          9075
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor.isList
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).isList
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          43451
        </td>
        <td>
          9079
          -
          9103
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor.getListType
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          43452
        </td>
        <td>
          9079
          -
          9103
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor.getListType
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor(descriptor).getListType()
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          43453
        </td>
        <td>
          9113
          -
          9142
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.feature.type.PropertyType.getBinding
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          descriptor.getType().getBinding()
        </td>
      </tr><tr>
        <td>
          215
        </td>
        <td>
          43454
        </td>
        <td>
          9113
          -
          9142
        </td>
        <td>
          Block
        </td>
        <td>
          org.geotools.api.feature.type.PropertyType.getBinding
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          descriptor.getType().getBinding()
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          43456
        </td>
        <td>
          9224
          -
          9256
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          binding.asInstanceOf[Class[Any]]
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          43457
        </td>
        <td>
          9169
          -
          9257
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          43458
        </td>
        <td>
          9169
          -
          9257
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractAttributeBounds[Any](filter, attribute, binding.asInstanceOf[Class[Any]])
        </td>
      </tr><tr>
        <td>
          219
        </td>
        <td>
          43496
        </td>
        <td>
          9272
          -
          10438
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          extractedBounds.flatMap[Long](((bounds: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[Any]]) =&gt; if (bounds.disjoint)
  scala.Some.apply[Long](0L)
else
  if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
    StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
  else
    {
      val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
        case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
      })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
        case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
      };
      val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
      val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
      val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
        scala.Some.apply[Long](0L)
      else
        {
          val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
          val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
          scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
            case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
            case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
            case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
          }
        };
      val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
        scala.Some.apply[Long](0L)
      else
        StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
      equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
    }))
        </td>
      </tr><tr>
        <td>
          220
        </td>
        <td>
          43460
        </td>
        <td>
          9320
          -
          9335
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.disjoint
        </td>
      </tr><tr>
        <td>
          221
        </td>
        <td>
          43461
        </td>
        <td>
          9349
          -
          9357
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          221
        </td>
        <td>
          43462
        </td>
        <td>
          9349
          -
          9357
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          43463
        </td>
        <td>
          9417
          -
          9428
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.isBounded
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$19.isBounded
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          43464
        </td>
        <td>
          9395
          -
          9429
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!
        </td>
      </tr><tr>
        <td>
          222
        </td>
        <td>
          43495
        </td>
        <td>
          9391
          -
          10430
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (bounds.values.exists(((x$19: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; x$19.isBounded)).unary_!)
  StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
else
  {
    val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
      case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
    })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
      case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
    };
    val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
    val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
    val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
      scala.Some.apply[Long](0L)
    else
      {
        val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
        val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
        scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
          case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
          case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
          case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
        }
      };
    val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
      scala.Some.apply[Long](0L)
    else
      StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
    equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
  }
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          43465
        </td>
        <td>
          9462
          -
          9476
        </td>
        <td>
          Select
        </td>
        <td>
          org.geotools.api.filter.Filter.INCLUDE
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.geotools.api.filter.Filter.INCLUDE
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          43466
        </td>
        <td>
          9443
          -
          9477
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          43467
        </td>
        <td>
          9443
          -
          9477
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          StatsBasedEstimator.this.estimateCount(sft, org.geotools.api.filter.Filter.INCLUDE)
        </td>
      </tr><tr>
        <td>
          224
        </td>
        <td>
          43494
        </td>
        <td>
          9513
          -
          10430
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val boundsValues: Seq[(Option[Any], Option[Any])] = bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]);
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$20: (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) = (boundsValues.partition(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((l @ _), (r @ _)) =&gt; l.==(r)
  })): (Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]) @unchecked) match {
    case (_1: Seq[(Option[Any], Option[Any])], _2: Seq[(Option[Any], Option[Any])])(Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])])((equalsBounds @ _), (rangeBounds @ _)) =&gt; scala.Tuple2.apply[Seq[(Option[Any], Option[Any])], Seq[(Option[Any], Option[Any])]](equalsBounds, rangeBounds)
  };
  val equalsBounds: Seq[(Option[Any], Option[Any])] = x$20._1;
  val rangeBounds: Seq[(Option[Any], Option[Any])] = x$20._2;
  val equalsCount: Option[Long] = if (equalsBounds.isEmpty)
    scala.Some.apply[Long](0L)
  else
    {
      val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
      val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
      scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
        case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
        case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
        case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
      }
    };
  val rangeCount: Option[Long] = if (rangeBounds.isEmpty)
    scala.Some.apply[Long](0L)
  else
    StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds);
  equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
}
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          43468
        </td>
        <td>
          9568
          -
          9581
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.value
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          b.lower.value
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          43469
        </td>
        <td>
          9583
          -
          9596
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.value
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          b.upper.value
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          43470
        </td>
        <td>
          9567
          -
          9597
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          43471
        </td>
        <td>
          9561
          -
          9561
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])]
        </td>
      </tr><tr>
        <td>
          225
        </td>
        <td>
          43472
        </td>
        <td>
          9544
          -
          9598
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bounds.values.map[(Option[Any], Option[Any]), Seq[(Option[Any], Option[Any])]](((b: org.locationtech.geomesa.filter.Bounds[Any]) =&gt; scala.Tuple2.apply[Option[Any], Option[Any]](b.lower.value, b.upper.value)))(collection.this.Seq.canBuildFrom[(Option[Any], Option[Any])])
        </td>
      </tr><tr>
        <td>
          226
        </td>
        <td>
          43473
        </td>
        <td>
          9614
          -
          9614
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$20._1
        </td>
      </tr><tr>
        <td>
          226
        </td>
        <td>
          43474
        </td>
        <td>
          9628
          -
          9628
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$20._2
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          43475
        </td>
        <td>
          9724
          -
          9744
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          equalsBounds.isEmpty
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          43476
        </td>
        <td>
          9748
          -
          9756
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          43477
        </td>
        <td>
          9748
          -
          9756
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          227
        </td>
        <td>
          43485
        </td>
        <td>
          9764
          -
          10208
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val equals: Option[Long] = StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]));
  val range: Option[Long] = StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds);
  scala.Tuple2.apply[Option[Long], Option[Long]](equals, range) match {
    case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((value: Long)Some[Long]((e @ _)), (value: Long)Some[Long]((r @ _))) =&gt; scala.Some.apply[Long](scala.math.`package`.min(e, r))
    case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])(scala.None, (r @ _)) =&gt; r
    case (_1: Option[Long], _2: Option[Long])(Option[Long], Option[Long])((e @ _), scala.None) =&gt; e
  }
}
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          43478
        </td>
        <td>
          9932
          -
          9940
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Option.get
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$21._1.get
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          43479
        </td>
        <td>
          9931
          -
          9931
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Any]
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          43480
        </td>
        <td>
          9915
          -
          9941
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any])
        </td>
      </tr><tr>
        <td>
          229
        </td>
        <td>
          43481
        </td>
        <td>
          9871
          -
          9942
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateEqualsCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateEqualsCount(sft, filter, attribute, equalsBounds.map[Any, Seq[Any]](((x$21: (Option[Any], Option[Any])) =&gt; x$21._1.get))(collection.this.Seq.canBuildFrom[Any]))
        </td>
      </tr><tr>
        <td>
          230
        </td>
        <td>
          43482
        </td>
        <td>
          9968
          -
          10016
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, equalsBounds)
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          43483
        </td>
        <td>
          10099
          -
          10113
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.min(e, r)
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          43484
        </td>
        <td>
          10094
          -
          10114
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](scala.math.`package`.min(e, r))
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          43486
        </td>
        <td>
          10240
          -
          10259
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rangeBounds.isEmpty
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          43487
        </td>
        <td>
          10263
          -
          10271
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          43488
        </td>
        <td>
          10263
          -
          10271
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          238
        </td>
        <td>
          43489
        </td>
        <td>
          10293
          -
          10340
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds)
        </td>
      </tr><tr>
        <td>
          238
        </td>
        <td>
          43490
        </td>
        <td>
          10293
          -
          10340
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.estimateRangeCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.estimateRangeCount(sft, attribute, rangeBounds)
        </td>
      </tr><tr>
        <td>
          240
        </td>
        <td>
          43491
        </td>
        <td>
          10413
          -
          10418
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          e.+(r)
        </td>
      </tr><tr>
        <td>
          240
        </td>
        <td>
          43492
        </td>
        <td>
          10387
          -
          10418
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          rangeCount.map[Long](((r: Long) =&gt; e.+(r)))
        </td>
      </tr><tr>
        <td>
          240
        </td>
        <td>
          43493
        </td>
        <td>
          10363
          -
          10418
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          equalsCount.flatMap[Long](((e: Long) =&gt; rangeCount.map[Long](((r: Long) =&gt; e.+(r)))))
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          43499
        </td>
        <td>
          10793
          -
          10809
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          43500
        </td>
        <td>
          10811
          -
          10823
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.isPoints
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          43501
        </td>
        <td>
          10754
          -
          10824
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractGeometries(filter, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).isPoints)
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          43502
        </td>
        <td>
          10833
          -
          10851
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.isEmpty
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          43503
        </td>
        <td>
          10861
          -
          10865
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          43504
        </td>
        <td>
          10861
          -
          10865
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          43505
        </td>
        <td>
          10881
          -
          10900
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.disjoint
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          43542
        </td>
        <td>
          10877
          -
          11884
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (geometries.disjoint)
  scala.Some.apply[Long](0L)
else
  {
    val zero: org.locationtech.jts.geom.Point = org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint;
    StatsBasedEstimator.this.getHistogram[org.locationtech.jts.geom.Geometry](sft, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, 0, zero, zero, StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry], StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[org.locationtech.jts.geom.Geometry]) =&gt; {
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$24: (Long, Long) = ({
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$22: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.min): (Double, Double, Double, Double) @unchecked) match {
          case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)((xmin @ _), (ymin @ _), _, _) =&gt; scala.Tuple2.apply[Double, Double](xmin, ymin)
        };
        val xmin: Double = x$22._1;
        val ymin: Double = x$22._2;
        &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$23: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.max): (Double, Double, Double, Double) @unchecked) match {
          case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)(_, _, (xmax @ _), (ymax @ _)) =&gt; scala.Tuple2.apply[Double, Double](xmax, ymax)
        };
        val xmax: Double = x$23._1;
        val ymax: Double = x$23._2;
        scala.Tuple2.apply[Long, Long](org.locationtech.geomesa.curve.Z2SFC.index(xmin, ymin, org.locationtech.geomesa.curve.Z2SFC.index$default$3), org.locationtech.geomesa.curve.Z2SFC.index(xmax, ymax, org.locationtech.geomesa.curve.Z2SFC.index$default$3))
      }: (Long, Long) @unchecked) match {
        case (_1: Long, _2: Long)(Long, Long)((zLo @ _), (zHi @ _)) =&gt; scala.Tuple2.apply[Long, Long](zLo, zHi)
      };
      val zLo: Long = x$24._1;
      val zHi: Long = x$24._2;
      def inRange(r: org.locationtech.geomesa.zorder.sfcurve.IndexRange): Boolean = r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo));
      val ranges: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
        ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
      })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3);
      val indices: Seq[Int] = ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
        val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
        val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
        scala.Predef.intWrapper(loIndex).to(hiIndex)
      }))(collection.this.Seq.canBuildFrom[Int]);
      if (indices.isEmpty)
        0L
      else
        indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }))
  }
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          43506
        </td>
        <td>
          10910
          -
          10918
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          43507
        </td>
        <td>
          10910
          -
          10918
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[Long](0L)
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          43541
        </td>
        <td>
          10930
          -
          11884
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val zero: org.locationtech.jts.geom.Point = org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint;
  StatsBasedEstimator.this.getHistogram[org.locationtech.jts.geom.Geometry](sft, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, 0, zero, zero, StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry], StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[org.locationtech.jts.geom.Geometry]) =&gt; {
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$24: (Long, Long) = ({
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$22: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.min): (Double, Double, Double, Double) @unchecked) match {
        case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)((xmin @ _), (ymin @ _), _, _) =&gt; scala.Tuple2.apply[Double, Double](xmin, ymin)
      };
      val xmin: Double = x$22._1;
      val ymin: Double = x$22._2;
      &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$23: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.max): (Double, Double, Double, Double) @unchecked) match {
        case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)(_, _, (xmax @ _), (ymax @ _)) =&gt; scala.Tuple2.apply[Double, Double](xmax, ymax)
      };
      val xmax: Double = x$23._1;
      val ymax: Double = x$23._2;
      scala.Tuple2.apply[Long, Long](org.locationtech.geomesa.curve.Z2SFC.index(xmin, ymin, org.locationtech.geomesa.curve.Z2SFC.index$default$3), org.locationtech.geomesa.curve.Z2SFC.index(xmax, ymax, org.locationtech.geomesa.curve.Z2SFC.index$default$3))
    }: (Long, Long) @unchecked) match {
      case (_1: Long, _2: Long)(Long, Long)((zLo @ _), (zHi @ _)) =&gt; scala.Tuple2.apply[Long, Long](zLo, zHi)
    };
    val zLo: Long = x$24._1;
    val zHi: Long = x$24._2;
    def inRange(r: org.locationtech.geomesa.zorder.sfcurve.IndexRange): Boolean = r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo));
    val ranges: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
      ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
    })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3);
    val indices: Seq[Int] = ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
      val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
      val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
      scala.Predef.intWrapper(loIndex).to(hiIndex)
    }))(collection.this.Seq.canBuildFrom[Int]);
    if (indices.isEmpty)
      0L
    else
      indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
  }))
}
        </td>
      </tr><tr>
        <td>
          259
        </td>
        <td>
          43508
        </td>
        <td>
          10949
          -
          10972
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.GeometryUtils.zeroPoint
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          43509
        </td>
        <td>
          11013
          -
          11029
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getGeomField
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          43510
        </td>
        <td>
          11031
          -
          11032
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          43511
        </td>
        <td>
          10997
          -
          10997
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$6
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          43512
        </td>
        <td>
          10997
          -
          10997
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$7
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          260
        </td>
        <td>
          43540
        </td>
        <td>
          10979
          -
          11878
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[org.locationtech.jts.geom.Geometry](sft, org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getGeomField, 0, zero, zero, StatsBasedEstimator.this.getHistogram$default$6[org.locationtech.jts.geom.Geometry], StatsBasedEstimator.this.getHistogram$default$7[org.locationtech.jts.geom.Geometry]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[org.locationtech.jts.geom.Geometry]) =&gt; {
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$24: (Long, Long) = ({
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$22: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.min): (Double, Double, Double, Double) @unchecked) match {
      case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)((xmin @ _), (ymin @ _), _, _) =&gt; scala.Tuple2.apply[Double, Double](xmin, ymin)
    };
    val xmin: Double = x$22._1;
    val ymin: Double = x$22._2;
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$23: (Double, Double) = (org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(histogram.max): (Double, Double, Double, Double) @unchecked) match {
      case (_1: Double, _2: Double, _3: Double, _4: Double)(Double, Double, Double, Double)(_, _, (xmax @ _), (ymax @ _)) =&gt; scala.Tuple2.apply[Double, Double](xmax, ymax)
    };
    val xmax: Double = x$23._1;
    val ymax: Double = x$23._2;
    scala.Tuple2.apply[Long, Long](org.locationtech.geomesa.curve.Z2SFC.index(xmin, ymin, org.locationtech.geomesa.curve.Z2SFC.index$default$3), org.locationtech.geomesa.curve.Z2SFC.index(xmax, ymax, org.locationtech.geomesa.curve.Z2SFC.index$default$3))
  }: (Long, Long) @unchecked) match {
    case (_1: Long, _2: Long)(Long, Long)((zLo @ _), (zHi @ _)) =&gt; scala.Tuple2.apply[Long, Long](zLo, zHi)
  };
  val zLo: Long = x$24._1;
  val zHi: Long = x$24._2;
  def inRange(r: org.locationtech.geomesa.zorder.sfcurve.IndexRange): Boolean = r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo));
  val ranges: Seq[org.locationtech.geomesa.zorder.sfcurve.IndexRange] = org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
    ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
  })(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3);
  val indices: Seq[Int] = ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
    val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
    val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
    scala.Predef.intWrapper(loIndex).to(hiIndex)
  }))(collection.this.Seq.canBuildFrom[Int]);
  if (indices.isEmpty)
    0L
  else
    indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))
        </td>
      </tr><tr>
        <td>
          261
        </td>
        <td>
          43513
        </td>
        <td>
          11078
          -
          11078
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$24._1
        </td>
      </tr><tr>
        <td>
          261
        </td>
        <td>
          43514
        </td>
        <td>
          11083
          -
          11083
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$24._2
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          43515
        </td>
        <td>
          11359
          -
          11372
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.upper.&gt;(zLo)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          43516
        </td>
        <td>
          11342
          -
          11372
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.&lt;(zHi).&amp;&amp;(r.upper.&gt;(zLo))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          43517
        </td>
        <td>
          11430
          -
          11450
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry)
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          43518
        </td>
        <td>
          11429
          -
          11429
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          43519
        </td>
        <td>
          11408
          -
          11451
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
  ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
})(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)])
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          43520
        </td>
        <td>
          11453
          -
          11472
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.ZHistogramPrecision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ZHistogramPrecision
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          43521
        </td>
        <td>
          11395
          -
          11473
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.Z2SFC.ranges
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.Z2SFC.ranges(geometries.values.map[(Double, Double, Double, Double), Seq[(Double, Double, Double, Double)]]({
  ((geometry: org.locationtech.jts.geom.Geometry) =&gt; org.locationtech.geomesa.utils.geotools.GeometryUtils.bounds(geometry))
})(collection.this.Seq.canBuildFrom[(Double, Double, Double, Double)]), StatsBasedEstimator.ZHistogramPrecision, org.locationtech.geomesa.curve.Z2SFC.ranges$default$3)
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          43522
        </td>
        <td>
          11510
          -
          11517
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.inRange
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRange(r)
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          43530
        </td>
        <td>
          11527
          -
          11527
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          43531
        </td>
        <td>
          11496
          -
          11783
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ranges.filter({
  ((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; inRange(r))
}).flatMap[Int, Seq[Int]](((range: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
  val loIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0);
  val hiIndex: Int = scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1));
  scala.Predef.intWrapper(loIndex).to(hiIndex)
}))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          43523
        </td>
        <td>
          11562
          -
          11631
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Int](histogram.directIndex(range.lower)).filter(((x$25: Int) =&gt; x$25.!=(-1))).getOrElse[Int](0)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          43524
        </td>
        <td>
          11683
          -
          11694
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.zorder.sfcurve.IndexRange.upper
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          range.upper
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          43525
        </td>
        <td>
          11661
          -
          11695
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.directIndex
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.directIndex(range.upper)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          43526
        </td>
        <td>
          11704
          -
          11711
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$26.!=(-1)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          43527
        </td>
        <td>
          11723
          -
          11743
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.length.-(1)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          43528
        </td>
        <td>
          11656
          -
          11744
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[Int](histogram.directIndex(range.upper)).filter(((x$26: Int) =&gt; x$26.!=(-1))).getOrElse[Int](histogram.length.-(1))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          43529
        </td>
        <td>
          11755
          -
          11773
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(loIndex).to(hiIndex)
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43532
        </td>
        <td>
          11796
          -
          11811
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.isEmpty
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43533
        </td>
        <td>
          11815
          -
          11817
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43534
        </td>
        <td>
          11815
          -
          11817
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43535
        </td>
        <td>
          11848
          -
          11863
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(i)
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43536
        </td>
        <td>
          11847
          -
          11847
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43537
        </td>
        <td>
          11865
          -
          11865
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43538
        </td>
        <td>
          11827
          -
          11868
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          43539
        </td>
        <td>
          11827
          -
          11868
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          288
        </td>
        <td>
          43544
        </td>
        <td>
          12229
          -
          12229
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](dateField, intervals)
        </td>
      </tr><tr>
        <td>
          288
        </td>
        <td>
          43583
        </td>
        <td>
          12217
          -
          13231
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.WithFilter.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField.map[(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])](((dateField: String) =&gt; {
  val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3);
  scala.Tuple2.apply[String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]](dateField, intervals)
})).withFilter(((x$31: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$31: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((dateField @ _), (intervals @ _)) =&gt; intervals.nonEmpty
})).flatMap[Long](((x$32: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])) =&gt; (x$32: (String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]]) @unchecked) match {
  case (_1: String, _2: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])(String, org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]])((dateField @ _), (intervals @ _)) =&gt; StatsBasedEstimator.this.getHistogram[java.util.Date](sft, dateField, 0, new java.util.Date(), new java.util.Date(), StatsBasedEstimator.this.getHistogram$default$6[java.util.Date], StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[java.util.Date]) =&gt; {
    def inRange(interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]): Boolean = interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))));
    if (intervals.disjoint)
      0L
    else
      {
        val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
          val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
          val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
          scala.Predef.intWrapper(loIndex).to(hiIndex)
        }))(collection.this.Seq.canBuildFrom[Int]);
        if (indices.isEmpty)
          0L
        else
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
      }
  }))
}))
        </td>
      </tr><tr>
        <td>
          289
        </td>
        <td>
          43543
        </td>
        <td>
          12277
          -
          12325
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dateField, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3)
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          43545
        </td>
        <td>
          12335
          -
          12353
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          43546
        </td>
        <td>
          12335
          -
          12353
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.nonEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.nonEmpty
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          43547
        </td>
        <td>
          12414
          -
          12415
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          43548
        </td>
        <td>
          12417
          -
          12427
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new java.util.Date()
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          43549
        </td>
        <td>
          12429
          -
          12439
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new java.util.Date()
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          43550
        </td>
        <td>
          12391
          -
          12391
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$6
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$6[java.util.Date]
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          43551
        </td>
        <td>
          12391
          -
          12391
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$7
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          43581
        </td>
        <td>
          12360
          -
          13231
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[java.util.Date](sft, dateField, 0, new java.util.Date(), new java.util.Date(), StatsBasedEstimator.this.getHistogram$default$6[java.util.Date], StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[java.util.Date]) =&gt; {
  def inRange(interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]): Boolean = interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))));
  if (intervals.disjoint)
    0L
  else
    {
      val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
        val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
        val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
        scala.Predef.intWrapper(loIndex).to(hiIndex)
      }))(collection.this.Seq.canBuildFrom[Int]);
      if (indices.isEmpty)
        0L
      else
        indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }
}))
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          43582
        </td>
        <td>
          12360
          -
          13231
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[java.util.Date](sft, dateField, 0, new java.util.Date(), new java.util.Date(), StatsBasedEstimator.this.getHistogram$default$6[java.util.Date], StatsBasedEstimator.this.getHistogram$default$7[java.util.Date]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[java.util.Date]) =&gt; {
  def inRange(interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]): Boolean = interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))));
  if (intervals.disjoint)
    0L
  else
    {
      val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
        val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
        val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
        scala.Predef.intWrapper(loIndex).to(hiIndex)
      }))(collection.this.Seq.canBuildFrom[Int]);
      if (indices.isEmpty)
        0L
      else
        indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
    }
}))
        </td>
      </tr><tr>
        <td>
          294
        </td>
        <td>
          43552
        </td>
        <td>
          12574
          -
          12595
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.max.getTime()
        </td>
      </tr><tr>
        <td>
          294
        </td>
        <td>
          43553
        </td>
        <td>
          12546
          -
          12595
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime())
        </td>
      </tr><tr>
        <td>
          294
        </td>
        <td>
          43557
        </td>
        <td>
          12518
          -
          12690
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.lower.value.forall(((x$27: java.time.ZonedDateTime) =&gt; x$27.toInstant().toEpochMilli().&lt;=(histogram.max.getTime()))).&amp;&amp;(interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime()))))
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          43554
        </td>
        <td>
          12668
          -
          12689
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.min.getTime()
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          43555
        </td>
        <td>
          12640
          -
          12689
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime())
        </td>
      </tr><tr>
        <td>
          295
        </td>
        <td>
          43556
        </td>
        <td>
          12612
          -
          12690
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.upper.value.forall(((x$28: java.time.ZonedDateTime) =&gt; x$28.toInstant().toEpochMilli().&gt;=(histogram.min.getTime())))
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          43558
        </td>
        <td>
          12710
          -
          12728
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.disjoint
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          43559
        </td>
        <td>
          12732
          -
          12734
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          43560
        </td>
        <td>
          12732
          -
          12734
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          43580
        </td>
        <td>
          12742
          -
          13225
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val indices: Seq[Int] = intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
    val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
    val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
    scala.Predef.intWrapper(loIndex).to(hiIndex)
  }))(collection.this.Seq.canBuildFrom[Int]);
  if (indices.isEmpty)
    0L
  else
    indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          43561
        </td>
        <td>
          12790
          -
          12797
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.StatsBasedEstimator.inRange
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRange(interval)
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          43570
        </td>
        <td>
          12807
          -
          12807
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          43571
        </td>
        <td>
          12766
          -
          13130
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          intervals.values.filter({
  ((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; inRange(interval))
}).flatMap[Int, Seq[Int]](((interval: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; {
  val loIndex: Int = interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0);
  val hiIndex: Int = interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1));
  scala.Predef.intWrapper(loIndex).to(hiIndex)
}))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          300
        </td>
        <td>
          43562
        </td>
        <td>
          12845
          -
          12946
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.lower.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$29: Int) =&gt; x$29.!=(-1))).getOrElse[Int](0)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          43563
        </td>
        <td>
          13029
          -
          13040
        </td>
        <td>
          Apply
        </td>
        <td>
          java.time.chrono.ChronoZonedDateTime.toInstant
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          i.toInstant()
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          43564
        </td>
        <td>
          13019
          -
          13041
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.from
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Date.from(i.toInstant())
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          43565
        </td>
        <td>
          13001
          -
          13042
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.indexOf(java.util.Date.from(i.toInstant()))
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          43566
        </td>
        <td>
          13051
          -
          13058
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$30.!=(-1)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          43567
        </td>
        <td>
          13070
          -
          13090
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          histogram.length.-(1)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          43568
        </td>
        <td>
          12971
          -
          13091
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          interval.upper.value.map[Int](((i: java.time.ZonedDateTime) =&gt; histogram.indexOf(java.util.Date.from(i.toInstant())))).filter(((x$30: Int) =&gt; x$30.!=(-1))).getOrElse[Int](histogram.length.-(1))
        </td>
      </tr><tr>
        <td>
          302
        </td>
        <td>
          43569
        </td>
        <td>
          13102
          -
          13120
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(loIndex).to(hiIndex)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43572
        </td>
        <td>
          13143
          -
          13158
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.isEmpty
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43573
        </td>
        <td>
          13162
          -
          13164
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43574
        </td>
        <td>
          13162
          -
          13164
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43575
        </td>
        <td>
          13195
          -
          13210
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(i)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43576
        </td>
        <td>
          13194
          -
          13194
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43577
        </td>
        <td>
          13212
          -
          13212
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43578
        </td>
        <td>
          13174
          -
          13215
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          43579
        </td>
        <td>
          13174
          -
          13215
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          322
        </td>
        <td>
          43584
        </td>
        <td>
          13716
          -
          13717
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          322
        </td>
        <td>
          43585
        </td>
        <td>
          13694
          -
          13694
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getFrequency$default$5
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getFrequency$default$5[Any]
        </td>
      </tr><tr>
        <td>
          322
        </td>
        <td>
          43616
        </td>
        <td>
          13676
          -
          14684
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getFrequency[Any](sft, attribute, 0, filter, StatsBasedEstimator.this.getFrequency$default$5[Any]).map[Long](((freq: org.locationtech.geomesa.utils.stats.Frequency[Any]) =&gt; {
  val absoluteError: Double = scala.math.`package`.floor(freq.size.*(freq.eps));
  val counts: Seq[Long] = if (absoluteError.&lt;(1.0))
    values.map[Long, Seq[Long]]({
      ((value: Any) =&gt; freq.count(value))
    })(collection.this.Seq.canBuildFrom[Long])
  else
    values.map[Long, Seq[Long]](((v: Any) =&gt; {
      val estimate: Long = freq.count(v);
      if (estimate.==(0L))
        0L
      else
        if (estimate.&gt;(absoluteError))
          {
            val relativeError: Double = absoluteError./(estimate);
            estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
          }
        else
          {
            val relativeError: Double = estimate./(absoluteError);
            StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
          }
    }))(collection.this.Seq.canBuildFrom[Long]);
  counts.sum[Long](math.this.Numeric.LongIsIntegral)
}))
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          43586
        </td>
        <td>
          14057
          -
          14065
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.eps
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          43587
        </td>
        <td>
          14045
          -
          14065
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.size.*(freq.eps)
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          43588
        </td>
        <td>
          14034
          -
          14066
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.floor
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.floor(freq.size.*(freq.eps))
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          43589
        </td>
        <td>
          14090
          -
          14109
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          absoluteError.&lt;(1.0)
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          43590
        </td>
        <td>
          14124
          -
          14134
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.count(value)
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          43591
        </td>
        <td>
          14123
          -
          14123
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          43592
        </td>
        <td>
          14113
          -
          14135
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]]({
  ((value: Any) =&gt; freq.count(value))
})(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          328
        </td>
        <td>
          43593
        </td>
        <td>
          14113
          -
          14135
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]]({
  ((value: Any) =&gt; freq.count(value))
})(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          43611
        </td>
        <td>
          14164
          -
          14164
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          43612
        </td>
        <td>
          14153
          -
          14653
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]](((v: Any) =&gt; {
  val estimate: Long = freq.count(v);
  if (estimate.==(0L))
    0L
  else
    if (estimate.&gt;(absoluteError))
      {
        val relativeError: Double = absoluteError./(estimate);
        estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
      }
    else
      {
        val relativeError: Double = estimate./(absoluteError);
        StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
      }
}))(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          329
        </td>
        <td>
          43613
        </td>
        <td>
          14153
          -
          14653
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          values.map[Long, Seq[Long]](((v: Any) =&gt; {
  val estimate: Long = freq.count(v);
  if (estimate.==(0L))
    0L
  else
    if (estimate.&gt;(absoluteError))
      {
        val relativeError: Double = absoluteError./(estimate);
        estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
      }
    else
      {
        val relativeError: Double = estimate./(absoluteError);
        StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
      }
}))(collection.this.Seq.canBuildFrom[Long])
        </td>
      </tr><tr>
        <td>
          330
        </td>
        <td>
          43594
        </td>
        <td>
          14196
          -
          14209
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.count(v)
        </td>
      </tr><tr>
        <td>
          331
        </td>
        <td>
          43595
        </td>
        <td>
          14224
          -
          14238
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate.==(0L)
        </td>
      </tr><tr>
        <td>
          332
        </td>
        <td>
          43596
        </td>
        <td>
          14254
          -
          14256
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          332
        </td>
        <td>
          43597
        </td>
        <td>
          14254
          -
          14256
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          333
        </td>
        <td>
          43598
        </td>
        <td>
          14278
          -
          14302
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate.&gt;(absoluteError)
        </td>
      </tr><tr>
        <td>
          333
        </td>
        <td>
          43604
        </td>
        <td>
          14304
          -
          14479
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val relativeError: Double = absoluteError./(estimate);
  estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
}
        </td>
      </tr><tr>
        <td>
          333
        </td>
        <td>
          43610
        </td>
        <td>
          14274
          -
          14643
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (estimate.&gt;(absoluteError))
  {
    val relativeError: Double = absoluteError./(estimate);
    estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
  }
else
  {
    val relativeError: Double = estimate./(absoluteError);
    StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
  }
        </td>
      </tr><tr>
        <td>
          334
        </td>
        <td>
          43599
        </td>
        <td>
          14338
          -
          14362
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          absoluteError./(estimate)
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          43600
        </td>
        <td>
          14413
          -
          14431
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$33.&lt;=(relativeError)
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          43601
        </td>
        <td>
          14440
          -
          14443
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0.5
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          43602
        </td>
        <td>
          14386
          -
          14467
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Double.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong
        </td>
      </tr><tr>
        <td>
          335
        </td>
        <td>
          43603
        </td>
        <td>
          14375
          -
          14467
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate.-(StatsBasedEstimator.ErrorThresholds.dropWhile(((x$33: Double) =&gt; x$33.&lt;=(relativeError))).head.*(0.5).*(absoluteError).toLong)
        </td>
      </tr><tr>
        <td>
          336
        </td>
        <td>
          43609
        </td>
        <td>
          14485
          -
          14643
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val relativeError: Double = estimate./(absoluteError);
  StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
}
        </td>
      </tr><tr>
        <td>
          337
        </td>
        <td>
          43605
        </td>
        <td>
          14519
          -
          14543
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          estimate./(absoluteError)
        </td>
      </tr><tr>
        <td>
          338
        </td>
        <td>
          43606
        </td>
        <td>
          14583
          -
          14600
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$34.&lt;(relativeError)
        </td>
      </tr><tr>
        <td>
          338
        </td>
        <td>
          43607
        </td>
        <td>
          14609
          -
          14612
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0.5
        </td>
      </tr><tr>
        <td>
          338
        </td>
        <td>
          43608
        </td>
        <td>
          14556
          -
          14631
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Double.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.ErrorThresholds.dropWhile(((x$34: Double) =&gt; x$34.&lt;(relativeError))).head.*(0.5).*(estimate).toLong
        </td>
      </tr><tr>
        <td>
          342
        </td>
        <td>
          43614
        </td>
        <td>
          14675
          -
          14675
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          342
        </td>
        <td>
          43615
        </td>
        <td>
          14668
          -
          14678
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          counts.sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          43617
        </td>
        <td>
          15213
          -
          15214
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          43618
        </td>
        <td>
          15216
          -
          15217
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          43619
        </td>
        <td>
          15219
          -
          15220
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          43620
        </td>
        <td>
          15191
          -
          15191
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$6
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$6[Any]
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          43621
        </td>
        <td>
          15191
          -
          15191
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.GeoMesaStats.getHistogram$default$7
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram$default$7[Any]
        </td>
      </tr><tr>
        <td>
          358
        </td>
        <td>
          43650
        </td>
        <td>
          15173
          -
          16052
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          StatsBasedEstimator.this.getHistogram[Any](sft, attribute, 0, 0, 0, StatsBasedEstimator.this.getHistogram$default$6[Any], StatsBasedEstimator.this.getHistogram$default$7[Any]).map[Long](((histogram: org.locationtech.geomesa.utils.stats.Histogram[Any]) =&gt; {
  val inRangeRanges: Seq[(Option[Any], Option[Any])] = ranges.filter(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, scala.None) =&gt; true
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), scala.None) =&gt; histogram.defaults.min(lo, histogram.max).==(lo)
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.max(up, histogram.min).==(up)
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
  }));
  val indices: Seq[Int] = inRangeRanges.flatMap[Int, Seq[Int]](((x0$2: (Option[Any], Option[Any])) =&gt; x0$2 match {
    case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((lower @ _), (upper @ _)) =&gt; {
      val lowerIndex: Int = lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0);
      val upperIndex: Int = upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1));
      scala.Predef.intWrapper(lowerIndex).to(upperIndex)
    }
  }))(collection.this.Seq.canBuildFrom[Int]);
  if (indices.isEmpty)
    0L
  else
    indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
}))
        </td>
      </tr><tr>
        <td>
          359
        </td>
        <td>
          43632
        </td>
        <td>
          15267
          -
          15668
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ranges.filter(((x0$1: (Option[Any], Option[Any])) =&gt; x0$1 match {
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, scala.None) =&gt; true
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), scala.None) =&gt; histogram.defaults.min(lo, histogram.max).==(lo)
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])(scala.None, (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.max(up, histogram.min).==(up)
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((value: Any)Some[Any]((lo @ _)), (value: Any)Some[Any]((up @ _))) =&gt; histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
}))
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          43622
        </td>
        <td>
          15320
          -
          15324
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          43623
        </td>
        <td>
          15320
          -
          15324
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          361
        </td>
        <td>
          43624
        </td>
        <td>
          15382
          -
          15429
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo)
        </td>
      </tr><tr>
        <td>
          361
        </td>
        <td>
          43625
        </td>
        <td>
          15382
          -
          15429
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo)
        </td>
      </tr><tr>
        <td>
          362
        </td>
        <td>
          43626
        </td>
        <td>
          15467
          -
          15514
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.max(up, histogram.min).==(up)
        </td>
      </tr><tr>
        <td>
          362
        </td>
        <td>
          43627
        </td>
        <td>
          15467
          -
          15514
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.max(up, histogram.min).==(up)
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          43628
        </td>
        <td>
          15589
          -
          15602
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.max
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.max
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          43629
        </td>
        <td>
          15613
          -
          15660
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.max(up, histogram.min).==(up)
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          43630
        </td>
        <td>
          15562
          -
          15660
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          43631
        </td>
        <td>
          15562
          -
          15660
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.defaults.min(lo, histogram.max).==(lo).&amp;&amp;(histogram.defaults.max(up, histogram.min).==(up))
        </td>
      </tr><tr>
        <td>
          366
        </td>
        <td>
          43639
        </td>
        <td>
          15733
          -
          15953
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val lowerIndex: Int = lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0);
  val upperIndex: Int = upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1));
  scala.Predef.intWrapper(lowerIndex).to(upperIndex)
}
        </td>
      </tr><tr>
        <td>
          366
        </td>
        <td>
          43640
        </td>
        <td>
          15711
          -
          15711
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Int]
        </td>
      </tr><tr>
        <td>
          366
        </td>
        <td>
          43641
        </td>
        <td>
          15689
          -
          15961
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          inRangeRanges.flatMap[Int, Seq[Int]](((x0$2: (Option[Any], Option[Any])) =&gt; x0$2 match {
  case (_1: Option[Any], _2: Option[Any])(Option[Any], Option[Any])((lower @ _), (upper @ _)) =&gt; {
    val lowerIndex: Int = lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0);
    val upperIndex: Int = upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1));
    scala.Predef.intWrapper(lowerIndex).to(upperIndex)
  }
}))(collection.this.Seq.canBuildFrom[Int])
        </td>
      </tr><tr>
        <td>
          367
        </td>
        <td>
          43633
        </td>
        <td>
          15761
          -
          15818
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          lower.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$35: Int) =&gt; x$35.!=(-1))).getOrElse[Int](0)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          43634
        </td>
        <td>
          15854
          -
          15871
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.indexOf(value)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          43635
        </td>
        <td>
          15880
          -
          15887
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$36.!=(-1)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          43636
        </td>
        <td>
          15899
          -
          15919
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.length.-(1)
        </td>
      </tr><tr>
        <td>
          368
        </td>
        <td>
          43637
        </td>
        <td>
          15844
          -
          15920
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          upper.map[Int]({
  ((value: Any) =&gt; histogram.indexOf(value))
}).filter(((x$36: Int) =&gt; x$36.!=(-1))).getOrElse[Int](histogram.length.-(1))
        </td>
      </tr><tr>
        <td>
          369
        </td>
        <td>
          43638
        </td>
        <td>
          15929
          -
          15953
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.runtime.RichInt.to
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(lowerIndex).to(upperIndex)
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43642
        </td>
        <td>
          15972
          -
          15987
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.isEmpty
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43643
        </td>
        <td>
          15991
          -
          15993
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43644
        </td>
        <td>
          15991
          -
          15993
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43645
        </td>
        <td>
          16024
          -
          16039
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Histogram.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          histogram.count(i)
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43646
        </td>
        <td>
          16023
          -
          16023
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43647
        </td>
        <td>
          16041
          -
          16041
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43648
        </td>
        <td>
          16003
          -
          16044
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          371
        </td>
        <td>
          43649
        </td>
        <td>
          16003
          -
          16044
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          indices.distinct.map[Long, Seq[Long]]({
  ((i: Int) =&gt; histogram.count(i))
})(collection.this.Seq.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          379
        </td>
        <td>
          43651
        </td>
        <td>
          16229
          -
          16303
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.ceil(scala.math.`package`.log(GeoMesaStats.MaxHistogramSize.toDouble)./(scala.math.`package`.log(2.0))).toInt.+(2)
        </td>
      </tr><tr>
        <td>
          381
        </td>
        <td>
          43652
        </td>
        <td>
          16342
          -
          16375
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[Double](0.1, 0.3, 0.5, 0.7, 0.9, 1.0)
        </td>
      </tr><tr>
        <td>
          392
        </td>
        <td>
          43653
        </td>
        <td>
          16815
          -
          16830
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType.getDtgField
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType(sft).getDtgField
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          43654
        </td>
        <td>
          16863
          -
          16880
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.everything
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.everything[java.util.Date]
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          43655
        </td>
        <td>
          16858
          -
          16881
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.everything[java.util.Date])
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          43656
        </td>
        <td>
          16858
          -
          16881
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.everything[java.util.Date])
        </td>
      </tr><tr>
        <td>
          394
        </td>
        <td>
          43689
        </td>
        <td>
          16903
          -
          17732
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          {
  val intervals: org.locationtech.geomesa.filter.FilterValues[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dtg, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3);
  if (intervals.disjoint)
    scala.None
  else
    {
      val dateTimes: Option[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = intervals.values.reduceOption[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](((x0$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], x1$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](x0$1, x1$1) match {
        case (_1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], _2: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])(org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])((left @ _), (right @ _)) =&gt; {
          val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
          val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
          org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
        }
      }));
      val lower: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)));
      val upper: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)));
      scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])))
    }
}
        </td>
      </tr><tr>
        <td>
          395
        </td>
        <td>
          43657
        </td>
        <td>
          16930
          -
          16972
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.FilterHelper.extractIntervals(filter, dtg, org.locationtech.geomesa.filter.FilterHelper.extractIntervals$default$3)
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          43658
        </td>
        <td>
          16985
          -
          17003
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.FilterValues.disjoint
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          intervals.disjoint
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          43659
        </td>
        <td>
          17007
          -
          17011
        </td>
        <td>
          Select
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          43660
        </td>
        <td>
          17007
          -
          17011
        </td>
        <td>
          Block
        </td>
        <td>
          scala.None
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.None
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          43688
        </td>
        <td>
          17019
          -
          17732
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          {
  val dateTimes: Option[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]] = intervals.values.reduceOption[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](((x0$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], x1$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](x0$1, x1$1) match {
    case (_1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], _2: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])(org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])((left @ _), (right @ _)) =&gt; {
      val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
      val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
      org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
    }
  }));
  val lower: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)));
  val upper: Option[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]] = dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)));
  scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])))
}
        </td>
      </tr><tr>
        <td>
          398
        </td>
        <td>
          43668
        </td>
        <td>
          17195
          -
          17377
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          {
  val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
  val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
  org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
}
        </td>
      </tr><tr>
        <td>
          398
        </td>
        <td>
          43669
        </td>
        <td>
          17121
          -
          17389
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.reduceOption
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          intervals.values.reduceOption[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](((x0$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], x1$1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]](x0$1, x1$1) match {
  case (_1: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], _2: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])(org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime], org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime])((left @ _), (right @ _)) =&gt; {
    val lower: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower);
    val upper: org.locationtech.geomesa.filter.Bounds.Bound[java.time.ZonedDateTime] = org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper);
    org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
  }
}))
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          43661
        </td>
        <td>
          17247
          -
          17257
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.lower
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          left.lower
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          43662
        </td>
        <td>
          17259
          -
          17270
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.lower
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          right.lower
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          43663
        </td>
        <td>
          17222
          -
          17271
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.smallerLowerBound
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.smallerLowerBound[java.time.ZonedDateTime](left.lower, right.lower)
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          43664
        </td>
        <td>
          17320
          -
          17330
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.upper
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          left.upper
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          43665
        </td>
        <td>
          17332
          -
          17343
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.upper
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          right.upper
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          43666
        </td>
        <td>
          17296
          -
          17344
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.largerUpperBound
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.largerUpperBound[java.time.ZonedDateTime](left.upper, right.upper)
        </td>
      </tr><tr>
        <td>
          401
        </td>
        <td>
          43667
        </td>
        <td>
          17357
          -
          17377
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.apply[java.time.ZonedDateTime](lower, upper)
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          43670
        </td>
        <td>
          17470
          -
          17481
        </td>
        <td>
          Apply
        </td>
        <td>
          java.time.chrono.ChronoZonedDateTime.toInstant
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          i.toInstant()
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          43671
        </td>
        <td>
          17460
          -
          17482
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.from
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          java.util.Date.from(i.toInstant())
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          43672
        </td>
        <td>
          17437
          -
          17483
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant())))
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          43673
        </td>
        <td>
          17485
          -
          17502
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.inclusive
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.lower.inclusive
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          43674
        </td>
        <td>
          17431
          -
          17503
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)
        </td>
      </tr><tr>
        <td>
          403
        </td>
        <td>
          43675
        </td>
        <td>
          17412
          -
          17504
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.lower.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.lower.inclusive)))
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          43676
        </td>
        <td>
          17585
          -
          17596
        </td>
        <td>
          Apply
        </td>
        <td>
          java.time.chrono.ChronoZonedDateTime.toInstant
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          i.toInstant()
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          43677
        </td>
        <td>
          17575
          -
          17597
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.from
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          java.util.Date.from(i.toInstant())
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          43678
        </td>
        <td>
          17552
          -
          17598
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant())))
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          43679
        </td>
        <td>
          17600
          -
          17617
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.inclusive
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          d.upper.inclusive
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          43680
        </td>
        <td>
          17546
          -
          17618
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)
        </td>
      </tr><tr>
        <td>
          404
        </td>
        <td>
          43681
        </td>
        <td>
          17527
          -
          17619
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.map
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          dateTimes.map[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](((d: org.locationtech.geomesa.filter.Bounds[java.time.ZonedDateTime]) =&gt; org.locationtech.geomesa.filter.Bounds.Bound.apply[java.util.Date](d.upper.value.map[java.util.Date](((i: java.time.ZonedDateTime) =&gt; java.util.Date.from(i.toInstant()))), d.upper.inclusive)))
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          43682
        </td>
        <td>
          17658
          -
          17679
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          43683
        </td>
        <td>
          17642
          -
          17680
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          43684
        </td>
        <td>
          17698
          -
          17719
        </td>
        <td>
          TypeApply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          43685
        </td>
        <td>
          17682
          -
          17720
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          43686
        </td>
        <td>
          17635
          -
          17721
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.filter.Bounds.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]))
        </td>
      </tr><tr>
        <td>
          405
        </td>
        <td>
          43687
        </td>
        <td>
          17630
          -
          17722
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Some.apply[org.locationtech.geomesa.filter.Bounds[java.util.Date]](org.locationtech.geomesa.filter.Bounds.apply[java.util.Date](lower.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date]), upper.getOrElse[org.locationtech.geomesa.filter.Bounds.Bound[java.util.Date]](org.locationtech.geomesa.filter.Bounds.Bound.unbounded[java.util.Date])))
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>