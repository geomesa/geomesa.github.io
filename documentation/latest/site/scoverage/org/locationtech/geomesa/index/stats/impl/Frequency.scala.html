<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          org/locationtech/geomesa/index/stats/impl/Frequency.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier, monospace;'>1 <span style=''>/***********************************************************************
</span>2 <span style=''> * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
</span>3 <span style=''> * All rights reserved. This program and the accompanying materials
</span>4 <span style=''> * are made available under the terms of the Apache License, Version 2.0
</span>5 <span style=''> * which accompanies this distribution and is available at
</span>6 <span style=''> * https://www.apache.org/licenses/LICENSE-2.0
</span>7 <span style=''> ***********************************************************************/
</span>8 <span style=''>
</span>9 <span style=''>package org.locationtech.geomesa.index.stats.impl
</span>10 <span style=''>
</span>11 <span style=''>import com.clearspring.analytics.stream.frequency.IFrequency
</span>12 <span style=''>import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
</span>13 <span style=''>import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
</span>14 <span style=''>import org.locationtech.geomesa.curve.{BinnedTime, Z2SFC}
</span>15 <span style=''>import org.locationtech.geomesa.index.stats.Stat
</span>16 <span style=''>import org.locationtech.geomesa.index.stats.clearspring.CountMinSketch
</span>17 <span style=''>import org.locationtech.geomesa.zorder.sfcurve.IndexRange
</span>18 <span style=''>import org.locationtech.jts.geom.Geometry
</span>19 <span style=''>
</span>20 <span style=''>import java.util.{Date, Locale}
</span>21 <span style=''>import scala.collection.immutable.ListMap
</span>22 <span style=''>import scala.reflect.ClassTag
</span>23 <span style=''>
</span>24 <span style=''>/**
</span>25 <span style=''>  *  Estimates frequency counts at scale
</span>26 <span style=''>  *
</span>27 <span style=''>  * @param sft simple feature type
</span>28 <span style=''>  * @param property attribute the sketch is being made for
</span>29 <span style=''>  * @param dtg primary date attribute of the sft, if there is one
</span>30 <span style=''>  * @param period time period to use for splitting by date
</span>31 <span style=''>  * @param eps (epsilon) with probability at least @see confidence, estimates will be within eps * N
</span>32 <span style=''>  * @param confidence percent - with probability at least confidence, estimates will be within @see eps * N
</span>33 <span style=''>  * @param precision for geometry types, this is the number of bits of z-index to keep (max of 64)
</span>34 <span style=''>  *                  (note: first 2 bits do not hold any info)
</span>35 <span style=''>  *                  for date types, this is the number of milliseconds to group for binning
</span>36 <span style=''>  *                  for number types, this is the number of digits that will be grouped together
</span>37 <span style=''>  *                  for floating point types, this is the number of decimal places that will be considered
</span>38 <span style=''>  *                  for string types, this is the number of characters that will be considered
</span>39 <span style=''>  * @param ct class tag
</span>40 <span style=''>  * @tparam T type parameter, should match the type binding of the attribute
</span>41 <span style=''>  */
</span>42 <span style=''>class Frequency[T](
</span>43 <span style=''>    val sft: SimpleFeatureType,
</span>44 <span style=''>    val property: String,
</span>45 <span style=''>    val dtg: Option[String],
</span>46 <span style=''>    val period: TimePeriod,
</span>47 <span style=''>    val precision: Int,
</span>48 <span style=''>    val eps: Double = 0.005,
</span>49 <span style=''>    val confidence: Double = 0.95
</span>50 <span style=''>  )(
</span>51 <span style=''>    implicit val ct: ClassTag[T]
</span>52 <span style=''>  ) extends Stat {
</span>53 <span style=''>
</span>54 <span style=''>  override type S = Frequency[T]
</span>55 <span style=''>
</span>56 <span style=''>  private val i = </span><span style='background: #AEF1AE'>sft.indexOf(property)</span><span style=''>
</span>57 <span style=''>  private val d = </span><span style='background: #AEF1AE'>dtg.map(sft.indexOf).getOrElse(-1)</span><span style=''>
</span>58 <span style=''>
</span>59 <span style=''>  private [stats] val sketchMap = </span><span style='background: #AEF1AE'>scala.collection.mutable.Map.empty[Short, CountMinSketch]</span><span style=''>
</span>60 <span style=''>  private [stats] def newSketch = </span><span style='background: #AEF1AE'>CountMinSketch(eps, confidence, Frequency.Seed)</span><span style=''>
</span>61 <span style=''>  private val timeToBin = </span><span style='background: #AEF1AE'>BinnedTime.timeToBinnedTime(period)</span><span style=''>
</span>62 <span style=''>
</span>63 <span style=''>  private val addAttribute = </span><span style='background: #AEF1AE'>Frequency.add[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span><span style=''>
</span>64 <span style=''>  private val getCount = </span><span style='background: #AEF1AE'>Frequency.count[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span><span style=''>
</span>65 <span style=''>
</span>66 <span style=''>  /**
</span>67 <span style=''>    * Gets the time bins covered by this frequency
</span>68 <span style=''>    *
</span>69 <span style=''>    * @return
</span>70 <span style=''>    */
</span>71 <span style=''>  def timeBins: Seq[Short] = </span><span style='background: #F0ADAD'>sketchMap.keys.toSeq.sorted</span><span style=''>
</span>72 <span style=''>
</span>73 <span style=''>  /**
</span>74 <span style=''>    * Gets the count for a given value, across all time bins
</span>75 <span style=''>    *
</span>76 <span style=''>    * @param value value to consider
</span>77 <span style=''>    * @return count of the value
</span>78 <span style=''>    */
</span>79 <span style=''>  def count(value: T): Long = if (</span><span style='background: #AEF1AE'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #AEF1AE'>sketchMap.values.map(getCount(_, value)).sum</span><span style=''> }
</span>80 <span style=''>
</span>81 <span style=''>  /**
</span>82 <span style=''>    * Gets the count for a given value in a particular time bin
</span>83 <span style=''>    *
</span>84 <span style=''>    * @param timeBin period since the epoch
</span>85 <span style=''>    * @param value value to consider
</span>86 <span style=''>    * @return count of the value
</span>87 <span style=''>    */
</span>88 <span style=''>  def count(timeBin: Short, value: T): Long = </span><span style='background: #AEF1AE'>sketchMap.get(timeBin).map(getCount(_, value)).getOrElse(0L)</span><span style=''>
</span>89 <span style=''>
</span>90 <span style=''>  /**
</span>91 <span style=''>    * Gets the count for a given value, which has already been converted into a string, across all time bins.
</span>92 <span style=''>    * Useful if you know the string key space ahead of time.
</span>93 <span style=''>    *
</span>94 <span style=''>    * @param value value to consider, converted into an appropriate string key
</span>95 <span style=''>    * @return count of the value
</span>96 <span style=''>    */
</span>97 <span style=''>  def countDirect(value: String): Long =
</span>98 <span style=''>    if (</span><span style='background: #F0ADAD'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #F0ADAD'>sketchMap.values.map(_.estimateCount(value)).sum</span><span style=''> }
</span>99 <span style=''>
</span>100 <span style=''>  /**
</span>101 <span style=''>    * Gets the count for a given value, which has already been converted into a string. Useful
</span>102 <span style=''>    * if you know the string key space ahead of time.
</span>103 <span style=''>    *
</span>104 <span style=''>    * @param timeBin period since the epoch
</span>105 <span style=''>    * @param value value to consider, converted into an appropriate string key
</span>106 <span style=''>    * @return count of the value
</span>107 <span style=''>    */
</span>108 <span style=''>  def countDirect(timeBin: Short, value: String): Long =
</span>109 <span style=''>    </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span><span style=''>
</span>110 <span style=''>
</span>111 <span style=''>  /**
</span>112 <span style=''>    * Gets the count for a given value, which has already been converted into a long, across all time bins.
</span>113 <span style=''>    * Useful if you know the long key space ahead of time (e.g. with z-values).
</span>114 <span style=''>    *
</span>115 <span style=''>    * @param value value to consider, converted into an appropriate long key
</span>116 <span style=''>    * @return count of the value
</span>117 <span style=''>    */
</span>118 <span style=''>  def countDirect(value: Long): Long =
</span>119 <span style=''>    if (</span><span style='background: #F0ADAD'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #F0ADAD'>sketchMap.values.map(_.estimateCount(value)).sum</span><span style=''> }
</span>120 <span style=''>
</span>121 <span style=''>  /**
</span>122 <span style=''>    * Gets the count for a given value, which has already been converted into a long. Useful
</span>123 <span style=''>    * if you know the long key space ahead of time (e.g. with z-values).
</span>124 <span style=''>    *
</span>125 <span style=''>    * @param timeBin period since the epoch
</span>126 <span style=''>    * @param value value to consider, converted into an appropriate long key
</span>127 <span style=''>    * @return count of the value
</span>128 <span style=''>    */
</span>129 <span style=''>  def countDirect(timeBin: Short, value: Long): Long =
</span>130 <span style=''>    </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span><span style=''>
</span>131 <span style=''>
</span>132 <span style=''>  /**
</span>133 <span style=''>    * Number of observations in the frequency map
</span>134 <span style=''>    *
</span>135 <span style=''>    * @return number of observations
</span>136 <span style=''>    */
</span>137 <span style=''>  def size: Long = if (</span><span style='background: #AEF1AE'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #AEF1AE'>0L</span><span style=''> } else { </span><span style='background: #AEF1AE'>sketchMap.values.map(_.size).sum</span><span style=''> }
</span>138 <span style=''>
</span>139 <span style=''>  /**
</span>140 <span style=''>    * Number of observations in the frequency map
</span>141 <span style=''>    *
</span>142 <span style=''>    * @return number of observations
</span>143 <span style=''>    */
</span>144 <span style=''>  def size(timeBin: Short): Long = </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.size).getOrElse(0L)</span><span style=''>
</span>145 <span style=''>
</span>146 <span style=''>  /**
</span>147 <span style=''>    * Split the stat into a separate stat per time bin of z data. Allows for separate handling of the reduced
</span>148 <span style=''>    * data set.
</span>149 <span style=''>    *
</span>150 <span style=''>    * @return
</span>151 <span style=''>    */
</span>152 <span style=''>  def splitByTime: Seq[(Short, Frequency[T])] = {
</span>153 <span style=''>    </span><span style='background: #AEF1AE'>sketchMap.toSeq.map { case (w, sketch) =&gt;
</span>154 <span style=''></span><span style='background: #AEF1AE'>      val freq = new Frequency[T](sft, property, dtg, period, precision, eps, confidence)
</span>155 <span style=''></span><span style='background: #AEF1AE'>      freq.sketchMap.put(w, sketch)
</span>156 <span style=''></span><span style='background: #AEF1AE'>      (w, freq)
</span>157 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>158 <span style=''>  }
</span>159 <span style=''>
</span>160 <span style=''>  override def observe(sf: SimpleFeature): Unit = {
</span>161 <span style=''>    val value = </span><span style='background: #AEF1AE'>sf.getAttribute(i).asInstanceOf[T]</span><span style=''>
</span>162 <span style=''>    if (</span><span style='background: #AEF1AE'>value != null</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>163 <span style=''></span><span style='background: #AEF1AE'>      val timeBin: Short = if (d == -1) { Frequency.DefaultTimeBin } else {
</span>164 <span style=''></span><span style='background: #AEF1AE'>        val dtg = sf.getAttribute(d).asInstanceOf[Date]
</span>165 <span style=''></span><span style='background: #AEF1AE'>        if (dtg == null) { </span><span style='background: #F0ADAD'>Frequency.DefaultTimeBin</span><span style='background: #AEF1AE'> } else { timeToBin(dtg.getTime).bin }
</span>166 <span style=''></span><span style='background: #AEF1AE'>      }
</span>167 <span style=''></span><span style='background: #AEF1AE'>      addAttribute(sketchMap.getOrElseUpdate(timeBin, newSketch), value)
</span>168 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>169 <span style=''>  }
</span>170 <span style=''>
</span>171 <span style=''>  // no-op
</span>172 <span style=''>  override def unobserve(sf: SimpleFeature): Unit = </span><span style='background: #AEF1AE'>{}</span><span style=''>
</span>173 <span style=''>
</span>174 <span style=''>  override def +(other: Frequency[T]): Frequency[T] = {
</span>175 <span style=''>    val plus = </span><span style='background: #AEF1AE'>new Frequency[T](sft, property, dtg, period, precision, eps, confidence)</span><span style=''>
</span>176 <span style=''>    </span><span style='background: #AEF1AE'>plus += this</span><span style=''>
</span>177 <span style=''>    </span><span style='background: #AEF1AE'>plus += other</span><span style=''>
</span>178 <span style=''>    plus
</span>179 <span style=''>  }
</span>180 <span style=''>
</span>181 <span style=''>  override def +=(other: Frequency[T]): Unit = {
</span>182 <span style=''>    </span><span style='background: #AEF1AE'>other.sketchMap.foreach { case (w, sketch) =&gt;
</span>183 <span style=''></span><span style='background: #AEF1AE'>      sketchMap.get(w) match {
</span>184 <span style=''></span><span style='background: #AEF1AE'>        case None =&gt; sketchMap.put(w, sketch) // note: sharing a reference now
</span>185 <span style=''></span><span style='background: #AEF1AE'>        case Some(s) =&gt; s += sketch
</span>186 <span style=''></span><span style='background: #AEF1AE'>      }
</span>187 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>188 <span style=''>  }
</span>189 <span style=''>
</span>190 <span style=''>  override def clear(): Unit = </span><span style='background: #AEF1AE'>sketchMap.values.foreach(_.clear())</span><span style=''>
</span>191 <span style=''>
</span>192 <span style=''>  override def isEmpty: Boolean = </span><span style='background: #AEF1AE'>sketchMap.isEmpty || sketchMap.values.forall(_.size == 0)</span><span style=''>
</span>193 <span style=''>
</span>194 <span style=''>  override def toJsonObject = </span><span style='background: #AEF1AE'>ListMap(&quot;epsilon&quot; -&gt; eps, &quot;confidence&quot; -&gt; confidence, &quot;size&quot; -&gt; size)</span><span style=''>
</span>195 <span style=''>
</span>196 <span style=''>  override def isEquivalent(other: Stat): Boolean = {
</span>197 <span style=''>    other match {
</span>198 <span style=''>      case s: Frequency[T] =&gt;
</span>199 <span style=''>        </span><span style='background: #AEF1AE'>property == s.property &amp;&amp; dtg == s.dtg &amp;&amp; period == s.period &amp;&amp; precision == s.precision &amp;&amp; {
</span>200 <span style=''></span><span style='background: #AEF1AE'>          val sketches = sketchMap.filter(_._2.size != 0)
</span>201 <span style=''></span><span style='background: #AEF1AE'>          val otherSketches = s.sketchMap.filter(_._2.size != 0)
</span>202 <span style=''></span><span style='background: #AEF1AE'>          sketches.keySet == otherSketches.keySet &amp;&amp; sketches.forall {
</span>203 <span style=''></span><span style='background: #AEF1AE'>            case (w, sketch) =&gt; sketch.isEquivalent(otherSketches(w))
</span>204 <span style=''></span><span style='background: #AEF1AE'>          }
</span>205 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>206 <span style=''>      case _ =&gt; </span><span style='background: #F0ADAD'>false</span><span style=''>
</span>207 <span style=''>    }
</span>208 <span style=''>  }
</span>209 <span style=''>}
</span>210 <span style=''>
</span>211 <span style=''>object Frequency {
</span>212 <span style=''>
</span>213 <span style=''>  // the seed for our frequencies - frequencies can only be combined if they have the same seed.
</span>214 <span style=''>  val Seed: Int = </span><span style='background: #AEF1AE'>-27</span><span style=''>
</span>215 <span style=''>
</span>216 <span style=''>  // default time bin we use for features without a date
</span>217 <span style=''>  val DefaultTimeBin: Short = </span><span style='background: #AEF1AE'>0</span><span style=''>
</span>218 <span style=''>
</span>219 <span style=''>  /**
</span>220 <span style=''>    * Enumerate all the values contained in a sequence of ranges, using the supplied precision.
</span>221 <span style=''>    * Because frequency can only do point lookups, this can be used to convert a range into a sequence
</span>222 <span style=''>    * of points.
</span>223 <span style=''>    *
</span>224 <span style=''>    * For example, [1, 4] would be converted into Seq(1, 2, 3, 4)
</span>225 <span style=''>    *
</span>226 <span style=''>    * @param ranges ranges to enumerate
</span>227 <span style=''>    * @param precision precision of the ranges, in bits [1, 64]
</span>228 <span style=''>    * @return the enumerated values
</span>229 <span style=''>    */
</span>230 <span style=''>  def enumerate(ranges: Seq[IndexRange], precision: Long): Iterator[Long] = {
</span>231 <span style=''>    val shift = </span><span style='background: #AEF1AE'>64 - precision</span><span style=''>
</span>232 <span style=''>    </span><span style='background: #AEF1AE'>ranges.toIterator.flatMap { r =&gt;
</span>233 <span style=''></span><span style='background: #AEF1AE'>      val c = (r.upper &gt;&gt; shift) - (r.lower &gt;&gt; shift)
</span>234 <span style=''></span><span style='background: #AEF1AE'>      new Iterator[Long] {
</span>235 <span style=''></span><span style='background: #AEF1AE'>        var i = 0L
</span>236 <span style=''></span><span style='background: #AEF1AE'>        override def hasNext: Boolean = i &lt;= c
</span>237 <span style=''></span><span style='background: #AEF1AE'>        override def next(): Long = try { r.lower + (i &lt;&lt; shift) } finally { i += 1 }
</span>238 <span style=''></span><span style='background: #AEF1AE'>      }
</span>239 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>240 <span style=''>  }
</span>241 <span style=''>
</span>242 <span style=''>  private def add[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Unit = {
</span>243 <span style=''>    if (</span><span style='background: #AEF1AE'>classOf[Geometry].isAssignableFrom(clas)</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>244 <span style=''></span><span style='background: #AEF1AE'>      val mask = getMask(precision)
</span>245 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(geomToKey(value.asInstanceOf[Geometry], mask), 1L)
</span>246 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else </span><span style='background: #AEF1AE'>if (classOf[Date].isAssignableFrom(clas)) {
</span>247 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(dateToKey(value.asInstanceOf[Date], precision), 1L)
</span>248 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[String]) {
</span>249 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(stringToKey(value.asInstanceOf[String], precision), 1L)
</span>250 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Long]) {
</span>251 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(longToKey(value.asInstanceOf[Long], precision), 1L)
</span>252 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[Integer]) {
</span>253 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(intToKey(value.asInstanceOf[Int], precision), 1L)
</span>254 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Float]) {
</span>255 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(floatToKey(value.asInstanceOf[Float], precision), 1L)
</span>256 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Double]) {
</span>257 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(doubleToKey(value.asInstanceOf[Double], precision), 1L)
</span>258 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>259 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span><span style='background: #AEF1AE'>
</span>260 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>261 <span style=''>  }
</span>262 <span style=''>
</span>263 <span style=''>  private def count[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Long = {
</span>264 <span style=''>    if (</span><span style='background: #AEF1AE'>classOf[Geometry].isAssignableFrom(clas)</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>265 <span style=''></span><span style='background: #AEF1AE'>      val mask = getMask(precision)
</span>266 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(geomToKey(value.asInstanceOf[Geometry], mask))
</span>267 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else </span><span style='background: #AEF1AE'>if (classOf[Date].isAssignableFrom(clas)) {
</span>268 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(dateToKey(value.asInstanceOf[Date], precision))
</span>269 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[String]) {
</span>270 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(stringToKey(value.asInstanceOf[String], precision))
</span>271 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Long]) {
</span>272 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(longToKey(value.asInstanceOf[Long], precision))
</span>273 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[Integer]) {
</span>274 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(intToKey(value.asInstanceOf[Int], precision))
</span>275 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Float]) {
</span>276 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(floatToKey(value.asInstanceOf[Float], precision))
</span>277 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Double]) {
</span>278 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(doubleToKey(value.asInstanceOf[Double], precision))
</span>279 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>280 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span><span style='background: #AEF1AE'>
</span>281 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>282 <span style=''>  }
</span>283 <span style=''>
</span>284 <span style=''>  // mask for right-zeroing bits
</span>285 <span style=''>  private [stats] def getMask(precision: Int): Long = {
</span>286 <span style=''>    </span><span style='background: #AEF1AE'>require(precision &gt;= 0 &amp;&amp; precision &lt;= 64, </span><span style='background: #F0ADAD'>&quot;Precision must be in the range [0, 64]&quot;</span><span style='background: #AEF1AE'>)</span><span style=''>
</span>287 <span style=''>    </span><span style='background: #AEF1AE'>Long.MaxValue &lt;&lt; (64 - precision)</span><span style=''>
</span>288 <span style=''>  }
</span>289 <span style=''>
</span>290 <span style=''>  private [stats] def geomToKey(value: Geometry, mask: Long): Long = {
</span>291 <span style=''>    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
</span>292 <span style=''>    val centroid = </span><span style='background: #AEF1AE'>value.safeCentroid()</span><span style=''>
</span>293 <span style=''>    </span><span style='background: #AEF1AE'>Z2SFC.index(centroid.getX, centroid.getY) &amp; mask</span><span style=''>
</span>294 <span style=''>  }
</span>295 <span style=''>
</span>296 <span style=''>  private [stats] def stringToKey(value: String, precision: Int): String = {
</span>297 <span style=''>    if (</span><span style='background: #AEF1AE'>value.length &gt; precision</span><span style=''>) {
</span>298 <span style=''>      </span><span style='background: #AEF1AE'>value.substring(0, precision).toLowerCase(Locale.US)</span><span style=''>
</span>299 <span style=''>    } else {
</span>300 <span style=''>      </span><span style='background: #AEF1AE'>value.toLowerCase(Locale.US)</span><span style=''>
</span>301 <span style=''>    }
</span>302 <span style=''>  }
</span>303 <span style=''>  private [stats] def dateToKey(value: Date, precision: Int): Long = </span><span style='background: #AEF1AE'>value.getTime / precision</span><span style=''>
</span>304 <span style=''>  private [stats] def longToKey(value: Long, precision: Int): Long = </span><span style='background: #AEF1AE'>value / precision</span><span style=''>
</span>305 <span style=''>  private [stats] def intToKey(value: Int, precision: Int): Long = </span><span style='background: #AEF1AE'>value / precision</span><span style=''>
</span>306 <span style=''>  private [stats] def floatToKey(value: Float, precision: Int): Long = </span><span style='background: #AEF1AE'>math.round(value * precision)</span><span style=''>
</span>307 <span style=''>  private [stats] def doubleToKey(value: Double, precision: Int): Long = </span><span style='background: #AEF1AE'>math.round(value * precision)</span><span style=''>
</span>308 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Tests</th>
        <th>Code</th>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          38945
        </td>
        <td>
          2582
          -
          2590
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          38946
        </td>
        <td>
          2570
          -
          2591
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.feature.simple.SimpleFeatureType.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft.indexOf(Frequency.this.property)
        </td>
      </tr><tr>
        <td>
          57
        </td>
        <td>
          38947
        </td>
        <td>
          2610
          -
          2644
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg.map[Int]({
  ((x$1: String) =&gt; Frequency.this.sft.indexOf(x$1))
}).getOrElse[Int](-1)
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          38948
        </td>
        <td>
          2680
          -
          2737
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Map.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.mutable.Map.empty[Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch]
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          38949
        </td>
        <td>
          2787
          -
          2790
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          38950
        </td>
        <td>
          2792
          -
          2802
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          38951
        </td>
        <td>
          2804
          -
          2818
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.Seed
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.Seed
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          38952
        </td>
        <td>
          2772
          -
          2819
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.apply(Frequency.this.eps, Frequency.this.confidence, Frequency.Seed)
        </td>
      </tr><tr>
        <td>
          61
        </td>
        <td>
          38953
        </td>
        <td>
          2874
          -
          2880
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          61
        </td>
        <td>
          38954
        </td>
        <td>
          2846
          -
          2881
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.timeToBinnedTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.BinnedTime.timeToBinnedTime(Frequency.this.period)
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          38955
        </td>
        <td>
          2929
          -
          2967
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]]
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          38956
        </td>
        <td>
          2969
          -
          2978
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          38957
        </td>
        <td>
          2912
          -
          2979
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.add[T](Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]], Frequency.this.precision)
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          38958
        </td>
        <td>
          3024
          -
          3062
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]]
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          38959
        </td>
        <td>
          3064
          -
          3073
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          64
        </td>
        <td>
          38960
        </td>
        <td>
          3005
          -
          3074
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.count[T](Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]], Frequency.this.precision)
        </td>
      </tr><tr>
        <td>
          71
        </td>
        <td>
          38961
        </td>
        <td>
          3210
          -
          3210
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Ordering.Short
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Ordering.Short
        </td>
      </tr><tr>
        <td>
          71
        </td>
        <td>
          38962
        </td>
        <td>
          3189
          -
          3216
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.sorted
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.keys.toSeq.sorted[Short](math.this.Ordering.Short)
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38963
        </td>
        <td>
          3402
          -
          3419
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38964
        </td>
        <td>
          3423
          -
          3425
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38965
        </td>
        <td>
          3423
          -
          3425
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38966
        </td>
        <td>
          3456
          -
          3474
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getCount.apply(x$1, value)
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38967
        </td>
        <td>
          3455
          -
          3455
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38968
        </td>
        <td>
          3476
          -
          3476
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38969
        </td>
        <td>
          3435
          -
          3479
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$1: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$1, value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          38970
        </td>
        <td>
          3435
          -
          3479
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$1: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$1, value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          88
        </td>
        <td>
          38971
        </td>
        <td>
          3726
          -
          3786
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$2: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$2, value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38972
        </td>
        <td>
          4139
          -
          4156
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38973
        </td>
        <td>
          4160
          -
          4162
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38974
        </td>
        <td>
          4160
          -
          4162
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38975
        </td>
        <td>
          4193
          -
          4215
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          x$3.estimateCount(value)
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38976
        </td>
        <td>
          4192
          -
          4192
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38977
        </td>
        <td>
          4217
          -
          4217
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38978
        </td>
        <td>
          4172
          -
          4220
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$3: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$3.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          98
        </td>
        <td>
          38979
        </td>
        <td>
          4172
          -
          4220
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$3: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$3.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          38980
        </td>
        <td>
          4609
          -
          4673
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$4: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$4.estimateCount(value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38981
        </td>
        <td>
          5039
          -
          5056
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38982
        </td>
        <td>
          5060
          -
          5062
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38983
        </td>
        <td>
          5060
          -
          5062
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38984
        </td>
        <td>
          5093
          -
          5115
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          x$5.estimateCount(value)
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38985
        </td>
        <td>
          5092
          -
          5092
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38986
        </td>
        <td>
          5117
          -
          5117
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38987
        </td>
        <td>
          5072
          -
          5120
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$5: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$5.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          119
        </td>
        <td>
          38988
        </td>
        <td>
          5072
          -
          5120
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$5: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$5.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          130
        </td>
        <td>
          38989
        </td>
        <td>
          5522
          -
          5586
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$6: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$6.estimateCount(value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38990
        </td>
        <td>
          5717
          -
          5734
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38991
        </td>
        <td>
          5738
          -
          5740
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38992
        </td>
        <td>
          5738
          -
          5740
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38993
        </td>
        <td>
          5771
          -
          5777
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7.size()
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38994
        </td>
        <td>
          5770
          -
          5770
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38995
        </td>
        <td>
          5779
          -
          5779
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38996
        </td>
        <td>
          5750
          -
          5782
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$7: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$7.size()))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          137
        </td>
        <td>
          38997
        </td>
        <td>
          5750
          -
          5782
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$7: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$7.size()))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          144
        </td>
        <td>
          38998
        </td>
        <td>
          5927
          -
          5975
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$8: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$8.size())).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          39010
        </td>
        <td>
          6229
          -
          6373
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val freq: org.locationtech.geomesa.index.stats.impl.Frequency[T] = new org.locationtech.geomesa.index.stats.impl.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct);
  freq.sketchMap.put(w, sketch);
  scala.Tuple2.apply[Short, org.locationtech.geomesa.index.stats.impl.Frequency[T]](w, freq)
}
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          39011
        </td>
        <td>
          6210
          -
          6210
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Short, org.locationtech.geomesa.index.stats.impl.Frequency[T])]
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          39012
        </td>
        <td>
          6190
          -
          6379
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.toSeq.map[(Short, org.locationtech.geomesa.index.stats.impl.Frequency[T]), Seq[(Short, org.locationtech.geomesa.index.stats.impl.Frequency[T])]](((x0$1: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; {
    val freq: org.locationtech.geomesa.index.stats.impl.Frequency[T] = new org.locationtech.geomesa.index.stats.impl.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct);
    freq.sketchMap.put(w, sketch);
    scala.Tuple2.apply[Short, org.locationtech.geomesa.index.stats.impl.Frequency[T]](w, freq)
  }
}))(collection.this.Seq.canBuildFrom[(Short, org.locationtech.geomesa.index.stats.impl.Frequency[T])])
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          38999
        </td>
        <td>
          6266
          -
          6269
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.sft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39000
        </td>
        <td>
          6271
          -
          6279
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39001
        </td>
        <td>
          6281
          -
          6284
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39002
        </td>
        <td>
          6286
          -
          6292
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39003
        </td>
        <td>
          6294
          -
          6303
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39004
        </td>
        <td>
          6305
          -
          6308
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39005
        </td>
        <td>
          6310
          -
          6320
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39006
        </td>
        <td>
          6249
          -
          6249
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.ct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          39007
        </td>
        <td>
          6249
          -
          6321
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.geomesa.index.stats.impl.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct)
        </td>
      </tr><tr>
        <td>
          155
        </td>
        <td>
          39008
        </td>
        <td>
          6328
          -
          6357
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          156
        </td>
        <td>
          39009
        </td>
        <td>
          6364
          -
          6373
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Short, org.locationtech.geomesa.index.stats.impl.Frequency[T]](w, freq)
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          39013
        </td>
        <td>
          6469
          -
          6470
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.i
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.i
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          39014
        </td>
        <td>
          6453
          -
          6487
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sf.getAttribute(Frequency.this.i).asInstanceOf[T]
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          39015
        </td>
        <td>
          6496
          -
          6509
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.!=(null)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          39031
        </td>
        <td>
          6511
          -
          6821
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val timeBin: Short = if (Frequency.this.d.==(-1))
    Frequency.DefaultTimeBin
  else
    {
      val dtg: java.util.Date = sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date];
      if (dtg.==(null))
        Frequency.DefaultTimeBin
      else
        Frequency.this.timeToBin.apply(dtg.getTime()).bin
    };
  Frequency.this.addAttribute.apply(Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch), value)
}
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          39032
        </td>
        <td>
          6492
          -
          6492
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          39033
        </td>
        <td>
          6492
          -
          6492
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          39016
        </td>
        <td>
          6544
          -
          6551
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.d.==(-1)
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          39017
        </td>
        <td>
          6555
          -
          6579
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          39018
        </td>
        <td>
          6555
          -
          6579
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          39027
        </td>
        <td>
          6587
          -
          6742
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val dtg: java.util.Date = sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date];
  if (dtg.==(null))
    Frequency.DefaultTimeBin
  else
    Frequency.this.timeToBin.apply(dtg.getTime()).bin
}
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          39019
        </td>
        <td>
          6623
          -
          6624
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.d
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.d
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          39020
        </td>
        <td>
          6607
          -
          6644
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          39021
        </td>
        <td>
          6657
          -
          6668
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          dtg.==(null)
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          39022
        </td>
        <td>
          6672
          -
          6696
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          39023
        </td>
        <td>
          6672
          -
          6696
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          39024
        </td>
        <td>
          6716
          -
          6727
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          dtg.getTime()
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          39025
        </td>
        <td>
          6706
          -
          6732
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.bin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.timeToBin.apply(dtg.getTime()).bin
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          39026
        </td>
        <td>
          6706
          -
          6732
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.bin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.timeToBin.apply(dtg.getTime()).bin
        </td>
      </tr><tr>
        <td>
          167
        </td>
        <td>
          39028
        </td>
        <td>
          6797
          -
          6806
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.newSketch
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.newSketch
        </td>
      </tr><tr>
        <td>
          167
        </td>
        <td>
          39029
        </td>
        <td>
          6762
          -
          6807
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.getOrElseUpdate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch)
        </td>
      </tr><tr>
        <td>
          167
        </td>
        <td>
          39030
        </td>
        <td>
          6749
          -
          6815
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.addAttribute.apply(Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch), value)
        </td>
      </tr><tr>
        <td>
          172
        </td>
        <td>
          39034
        </td>
        <td>
          6890
          -
          6892
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39035
        </td>
        <td>
          6982
          -
          6985
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.sft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39036
        </td>
        <td>
          6987
          -
          6995
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39037
        </td>
        <td>
          6997
          -
          7000
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39038
        </td>
        <td>
          7002
          -
          7008
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39039
        </td>
        <td>
          7010
          -
          7019
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39040
        </td>
        <td>
          7021
          -
          7024
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39041
        </td>
        <td>
          7026
          -
          7036
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39042
        </td>
        <td>
          6965
          -
          6965
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.ct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          39043
        </td>
        <td>
          6965
          -
          7037
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.geomesa.index.stats.impl.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct)
        </td>
      </tr><tr>
        <td>
          176
        </td>
        <td>
          39044
        </td>
        <td>
          7042
          -
          7054
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          plus.+=(this)
        </td>
      </tr><tr>
        <td>
          177
        </td>
        <td>
          39045
        </td>
        <td>
          7059
          -
          7072
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          plus.+=(other)
        </td>
      </tr><tr>
        <td>
          182
        </td>
        <td>
          39052
        </td>
        <td>
          7140
          -
          7345
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          other.sketchMap.foreach[Any](((x0$1: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; Frequency.this.sketchMap.get(w) match {
    case scala.None =&gt; Frequency.this.sketchMap.put(w, sketch)
    case (value: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)Some[org.locationtech.geomesa.index.stats.clearspring.CountMinSketch]((s @ _)) =&gt; s.+=(sketch)
  }
}))
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          39046
        </td>
        <td>
          7192
          -
          7208
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.get
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(w)
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          39051
        </td>
        <td>
          7192
          -
          7339
        </td>
        <td>
          Match
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(w) match {
  case scala.None =&gt; Frequency.this.sketchMap.put(w, sketch)
  case (value: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)Some[org.locationtech.geomesa.index.stats.clearspring.CountMinSketch]((s @ _)) =&gt; s.+=(sketch)
}
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          39047
        </td>
        <td>
          7238
          -
          7262
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          39048
        </td>
        <td>
          7238
          -
          7262
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          39049
        </td>
        <td>
          7320
          -
          7331
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.+=(sketch)
        </td>
      </tr><tr>
        <td>
          185
        </td>
        <td>
          39050
        </td>
        <td>
          7320
          -
          7331
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.+=(sketch)
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          39053
        </td>
        <td>
          7407
          -
          7416
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.clear
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9.clear()
        </td>
      </tr><tr>
        <td>
          190
        </td>
        <td>
          39054
        </td>
        <td>
          7382
          -
          7417
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.foreach[Unit](((x$9: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$9.clear()))
        </td>
      </tr><tr>
        <td>
          192
        </td>
        <td>
          39055
        </td>
        <td>
          7498
          -
          7509
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10.size().==(0)
        </td>
      </tr><tr>
        <td>
          192
        </td>
        <td>
          39056
        </td>
        <td>
          7474
          -
          7510
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.forall(((x$10: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$10.size().==(0)))
        </td>
      </tr><tr>
        <td>
          192
        </td>
        <td>
          39057
        </td>
        <td>
          7453
          -
          7510
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty.||(Frequency.this.sketchMap.values.forall(((x$10: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch) =&gt; x$10.size().==(0))))
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39058
        </td>
        <td>
          7550
          -
          7559
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;epsilon&quot;
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39059
        </td>
        <td>
          7563
          -
          7566
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39060
        </td>
        <td>
          7550
          -
          7566
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;epsilon&quot;).-&gt;[Double](Frequency.this.eps)
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39061
        </td>
        <td>
          7568
          -
          7580
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;confidence&quot;
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39062
        </td>
        <td>
          7584
          -
          7594
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39063
        </td>
        <td>
          7568
          -
          7594
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;confidence&quot;).-&gt;[Double](Frequency.this.confidence)
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39064
        </td>
        <td>
          7596
          -
          7602
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;size&quot;
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39065
        </td>
        <td>
          7606
          -
          7610
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.size
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39066
        </td>
        <td>
          7596
          -
          7610
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;size&quot;).-&gt;[Long](Frequency.this.size)
        </td>
      </tr><tr>
        <td>
          194
        </td>
        <td>
          39067
        </td>
        <td>
          7542
          -
          7611
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenMapFactory.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.ListMap.apply[String, AnyVal](scala.Predef.ArrowAssoc[String](&quot;epsilon&quot;).-&gt;[Double](Frequency.this.eps), scala.Predef.ArrowAssoc[String](&quot;confidence&quot;).-&gt;[Double](Frequency.this.confidence), scala.Predef.ArrowAssoc[String](&quot;size&quot;).-&gt;[Long](Frequency.this.size))
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39068
        </td>
        <td>
          7735
          -
          7745
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.property
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39069
        </td>
        <td>
          7756
          -
          7761
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.dtg
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39070
        </td>
        <td>
          7749
          -
          7761
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg.==(s.dtg)
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39071
        </td>
        <td>
          7775
          -
          7783
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.period
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39072
        </td>
        <td>
          7765
          -
          7783
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period.==(s.period)
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39073
        </td>
        <td>
          7800
          -
          7811
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.precision
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39074
        </td>
        <td>
          7787
          -
          7811
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision.==(s.precision)
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39085
        </td>
        <td>
          7723
          -
          8102
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property.==(s.property).&amp;&amp;(Frequency.this.dtg.==(s.dtg)).&amp;&amp;(Frequency.this.period.==(s.period)).&amp;&amp;(Frequency.this.precision.==(s.precision)).&amp;&amp;({
  val sketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.index.stats.clearspring.CountMinSketch] = Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)));
  val otherSketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.index.stats.clearspring.CountMinSketch] = s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)));
  sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x0$1 match {
    case (_1: Short, _2: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
  })))
})
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          39086
        </td>
        <td>
          7723
          -
          8102
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property.==(s.property).&amp;&amp;(Frequency.this.dtg.==(s.dtg)).&amp;&amp;(Frequency.this.period.==(s.period)).&amp;&amp;(Frequency.this.precision.==(s.precision)).&amp;&amp;({
  val sketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.index.stats.clearspring.CountMinSketch] = Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)));
  val otherSketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.index.stats.clearspring.CountMinSketch] = s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)));
  sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x0$1 match {
    case (_1: Short, _2: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
  })))
})
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          39075
        </td>
        <td>
          7859
          -
          7873
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._2.size().!=(0)
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          39076
        </td>
        <td>
          7842
          -
          7874
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)))
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          39077
        </td>
        <td>
          7924
          -
          7938
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$12._2.size().!=(0)
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          39078
        </td>
        <td>
          7905
          -
          7939
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)))
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          39079
        </td>
        <td>
          7969
          -
          7989
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.keySet
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          otherSketches.keySet
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          39083
        </td>
        <td>
          7993
          -
          8092
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketches.forall(((x0$1: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
}))
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          39084
        </td>
        <td>
          7950
          -
          8092
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.index.stats.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
})))
        </td>
      </tr><tr>
        <td>
          203
        </td>
        <td>
          39080
        </td>
        <td>
          8063
          -
          8079
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          otherSketches.apply(w)
        </td>
      </tr><tr>
        <td>
          203
        </td>
        <td>
          39081
        </td>
        <td>
          8043
          -
          8080
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.isEquivalent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.isEquivalent(otherSketches.apply(w))
        </td>
      </tr><tr>
        <td>
          203
        </td>
        <td>
          39082
        </td>
        <td>
          8043
          -
          8080
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.clearspring.CountMinSketch.isEquivalent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.isEquivalent(otherSketches.apply(w))
        </td>
      </tr><tr>
        <td>
          206
        </td>
        <td>
          39087
        </td>
        <td>
          8119
          -
          8124
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          206
        </td>
        <td>
          39088
        </td>
        <td>
          8119
          -
          8124
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          214
        </td>
        <td>
          39089
        </td>
        <td>
          8273
          -
          8276
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          -27
        </td>
      </tr><tr>
        <td>
          217
        </td>
        <td>
          39090
        </td>
        <td>
          8365
          -
          8366
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          231
        </td>
        <td>
          39091
        </td>
        <td>
          8909
          -
          8923
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          64.-(precision)
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          39103
        </td>
        <td>
          8928
          -
          9207
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.Iterator.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ranges.toIterator.flatMap[Long](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
  val c: Long = r.upper.&gt;&gt;(shift).-(r.lower.&gt;&gt;(shift));
  {
    final class $anon extends AnyRef with Iterator[Long] {
      def &lt;init&gt;(): &lt;$anon: Iterator[Long]&gt; = {
        $anon.super.&lt;init&gt;();
        ()
      };
      private[this] var i: Long = 0L;
      &lt;accessor&gt; private def i: Long = $anon.this.i;
      &lt;accessor&gt; private def i_=(x$1: Long): Unit = $anon.this.i = x$1;
      override def hasNext: Boolean = $anon.this.i.&lt;=(c);
      override def next(): Long = try {
        r.lower.+($anon.this.i.&lt;&lt;(shift))
      } finally $anon.this.i_=($anon.this.i.+(1))
    };
    new $anon()
  }
}))
        </td>
      </tr><tr>
        <td>
          233
        </td>
        <td>
          39092
        </td>
        <td>
          8997
          -
          9013
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.&gt;&gt;(shift)
        </td>
      </tr><tr>
        <td>
          233
        </td>
        <td>
          39093
        </td>
        <td>
          8975
          -
          9014
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.upper.&gt;&gt;(shift).-(r.lower.&gt;&gt;(shift))
        </td>
      </tr><tr>
        <td>
          234
        </td>
        <td>
          39102
        </td>
        <td>
          9021
          -
          9024
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anon.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new $anon()
        </td>
      </tr><tr>
        <td>
          235
        </td>
        <td>
          39094
        </td>
        <td>
          9058
          -
          9060
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          39095
        </td>
        <td>
          9101
          -
          9107
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.&lt;=(c)
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          39096
        </td>
        <td>
          9161
          -
          9171
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.&lt;&lt;(shift)
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          39097
        </td>
        <td>
          9150
          -
          9172
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.+($anon.this.i.&lt;&lt;(shift))
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          39098
        </td>
        <td>
          9150
          -
          9172
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.+($anon.this.i.&lt;&lt;(shift))
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          39099
        </td>
        <td>
          9185
          -
          9191
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.+(1)
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          39100
        </td>
        <td>
          9185
          -
          9191
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anon.i_=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i_=($anon.this.i.+(1))
        </td>
      </tr><tr>
        <td>
          237
        </td>
        <td>
          39101
        </td>
        <td>
          9185
          -
          9191
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anon.i_=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i_=($anon.this.i.+(1))
        </td>
      </tr><tr>
        <td>
          243
        </td>
        <td>
          39104
        </td>
        <td>
          9303
          -
          9343
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[org.locationtech.jts.geom.Geometry].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          243
        </td>
        <td>
          39110
        </td>
        <td>
          9345
          -
          9475
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val mask: Long = Frequency.this.getMask(precision);
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask), 1L))
}
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          39105
        </td>
        <td>
          9364
          -
          9382
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.getMask
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getMask(precision)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          39106
        </td>
        <td>
          9429
          -
          9457
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          39107
        </td>
        <td>
          9419
          -
          9464
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.geomToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          39108
        </td>
        <td>
          9466
          -
          9468
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          39109
        </td>
        <td>
          9408
          -
          9469
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask), 1L)
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          39111
        </td>
        <td>
          9485
          -
          9521
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[java.util.Date].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          39154
        </td>
        <td>
          9481
          -
          10429
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (classOf[java.util.Date].isAssignableFrom(clas))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L))
else
  if (clas.==(classOf[java.lang.String]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Long]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Integer]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
      else
        if (clas.==(classOf[java.lang.Float]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
        else
          if (clas.==(classOf[java.lang.Double]))
            ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
          else
            throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          39112
        </td>
        <td>
          9571
          -
          9595
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          39113
        </td>
        <td>
          9561
          -
          9607
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.dateToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          39114
        </td>
        <td>
          9609
          -
          9611
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          39115
        </td>
        <td>
          9550
          -
          9612
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L)
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          39116
        </td>
        <td>
          9531
          -
          9612
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L))
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          39117
        </td>
        <td>
          9628
          -
          9651
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.String])
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          39153
        </td>
        <td>
          9624
          -
          10429
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.String]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
else
  if (clas.==(classOf[java.lang.Long]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Integer]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Float]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
      else
        if (clas.==(classOf[java.lang.Double]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
        else
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          39118
        </td>
        <td>
          9703
          -
          9729
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[String]
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          39119
        </td>
        <td>
          9691
          -
          9741
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.stringToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.stringToKey(value.asInstanceOf[String], precision)
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          39120
        </td>
        <td>
          9743
          -
          9745
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          39121
        </td>
        <td>
          9680
          -
          9746
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L)
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          39122
        </td>
        <td>
          9661
          -
          9746
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          39123
        </td>
        <td>
          9762
          -
          9793
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Long])
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          39152
        </td>
        <td>
          9758
          -
          10429
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Long]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
else
  if (clas.==(classOf[java.lang.Integer]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Float]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Double]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
      else
        throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          39124
        </td>
        <td>
          9843
          -
          9867
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Long]
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          39125
        </td>
        <td>
          9833
          -
          9879
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.longToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.longToKey(value.asInstanceOf[Long], precision)
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          39126
        </td>
        <td>
          9881
          -
          9883
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          39127
        </td>
        <td>
          9822
          -
          9884
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L)
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          39128
        </td>
        <td>
          9803
          -
          9884
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          39129
        </td>
        <td>
          9900
          -
          9924
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Integer])
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          39151
        </td>
        <td>
          9896
          -
          10429
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Integer]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
else
  if (clas.==(classOf[java.lang.Float]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Double]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
    else
      throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          39130
        </td>
        <td>
          9973
          -
          9996
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Int]
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          39131
        </td>
        <td>
          9964
          -
          10008
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.intToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.intToKey(value.asInstanceOf[Int], precision)
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          39132
        </td>
        <td>
          10010
          -
          10012
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          39133
        </td>
        <td>
          9953
          -
          10013
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L)
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          39134
        </td>
        <td>
          9934
          -
          10013
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          39135
        </td>
        <td>
          10029
          -
          10061
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Float])
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          39150
        </td>
        <td>
          10025
          -
          10429
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Float]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
else
  if (clas.==(classOf[java.lang.Double]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
  else
    throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          39136
        </td>
        <td>
          10112
          -
          10137
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Float]
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          39137
        </td>
        <td>
          10101
          -
          10149
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.floatToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.floatToKey(value.asInstanceOf[Float], precision)
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          39138
        </td>
        <td>
          10151
          -
          10153
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          39139
        </td>
        <td>
          10090
          -
          10154
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L)
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          39140
        </td>
        <td>
          10071
          -
          10154
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          39141
        </td>
        <td>
          10170
          -
          10203
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Double])
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          39149
        </td>
        <td>
          10166
          -
          10429
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Double]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
else
  throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          39142
        </td>
        <td>
          10255
          -
          10281
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Double]
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          39143
        </td>
        <td>
          10243
          -
          10293
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.doubleToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          39144
        </td>
        <td>
          10295
          -
          10297
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          39145
        </td>
        <td>
          10232
          -
          10298
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L)
        </td>
      </tr><tr>
        <td>
          257
        </td>
        <td>
          39146
        </td>
        <td>
          10213
          -
          10298
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
        </td>
      </tr><tr>
        <td>
          259
        </td>
        <td>
          39147
        </td>
        <td>
          10318
          -
          10423
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          259
        </td>
        <td>
          39148
        </td>
        <td>
          10318
          -
          10423
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          264
        </td>
        <td>
          39155
        </td>
        <td>
          10527
          -
          10567
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[org.locationtech.jts.geom.Geometry].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          264
        </td>
        <td>
          39160
        </td>
        <td>
          10569
          -
          10705
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val mask: Long = Frequency.this.getMask(precision);
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)))
}
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          39156
        </td>
        <td>
          10588
          -
          10606
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.getMask
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getMask(precision)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          39157
        </td>
        <td>
          10663
          -
          10691
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          39158
        </td>
        <td>
          10653
          -
          10698
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.geomToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          39159
        </td>
        <td>
          10632
          -
          10699
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask))
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          39161
        </td>
        <td>
          10715
          -
          10751
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[java.util.Date].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          39198
        </td>
        <td>
          10711
          -
          11695
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (classOf[java.util.Date].isAssignableFrom(clas))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)))
else
  if (clas.==(classOf[java.lang.String]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
  else
    if (clas.==(classOf[java.lang.Long]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
    else
      if (clas.==(classOf[java.lang.Integer]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
      else
        if (clas.==(classOf[java.lang.Float]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
        else
          if (clas.==(classOf[java.lang.Double]))
            ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
          else
            throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          39162
        </td>
        <td>
          10811
          -
          10835
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          39163
        </td>
        <td>
          10801
          -
          10847
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.dateToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          39164
        </td>
        <td>
          10780
          -
          10848
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          39165
        </td>
        <td>
          10761
          -
          10848
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)))
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          39166
        </td>
        <td>
          10864
          -
          10887
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.String])
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          39197
        </td>
        <td>
          10860
          -
          11695
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.String]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
else
  if (clas.==(classOf[java.lang.Long]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
  else
    if (clas.==(classOf[java.lang.Integer]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
    else
      if (clas.==(classOf[java.lang.Float]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
      else
        if (clas.==(classOf[java.lang.Double]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
        else
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          39167
        </td>
        <td>
          10949
          -
          10975
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[String]
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          39168
        </td>
        <td>
          10937
          -
          10987
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.stringToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.stringToKey(value.asInstanceOf[String], precision)
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          39169
        </td>
        <td>
          10916
          -
          10988
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision))
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          39170
        </td>
        <td>
          10897
          -
          10988
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          39171
        </td>
        <td>
          11004
          -
          11035
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Long])
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          39196
        </td>
        <td>
          11000
          -
          11695
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Long]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
else
  if (clas.==(classOf[java.lang.Integer]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
  else
    if (clas.==(classOf[java.lang.Float]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
    else
      if (clas.==(classOf[java.lang.Double]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
      else
        throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          39172
        </td>
        <td>
          11095
          -
          11119
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Long]
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          39173
        </td>
        <td>
          11085
          -
          11131
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.longToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.longToKey(value.asInstanceOf[Long], precision)
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          39174
        </td>
        <td>
          11064
          -
          11132
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          39175
        </td>
        <td>
          11045
          -
          11132
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          39176
        </td>
        <td>
          11148
          -
          11172
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Integer])
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          39195
        </td>
        <td>
          11144
          -
          11695
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Integer]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
else
  if (clas.==(classOf[java.lang.Float]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
  else
    if (clas.==(classOf[java.lang.Double]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
    else
      throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          39177
        </td>
        <td>
          11231
          -
          11254
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Int]
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          39178
        </td>
        <td>
          11222
          -
          11266
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.intToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.intToKey(value.asInstanceOf[Int], precision)
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          39179
        </td>
        <td>
          11201
          -
          11267
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision))
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          39180
        </td>
        <td>
          11182
          -
          11267
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          39181
        </td>
        <td>
          11283
          -
          11315
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Float])
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          39194
        </td>
        <td>
          11279
          -
          11695
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Float]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
else
  if (clas.==(classOf[java.lang.Double]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
  else
    throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          39182
        </td>
        <td>
          11376
          -
          11401
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Float]
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          39183
        </td>
        <td>
          11365
          -
          11413
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.floatToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.floatToKey(value.asInstanceOf[Float], precision)
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          39184
        </td>
        <td>
          11344
          -
          11414
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision))
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          39185
        </td>
        <td>
          11325
          -
          11414
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          39186
        </td>
        <td>
          11430
          -
          11463
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Double])
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          39193
        </td>
        <td>
          11426
          -
          11695
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Double]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
else
  throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          278
        </td>
        <td>
          39187
        </td>
        <td>
          11525
          -
          11551
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Double]
        </td>
      </tr><tr>
        <td>
          278
        </td>
        <td>
          39188
        </td>
        <td>
          11513
          -
          11563
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.doubleToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)
        </td>
      </tr><tr>
        <td>
          278
        </td>
        <td>
          39189
        </td>
        <td>
          11492
          -
          11564
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision))
        </td>
      </tr><tr>
        <td>
          278
        </td>
        <td>
          39190
        </td>
        <td>
          11473
          -
          11564
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.index.stats.impl.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
        </td>
      </tr><tr>
        <td>
          280
        </td>
        <td>
          39191
        </td>
        <td>
          11584
          -
          11689
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          280
        </td>
        <td>
          39192
        </td>
        <td>
          11584
          -
          11689
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          39199
        </td>
        <td>
          11815
          -
          11816
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          39200
        </td>
        <td>
          11820
          -
          11835
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          precision.&lt;=(64)
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          39201
        </td>
        <td>
          11802
          -
          11835
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          precision.&gt;=(0).&amp;&amp;(precision.&lt;=(64))
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          39202
        </td>
        <td>
          11837
          -
          11877
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Precision must be in the range [0, 64]&quot;
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          39203
        </td>
        <td>
          11794
          -
          11878
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.require
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.require(precision.&gt;=(0).&amp;&amp;(precision.&lt;=(64)), &quot;Precision must be in the range [0, 64]&quot;)
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          39204
        </td>
        <td>
          11883
          -
          11896
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          9223372036854775807L
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          39205
        </td>
        <td>
          11901
          -
          11915
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          64.-(precision)
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          39206
        </td>
        <td>
          11883
          -
          11916
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          9223372036854775807L.&lt;&lt;(64.-(precision))
        </td>
      </tr><tr>
        <td>
          292
        </td>
        <td>
          39207
        </td>
        <td>
          12088
          -
          12108
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry.safeCentroid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(value).safeCentroid()
        </td>
      </tr><tr>
        <td>
          293
        </td>
        <td>
          39208
        </td>
        <td>
          12113
          -
          12161
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.Z2SFC.index(centroid.getX(), centroid.getY(), org.locationtech.geomesa.curve.Z2SFC.index$default$3).&amp;(mask)
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          39209
        </td>
        <td>
          12252
          -
          12276
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.length().&gt;(precision)
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          39210
        </td>
        <td>
          12302
          -
          12303
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          39211
        </td>
        <td>
          12328
          -
          12337
        </td>
        <td>
          Select
        </td>
        <td>
          java.util.Locale.US
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Locale.US
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          39212
        </td>
        <td>
          12286
          -
          12338
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.substring(0, precision).toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          39213
        </td>
        <td>
          12286
          -
          12338
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.substring(0, precision).toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          300
        </td>
        <td>
          39214
        </td>
        <td>
          12376
          -
          12385
        </td>
        <td>
          Select
        </td>
        <td>
          java.util.Locale.US
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Locale.US
        </td>
      </tr><tr>
        <td>
          300
        </td>
        <td>
          39215
        </td>
        <td>
          12358
          -
          12386
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          300
        </td>
        <td>
          39216
        </td>
        <td>
          12358
          -
          12386
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          303
        </td>
        <td>
          39217
        </td>
        <td>
          12466
          -
          12491
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.getTime()./(precision)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          39218
        </td>
        <td>
          12561
          -
          12578
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value./(precision)
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          39219
        </td>
        <td>
          12646
          -
          12663
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value./(precision).toLong
        </td>
      </tr><tr>
        <td>
          306
        </td>
        <td>
          39220
        </td>
        <td>
          12746
          -
          12763
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Float.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.*(precision)
        </td>
      </tr><tr>
        <td>
          306
        </td>
        <td>
          39221
        </td>
        <td>
          12735
          -
          12764
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.round(value.*(precision)).toLong
        </td>
      </tr><tr>
        <td>
          307
        </td>
        <td>
          39222
        </td>
        <td>
          12849
          -
          12866
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.*(precision)
        </td>
      </tr><tr>
        <td>
          307
        </td>
        <td>
          39223
        </td>
        <td>
          12838
          -
          12867
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.round
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.round(value.*(precision))
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>