<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CassandraIndexAdapter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Cassandra DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.cassandra.data</a> &gt; <span class="el_source">CassandraIndexAdapter.scala</span></div><h1>CassandraIndexAdapter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2017-2025 IBM
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.cassandra.data

import com.datastax.driver.core.Row
import com.datastax.driver.core.exceptions.AlreadyExistsException
import com.datastax.driver.core.querybuilder.{QueryBuilder, Select}
import com.typesafe.scalalogging.{LazyLogging, StrictLogging}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.cassandra.ColumnSelect
import org.locationtech.geomesa.cassandra.data.CassandraIndexAdapter.CassandraIndexWriter
import org.locationtech.geomesa.cassandra.data.CassandraQueryPlan.{EmptyPlan, StatementPlan}
import org.locationtech.geomesa.cassandra.index.CassandraColumnMapper
import org.locationtech.geomesa.cassandra.index.CassandraColumnMapper.{FeatureIdColumnName, SimpleFeatureColumnName}
import org.locationtech.geomesa.features.SerializationOption
import org.locationtech.geomesa.features.kryo.KryoFeatureSerializer
import org.locationtech.geomesa.index.api.IndexAdapter.{BaseIndexWriter, RequiredVisibilityWriter}
import org.locationtech.geomesa.index.api.QueryPlan.IndexResultsToFeatures
import org.locationtech.geomesa.index.api.WritableFeature.FeatureWrapper
import org.locationtech.geomesa.index.api._
import org.locationtech.geomesa.index.planning.LocalQueryRunner.LocalProcessor
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.utils.index.ByteArrays

import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets

<span class="nc" id="L36">class CassandraIndexAdapter(ds: CassandraDataStore) extends IndexAdapter[CassandraDataStore] with StrictLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L40">  override val tableNameLimit: Option[Int] = Some(CassandraIndexAdapter.TableNameLimit)</span>

  override def createTable(
      index: GeoMesaFeatureIndex[_, _],
      partition: Option[String],
      splits: =&gt; Seq[Array[Byte]]): Unit = {
<span class="nc" id="L46">    val cluster = ds.session.getCluster</span>
<span class="nc" id="L47">    val table = index.configureTableName(partition, tableNameLimit) // writes metadata for table name</span>

<span class="nc bnc" id="L49" title="All 2 branches missed.">    if (cluster.getMetadata.getKeyspace(ds.session.getLoggedKeyspace).getTable(table) == null) {</span>
<span class="nc" id="L50">      val columns = CassandraColumnMapper(index).columns</span>
<span class="nc bnc" id="L51" title="All 6 branches missed.">      require(columns.last.name == SimpleFeatureColumnName, s&quot;Expected final column to be $SimpleFeatureColumnName&quot;)</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">      val (partitions, pks) = columns.dropRight(1).partition(_.partition) // drop serialized feature col</span>
<span class="nc" id="L53">      val create = s&quot;CREATE TABLE $table (${columns.map(c =&gt; s&quot;${c.name} ${c.cType}&quot;).mkString(&quot;, &quot;)}, &quot; +</span>
<span class="nc" id="L54">          s&quot;PRIMARY KEY (${partitions.map(_.name).mkString(&quot;(&quot;, &quot;, &quot;, &quot;)&quot;)}&quot; +</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">          s&quot;${if (pks.nonEmpty) { pks.map(_.name).mkString(&quot;, &quot;, &quot;, &quot;, &quot;&quot;)} else { &quot;&quot; }}))&quot;</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">      logger.debug(create)</span>
<span class="nc" id="L57">      try { ds.session.execute(create) } catch {</span>
<span class="nc" id="L58">        case _: AlreadyExistsException =&gt; // ignore, another thread created it for us</span>
      }
    }
  }

  override def renameTable(from: String, to: String): Unit =
<span class="nc" id="L64">    throw new UnsupportedOperationException(&quot;Cassandra does not support renaming tables&quot;)</span>

  override def deleteTables(tables: Seq[String]): Unit = {
<span class="nc" id="L67">    tables.foreach { table =&gt;</span>
<span class="nc" id="L68">      val delete = s&quot;DROP TABLE IF EXISTS $table&quot;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">      logger.debug(delete)</span>
<span class="nc" id="L70">      ds.session.execute(delete)</span>
    }
  }

  override def clearTables(tables: Seq[String], prefix: Option[Array[Byte]]): Unit = {
<span class="nc bnc" id="L75" title="All 2 branches missed.">    if (prefix.isDefined) {</span>
<span class="nc" id="L76">      throw new IllegalArgumentException(&quot;Received a range in `clearTables` but table sharing should be disabled&quot;)</span>
    }
<span class="nc" id="L78">    tables.foreach { table =&gt;</span>
<span class="nc" id="L79">      val truncate = s&quot;TRUNCATE $table&quot;</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">      logger.debug(truncate)</span>
<span class="nc" id="L81">      ds.session.execute(truncate)</span>
    }
  }

  override def createQueryPlan(strategy: QueryStrategy): CassandraQueryPlan = {
    import org.locationtech.geomesa.index.conf.QueryHints.RichHints

<span class="nc" id="L88">    val processor = LocalProcessor(strategy.index.sft, strategy.hints, Some(ds.config.authProvider))</span>

<span class="nc" id="L90">    val hints = strategy.hints</span>

<span class="nc bnc" id="L92" title="All 2 branches missed.">    if (strategy.keyRanges.isEmpty) { EmptyPlan(strategy, processor.reducer) } else {</span>
<span class="nc" id="L93">      val mapper = CassandraColumnMapper(strategy.index)</span>
<span class="nc" id="L94">      val ranges = strategy.keyRanges.flatMap(mapper.select(_, strategy.tieredKeyRanges))</span>
<span class="nc" id="L95">      val tables = strategy.index.getTablesForQuery(strategy.filter.filter)</span>
<span class="nc" id="L96">      val ks = ds.session.getLoggedKeyspace</span>
<span class="nc" id="L97">      val statements = tables.flatMap(table =&gt; ranges.map(r =&gt; CassandraIndexAdapter.statement(ks, table, r.clauses)))</span>
<span class="nc" id="L98">      val threads = ds.config.queries.threads</span>
<span class="nc" id="L99">      val project = hints.getProjection</span>
<span class="nc" id="L100">      StatementPlan(ds, strategy, tables, statements, threads, strategy.ecql, processor, project)</span>
    }
  }

  override def createWriter(
      sft: SimpleFeatureType,
      indices: Seq[GeoMesaFeatureIndex[_, _]],
      partition: Option[String],
      atomic: Boolean): CassandraIndexWriter = {
<span class="nc bnc" id="L109" title="All 2 branches missed.">    require(!atomic, &quot;Cassandra data store does not currently support atomic writes&quot;)</span>
<span class="nc" id="L110">    val wrapper = WritableFeature.wrapper(sft, groups)</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">    if (sft.isVisibilityRequired) {</span>
<span class="nc" id="L112">      new CassandraIndexWriter(ds, indices, wrapper, partition) with RequiredVisibilityWriter</span>
    } else {
<span class="nc" id="L114">      new CassandraIndexWriter(ds, indices, wrapper, partition)</span>
    }
  }

  override def getStrategyCost(strategy: FilterStrategy, explain: Explainer): Option[Long] =
<span class="nc" id="L119">    ds.stats.getCount(strategy.index.sft, strategy.primary.getOrElse(Filter.INCLUDE))</span>
}

<span class="nc bnc" id="L122" title="All 4 branches missed.">object CassandraIndexAdapter extends LazyLogging {</span>

<span class="nc" id="L124">  val TableNameLimit = 48</span>

  def statement(keyspace: String, table: String, criteria: Seq[ColumnSelect]): Select = {
<span class="nc" id="L127">    val select = QueryBuilder.select.all.from(keyspace, table)</span>
<span class="nc" id="L128">    criteria.foreach { c =&gt;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      if (c.start == null) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (c.end != null) {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">          if (c.endInclusive) {</span>
<span class="nc" id="L132">            select.where(QueryBuilder.lte(c.column.name, c.end))</span>
          } else {
<span class="nc" id="L134">            select.where(QueryBuilder.lt(c.column.name, c.end))</span>
          }
        }
<span class="nc bnc" id="L137" title="All 2 branches missed.">      } else if (c.end == null) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (c.startInclusive) {</span>
<span class="nc" id="L139">          select.where(QueryBuilder.gte(c.column.name, c.start))</span>
        } else {
<span class="nc" id="L141">          select.where(QueryBuilder.gt(c.column.name, c.start))</span>
        }
<span class="nc bnc" id="L143" title="All 2 branches missed.">      } else if (c.start == c.end) {</span>
<span class="nc" id="L144">        select.where(QueryBuilder.eq(c.column.name, c.start))</span>
      } else {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (c.startInclusive) {</span>
<span class="nc" id="L147">          select.where(QueryBuilder.gte(c.column.name, c.start))</span>
        } else {
<span class="nc" id="L149">          select.where(QueryBuilder.gt(c.column.name, c.start))</span>
        }
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (c.endInclusive) {</span>
<span class="nc" id="L152">          select.where(QueryBuilder.lte(c.column.name, c.end))</span>
        } else {
<span class="nc" id="L154">          select.where(QueryBuilder.lt(c.column.name, c.end))</span>
        }
      }
    }
<span class="nc" id="L158">    select</span>
  }

<span class="nc" id="L161">  class CassandraResultsToFeatures(_index: GeoMesaFeatureIndex[_, _], _sft: SimpleFeatureType)</span>
<span class="nc" id="L162">      extends IndexResultsToFeatures[Row](_index, _sft) {</span>

<span class="nc" id="L164">    def this() = this(null, null) // no-arg constructor required for serialization</span>

<span class="nc" id="L166">    private var idSerializer: (Array[Byte], Int, Int, SimpleFeature) =&gt; String = _</span>

    override def apply(result: Row): SimpleFeature = {
      val fid = {
<span class="nc" id="L170">        val bytes = result.get(FeatureIdColumnName, classOf[String]).getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L171">        idSerializer.apply(bytes, 0, bytes.length, null)</span>
      }
<span class="nc" id="L173">      val sf = result.getBytes(SimpleFeatureColumnName)</span>
<span class="nc" id="L174">      val bytes = Array.ofDim[Byte](sf.limit())</span>
<span class="nc" id="L175">      sf.get(bytes)</span>
<span class="nc" id="L176">      serializer.deserialize(fid, bytes)</span>
    }

    override protected def createSerializer: KryoFeatureSerializer = {
<span class="nc" id="L180">      idSerializer = GeoMesaFeatureIndex.idFromBytes(index.sft)</span>
<span class="nc" id="L181">      KryoFeatureSerializer(index.sft, SerializationOption.builder.`lazy`.withoutId.build())</span>
    }
  }

<span class="nc" id="L185">  class CassandraIndexWriter(</span>
<span class="nc" id="L186">      ds: CassandraDataStore,</span>
      indices: Seq[GeoMesaFeatureIndex[_, _]],
      wrapper: FeatureWrapper[WritableFeature],
<span class="nc" id="L189">      partition: Option[String]</span>
<span class="nc" id="L190">    ) extends BaseIndexWriter(indices, wrapper) with StrictLogging {</span>

<span class="nc" id="L192">    private val mappers = indices.toArray.map { index =&gt;</span>
<span class="nc" id="L193">      val mapper = CassandraColumnMapper(index)</span>
      // should always be writing to a single table here
<span class="nc" id="L195">      val table = index.getTableName(partition)</span>
<span class="nc" id="L196">      val insert = mapper.insert(ds.session, table)</span>
<span class="nc" id="L197">      val delete = mapper.delete(ds.session, table)</span>
<span class="nc" id="L198">      (mapper, insert, delete)</span>
    }

<span class="nc" id="L201">    private var i = 0</span>

    override protected def append(feature: WritableFeature, values: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L204">      i = 0</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">      while (i &lt; values.length) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        val (mapper, statement, _) = mappers(i)</span>
<span class="nc" id="L207">        values(i) match {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">          case kv: SingleRowKeyValue[_] =&gt;</span>
<span class="nc" id="L209">            val bindings = mapper.bind(kv)</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            logger.trace(s&quot;${statement.getQueryString} : ${debug(bindings)}&quot;)</span>
<span class="nc" id="L211">            ds.session.execute(statement.bind(bindings: _*))</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">          case mkv: MultiRowKeyValue[_] =&gt;</span>
<span class="nc" id="L214">            mkv.split.foreach { kv =&gt;</span>
<span class="nc" id="L215">              val bindings = mapper.bind(kv)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">              logger.trace(s&quot;${statement.getQueryString} : ${debug(bindings)}&quot;)</span>
<span class="nc" id="L217">              ds.session.execute(statement.bind(bindings: _*))</span>
            }
        }
<span class="nc" id="L220">        i += 1</span>
      }
    }

    override protected def update(
        feature: WritableFeature,
        values: Array[RowKeyValue[_]],
        previous: WritableFeature,
        previousValues: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L229">      delete(previous, previousValues)</span>
<span class="nc" id="L230">      append(feature, values)</span>
    }

    override protected def delete(feature: WritableFeature, values: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L234">      i = 0</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">      while (i &lt; values.length) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        val (mapper, _, statement) = mappers(i)</span>
<span class="nc" id="L237">        values(i) match {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">          case kv: SingleRowKeyValue[_] =&gt;</span>
<span class="nc" id="L239">            val bindings = mapper.bindDelete(kv)</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            logger.trace(s&quot;${statement.getQueryString} : ${debug(bindings)}&quot;)</span>
<span class="nc" id="L241">            ds.session.execute(statement.bind(bindings: _*))</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">          case mkv: MultiRowKeyValue[_] =&gt;</span>
<span class="nc" id="L244">            mkv.split.foreach { kv =&gt;</span>
<span class="nc" id="L245">              val bindings = mapper.bindDelete(kv)</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">              logger.trace(s&quot;${statement.getQueryString} : ${debug(bindings)}&quot;)</span>
<span class="nc" id="L247">              ds.session.execute(statement.bind(bindings: _*))</span>
            }
        }
<span class="nc" id="L250">        i += 1</span>
      }
    }

<span class="nc" id="L254">    override def flush(): Unit = {}</span>
<span class="nc" id="L255">    override def close(): Unit = {}</span>
  }

  private def debug(bindings: Seq[AnyRef]): String =
<span class="nc" id="L259">    bindings.map {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      case null =&gt; &quot;null&quot;</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">      case b: ByteBuffer if b.hasArray =&gt; ByteArrays.toHex(b.array(), b.arrayOffset(), b.limit())</span>
<span class="nc" id="L262">      case b =&gt; b.toString</span>
<span class="nc" id="L263">    }.mkString(&quot;,&quot;)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>