<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CassandraDataStore.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Cassandra DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.cassandra.data</a> &gt; <span class="el_source">CassandraDataStore.scala</span></div><h1>CassandraDataStore.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2017-2025 IBM
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.cassandra.data

import com.datastax.driver.core._
import org.geotools.api.data.Query
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.cassandra.data.CassandraDataStoreFactory.CassandraDataStoreConfig
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.index.attribute.AttributeIndex
import org.locationtech.geomesa.index.index.id.IdIndex
import org.locationtech.geomesa.index.index.z2.{XZ2Index, Z2Index}
import org.locationtech.geomesa.index.index.z3.{XZ3Index, Z3Index}
import org.locationtech.geomesa.index.metadata.{GeoMesaMetadata, MetadataStringSerializer}
import org.locationtech.geomesa.index.stats.{GeoMesaStats, RunnableStats}
import org.locationtech.geomesa.index.utils.DistributedLocking.LocalLocking
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.utils.concurrent.CachedThreadPool
import org.locationtech.geomesa.utils.conf.IndexId
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeOptions
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.index.IndexCoverage

<span class="nc" id="L32">class CassandraDataStore(val session: Session, config: CassandraDataStoreConfig)</span>
<span class="nc" id="L33">    extends GeoMesaDataStore[CassandraDataStore](config) with LocalLocking {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

<span class="nc" id="L39">  override val metadata: GeoMesaMetadata[String] =</span>
<span class="nc" id="L40">    new CassandraBackedMetadata(session, config.catalog, MetadataStringSerializer)</span>

<span class="nc" id="L42">  override val adapter: CassandraIndexAdapter = new CassandraIndexAdapter(this)</span>

<span class="nc" id="L44">  override val stats: GeoMesaStats = new RunnableStats(this)</span>

  override def getQueryPlan(query: Query, index: Option[String], explainer: Explainer): Seq[CassandraQueryPlan] =
<span class="nc" id="L47">    super.getQueryPlan(query, index, explainer).asInstanceOf[Seq[CassandraQueryPlan]]</span>

  override def delete(): Unit = {
<span class="nc" id="L50">    val tables = getTypeNames.flatMap(getAllIndexTableNames).distinct :+ config.catalog</span>
<span class="nc" id="L51">    tables.toList.map(t =&gt; CachedThreadPool.submit(() =&gt; session.execute(s&quot;drop table $t&quot;))).foreach(_.get)</span>
  }

  override protected def preSchemaUpdate(sft: SimpleFeatureType, previous: SimpleFeatureType): Unit = {
<span class="nc" id="L55">    val rename = sft.getUserData.remove(SimpleFeatureTypes.Configs.UpdateRenameTables)</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    if (FastConverter.convert(rename, classOf[java.lang.Boolean]) == java.lang.Boolean.TRUE) {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">      logger.warn(&quot;Cassandra does not support renaming tables - disabling rename option&quot;)</span>
    }
<span class="nc" id="L59">    sft.getUserData.put(SimpleFeatureTypes.Configs.UpdateRenameTables, java.lang.Boolean.FALSE)</span>
<span class="nc" id="L60">    super.preSchemaUpdate(sft, previous)</span>
  }

  override protected def transitionIndices(sft: SimpleFeatureType): Unit = {
<span class="nc" id="L64">    val dtg = sft.getDtgField.toSeq</span>
<span class="nc" id="L65">    val geom = Option(sft.getGeomField).toSeq</span>

<span class="nc" id="L67">    val indices = Seq.newBuilder[IndexId]</span>
<span class="nc" id="L68">    val tableNameKeys = Seq.newBuilder[(String, String)]</span>

<span class="nc" id="L70">    sft.getIndices.foreach {</span>
<span class="nc bnc" id="L71" title="All 6 branches missed.">      case id if id.name == IdIndex.name =&gt;</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        require(id.version == 1, s&quot;Expected index version of 1 but got: $id&quot;)</span>
<span class="nc" id="L73">        indices += id.copy(version = 3)</span>
<span class="nc" id="L74">        tableNameKeys += ((s&quot;table.${IdIndex.name}.v1&quot;, s&quot;table.${IdIndex.name}.v3&quot;))</span>

<span class="nc bnc" id="L76" title="All 6 branches missed.">      case id if id.name == Z3Index.name =&gt;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        require(id.version &lt;= 2, s&quot;Expected index version of 1 or 2 but got: $id&quot;)</span>
<span class="nc" id="L78">        indices += id.copy(attributes = geom ++ dtg, version = id.version + 3)</span>
<span class="nc" id="L79">        tableNameKeys += ((s&quot;table.${Z3Index.name}.v${id.version}&quot;, s&quot;table.${Z3Index.name}.v${id.version + 3}&quot;))</span>

<span class="nc bnc" id="L81" title="All 6 branches missed.">      case id if id.name == XZ3Index.name =&gt;</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        require(id.version == 1, s&quot;Expected index version of 1 but got: $id&quot;)</span>
<span class="nc" id="L83">        indices += id.copy(attributes = geom ++ dtg)</span>

<span class="nc bnc" id="L85" title="All 6 branches missed.">      case id if id.name == Z2Index.name =&gt;</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        require(id.version &lt;= 2, s&quot;Expected index version of 1 or 2 but got: $id&quot;)</span>
<span class="nc" id="L87">        indices += id.copy(attributes = geom, version = id.version + 2)</span>
<span class="nc" id="L88">        tableNameKeys += ((s&quot;table.${Z2Index.name}.v${id.version}&quot;, s&quot;table.${Z2Index.name}.v${id.version + 2}&quot;))</span>

<span class="nc bnc" id="L90" title="All 6 branches missed.">      case id if id.name == XZ2Index.name =&gt;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        require(id.version == 1, s&quot;Expected index version of 1 but got: $id&quot;)</span>
<span class="nc" id="L92">        indices += id.copy(attributes = geom)</span>

<span class="nc bnc" id="L94" title="All 6 branches missed.">      case id if id.name == AttributeIndex.name =&gt;</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        require(id.version &lt;= 2, s&quot;Expected index version of 1 or 2 but got: $id&quot;)</span>
<span class="nc" id="L96">        val fields = geom ++ dtg</span>
<span class="nc" id="L97">        sft.getAttributeDescriptors.asScala.foreach { d =&gt;</span>
<span class="nc" id="L98">          val index = d.getUserData.remove(AttributeOptions.OptIndex).asInstanceOf[String]</span>
<span class="nc bnc" id="L99" title="All 6 branches missed.">          if (index == null || index.equalsIgnoreCase(&quot;false&quot;) || index.equalsIgnoreCase(IndexCoverage.NONE.toString)) {</span>
            // no-op
<span class="nc bnc" id="L101" title="All 4 branches missed.">          } else if (java.lang.Boolean.valueOf(index) || index.equalsIgnoreCase(IndexCoverage.FULL.toString) ||</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">              index.equalsIgnoreCase(IndexCoverage.JOIN.toString)) {</span>
<span class="nc" id="L103">            indices += id.copy(attributes = Seq(d.getLocalName) ++ fields, version = id.version + 4)</span>
          } else {
<span class="nc" id="L105">            throw new IllegalStateException(s&quot;Expected an index coverage or boolean but got: $index&quot;)</span>
          }
        }
<span class="nc" id="L108">        tableNameKeys ++=</span>
<span class="nc" id="L109">            Seq(s&quot;table.${AttributeIndex.name}.v${id.version}&quot;, &quot;tables.idx.attr.name&quot;)</span>
<span class="nc" id="L110">                .map((_, s&quot;table.${AttributeIndex.name}.v${id.version + 4}&quot;))</span>
    }

<span class="nc" id="L113">    sft.setIndices(indices.result)</span>

    // update metadata keys for tables
<span class="nc bnc" id="L116" title="All 2 branches missed.">    tableNameKeys.result.foreach { case (from, to) =&gt;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">      metadata.scan(sft.getTypeName, from, cache = false).foreach { case (key, name) =&gt;</span>
<span class="nc" id="L118">        metadata.insert(sft.getTypeName, to + key.substring(from.length), name)</span>
<span class="nc" id="L119">        metadata.remove(sft.getTypeName, key)</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>