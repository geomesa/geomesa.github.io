<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScalaSimpleFeature.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features</a> &gt; <span class="el_source">ScalaSimpleFeature.scala</span></div><h1>ScalaSimpleFeature.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features

import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.features.AbstractSimpleFeature.{AbstractImmutableSimpleFeature, AbstractMutableSimpleFeature}
import org.locationtech.geomesa.utils.collection.WordBitSet
import org.locationtech.geomesa.utils.io.Sizable

import java.util
import java.util.Collections
import java.util.concurrent.atomic.AtomicInteger

/**
 * Simple feature implementation optimized to instantiate from serialization
 *
 * @param sft simple feature type
 * @param values array of attribute values
 */
<span class="nc" id="L26">class ScalaSimpleFeature private (sft: SimpleFeatureType, values: Array[AnyRef])</span>
<span class="nc" id="L27">    extends AbstractMutableSimpleFeature(sft) with Sizable {</span>

<span class="nc" id="L29">  private var userData: java.util.Map[AnyRef, AnyRef] = _</span>

  /**
   * Public constructor
   *
   * @param sft simple feature type
   * @param id simple feature id
   * @param values if provided, must already be converted into the appropriate types
   * @param userData user data
   */
  def this(
      sft: SimpleFeatureType,
      id: String,
<span class="nc" id="L42">      values: Array[AnyRef] = null,</span>
<span class="nc" id="L43">      userData: java.util.Map[AnyRef, AnyRef] = null) = {</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">    this(sft, if (values == null) { Array.ofDim[AnyRef](sft.getAttributeCount) } else { values })</span>
<span class="nc" id="L45">    this.id = id</span>
<span class="nc" id="L46">    this.userData = userData</span>
  }

<span class="nc" id="L49">  override def setAttributeNoConvert(index: Int, value: AnyRef): Unit = values(index) = value</span>
<span class="nc" id="L50">  override def getAttribute(index: Int): AnyRef = values(index)</span>

  override def getUserData: java.util.Map[AnyRef, AnyRef] = synchronized {
<span class="nc bnc" id="L53" title="All 2 branches missed.">    if (userData == null) {</span>
<span class="nc" id="L54">      userData = new java.util.HashMap[AnyRef, AnyRef]()</span>
    }
<span class="nc" id="L56">    userData</span>
  }

<span class="nc" id="L59">  override def calculateSizeOf(): Long = Sizable.sizeOf(this) + Sizable.deepSizeOf(id, values, userData)</span>
}

<span class="nc" id="L62">object ScalaSimpleFeature {</span>

  import scala.collection.JavaConverters._

  /**
    * Copy the feature. This is a shallow copy, in that the attributes and user data values will be shared
    * between the two features
    *
    * @param in feature to copy
    * @return
    */
<span class="nc" id="L73">  def copy(in: SimpleFeature): ScalaSimpleFeature = copy(in.getFeatureType, in)</span>

  /**
    * Copy the feature, with a new feature type. Attributes are copied by index and not converted, so the new
    * feature type must have a compatible schema.
    *
    * This is a shallow copy, in that the attributes and user data values will be shared between the two features
    *
    * @param sft new simple feature type
    * @param in feature to copy
    * @return
    */
  def copy(sft: SimpleFeatureType, in: SimpleFeature): ScalaSimpleFeature =
<span class="nc" id="L86">    new ScalaSimpleFeature(sft, in.getID, in.getAttributes.toArray, new java.util.HashMap[AnyRef, AnyRef](in.getUserData))</span>

  /**
    * Copy the feature with a new feature type. Attributes will be copied by name, and converted
    * as necessary. As compared to `copy`, the new feature type does not have to have a compatible schema.
    *
    * If the feature already has the desired feature type, it will be returned as-is and not copied.
    *
    * This is a shallow copy, in that the attributes and user data values will be shared between the two features
    *
    * @param sft new feature type
    * @param in feature to copy
    * @return
    */
  def retype(sft: SimpleFeatureType, in: SimpleFeature): SimpleFeature = {
<span class="nc bnc" id="L101" title="All 6 branches missed.">    if (sft == in.getFeatureType) { in } else {</span>
<span class="nc" id="L102">      val out = new ScalaSimpleFeature(sft, in.getID)</span>
<span class="nc" id="L103">      var i = 0</span>
<span class="nc" id="L104">      sft.getAttributeDescriptors.asScala.foreach { d =&gt;</span>
<span class="nc" id="L105">        out.setAttribute(i, in.getAttribute(d.getLocalName))</span>
<span class="nc" id="L106">        i += 1</span>
      }
<span class="nc" id="L108">      out.getUserData.putAll(in.getUserData)</span>
<span class="nc" id="L109">      out</span>
    }
  }

  /**
    * Creates a simple feature, converting the values to the appropriate type
    *
    * @param sft simple feature type
    * @param id feature id
    * @param values attributes values, corresponding to the feature type. types will be converted as necessary
    * @return
    */
  def create(sft: SimpleFeatureType, id: String, values: Any*): ScalaSimpleFeature = {
<span class="nc" id="L122">    val sf = new ScalaSimpleFeature(sft, id)</span>
<span class="nc" id="L123">    var i = 0</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    while (i &lt; values.length) {</span>
<span class="nc" id="L125">      sf.setAttribute(i, values(i).asInstanceOf[AnyRef])</span>
<span class="nc" id="L126">      i += 1</span>
    }
<span class="nc" id="L128">    sf</span>
  }

  /**
   * Compares the id and attributes for the simple features - concrete class is not checked
   */
  def equalIdAndAttributes(sf1: SimpleFeature, sf2: SimpleFeature): Boolean =
<span class="nc bnc" id="L135" title="All 6 branches missed.">    sf1 != null &amp;&amp; sf2 != null &amp;&amp; sf1.getIdentifier.equalsExact(sf2.getIdentifier) &amp;&amp;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        java.util.Arrays.equals(sf1.getAttributes.toArray, sf2.getAttributes.toArray)</span>

  /**
    * Immutable simple feature implementation
    *
    * @param sft simple feature type
    * @param values attribute values, must already be converted into the appropriate types
    */
<span class="nc" id="L144">  class ImmutableSimpleFeature private (sft: SimpleFeatureType, values: Array[AnyRef])</span>
<span class="nc" id="L145">      extends AbstractImmutableSimpleFeature(sft) with Sizable {</span>

<span class="nc" id="L147">    private var userData: java.util.Map[AnyRef, AnyRef] = _</span>

    /**
     *
     * Alternate constructor
     *
     * @param sft simple feature type
     * @param id simple feature id
     * @param values attribute values, must already be converted into the appropriate types
     * @param userData user data (not null)
     */
    def this(
        sft: SimpleFeatureType,
        id: String,
        values: Array[AnyRef],
<span class="nc" id="L162">        userData: java.util.Map[AnyRef, AnyRef] = Collections.emptyMap()) = {</span>
<span class="nc" id="L163">      this(sft, values)</span>
<span class="nc" id="L164">      this.id = id</span>
<span class="nc" id="L165">      this.userData = Collections.unmodifiableMap(userData)</span>
    }

<span class="nc" id="L168">    override def getAttribute(index: Int): AnyRef = values(index)</span>
<span class="nc" id="L169">    override def getUserData: util.Map[AnyRef, AnyRef] = userData</span>

<span class="nc" id="L171">    override def calculateSizeOf(): Long = Sizable.sizeOf(this) + Sizable.deepSizeOf(id, values, userData)</span>
  }

  /**
    * Lazily evaluated, immutable simple feature implementation
    *
    * @param sft simple feature type
    */
<span class="nc" id="L179">  class LazyImmutableSimpleFeature private (sft: SimpleFeatureType)</span>
<span class="nc" id="L180">      extends AbstractImmutableSimpleFeature(sft) with LazySimpleFeature with Sizable {</span>

    /**
     * Constructor
     *
     * @param sft simple feature type
     * @param id simple feature id
     * @param reader lazily read attributes, must be thread-safe and already of the appropriate types
     * @param userDataReader lazily read user data, must be thread-safe
     *
     */
<span class="nc" id="L191">    def this(sft: SimpleFeatureType, id: String, reader: LazyAttributeReader, userDataReader: LazyUserDataReader) = {</span>
<span class="nc" id="L192">      this(sft)</span>
<span class="nc" id="L193">      this.id = id</span>
<span class="nc" id="L194">      this.reader = reader</span>
<span class="nc" id="L195">      this.userDataReader = new ImmutableLazyUserDataReader(userDataReader)</span>
    }

    override def calculateSizeOf(): Long =
<span class="nc" id="L199">      Sizable.sizeOf(this) + Sizable.deepSizeOf(id, bits, attributes, userData, count, reader, userDataReader)</span>
  }

  /**
    * Lazily evaluated, mutable simple feature implementation
    *
    * @param sft simple feature type
    */
<span class="nc" id="L207">  class LazyMutableSimpleFeature private (sft: SimpleFeatureType)</span>
<span class="nc" id="L208">      extends AbstractMutableSimpleFeature(sft) with LazySimpleFeature with Sizable {</span>

    /**
     * Constructor
     *
     * @param sft simple feature type
     * @param id simple feature id
     * @param reader lazily read attributes, must be thread-safe and already of the appropriate types
     * @param userDataReader lazily read user data, must be thread-safe
     *
     */
<span class="nc" id="L219">    def this(sft: SimpleFeatureType, id: String, reader: LazyAttributeReader, userDataReader: LazyUserDataReader) = {</span>
<span class="nc" id="L220">      this(sft)</span>
<span class="nc" id="L221">      this.id = id</span>
<span class="nc" id="L222">      this.reader = reader</span>
<span class="nc" id="L223">      this.userDataReader = userDataReader</span>
    }

    override def setAttributeNoConvert(index: Int, value: AnyRef): Unit = {
<span class="nc bnc" id="L227" title="All 2 branches missed.">      if (reader != null) {</span>
<span class="nc" id="L228">        val word = bits.word(index)</span>
<span class="nc" id="L229">        word.synchronized {</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">          if (word.add(index)) {</span>
<span class="nc" id="L231">            bits.synchronized {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">              if (attributes == null) {</span>
<span class="nc" id="L233">                attributes = Array.ofDim[AnyRef](sft.getAttributeCount)</span>
              }
            }
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (count.decrementAndGet() == 0) {</span>
              // once all attributes have been read, dereference any backing resources so that they can be gc'd
<span class="nc" id="L238">              reader = null</span>
<span class="nc" id="L239">              count = null</span>
            }
          }
        }
      }
<span class="nc" id="L244">      attributes(index) = value</span>
    }

    override def calculateSizeOf(): Long =
<span class="nc" id="L248">      Sizable.sizeOf(this) + Sizable.deepSizeOf(id, bits, attributes, userData, count, reader, userDataReader)</span>
  }

  /**
   * Thread-safe lazy evaluation of attributes
   */
<span class="nc" id="L254">  trait LazySimpleFeature extends AbstractSimpleFeature {</span>

    // we synchronize on the low-level words, in order to minimize contention
<span class="nc" id="L257">    protected val bits: WordBitSet = WordBitSet(getFeatureType.getAttributeCount + 1)</span>
    protected var attributes: Array[AnyRef] = _
    protected var userData: java.util.Map[AnyRef, AnyRef] = _

<span class="nc" id="L261">    protected var count = new AtomicInteger(getFeatureType.getAttributeCount)</span>
    protected var reader: LazyAttributeReader = _
    protected var userDataReader: LazyUserDataReader = _

    override def getAttribute(index: Int): AnyRef = {
<span class="nc bnc" id="L266" title="All 2 branches missed.">      if (reader != null) {</span>
<span class="nc" id="L267">        val word = bits.word(index)</span>
<span class="nc" id="L268">        word.synchronized {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">          if (word.add(index)) {</span>
<span class="nc" id="L270">            bits.synchronized {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">              if (attributes == null) {</span>
<span class="nc" id="L272">                attributes = Array.ofDim[AnyRef](getFeatureType.getAttributeCount)</span>
              }
            }
<span class="nc" id="L275">            attributes(index) = reader.read(index)</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (count.decrementAndGet() == 0) {</span>
              // once all attributes have been read, dereference any backing resources so that they can be gc'd
<span class="nc" id="L278">              reader = null</span>
<span class="nc" id="L279">              count = null</span>
            }
          }
        }
      }
<span class="nc" id="L284">      attributes(index)</span>
    }

    override def getUserData: java.util.Map[AnyRef, AnyRef] = {
<span class="nc bnc" id="L288" title="All 2 branches missed.">      if (userDataReader != null) {</span>
<span class="nc" id="L289">        synchronized {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">          if (userData == null) {</span>
<span class="nc" id="L291">            userData = userDataReader.read()</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            userDataReader == null // dereference any backing resources</span>
          }
        }
      }
<span class="nc" id="L296">      userData</span>
    }
  }

  /**
    * Lazy attribute reader
    */
  trait LazyAttributeReader extends Sizable {
    def read(i: Int): AnyRef
  }

  /**
    * Lazy user data reader
    */
  trait LazyUserDataReader extends Sizable {
    def read(): java.util.Map[AnyRef, AnyRef]
  }

<span class="nc" id="L314">  class ImmutableLazyUserDataReader(delegate: LazyUserDataReader) extends LazyUserDataReader {</span>
<span class="nc" id="L315">    override def read(): java.util.Map[AnyRef, AnyRef] = Collections.unmodifiableMap(delegate.read())</span>
<span class="nc" id="L316">    override def calculateSizeOf(): Long = delegate.calculateSizeOf()</span>
  }
<span class="nc" id="L318">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>