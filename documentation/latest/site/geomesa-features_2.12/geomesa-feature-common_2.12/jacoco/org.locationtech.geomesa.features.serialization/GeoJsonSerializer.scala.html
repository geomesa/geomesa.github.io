<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoJsonSerializer.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.serialization</a> &gt; <span class="el_source">GeoJsonSerializer.scala</span></div><h1>GeoJsonSerializer.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.serialization

import com.google.gson.stream.JsonWriter
import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.utils.text.DateParsing
import org.locationtech.jts.geom.Geometry

import java.io.Writer
import java.util.regex.Pattern
import java.util.{Base64, Date, UUID}

/**
 * Serializer to write out geojson from simple features. There are two valid usage patterns.
 *
 * To encode a feature collection with an array of features:
 *
 * &amp;lt;ol&amp;gt;
 *   &amp;lt;li&amp;gt;`startFeatureCollection`&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;`write` (0-n)&amp;lt;/li&amp;gt;
 *   &amp;lt;li&amp;gt;`endFeatureCollection`&amp;lt;/li&amp;gt;
 * &amp;lt;/ol&amp;gt;
 *
 * To encode individual features:
 *
 * &amp;lt;ol&amp;gt;
 *   &amp;lt;li&amp;gt;`write` (0-n)&amp;lt;/li&amp;gt;
 * &amp;lt;/ol&amp;gt;
 *
 * Note that encoding individual features is not valid json, so generally you would
 * want to split up the output after each feature.
 *
 * @param sft simple feature type
 */
<span class="nc bnc" id="L43" title="All 4 branches missed.">class GeoJsonSerializer(sft: SimpleFeatureType) extends LazyLogging {</span>

  import GeoJsonSerializer._

<span class="nc" id="L47">  private val defaultGeomIndex = sft.indexOf(sft.getGeometryDescriptor.getLocalName)</span>

<span class="nc" id="L49">  private val geometryWriter = new GeometryWriter(&quot;geometry&quot;, defaultGeomIndex)</span>

<span class="nc" id="L51">  private val attributeWriters = Seq.tabulate(sft.getAttributeCount - 1) { i =&gt;</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">    GeoJsonSerializer.createAttributeWriter(sft, if (i &lt; defaultGeomIndex) { i } else { i + 1 })</span>
  }

  /**
   * Start a feature collection type
   *
   * @param writer json writer
   */
  def startFeatureCollection(writer: JsonWriter): Unit =
<span class="nc" id="L61">    writer.beginObject().name(&quot;type&quot;).value(&quot;FeatureCollection&quot;).name(&quot;features&quot;).beginArray()</span>

  /**
   * Write a single feature
   *
   * @param writer json writer
   * @param feature feature
   */
  def write(writer: JsonWriter, feature: SimpleFeature): Unit = {
<span class="nc" id="L70">    writer.beginObject()</span>
<span class="nc" id="L71">    writer.name(&quot;type&quot;).value(&quot;Feature&quot;)</span>
<span class="nc" id="L72">    writer.name(&quot;id&quot;).value(feature.getID)</span>
<span class="nc" id="L73">    geometryWriter.apply(feature, writer)</span>
<span class="nc" id="L74">    writer.name(&quot;properties&quot;).beginObject()</span>
<span class="nc" id="L75">    attributeWriters.foreach(_.apply(feature, writer))</span>
<span class="nc" id="L76">    writer.endObject()</span>
<span class="nc" id="L77">    writer.endObject()</span>
  }

  /**
   * End a previously started feature collection
   *
   * @param writer json writer
   */
<span class="nc" id="L85">  def endFeatureCollection(writer: JsonWriter): Unit = writer.endArray().endObject()</span>
}

<span class="nc bnc" id="L88" title="All 4 branches missed.">object GeoJsonSerializer extends LazyLogging {</span>

  import org.locationtech.geomesa.utils.geotools.ObjectType
  import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType

<span class="nc" id="L93">  private val GeometryWriter = {</span>
<span class="nc" id="L94">    val writer = new org.locationtech.jts.io.geojson.GeoJsonWriter()</span>
<span class="nc" id="L95">    writer.setEncodeCRS(false)</span>
<span class="nc" id="L96">    writer</span>
  }

<span class="nc" id="L99">  private val JsonObjectPattern = Pattern.compile(&quot;^\\s*[{\\[]&quot;)</span>

  /**
   * Create a JsonWriter from a standard writer.
   *
   * Note that closing the JsonWriter will close the wrapped writer. Technically the JsonWriter does not need
   * to be closed if you close the wrapped writer directly, although this is mainly a gson implementation
   * detail and may change in the future.
   *
   * @param wrapped writer
   * @return
   */
  def writer(wrapped: Writer): JsonWriter = {
<span class="nc" id="L112">    val writer = new JsonWriter(wrapped)</span>
<span class="nc" id="L113">    writer.setSerializeNulls(true)</span>
<span class="nc" id="L114">    writer.setLenient(true) // allow multiple top-level objects</span>
<span class="nc" id="L115">    writer</span>
  }

  private def createAttributeWriter(sft: SimpleFeatureType, i: Int): JsonAttributeWriter = {
<span class="nc" id="L119">    val descriptor = sft.getDescriptor(i)</span>
<span class="nc" id="L120">    val name = descriptor.getLocalName</span>
<span class="nc" id="L121">    val bindings = ObjectType.selectType(descriptor)</span>

<span class="nc" id="L123">    bindings.head match {</span>
<span class="nc bnc" id="L124" title="All 12 branches missed.">      case ObjectType.STRING if bindings.last == ObjectType.JSON =&gt; new JsonStringWriter(name, i)</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      case ObjectType.STRING   =&gt; new StringWriter(name, i)</span>
<span class="nc bnc" id="L126" title="All 6 branches missed.">      case ObjectType.INT      =&gt; new NumberWriter(name, i)</span>
<span class="nc bnc" id="L127" title="All 6 branches missed.">      case ObjectType.LONG     =&gt; new NumberWriter(name, i)</span>
<span class="nc bnc" id="L128" title="All 6 branches missed.">      case ObjectType.FLOAT    =&gt; new NumberWriter(name, i)</span>
<span class="nc bnc" id="L129" title="All 6 branches missed.">      case ObjectType.DOUBLE   =&gt; new NumberWriter(name, i)</span>
<span class="nc bnc" id="L130" title="All 6 branches missed.">      case ObjectType.DATE     =&gt; new DateWriter(name, i)</span>
<span class="nc bnc" id="L131" title="All 6 branches missed.">      case ObjectType.GEOMETRY =&gt; new GeometryWriter(name, i)</span>
<span class="nc bnc" id="L132" title="All 6 branches missed.">      case ObjectType.UUID     =&gt; new UuidWriter(name, i)</span>
<span class="nc bnc" id="L133" title="All 6 branches missed.">      case ObjectType.BYTES    =&gt; new BytesWriter(name, i)</span>
<span class="nc bnc" id="L134" title="All 6 branches missed.">      case ObjectType.BOOLEAN  =&gt; new BooleanWriter(name, i)</span>
<span class="nc bnc" id="L135" title="All 6 branches missed.">      case ObjectType.LIST     =&gt; new ListWriter(name, i, bindings(1))</span>
<span class="nc bnc" id="L136" title="All 6 branches missed.">      case ObjectType.MAP      =&gt; new MapWriter(name, i, bindings(1), bindings(2))</span>

      case _ =&gt;
<span class="nc bnc" id="L139" title="All 2 branches missed.">        logger.warn(s&quot;Dropping unsupported attribute '$name:${descriptor.getType.getBinding.getName}'&quot;)</span>
<span class="nc" id="L140">        NoopWriter</span>
    }
  }

  sealed private trait JsonAttributeWriter {
    def apply(feature: SimpleFeature, writer: JsonWriter): Unit
  }

<span class="nc" id="L148">  private object NoopWriter extends JsonAttributeWriter {</span>
<span class="nc" id="L149">    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {}</span>
  }

<span class="nc" id="L152">  private class StringWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit =
<span class="nc" id="L154">      writer.name(name).value(feature.getAttribute(i).asInstanceOf[String])</span>
  }

<span class="nc" id="L157">  private class JsonStringWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {
<span class="nc" id="L159">      writer.name(name)</span>
<span class="nc" id="L160">      feature.getAttribute(i).asInstanceOf[String] match {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        case null =&gt; writer.nullValue()</span>
        // note: this check isn't exhaustive, and may still produce invalid json if the value is badly formatted
<span class="nc bnc" id="L163" title="All 2 branches missed.">        case obj if JsonObjectPattern.matcher(obj).find() =&gt; writer.jsonValue(obj.trim)</span>
        // note: we don't support primitive types, but this is here to prevent bad input from producing invalid json
<span class="nc" id="L165">        case primitive =&gt; writer.value(primitive)</span>
      }
    }
  }

<span class="nc" id="L170">  private class NumberWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit =
<span class="nc" id="L172">      writer.name(name).value(feature.getAttribute(i).asInstanceOf[Number])</span>
  }

<span class="nc" id="L175">  private class BooleanWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit =
<span class="nc" id="L177">      writer.name(name).value(feature.getAttribute(i).asInstanceOf[java.lang.Boolean])</span>
  }

<span class="nc" id="L180">  private class DateWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {
<span class="nc" id="L182">      writer.name(name)</span>
<span class="nc" id="L183">      val date = feature.getAttribute(i).asInstanceOf[Date]</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      if (date == null) { writer.nullValue() } else {</span>
<span class="nc" id="L185">        writer.value(DateParsing.formatDate(date))</span>
      }
    }
  }

<span class="nc" id="L190">  private class GeometryWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {
<span class="nc" id="L192">      writer.name(name)</span>
<span class="nc" id="L193">      val geom = feature.getAttribute(i).asInstanceOf[Geometry]</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      if (geom == null) { writer.nullValue() } else {</span>
<span class="nc" id="L195">        writer.jsonValue(GeometryWriter.write(geom))</span>
      }
    }
  }

<span class="nc" id="L200">  private class UuidWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {
<span class="nc" id="L202">      writer.name(name)</span>
<span class="nc" id="L203">      val uuid = feature.getAttribute(i).asInstanceOf[UUID]</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">      if (uuid == null) { writer.nullValue() } else {</span>
<span class="nc" id="L205">        writer.value(uuid.toString)</span>
      }
    }
  }

<span class="nc" id="L210">  private class BytesWriter(name: String, i: Int) extends JsonAttributeWriter {</span>
    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {
<span class="nc" id="L212">      writer.name(name)</span>
<span class="nc" id="L213">      val bytes = feature.getAttribute(i).asInstanceOf[Array[Byte]]</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">      if (bytes == null) { writer.nullValue() } else {</span>
<span class="nc" id="L215">        writer.value(Base64.getEncoder.encodeToString(bytes))</span>
      }
    }
  }

<span class="nc" id="L220">  private class ListWriter(name: String, i: Int, binding: ObjectType) extends JsonAttributeWriter {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L224">    private val elementWriter: (JsonWriter, Any) =&gt; Unit = subWriter(binding)</span>

    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {
<span class="nc" id="L227">      writer.name(name)</span>
<span class="nc" id="L228">      val list = feature.getAttribute(i).asInstanceOf[java.util.List[_]]</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      if (list == null) {</span>
<span class="nc" id="L230">        writer.nullValue()</span>
      } else {
<span class="nc" id="L232">        writer.beginArray()</span>
<span class="nc" id="L233">        list.asScala.foreach(elementWriter.apply(writer, _))</span>
<span class="nc" id="L234">        writer.endArray()</span>
      }
    }
  }

<span class="nc" id="L239">  private class MapWriter(name: String, i: Int, keyBinding: ObjectType, valueBinding: ObjectType)</span>
<span class="nc" id="L240">      extends JsonAttributeWriter {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L244">    private val valueWriter: (JsonWriter, Any) =&gt; Unit = subWriter(valueBinding)</span>

    override def apply(feature: SimpleFeature, writer: JsonWriter): Unit = {
<span class="nc" id="L247">      writer.name(name)</span>
<span class="nc" id="L248">      val map = feature.getAttribute(i).asInstanceOf[java.util.Map[_, _]]</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">      if (map == null) {</span>
<span class="nc" id="L250">        writer.nullValue()</span>
      } else {
<span class="nc" id="L252">        writer.beginObject()</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        map.asScala.foreach { case (k, v) =&gt;</span>
<span class="nc" id="L254">          writer.name(k.toString)</span>
<span class="nc" id="L255">          valueWriter(writer, v)</span>
        }
<span class="nc" id="L257">        writer.endObject()</span>
      }
    }
  }

<span class="nc" id="L262">  private def subWriter(binding: ObjectType): (JsonWriter, Any) =&gt; Unit = binding match {</span>
<span class="nc bnc" id="L263" title="All 6 branches missed.">    case ObjectType.INT      =&gt; (writer, elem) =&gt; writer.value(elem.asInstanceOf[Number])</span>
<span class="nc bnc" id="L264" title="All 6 branches missed.">    case ObjectType.LONG     =&gt; (writer, elem) =&gt; writer.value(elem.asInstanceOf[Number])</span>
<span class="nc bnc" id="L265" title="All 6 branches missed.">    case ObjectType.FLOAT    =&gt; (writer, elem) =&gt; writer.value(elem.asInstanceOf[Number])</span>
<span class="nc bnc" id="L266" title="All 6 branches missed.">    case ObjectType.DOUBLE   =&gt; (writer, elem) =&gt; writer.value(elem.asInstanceOf[Number])</span>
<span class="nc bnc" id="L267" title="All 6 branches missed.">    case ObjectType.DATE     =&gt; (writer, elem) =&gt; writer.value(DateParsing.formatDate(elem.asInstanceOf[Date]))</span>
<span class="nc bnc" id="L268" title="All 6 branches missed.">    case ObjectType.GEOMETRY =&gt; (writer, elem) =&gt; writer.jsonValue(GeometryWriter.write(elem.asInstanceOf[Geometry]))</span>
<span class="nc bnc" id="L269" title="All 6 branches missed.">    case ObjectType.BYTES    =&gt; (writer, elem) =&gt; writer.value(Base64.getEncoder.encodeToString(elem.asInstanceOf[Array[Byte]]))</span>
<span class="nc bnc" id="L270" title="All 6 branches missed.">    case ObjectType.BOOLEAN  =&gt; (writer, elem) =&gt; writer.value(elem.asInstanceOf[java.lang.Boolean])</span>
<span class="nc" id="L271">    case _                   =&gt; (writer, elem) =&gt; writer.value(elem.toString)</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>