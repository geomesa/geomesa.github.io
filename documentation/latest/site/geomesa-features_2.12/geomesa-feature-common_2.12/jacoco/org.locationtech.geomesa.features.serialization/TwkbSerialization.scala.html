<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TwkbSerialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.serialization</a> &gt; <span class="el_source">TwkbSerialization.scala</span></div><h1>TwkbSerialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.serialization

import com.typesafe.scalalogging.LazyLogging
import org.locationtech.geomesa.utils.geometry.GeometryPrecision.TwkbPrecision
import org.locationtech.jts.geom._

import scala.util.control.NonFatal

/**
  * Based on the TWKB standard: https://github.com/TWKB/Specification/blob/master/twkb.md
  *
  * For backwards compatibility, also reads original serialization, with the `LegacyGeometrySerialization` trait
  */
// noinspection LanguageFeature
trait TwkbSerialization[T &lt;: NumericWriter, V &lt;: NumericReader]
<span class="nc" id="L24">    extends VarIntEncoding[T, V] with WkbSerialization[T, V] with LazyLogging {</span>

  import DimensionalBounds._
  import TwkbSerialization.FlagBytes._
  import TwkbSerialization.GeometryBytes._
  import TwkbSerialization.ZeroByte

<span class="nc" id="L31">  private val factory = new GeometryFactory()</span>
<span class="nc" id="L32">  private val csFactory = factory.getCoordinateSequenceFactory</span>

  /**
    * Serialize a geometry
    *
    * For explanation of precisions, see `org.locationtech.geomesa.utils.geometry.GeometryPrecision`
    *
    * @param out output
    * @param geometry geometry
    * @param precision precision for encoding x, y, z, m
    */
<span class="nc" id="L43">  def serialize(out: T, geometry: Geometry, precision: TwkbPrecision = TwkbPrecision()): Unit = {</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">    if (geometry == null) {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      out.writeByte(ZeroByte)</span>
    } else {
      // choose our state to correspond with the dimensions in the geometry
      implicit val state: DeltaState = {
        // note that we only check the first coordinate - if a geometry is written with different
        // dimensions in each coordinate, some information may be lost
<span class="nc" id="L51">        val coord = geometry.getCoordinate</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">        if (coord == null) {</span>
<span class="nc" id="L53">          new XYState(precision.xy)</span>
        } else {
          // check for dimensions - use NaN != NaN to verify presence of coordinates
<span class="nc bnc" id="L56" title="All 2 branches missed.">          val hasZ = !java.lang.Double.isNaN(coord.getZ)</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">          val hasM = !java.lang.Double.isNaN(coord.getM)</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">          if (hasZ) {</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">            if (hasM) {</span>
<span class="nc" id="L60">              new XYZMState(precision.xy, precision.z, precision.m)</span>
            } else {
<span class="nc" id="L62">              new XYZState(precision.xy, precision.z)</span>
            }
<span class="nc bnc" id="L64" title="All 2 branches missed.">          } else if (hasM) {</span>
<span class="nc" id="L65">            new XYMState(precision.xy, precision.m)</span>
          } else {
<span class="nc" id="L67">            new XYState(precision.xy)</span>
          }
        }
      }

<span class="nc" id="L72">      geometry match {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        case g: Point =&gt;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">          if (g.isEmpty) {</span>
<span class="nc" id="L75">            state.writeMetadata(out, TwkbPoint, empty = true, bbox = false)</span>
          } else {
<span class="nc" id="L77">            state.writeMetadata(out, TwkbPoint, empty = false, bbox = false)</span>
<span class="nc" id="L78">            state.writeCoordinate(out, g.getCoordinate)</span>
          }

<span class="nc bnc" id="L81" title="All 2 branches missed.">        case g: LineString =&gt;</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">          if (g.isEmpty) {</span>
<span class="nc" id="L83">            state.writeMetadata(out, TwkbLineString, empty = true, bbox = false)</span>
          } else {
<span class="nc" id="L85">            state.writeMetadata(out, TwkbLineString, empty = false, bbox = true)</span>
<span class="nc" id="L86">            state.writeBoundingBox(out, g)</span>
          }
<span class="nc" id="L88">          writeLineString(out, g)</span>

<span class="nc bnc" id="L90" title="All 2 branches missed.">        case g: Polygon =&gt;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">          if (g.isEmpty) {</span>
<span class="nc" id="L92">            state.writeMetadata(out, TwkbPolygon, empty = true, bbox = false)</span>
          } else {
<span class="nc" id="L94">            state.writeMetadata(out, TwkbPolygon, empty = false, bbox = true)</span>
<span class="nc" id="L95">            state.writeBoundingBox(out, g)</span>
          }
<span class="nc" id="L97">          writePolygon(out, g)</span>

<span class="nc bnc" id="L99" title="All 2 branches missed.">        case g: MultiPoint =&gt;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">          if (g.isEmpty) {</span>
<span class="nc" id="L101">            state.writeMetadata(out, TwkbMultiPoint, empty = true, bbox = false)</span>
          } else {
<span class="nc" id="L103">            state.writeMetadata(out, TwkbMultiPoint, empty = false, bbox = true)</span>
<span class="nc" id="L104">            state.writeBoundingBox(out, g)</span>
          }
<span class="nc" id="L106">          writeMultiPoint(out, g)</span>

<span class="nc bnc" id="L108" title="All 2 branches missed.">        case g: MultiLineString =&gt;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">          if (g.isEmpty) {</span>
<span class="nc" id="L110">            state.writeMetadata(out, TwkbMultiLineString, empty = true, bbox = false)</span>
          } else {
<span class="nc" id="L112">            state.writeMetadata(out, TwkbMultiLineString, empty = false, bbox = true)</span>
<span class="nc" id="L113">            state.writeBoundingBox(out, g)</span>
          }
<span class="nc" id="L115">          writeMultiLineString(out, g)</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">        case g: MultiPolygon =&gt;</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">          if (g.isEmpty) {</span>
<span class="nc" id="L119">            state.writeMetadata(out, TwkbMultiPolygon, empty = true, bbox = false)</span>
          } else {
<span class="nc" id="L121">            state.writeMetadata(out, TwkbMultiPolygon, empty = false, bbox = true)</span>
<span class="nc" id="L122">            state.writeBoundingBox(out, g)</span>
          }
<span class="nc" id="L124">          writeMultiPolygon(out, g)</span>

<span class="nc bnc" id="L126" title="All 2 branches missed.">        case g: GeometryCollection =&gt;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">          if (g.isEmpty) {</span>
<span class="nc" id="L128">            state.writeMetadata(out, TwkbCollection, empty = true, bbox = false)</span>
          } else {
<span class="nc" id="L130">            state.writeMetadata(out, TwkbCollection, empty = false, bbox = true)</span>
<span class="nc" id="L131">            state.writeBoundingBox(out, g)</span>
          }
<span class="nc" id="L133">          writeCollection(out, g)</span>
      }
    }
  }

  /**
    * Deserialize a geometry
    *
    * @param in input
    * @return
    */
  def deserialize(in: V): Geometry = {
<span class="nc" id="L145">    try { deserialize(in, 0) } catch {</span>
<span class="nc bnc" id="L146" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.error(s&quot;Error reading serialized kryo geometry:&quot;, e); null</span>
    }
  }

  private def deserialize(in: V, nesting: Int): Geometry = {
<span class="nc bnc" id="L151" title="All 2 branches missed.">    val precisionAndType = in.readByte()</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">    if (precisionAndType == ZeroByte) {</span>
<span class="nc" id="L153">      null</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">    } else if (precisionAndType == NOT_NULL_BYTE) {</span>
      // TODO this overlaps with twkb point type with precision 0
<span class="nc" id="L156">      deserializeWkb(in)</span>
    } else {
      // first byte contains the geometry type in the first 4 bits and the x-y precision in the second 4 bits
<span class="nc" id="L159">      val geomType = (precisionAndType &amp; 0x0F).toByte</span>
<span class="nc" id="L160">      val precision = VarIntEncoding.zigzagDecode((precisionAndType &amp; 0xF0) &gt;&gt;&gt; 4)</span>

      // second byte contains flags for optional elements
<span class="nc bnc" id="L163" title="All 2 branches missed.">      val flags = in.readByte()</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      val hasBoundingBox = (flags &amp; BoundingBoxFlag) != 0</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">      val hasExtendedDims = (flags &amp; ExtendedDimsFlag) != 0</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">      val isEmpty = (flags &amp; EmptyFlag) != 0</span>

      // extended dims indicates the presence of z and/or m
      // we create our state tracker based on the dimensions that are present
<span class="nc bnc" id="L170" title="All 2 branches missed.">      implicit val state: DeltaState = if (hasExtendedDims) {</span>
        // z and m precisions are indicated in the next byte, where (from right to left):
        //   bit 0 indicates presence of z dimension
        //   bit 1 indicates presence of m dimension
        //   bits 2-5 indicate z precision
        //   bits 6-8 indicate m precision
<span class="nc bnc" id="L176" title="All 2 branches missed.">        val extendedDims = in.readByte()</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if ((extendedDims &amp; 0x01) != 0) { // indicates z dimension</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">          if ((extendedDims &amp; 0x02) != 0) { // indicates m dimension</span>
<span class="nc" id="L179">            new XYZMState(precision, (extendedDims &amp; 0x1C) &gt;&gt; 2, (extendedDims &amp; 0xE0) &gt;&gt;&gt; 5)</span>
          } else {
<span class="nc" id="L181">            new XYZState(precision, (extendedDims &amp; 0x1C) &gt;&gt; 2)</span>
          }
<span class="nc bnc" id="L183" title="All 2 branches missed.">        } else if ((extendedDims &amp; 0x02) != 0) {  // indicates m dimension</span>
<span class="nc" id="L184">          new XYMState(precision, (extendedDims &amp; 0xE0) &gt;&gt;&gt; 5)</span>
        } else {
          // not sure why anyone would indicate extended dims but set them all false...
<span class="nc" id="L187">          new XYState(precision)</span>
        }
      } else {
<span class="nc" id="L190">        new XYState(precision)</span>
      }

      // size is the length of the remainder of the geometry, after the size attribute
      // we don't currently use size - parsing will fail if size is actually present

      // val hasSize = (flags &amp; FlagBytes.SizeFlag) != 0
      // if (hasSize) {
      //   val size = readUnsignedVarInt(in)
      // }

      // bounding box is not currently used, but we write it in anticipation of future filter optimizations
<span class="nc bnc" id="L202" title="All 2 branches missed.">      if (hasBoundingBox) {</span>
<span class="nc" id="L203">        state.skipBoundingBox(in)</span>
      }

      // children geometries can be written with an id list
      // we don't currently use ids - parsing will fail if ids are actually present
      // val hasIds = (flags &amp; FlagBytes.IdsFlag) != 0

<span class="nc" id="L210">      geomType match {</span>
<span class="nc bnc" id="L211" title="All 4 branches missed.">        case TwkbPoint =&gt; factory.createPoint(if (isEmpty) { null } else { csFactory.create(readPointArray(in, 1)) })</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        case TwkbLineString      =&gt; readLineString(in)</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        case TwkbPolygon         =&gt; readPolygon(in)</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        case TwkbMultiPoint      =&gt; readMultiPoint(in)</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        case TwkbMultiLineString =&gt; readMultiLineString(in)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        case TwkbMultiPolygon    =&gt; readMultiPolygon(in)</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        case TwkbCollection      =&gt; readCollection(in, nesting)</span>
<span class="nc" id="L218">        case _ =&gt; throw new IllegalArgumentException(s&quot;Invalid TWKB geometry type $geomType&quot;)</span>
      }
    }
  }

  private def writeLineString(out: T, g: LineString)(implicit state: DeltaState): Unit =
<span class="nc" id="L224">      writePointArray(out, g.getCoordinateSequence, g.getNumPoints)</span>

  private def readLineString(in: V)(implicit state: DeltaState): LineString =
<span class="nc" id="L227">    factory.createLineString(csFactory.create(readPointArray(in, readUnsignedVarInt(in))))</span>

  private def writePolygon(out: T, g: Polygon)(implicit state: DeltaState): Unit = {
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (g.isEmpty) {</span>
<span class="nc" id="L231">      writeUnsignedVarInt(out, 0)</span>
    } else {
<span class="nc" id="L233">      val numRings = g.getNumInteriorRing</span>
<span class="nc" id="L234">      writeUnsignedVarInt(out, numRings + 1) // include exterior ring in count</span>
      // note: don't write final point for each ring, as they should duplicate the first point
<span class="nc" id="L236">      var ring = g.getExteriorRing.getCoordinateSequence</span>
<span class="nc" id="L237">      writePointArray(out, ring, ring.size() - 1)</span>
<span class="nc" id="L238">      var j = 0</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">      while (j &lt; numRings) {</span>
<span class="nc" id="L240">        ring = g.getInteriorRingN(j).getCoordinateSequence</span>
<span class="nc" id="L241">        writePointArray(out, ring, ring.size() - 1)</span>
<span class="nc" id="L242">        j += 1</span>
      }
    }
  }

  private def readPolygon(in: V)(implicit state: DeltaState): Polygon = {
<span class="nc" id="L248">    val numRings = readUnsignedVarInt(in)</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if (numRings == 0) {</span>
<span class="nc" id="L250">      factory.createPolygon(null, null)</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">    } else if (numRings &gt; maxLength) {</span>
<span class="nc" id="L252">      throw new IllegalArgumentException(</span>
<span class="nc" id="L253">        s&quot;Attempting to deserialize a polygon of size $numRings &quot; +</span>
<span class="nc" id="L254">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    } else {
<span class="nc" id="L256">      val exteriorRing = readLinearRing(in, readUnsignedVarInt(in))</span>
<span class="nc" id="L257">      val interiorRings = Array.ofDim[LinearRing](numRings - 1)</span>
<span class="nc" id="L258">      var i = 1</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      while (i &lt; numRings) {</span>
<span class="nc" id="L260">        interiorRings(i - 1) = readLinearRing(in, readUnsignedVarInt(in))</span>
<span class="nc" id="L261">        i += 1</span>
      }
<span class="nc" id="L263">      factory.createPolygon(exteriorRing, interiorRings)</span>
    }
  }

  private def writeMultiPoint(out: T, g: MultiPoint)(implicit state: DeltaState): Unit = {
<span class="nc" id="L268">    val length = g.getNumPoints</span>
<span class="nc" id="L269">    writeUnsignedVarInt(out, length)</span>
<span class="nc" id="L270">    var i = 0</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L272">      state.writeCoordinate(out, g.getGeometryN(i).asInstanceOf[Point].getCoordinate)</span>
<span class="nc" id="L273">      i += 1</span>
    }
  }

  private def readMultiPoint(in: V)(implicit state: DeltaState): MultiPoint = {
<span class="nc" id="L278">    val numPoints = readUnsignedVarInt(in)</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">    if (numPoints == 0) { factory.createMultiPoint(null: CoordinateSequence) } else {</span>
      // note: id list would go here, with one ID per point
<span class="nc" id="L281">      factory.createMultiPoint(readPointArray(in, numPoints).map(factory.createPoint))</span>
    }
  }

  private def writeMultiLineString(out: T, g: MultiLineString)(implicit state: DeltaState): Unit = {
<span class="nc" id="L286">    val length = g.getNumGeometries</span>
<span class="nc" id="L287">    writeUnsignedVarInt(out, length)</span>
<span class="nc" id="L288">    var i = 0</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L290">      val line = g.getGeometryN(i).asInstanceOf[LineString].getCoordinateSequence</span>
<span class="nc" id="L291">      writePointArray(out, line, line.size())</span>
<span class="nc" id="L292">      i += 1</span>
    }
  }

  private def readMultiLineString(in: V)(implicit state: DeltaState): MultiLineString = {
<span class="nc" id="L297">    val numLineStrings = readUnsignedVarInt(in)</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">    if (numLineStrings == 0) {</span>
<span class="nc" id="L299">      factory.createMultiLineString(null)</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">    } else if (numLineStrings &gt; maxLength) {</span>
<span class="nc" id="L301">      throw new IllegalArgumentException(</span>
<span class="nc" id="L302">        s&quot;Attempting to deserialize a multi-linestring of size $numLineStrings &quot; +</span>
<span class="nc" id="L303">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    } else {
      // note: id list would go here, with one ID per line string
<span class="nc" id="L306">      val lineStrings = Array.ofDim[LineString](numLineStrings)</span>
<span class="nc" id="L307">      var i = 0</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">      while (i &lt; numLineStrings) {</span>
<span class="nc" id="L309">        lineStrings(i) = readLineString(in)</span>
<span class="nc" id="L310">        i += 1</span>
      }
<span class="nc" id="L312">      factory.createMultiLineString(lineStrings)</span>
    }
  }

  private def writeMultiPolygon(out: T, g: MultiPolygon)(implicit state: DeltaState): Unit = {
<span class="nc" id="L317">    val length = g.getNumGeometries</span>
<span class="nc" id="L318">    writeUnsignedVarInt(out, length)</span>
<span class="nc" id="L319">    var i = 0</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L321">      writePolygon(out, g.getGeometryN(i).asInstanceOf[Polygon])</span>
<span class="nc" id="L322">      i += 1</span>
    }
  }

  private def readMultiPolygon(in: V)(implicit state: DeltaState): MultiPolygon = {
<span class="nc" id="L327">    val numPolygons = readUnsignedVarInt(in)</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">    if (numPolygons == 0) {</span>
<span class="nc" id="L329">      factory.createMultiPolygon(null)</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    } else if (numPolygons &gt; maxLength) {</span>
<span class="nc" id="L331">      throw new IllegalArgumentException(</span>
<span class="nc" id="L332">        s&quot;Attempting to deserialize a multi-polygon of size $numPolygons &quot; +</span>
<span class="nc" id="L333">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    } else {
      // note: id list would go here, with one ID per polygon
<span class="nc" id="L336">      val polygons = Array.ofDim[Polygon](numPolygons)</span>
<span class="nc" id="L337">      var i = 0</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">      while (i &lt; numPolygons) {</span>
<span class="nc" id="L339">        polygons(i) = readPolygon(in)</span>
<span class="nc" id="L340">        i += 1</span>
      }
<span class="nc" id="L342">      factory.createMultiPolygon(polygons)</span>
    }
  }

  private def writeCollection(out: T, g: GeometryCollection)(implicit state: DeltaState): Unit = {
<span class="nc" id="L347">    val length = g.getNumGeometries</span>
<span class="nc" id="L348">    writeUnsignedVarInt(out, length)</span>
<span class="nc" id="L349">    var i = 0</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L351">      serialize(out, g.getGeometryN(i))</span>
<span class="nc" id="L352">      i += 1</span>
    }
  }

  private def readCollection(in: V, nesting: Int): GeometryCollection = {
<span class="nc bnc" id="L357" title="All 2 branches missed.">    if (nesting &gt; maxNesting) {</span>
<span class="nc" id="L358">      throw new IllegalArgumentException(s&quot;Detected recursive deserialization loop of $maxNesting&quot;)</span>
    }
<span class="nc" id="L360">    val numGeoms = readUnsignedVarInt(in)</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">    if (numGeoms == 0) {</span>
<span class="nc" id="L362">      factory.createGeometryCollection(null)</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">    } else if (numGeoms &gt; maxLength) {</span>
<span class="nc" id="L364">      throw new IllegalArgumentException(</span>
<span class="nc" id="L365">        s&quot;Attempting to deserialize a geometry collection of size $numGeoms &quot; +</span>
<span class="nc" id="L366">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    } else {
      // note: id list would go here, with one ID per sub geometry
<span class="nc" id="L369">      val geoms = Array.ofDim[Geometry](numGeoms)</span>
<span class="nc" id="L370">      var i = 0</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">      while (i &lt; numGeoms) {</span>
<span class="nc" id="L372">        geoms(i) = deserialize(in, nesting + 1)</span>
<span class="nc" id="L373">        i += 1</span>
      }
<span class="nc" id="L375">      factory.createGeometryCollection(geoms)</span>
    }
  }

  private def writePointArray(out: T, coords: CoordinateSequence, length: Int)(implicit state: DeltaState): Unit = {
<span class="nc" id="L380">    writeUnsignedVarInt(out, length)</span>
<span class="nc" id="L381">    var i = 0</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L383">      state.writeCoordinate(out, coords.getCoordinate(i))</span>
<span class="nc" id="L384">      i += 1</span>
    }
  }

  private def readPointArray(in: V, length: Int)(implicit state: DeltaState): Array[Coordinate] = {
<span class="nc bnc" id="L389" title="All 2 branches missed.">    if (length &gt; maxLength) {</span>
<span class="nc" id="L390">      throw new IllegalArgumentException(</span>
<span class="nc" id="L391">        s&quot;Attempting to deserialize a point array of size $length with &quot; +</span>
<span class="nc" id="L392">            s&quot;'${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    }
<span class="nc" id="L394">    val result = Array.ofDim[Coordinate](length)</span>
<span class="nc" id="L395">    var i = 0</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L397">      result(i) = state.readCoordinate(in)</span>
<span class="nc" id="L398">      i += 1</span>
    }
<span class="nc" id="L400">    result</span>
  }

  private def readLinearRing(in: V, length: Int)(implicit state: DeltaState): LinearRing = {
<span class="nc bnc" id="L404" title="All 2 branches missed.">    if (length == 0) {</span>
<span class="nc" id="L405">      factory.createLinearRing(null: CoordinateSequence)</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">    } else if (length &gt; maxLength) {</span>
<span class="nc" id="L407">      throw new IllegalArgumentException(</span>
<span class="nc" id="L408">        s&quot;Attempting to deserialize a linear ring of size $length &quot; +</span>
<span class="nc" id="L409">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    } else {
<span class="nc" id="L411">      val result = Array.ofDim[Coordinate](length + 1)</span>
<span class="nc" id="L412">      var i = 0</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">      while (i &lt; length) {</span>
<span class="nc" id="L414">        result(i) = state.readCoordinate(in)</span>
<span class="nc" id="L415">        i += 1</span>
      }
      // linear rings should not store the final, duplicate point, but still need it for the geometry
<span class="nc" id="L418">      result(length) = result(0)</span>
<span class="nc" id="L419">      factory.createLinearRing(csFactory.create(result))</span>
    }
  }

  /**
    * TWKB only reads and writes the delta from one coordinate to the next, which generally saves space
    * over absolute values. This trait tracks the values used for delta calculations over a single
    * read or write operation
    */
<span class="nc" id="L428">  private sealed trait DeltaState {</span>

    protected def readCoordinateState(in: V): Unit
    protected def createCoordinate(): Coordinate

    /**
      * Write metadata, which includes the geometry and precision byte, the flag byte, and optionally
      * an extended precision byte
      *
      * @param out output
      * @param geometryType geometry type
      * @param empty indicate that the geometry is empty
      * @param bbox indicate that a bbox will be written
      */
    def writeMetadata(out: T, geometryType: Byte, empty: Boolean, bbox: Boolean): Unit

    /**
      * Writes out a bounding box. Each dimension stores a min value and a delta to the max value
      *
      * @param out output
      * @param geometry geometry
      * @param bounds bounds operation
      * @tparam G geometry type
      */
    def writeBoundingBox[G &lt;: Geometry](out: T, geometry: G)(implicit bounds: DimensionalBounds[G]): Unit

    /**
      * Skips over a bounding box. We don't currently use the bounding box when reading
      *
      * @param in in
      */
    def skipBoundingBox(in: V): Unit

    /**
      * Write a coordinate
      *
      * @param out output
      * @param coordinate coordinate
      */
    def writeCoordinate(out: T, coordinate: Coordinate): Unit

    /**
      * Read a coordinate
      *
      * @param in input
      * @return
      */
    def readCoordinate(in: V): Coordinate = {
<span class="nc" id="L476">      readCoordinateState(in)</span>
<span class="nc" id="L477">      createCoordinate()</span>
    }

    /**
      * Reset the state back to its original state, suitable for re-use
      */
    def reset(): Unit
  }

<span class="nc bnc" id="L486" title="All 2 branches missed.">  private class XYState(precision: Int) extends DeltaState {</span>

<span class="nc" id="L488">    protected val p: Double = math.pow(10, precision)</span>
<span class="nc" id="L489">    protected var x: Int = 0</span>
<span class="nc" id="L490">    protected var y: Int = 0</span>

<span class="nc" id="L492">    protected val boundingBoxFlag: Byte = BoundingBoxFlag</span>
<span class="nc" id="L493">    protected val emptyFlag: Byte = EmptyFlag</span>
<span class="nc" id="L494">    protected val dimensionsFlag: Byte = ZeroByte</span>

    override protected def readCoordinateState(in: V): Unit = {
<span class="nc" id="L497">      x = x + readVarInt(in)</span>
<span class="nc" id="L498">      y = y + readVarInt(in)</span>
    }

<span class="nc" id="L501">    override protected def createCoordinate(): Coordinate = new CoordinateXY(x / p, y / p)</span>

    override def writeMetadata(out: T, geometryType: Byte, empty: Boolean, bbox: Boolean): Unit = {
      // write the geometry type and the main precision
<span class="nc bnc" id="L505" title="All 2 branches missed.">      out.writeByte(((VarIntEncoding.zigzagEncode(precision) &lt;&lt; 4) | geometryType).toByte)</span>
      // write the flag byte
<span class="nc bnc" id="L507" title="All 6 branches missed.">      out.writeByte(if (bbox) { boundingBoxFlag } else if (empty) { emptyFlag } else { dimensionsFlag })</span>
    }

    override def writeCoordinate(out: T, coordinate: Coordinate): Unit = {
<span class="nc" id="L511">      val cx = math.round(coordinate.x * p).toInt</span>
<span class="nc" id="L512">      val cy = math.round(coordinate.y * p).toInt</span>
<span class="nc" id="L513">      writeVarInt(out, cx - x)</span>
<span class="nc" id="L514">      writeVarInt(out, cy - y)</span>
<span class="nc" id="L515">      x = cx</span>
<span class="nc" id="L516">      y = cy</span>
    }

    override def writeBoundingBox[G &lt;: Geometry](out: T, geometry: G)(implicit bounds: DimensionalBounds[G]): Unit = {
<span class="nc bnc" id="L520" title="All 2 branches missed.">      val (minX, maxX) = bounds.x(geometry)</span>
<span class="nc" id="L521">      val intX = math.round(minX * p).toInt</span>
<span class="nc" id="L522">      writeVarInt(out, intX)</span>
<span class="nc" id="L523">      writeVarInt(out, math.round(maxX * p).toInt - intX)</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">      val (minY, maxY) = bounds.y(geometry)</span>
<span class="nc" id="L525">      val intY = math.round(minY * p).toInt</span>
<span class="nc" id="L526">      writeVarInt(out, intY)</span>
<span class="nc" id="L527">      writeVarInt(out, math.round(maxY * p).toInt - intY)</span>
    }

    override def skipBoundingBox(in: V): Unit = {
<span class="nc" id="L531">      skipVarInt(in)</span>
<span class="nc" id="L532">      skipVarInt(in)</span>
<span class="nc" id="L533">      skipVarInt(in)</span>
<span class="nc" id="L534">      skipVarInt(in)</span>
    }

    override def reset(): Unit = {
<span class="nc" id="L538">      x = 0</span>
<span class="nc" id="L539">      y = 0</span>
    }
  }

<span class="nc" id="L543">  private abstract class ExtendedState(precision: Int) extends XYState(precision) {</span>

    protected def extendedDims: Byte

<span class="nc" id="L547">    override protected val boundingBoxFlag: Byte = (ExtendedDimsFlag | BoundingBoxFlag).toByte</span>
<span class="nc" id="L548">    override protected val emptyFlag: Byte = (ExtendedDimsFlag | EmptyFlag).toByte</span>
<span class="nc" id="L549">    override protected val dimensionsFlag: Byte = ExtendedDimsFlag</span>

    override def writeMetadata(out: T, geometryType: Byte, empty: Boolean, bbox: Boolean): Unit = {
<span class="nc" id="L552">      super.writeMetadata(out, geometryType, empty, bbox)</span>
      // write the extended precision values
<span class="nc bnc" id="L554" title="All 2 branches missed.">      out.writeByte(extendedDims)</span>
    }
  }

<span class="nc" id="L558">  private class XYZState(precision: Int, zPrecision: Int) extends ExtendedState(precision) {</span>

<span class="nc" id="L560">    protected val pz: Double = math.pow(10, zPrecision)</span>
<span class="nc" id="L561">    protected var z: Int = 0</span>

    // sets bits for z dim, and its precisions
<span class="nc" id="L564">    override protected val extendedDims: Byte = (0x01 | ((zPrecision &amp; 0x03) &lt;&lt; 2)).toByte</span>

    override protected def readCoordinateState(in: V): Unit = {
<span class="nc" id="L567">      super.readCoordinateState(in)</span>
<span class="nc" id="L568">      z = z + readVarInt(in)</span>
    }

<span class="nc" id="L571">    override protected def createCoordinate(): Coordinate = new Coordinate(x / p, y / p, z / pz)</span>

    override def writeBoundingBox[G &lt;: Geometry](out: T, geometry: G)(implicit bounds: DimensionalBounds[G]): Unit = {
<span class="nc" id="L574">      super.writeBoundingBox(out, geometry)</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">      val (minZ, maxZ) = bounds.z(geometry)</span>
<span class="nc" id="L576">      val intZ = math.round(minZ * pz).toInt</span>
<span class="nc" id="L577">      writeVarInt(out, intZ)</span>
<span class="nc" id="L578">      writeVarInt(out, math.round(maxZ * pz).toInt - intZ)</span>
    }

    override def writeCoordinate(out: T, coordinate: Coordinate): Unit = {
<span class="nc" id="L582">      super.writeCoordinate(out, coordinate)</span>
<span class="nc" id="L583">      val cz = math.round(coordinate.getZ * pz).toInt</span>
<span class="nc" id="L584">      writeVarInt(out, cz - z)</span>
<span class="nc" id="L585">      z = cz</span>
    }

    override def skipBoundingBox(in: V): Unit = {
<span class="nc" id="L589">      super.skipBoundingBox(in)</span>
<span class="nc" id="L590">      skipVarInt(in)</span>
<span class="nc" id="L591">      skipVarInt(in)</span>
    }

    override def reset(): Unit = {
<span class="nc" id="L595">      super.reset()</span>
<span class="nc" id="L596">      z = 0</span>
    }
  }

<span class="nc" id="L600">  private class XYMState(precision: Int, mPrecision: Int) extends ExtendedState(precision) {</span>

<span class="nc" id="L602">    protected val pm: Double = math.pow(10, mPrecision)</span>
<span class="nc" id="L603">    protected var m: Int = 0</span>

    // sets bit for m dim, and its precisions
<span class="nc" id="L606">    override protected val extendedDims: Byte = (0x02 | ((mPrecision &amp; 0x03) &lt;&lt; 5)).toByte</span>

    override protected def readCoordinateState(in: V): Unit = {
<span class="nc" id="L609">      super.readCoordinateState(in)</span>
<span class="nc" id="L610">      m = m + readVarInt(in)</span>
    }

<span class="nc" id="L613">    override protected def createCoordinate(): Coordinate = new CoordinateXYM(x / p, y / p, m / pm)</span>

    override def writeBoundingBox[G &lt;: Geometry](out: T, geometry: G)(implicit bounds: DimensionalBounds[G]): Unit = {
<span class="nc" id="L616">      super.writeBoundingBox(out, geometry)</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">      val (minM, maxM) = bounds.m(geometry)</span>
<span class="nc" id="L618">      val intM = math.round(minM * pm).toInt</span>
<span class="nc" id="L619">      writeVarInt(out, intM)</span>
<span class="nc" id="L620">      writeVarInt(out, math.round(maxM * pm).toInt - intM)</span>
    }

    override def writeCoordinate(out: T, coordinate: Coordinate): Unit = {
<span class="nc" id="L624">      super.writeCoordinate(out, coordinate)</span>
<span class="nc" id="L625">      val cm = math.round(coordinate.getM * pm).toInt</span>
<span class="nc" id="L626">      writeVarInt(out, cm - m)</span>
<span class="nc" id="L627">      m = cm</span>
    }

    override def skipBoundingBox(in: V): Unit = {
<span class="nc" id="L631">      super.skipBoundingBox(in)</span>
<span class="nc" id="L632">      skipVarInt(in)</span>
<span class="nc" id="L633">      skipVarInt(in)</span>
    }

    override def reset(): Unit = {
<span class="nc" id="L637">      super.reset()</span>
<span class="nc" id="L638">      m = 0</span>
    }
  }

<span class="nc" id="L642">  private class XYZMState(precision: Int, zPrecision: Int, mPrecision: Int) extends XYZState(precision, zPrecision) {</span>

<span class="nc" id="L644">    protected val pm: Double = math.pow(10, mPrecision)</span>
<span class="nc" id="L645">    protected var m: Int = 0</span>

    // sets bits for both z and m dims, and their precisions
<span class="nc" id="L648">    override protected val extendedDims: Byte =</span>
<span class="nc" id="L649">      (0x03 | ((zPrecision &amp; 0x03) &lt;&lt; 2) | ((mPrecision &amp; 0x03) &lt;&lt; 5)).toByte</span>

    override protected def readCoordinateState(in: V): Unit = {
<span class="nc" id="L652">      super.readCoordinateState(in)</span>
<span class="nc" id="L653">      m = m + readVarInt(in)</span>
    }

<span class="nc" id="L656">    override protected def createCoordinate(): Coordinate = new CoordinateXYZM(x / p, y / p, z / pz, m / pm)</span>

    override def writeBoundingBox[G &lt;: Geometry](out: T, geometry: G)(implicit bounds: DimensionalBounds[G]): Unit = {
<span class="nc" id="L659">      super.writeBoundingBox(out, geometry)</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">      val (minM, maxM) = bounds.m(geometry)</span>
<span class="nc" id="L661">      val intM = math.round(minM * pm).toInt</span>
<span class="nc" id="L662">      writeVarInt(out, intM)</span>
<span class="nc" id="L663">      writeVarInt(out, math.round(maxM * pm).toInt - intM)</span>
    }

    override def writeCoordinate(out: T, coordinate: Coordinate): Unit = {
<span class="nc" id="L667">      super.writeCoordinate(out, coordinate)</span>
<span class="nc" id="L668">      val cm = math.round(coordinate.getM * pm).toInt</span>
<span class="nc" id="L669">      writeVarInt(out, cm - m)</span>
<span class="nc" id="L670">      m = cm</span>
    }

    override def skipBoundingBox(in: V): Unit = {
<span class="nc" id="L674">      super.skipBoundingBox(in)</span>
<span class="nc" id="L675">      skipVarInt(in)</span>
<span class="nc" id="L676">      skipVarInt(in)</span>
    }

    override def reset(): Unit = {
<span class="nc" id="L680">      super.reset()</span>
<span class="nc" id="L681">      m = 0</span>
    }
  }
}

<span class="nc" id="L686">object TwkbSerialization {</span>

<span class="nc" id="L688">  val MaxPrecision: Byte = 7</span>

<span class="nc" id="L690">  private val ZeroByte: Byte = 0</span>

  // twkb constants
<span class="nc" id="L693">  object GeometryBytes {</span>
<span class="nc" id="L694">    val TwkbPoint           :Byte = 1</span>
<span class="nc" id="L695">    val TwkbLineString      :Byte = 2</span>
<span class="nc" id="L696">    val TwkbPolygon         :Byte = 3</span>
<span class="nc" id="L697">    val TwkbMultiPoint      :Byte = 4</span>
<span class="nc" id="L698">    val TwkbMultiLineString :Byte = 5</span>
<span class="nc" id="L699">    val TwkbMultiPolygon    :Byte = 6</span>
<span class="nc" id="L700">    val TwkbCollection      :Byte = 7</span>
  }

<span class="nc" id="L703">  object FlagBytes {</span>
<span class="nc" id="L704">    val BoundingBoxFlag  :Byte = 0x01</span>
<span class="nc" id="L705">    val SizeFlag         :Byte = 0x02</span>
<span class="nc" id="L706">    val IdsFlag          :Byte = 0x04</span>
<span class="nc" id="L707">    val ExtendedDimsFlag :Byte = 0x08</span>
<span class="nc" id="L708">    val EmptyFlag        :Byte = 0x10</span>
  }
<span class="nc" id="L710">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>