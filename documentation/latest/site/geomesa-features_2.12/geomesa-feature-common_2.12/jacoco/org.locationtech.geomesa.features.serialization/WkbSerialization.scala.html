<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WkbSerialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.serialization</a> &gt; <span class="el_source">WkbSerialization.scala</span></div><h1>WkbSerialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.serialization

import org.locationtech.jts.geom._
import org.locationtech.jts.geom.impl.CoordinateArraySequenceFactory

import scala.reflect.ClassTag

/**
  * Based on the method from geotools WKBWriter. This method is optimized for kryo and simplified from
  * WKBWriter in the following ways:
  *
  * 1. Doesn't save SRID (geomesa didn't use that functionality in WKBWriter)
  * 2. Doesn't worry about byte order (handled by kryo)  TODO does avro handle byte order?
  * 3. Doesn't use a precision model
  */
// noinspection LanguageFeature
<span class="nc" id="L25">trait WkbSerialization[T &lt;: NumericWriter, V &lt;: NumericReader] {</span>

  // note: dimensions have to be determined from the internal coordinate sequence, not the geometry itself.

  import WkbSerialization._

<span class="nc" id="L31">  private val factory = new GeometryFactory()</span>
<span class="nc" id="L32">  private val csFactory = CoordinateArraySequenceFactory.instance()</span>

<span class="nc" id="L34">  private val xySerializer   = new XYSerializer()</span>
<span class="nc" id="L35">  private val xyzSerializer  = new XYZSerializer()</span>
<span class="nc" id="L36">  private val xymSerializer  = new XYMSerializer()</span>
<span class="nc" id="L37">  private val xyzmSerializer = new XYZMSerializer()</span>

<span class="nc" id="L39">  protected val maxNesting: Int = GeometryNestingThreshold.toInt.get</span>
<span class="nc" id="L40">  protected val maxLength : Int = GeometryLengthThreshold.toInt.getOrElse(Int.MaxValue)</span>

  def serializeWkb(out: T, geometry: Geometry): Unit = {
<span class="nc bnc" id="L43" title="All 4 branches missed.">    if (geometry == null) { out.writeByte(NULL_BYTE) } else {</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">      out.writeByte(NOT_NULL_BYTE)</span>
<span class="nc" id="L45">      geometry match {</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        case g: Point              =&gt; writePoint(out, g)</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">        case g: LineString         =&gt; writeLineString(out, g)</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">        case g: Polygon            =&gt; writePolygon(out, g)</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        case g: MultiPoint         =&gt; writeGeometryCollection(out, WkbSerialization.MultiPoint, g)</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">        case g: MultiLineString    =&gt; writeGeometryCollection(out, WkbSerialization.MultiLineString, g)</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">        case g: MultiPolygon       =&gt; writeGeometryCollection(out, WkbSerialization.MultiPolygon, g)</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">        case g: GeometryCollection =&gt; writeGeometryCollection(out, WkbSerialization.GeometryCollection, g)</span>
      }
    }
  }

<span class="nc" id="L57">  def deserializeWkb(in: V, checkNull: Boolean = false): Geometry = deserializeWkb(in, checkNull, 0)</span>

  private def deserializeWkb(in: V, checkNull: Boolean, nesting: Int): Geometry = {
<span class="nc bnc" id="L60" title="All 6 branches missed.">    if (checkNull &amp;&amp; in.readByte() == NULL_BYTE) { null } else {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">      in.readInt(true) match {</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        case Point              =&gt; readPoint(in, xySerializer)</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        case LineString         =&gt; readLineString(in, xySerializer)</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        case Polygon            =&gt; readPolygon(in, xySerializer)</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        case PointXYZ           =&gt; readPoint(in, xyzSerializer)</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        case LineStringXYZ      =&gt; readLineString(in, xyzSerializer)</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        case PolygonXYZ         =&gt; readPolygon(in, xyzSerializer)</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        case PointXYM           =&gt; readPoint(in, xymSerializer)</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">        case LineStringXYM      =&gt; readLineString(in, xymSerializer)</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        case PolygonXYM         =&gt; readPolygon(in, xymSerializer)</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        case PointXYZM          =&gt; readPoint(in, xyzmSerializer)</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        case LineStringXYZM     =&gt; readLineString(in, xyzmSerializer)</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        case PolygonXYZM        =&gt; readPolygon(in, xyzmSerializer)</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">        case MultiPoint         =&gt; factory.createMultiPoint(readGeometryCollection[Point](in, nesting))</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        case MultiLineString    =&gt; factory.createMultiLineString(readGeometryCollection[LineString](in, nesting))</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">        case MultiPolygon       =&gt; factory.createMultiPolygon(readGeometryCollection[Polygon](in, nesting))</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        case GeometryCollection =&gt; factory.createGeometryCollection(readGeometryCollection[Geometry](in, nesting))</span>
        // legacy encodings - dimension serialized as a separate int
<span class="nc bnc" id="L79" title="All 2 branches missed.">        case 8                  =&gt; readLegacyPoint(in)</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        case 9                  =&gt; readLegacyLineString(in)</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        case 10                 =&gt; readLegacyPolygon(in)</span>
<span class="nc" id="L82">        case f =&gt; throw new IllegalArgumentException(s&quot;Expected geometry type byte, but got $f&quot;)</span>
      }
    }
  }

  private def writePoint(out: T, g: Point): Unit = {
<span class="nc" id="L88">    val writer = getWriter(g)</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    out.writeInt(writer.flag + Point, optimizePositive = true)</span>
<span class="nc" id="L90">    writeCoordinateSequence(out, writer, g.getCoordinateSequence, writeLength = false)</span>
  }

  private def readPoint(in: V, reader: CoordinateSerializer): Point =
<span class="nc" id="L94">    factory.createPoint(readCoordinateSequence(in, reader, Some(1)))</span>

  private def readLegacyPoint(in: V): Point = {
<span class="nc bnc" id="L97" title="All 5 branches missed.">    in.readInt(optimizePositive = true) match {</span>
<span class="nc" id="L98">      case 2 =&gt; readPoint(in, xySerializer)</span>
<span class="nc" id="L99">      case 3 =&gt; readPoint(in, xyzSerializer)</span>
<span class="nc" id="L100">      case i =&gt; throw new IllegalArgumentException(s&quot;Expected 2 or 3 dimensions, but got $i&quot;)</span>
    }
  }

  private def writeLineString(out: T, g: LineString): Unit = {
<span class="nc" id="L105">    val writer = getWriter(g)</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">    out.writeInt(writer.flag + LineString, optimizePositive = true)</span>
<span class="nc" id="L107">    val coords = g.getCoordinateSequence</span>
<span class="nc" id="L108">    writeCoordinateSequence(out, writer, coords, writeLength = true)</span>
  }

  private def readLineString(in: V, reader: CoordinateSerializer): LineString =
<span class="nc" id="L112">    factory.createLineString(readCoordinateSequence(in, reader, None))</span>

  private def readLegacyLineString(in: V): LineString = {
<span class="nc bnc" id="L115" title="All 2 branches missed.">    val length = in.readInt(optimizePositive = true)</span>
<span class="nc bnc" id="L116" title="All 5 branches missed.">    in.readInt(optimizePositive = true) match {</span>
<span class="nc" id="L117">      case 2 =&gt; factory.createLineString(readCoordinateSequence(in, xySerializer, Some(length)))</span>
<span class="nc" id="L118">      case 3 =&gt; factory.createLineString(readCoordinateSequence(in, xyzSerializer, Some(length)))</span>
<span class="nc" id="L119">      case i =&gt; throw new IllegalArgumentException(s&quot;Expected 2 or 3 dimensions, but got $i&quot;)</span>
    }
  }

  private def writePolygon(out: T, g: Polygon): Unit = {
<span class="nc" id="L124">    val writer = getWriter(g)</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">    out.writeInt(writer.flag + Polygon, optimizePositive = true)</span>
<span class="nc" id="L126">    val exterior = g.getExteriorRing.getCoordinateSequence</span>
<span class="nc" id="L127">    writeCoordinateSequence(out, writer, exterior, writeLength = true)</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    out.writeInt(g.getNumInteriorRing, optimizePositive = true)</span>
<span class="nc" id="L129">    var i = 0</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">    while (i &lt; g.getNumInteriorRing) {</span>
<span class="nc" id="L131">      writeCoordinateSequence(out, writer, g.getInteriorRingN(i).getCoordinateSequence, writeLength = true)</span>
<span class="nc" id="L132">      i += 1</span>
    }
  }

  private def readPolygon(in: V, reader: CoordinateSerializer): Polygon = {
<span class="nc" id="L137">    val exteriorRing = factory.createLinearRing(readCoordinateSequence(in, reader, None))</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    val numInteriorRings = in.readInt(true)</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (numInteriorRings == 0) {</span>
<span class="nc" id="L140">      factory.createPolygon(exteriorRing)</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">    } else if (numInteriorRings &gt; maxLength) {</span>
<span class="nc" id="L142">      throw new IllegalArgumentException(</span>
<span class="nc" id="L143">        s&quot;Attempting to deserialize a polygon of size $numInteriorRings &quot; +</span>
<span class="nc" id="L144">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    } else {
<span class="nc" id="L146">      val interiorRings = Array.ofDim[LinearRing](numInteriorRings)</span>
<span class="nc" id="L147">      var i = 0</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">      while (i &lt; numInteriorRings) {</span>
<span class="nc" id="L149">        interiorRings(i) = factory.createLinearRing(readCoordinateSequence(in, reader, None))</span>
<span class="nc" id="L150">        i += 1</span>
      }
<span class="nc" id="L152">      factory.createPolygon(exteriorRing, interiorRings)</span>
    }
  }

  private def readLegacyPolygon(in: V): Polygon = {
    def readLinearRing(): LinearRing = {
<span class="nc bnc" id="L158" title="All 2 branches missed.">      val length = in.readInt(optimizePositive = true)</span>
<span class="nc bnc" id="L159" title="All 5 branches missed.">      in.readInt(optimizePositive = true) match {</span>
<span class="nc" id="L160">        case 2 =&gt; factory.createLinearRing(readCoordinateSequence(in, xySerializer, Some(length)))</span>
<span class="nc" id="L161">        case 3 =&gt; factory.createLinearRing(readCoordinateSequence(in, xyzSerializer, Some(length)))</span>
<span class="nc" id="L162">        case i =&gt; throw new IllegalArgumentException(s&quot;Expected 2 or 3 dimensions, but got $i&quot;)</span>
      }
    }
<span class="nc" id="L165">    val exteriorRing = readLinearRing()</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">    val numInteriorRings = in.readInt(true)</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (numInteriorRings == 0) {</span>
<span class="nc" id="L168">      factory.createPolygon(exteriorRing)</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">    } else if (numInteriorRings &gt; maxLength) {</span>
<span class="nc" id="L170">      throw new IllegalArgumentException(</span>
<span class="nc" id="L171">        s&quot;Attempting to deserialize a polygon of size $numInteriorRings &quot; +</span>
<span class="nc" id="L172">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    } else {
<span class="nc" id="L174">      val interiorRings = Array.ofDim[LinearRing](numInteriorRings)</span>
<span class="nc" id="L175">      var i = 0</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      while (i &lt; numInteriorRings) {</span>
<span class="nc" id="L177">        interiorRings(i) = readLinearRing()</span>
<span class="nc" id="L178">        i += 1</span>
      }
<span class="nc" id="L180">      factory.createPolygon(exteriorRing, interiorRings)</span>
    }
  }

  private def writeGeometryCollection(out: T, typ: Int, g: GeometryCollection): Unit = {
<span class="nc bnc" id="L185" title="All 2 branches missed.">    out.writeInt(typ, optimizePositive = true)</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">    out.writeInt(g.getNumGeometries, optimizePositive = true)</span>
<span class="nc" id="L187">    var i = 0</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">    while (i &lt; g.getNumGeometries) {</span>
<span class="nc" id="L189">      serializeWkb(out, g.getGeometryN(i))</span>
<span class="nc" id="L190">      i += 1</span>
    }
  }

  private def readGeometryCollection[U &lt;: Geometry: ClassTag](in: V, nesting: Int): Array[U] = {
<span class="nc bnc" id="L195" title="All 2 branches missed.">    if (nesting &gt; maxNesting) {</span>
<span class="nc" id="L196">      throw new IllegalArgumentException(s&quot;Detected recursive deserialization loop of $maxNesting&quot;)</span>
    }
<span class="nc bnc" id="L198" title="All 2 branches missed.">    val numGeoms = in.readInt(true)</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    if (numGeoms &gt; maxLength) {</span>
<span class="nc" id="L200">      throw new IllegalArgumentException(</span>
<span class="nc" id="L201">        s&quot;Attempting to deserialize a geometry of size $numGeoms &quot; +</span>
<span class="nc" id="L202">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    }
<span class="nc" id="L204">    val geoms = Array.ofDim[U](numGeoms)</span>
<span class="nc" id="L205">    var i = 0</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">    while (i &lt; numGeoms) {</span>
<span class="nc" id="L207">      geoms.update(i, deserializeWkb(in, checkNull = true, nesting + 1).asInstanceOf[U])</span>
<span class="nc" id="L208">      i += 1</span>
    }
<span class="nc" id="L210">    geoms</span>
  }

  private def writeCoordinateSequence(
      out: T,
      writer: CoordinateSerializer,
      coords: CoordinateSequence,
      writeLength: Boolean): Unit = {
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (writeLength) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">      out.writeInt(coords.size(), optimizePositive = true)</span>
    }
<span class="nc" id="L221">    var i = 0</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">    while (i &lt; coords.size()) {</span>
<span class="nc" id="L223">      writer.write(out, coords.getCoordinate(i))</span>
<span class="nc" id="L224">      i += 1</span>
    }
  }

  private def readCoordinateSequence(in: V, reader: CoordinateSerializer, length: Option[Int]): CoordinateSequence = {
<span class="nc bnc" id="L229" title="All 2 branches missed.">    val numCoords = length.getOrElse(in.readInt(true))</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (numCoords &gt; maxLength) {</span>
<span class="nc" id="L231">      throw new IllegalArgumentException(</span>
<span class="nc" id="L232">        s&quot;Attempting to deserialize a geometry of size $numCoords &quot; +</span>
<span class="nc" id="L233">            s&quot;with '${GeometryLengthThreshold.property}' = $maxLength'&quot;)</span>
    }
<span class="nc" id="L235">    val coords = Array.ofDim[Coordinate](numCoords)</span>
<span class="nc" id="L236">    var i = 0</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">    while (i &lt; numCoords) {</span>
<span class="nc" id="L238">      coords(i) = reader.read(in)</span>
<span class="nc" id="L239">      i += 1</span>
    }
<span class="nc" id="L241">    csFactory.create(coords)</span>
  }

  private def getWriter(geometry: Geometry): CoordinateSerializer = {
    // don't trust coord.getDimensions - it always returns 3 in jts
    // instead, check for NaN for the z dimension
    // note that we only check the first coordinate - if a geometry is written with different
    // dimensions in each coordinate, some information may be lost
<span class="nc" id="L249">    val coord = geometry.getCoordinate</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    if (coord == null) { xySerializer } else {</span>
      // check for dimensions - use NaN != NaN to verify coordinate dimensions
<span class="nc bnc" id="L252" title="All 2 branches missed.">      val hasZ = !java.lang.Double.isNaN(coord.getZ)</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">      val hasM = !java.lang.Double.isNaN(coord.getM)</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (hasZ) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (hasM) {</span>
<span class="nc" id="L256">          xyzmSerializer</span>
        } else {
<span class="nc" id="L258">          xyzSerializer</span>
        }
<span class="nc bnc" id="L260" title="All 2 branches missed.">      } else if (hasM) {</span>
<span class="nc" id="L261">        xymSerializer</span>
      } else {
<span class="nc" id="L263">        xySerializer</span>
      }
    }
  }

  private sealed trait CoordinateSerializer {
    def flag: Int
    def write(out: T, coord: Coordinate): Unit
    def read(in: V): Coordinate
  }

<span class="nc bnc" id="L274" title="All 2 branches missed.">  private class XYSerializer extends CoordinateSerializer {</span>
<span class="nc" id="L275">    override val flag: Int = XYFlag</span>
    override def write(out: T, coord: Coordinate): Unit = {
<span class="nc bnc" id="L277" title="All 2 branches missed.">      out.writeDouble(coord.getX)</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">      out.writeDouble(coord.getY)</span>
    }
    override def read(in: V): Coordinate = {
<span class="nc bnc" id="L281" title="All 2 branches missed.">      val x = in.readDouble()</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">      val y = in.readDouble()</span>
<span class="nc" id="L283">      new CoordinateXY(x, y)</span>
    }
  }

<span class="nc bnc" id="L287" title="All 2 branches missed.">  private class XYZSerializer extends CoordinateSerializer {</span>
<span class="nc" id="L288">    override val flag: Int = XYZFlag</span>
    override def write(out: T, coord: Coordinate): Unit = {
<span class="nc bnc" id="L290" title="All 2 branches missed.">      out.writeDouble(coord.getX)</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      out.writeDouble(coord.getY)</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">      out.writeDouble(coord.getZ)</span>
    }
    override def read(in: V): Coordinate = {
<span class="nc bnc" id="L295" title="All 2 branches missed.">      val x = in.readDouble()</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">      val y = in.readDouble()</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">      val z = in.readDouble()</span>
<span class="nc" id="L298">      new Coordinate(x, y, z)</span>
    }
  }

<span class="nc bnc" id="L302" title="All 2 branches missed.">  private class XYMSerializer extends CoordinateSerializer {</span>
<span class="nc" id="L303">    override val flag: Int = XYMFlag</span>
    override def write(out: T, coord: Coordinate): Unit = {
<span class="nc bnc" id="L305" title="All 2 branches missed.">      out.writeDouble(coord.getX)</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">      out.writeDouble(coord.getY)</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      out.writeDouble(coord.getM)</span>
    }
    override def read(in: V): Coordinate = {
<span class="nc bnc" id="L310" title="All 2 branches missed.">      val x = in.readDouble()</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">      val y = in.readDouble()</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">      val m = in.readDouble()</span>
<span class="nc" id="L313">      new CoordinateXYM(x, y, m)</span>
    }
  }

<span class="nc bnc" id="L317" title="All 2 branches missed.">  private class XYZMSerializer extends CoordinateSerializer {</span>
<span class="nc" id="L318">    override val flag: Int = XYZMFlag</span>
    override def write(out: T, coord: Coordinate): Unit = {
<span class="nc bnc" id="L320" title="All 2 branches missed.">      out.writeDouble(coord.getX)</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">      out.writeDouble(coord.getY)</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      out.writeDouble(coord.getZ)</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">      out.writeDouble(coord.getM)</span>
    }
    override def read(in: V): Coordinate = {
<span class="nc bnc" id="L326" title="All 2 branches missed.">      val x = in.readDouble()</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">      val y = in.readDouble()</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">      val z = in.readDouble()</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">      val m = in.readDouble()</span>
<span class="nc" id="L330">      new CoordinateXYZM(x, y, z, m)</span>
    }
  }
}

<span class="nc" id="L335">object WkbSerialization {</span>

  // geometry type constants
<span class="nc" id="L338">  val Point              : Int = 1</span>
<span class="nc" id="L339">  val LineString         : Int = 2</span>
<span class="nc" id="L340">  val Polygon            : Int = 3</span>
<span class="nc" id="L341">  val MultiPoint         : Int = 4</span>
<span class="nc" id="L342">  val MultiLineString    : Int = 5</span>
<span class="nc" id="L343">  val MultiPolygon       : Int = 6</span>
<span class="nc" id="L344">  val GeometryCollection : Int = 7</span>

  // dimension constants
<span class="nc" id="L347">  val XYFlag   : Int = 0</span>
<span class="nc" id="L348">  val XYZFlag  : Int = 1000</span>
<span class="nc" id="L349">  val XYMFlag  : Int = 2000</span>
<span class="nc" id="L350">  val XYZMFlag : Int = 3000</span>

  // used in our match statement
<span class="nc" id="L353">  val PointXYZ       : Int = Point      + XYZFlag</span>
<span class="nc" id="L354">  val LineStringXYZ  : Int = LineString + XYZFlag</span>
<span class="nc" id="L355">  val PolygonXYZ     : Int = Polygon    + XYZFlag</span>
<span class="nc" id="L356">  val PointXYM       : Int = Point      + XYMFlag</span>
<span class="nc" id="L357">  val LineStringXYM  : Int = LineString + XYMFlag</span>
<span class="nc" id="L358">  val PolygonXYM     : Int = Polygon    + XYMFlag</span>
<span class="nc" id="L359">  val PointXYZM      : Int = Point      + XYZMFlag</span>
<span class="nc" id="L360">  val LineStringXYZM : Int = LineString + XYZMFlag</span>
<span class="nc" id="L361">  val PolygonXYZM    : Int = Polygon    + XYZMFlag</span>
<span class="nc" id="L362">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>