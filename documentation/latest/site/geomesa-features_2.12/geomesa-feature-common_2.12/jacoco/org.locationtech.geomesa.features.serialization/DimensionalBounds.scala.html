<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DimensionalBounds.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.serialization</a> &gt; <span class="el_source">DimensionalBounds.scala</span></div><h1>DimensionalBounds.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.serialization

import org.locationtech.geomesa.features.serialization.DimensionalBounds.{CoordAccessor, MAccessor, ZAccessor}
import org.locationtech.jts.geom._

/**
  * Extracts the bounds from a geometry. The generic geometry envelope only deals with X and Y, this
  * also supports Z and M
  *
  * Operations expect a non-empty geometry
  *
  * @tparam T geometry type
  */
<span class="nc" id="L22">trait DimensionalBounds[T &lt;: Geometry] {</span>

  /**
    * Get bounds for the x dimension
    *
    * @param geometry geometry, not null and not empty
    * @return (min, max)
    */
<span class="nc" id="L30">  def x(geometry: T): (Double, Double) = (geometry.getEnvelopeInternal.getMinX, geometry.getEnvelopeInternal.getMaxX)</span>

  /**
    * Get bounds for the y dimension
    *
    * @param geometry geometry, not null and not empty
    * @return (min, max)
    */
<span class="nc" id="L38">  def y(geometry: T): (Double, Double) = (geometry.getEnvelopeInternal.getMinY, geometry.getEnvelopeInternal.getMaxY)</span>

  /**
    * Get bounds for the z dimension
    *
    * @param geometry geometry, not null and not empty
    * @return (min, max)
    */
<span class="nc" id="L46">  def z(geometry: T): (Double, Double) = bounds(geometry, ZAccessor)</span>

  /**
    * Get bounds for the m dimension
    *
    * @param geometry geometry, not null and not empty
    * @return (min, max)
    */
<span class="nc" id="L54">  def m(geometry: T): (Double, Double) = bounds(geometry, MAccessor)</span>

  private [serialization] def bounds(geometry: T, accessor: CoordAccessor): (Double, Double)
}

<span class="nc" id="L59">object DimensionalBounds {</span>

<span class="nc" id="L61">  implicit object LineStringBounds extends DimensionalBounds[LineString] {</span>
    override private [serialization] def bounds(
        geometry: LineString,
        accessor: CoordAccessor): (Double, Double) = {
<span class="nc" id="L65">      var min = accessor(geometry.getCoordinateN(0))</span>
<span class="nc" id="L66">      var max = min</span>
<span class="nc" id="L67">      var i = 1</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">      while (i &lt; geometry.getNumPoints) {</span>
<span class="nc" id="L69">        val next = accessor(geometry.getCoordinateN(i))</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (next &lt; min) {</span>
<span class="nc" id="L71">          min = next</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        } else if (next &gt; max) {</span>
<span class="nc" id="L73">          max = next</span>
        }
<span class="nc" id="L75">        i += 1</span>
      }
<span class="nc" id="L77">      (min, max)</span>
    }
  }

<span class="nc" id="L81">  implicit object PolygonBounds extends DimensionalBounds[Polygon] {</span>
    override private [serialization] def bounds(
        geometry: Polygon,
        accessor: CoordAccessor): (Double, Double) = {
<span class="nc" id="L85">      var ring = geometry.getExteriorRing</span>
<span class="nc" id="L86">      var min = accessor(ring.getCoordinateN(0))</span>
<span class="nc" id="L87">      var max = min</span>
<span class="nc" id="L88">      var i = 1</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">      while (i &lt; ring.getNumPoints) {</span>
<span class="nc" id="L90">        val next = accessor(ring.getCoordinateN(i))</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (next &lt; min) {</span>
<span class="nc" id="L92">          min = next</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        } else if (next &gt; max) {</span>
<span class="nc" id="L94">          max = next</span>
        }
<span class="nc" id="L96">        i += 1</span>
      }
<span class="nc" id="L98">      val numRings = geometry.getNumInteriorRing</span>
<span class="nc" id="L99">      var j = 0</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      while (j &lt; numRings) {</span>
<span class="nc" id="L101">        ring = geometry.getInteriorRingN(j)</span>
<span class="nc" id="L102">        i = 0</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        while (i &lt; ring.getNumPoints) {</span>
<span class="nc" id="L104">          val next = accessor(ring.getCoordinateN(i))</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">          if (next &lt; min) {</span>
<span class="nc" id="L106">            min = next</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">          } else if (next &gt; max) {</span>
<span class="nc" id="L108">            max = next</span>
          }
<span class="nc" id="L110">          i += 1</span>
        }
<span class="nc" id="L112">        j += 1</span>
      }
<span class="nc" id="L114">      (min, max)</span>
    }
  }

<span class="nc" id="L118">  implicit object MultiPointBounds extends DimensionalBounds[MultiPoint] {</span>
    override private [serialization] def bounds(
        geometry: MultiPoint,
        accessor: CoordAccessor): (Double, Double) = {
<span class="nc" id="L122">      var min = accessor(geometry.getGeometryN(0).asInstanceOf[Point].getCoordinate)</span>
<span class="nc" id="L123">      var max = min</span>
<span class="nc" id="L124">      var i = 1</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      while (i &lt; geometry.getNumGeometries) {</span>
<span class="nc" id="L126">        val next = accessor(geometry.getGeometryN(i).asInstanceOf[Point].getCoordinate)</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (next &lt; min) {</span>
<span class="nc" id="L128">          min = next</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        } else if (next &gt; max) {</span>
<span class="nc" id="L130">          max = next</span>
        }
<span class="nc" id="L132">        i += 1</span>
      }
<span class="nc" id="L134">      (min, max)</span>
    }
  }

<span class="nc" id="L138">  implicit object MultiLineStringBounds extends DimensionalBounds[MultiLineString] {</span>
    override private [serialization] def bounds(
        geometry: MultiLineString,
        accessor: CoordAccessor): (Double, Double) = {
<span class="nc bnc" id="L142" title="All 2 branches missed.">      var (min, max) = LineStringBounds.bounds(geometry.getGeometryN(0).asInstanceOf[LineString], accessor)</span>
<span class="nc" id="L143">      var i = 1</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">      while (i &lt; geometry.getNumGeometries) {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        val (mini, maxi) = LineStringBounds.bounds(geometry.getGeometryN(i).asInstanceOf[LineString], accessor)</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (mini &lt; min) {</span>
<span class="nc" id="L147">          min = min</span>
        }
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (maxi &gt; max) {</span>
<span class="nc" id="L150">          max = maxi</span>
        }
<span class="nc" id="L152">        i += 1</span>
      }
<span class="nc" id="L154">      (min, max)</span>
    }
  }

<span class="nc" id="L158">  implicit object MultiPolygonBounds extends DimensionalBounds[MultiPolygon] {</span>
    override private [serialization] def bounds(
        geometry: MultiPolygon,
        accessor: CoordAccessor): (Double, Double) = {
<span class="nc bnc" id="L162" title="All 2 branches missed.">      var (min, max) = PolygonBounds.bounds(geometry.getGeometryN(0).asInstanceOf[Polygon], accessor)</span>
<span class="nc" id="L163">      var i = 1</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      while (i &lt; geometry.getNumGeometries) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        val (mini, maxi) = PolygonBounds.bounds(geometry.getGeometryN(i).asInstanceOf[Polygon], accessor)</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (mini &lt; min) {</span>
<span class="nc" id="L167">          min = min</span>
        }
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (maxi &gt; max) {</span>
<span class="nc" id="L170">          max = maxi</span>
        }
<span class="nc" id="L172">        i += 1</span>
      }
<span class="nc" id="L174">      (min, max)</span>
    }
  }

<span class="nc" id="L178">  implicit object GeometryCollectionBounds extends DimensionalBounds[GeometryCollection] {</span>
    override private [serialization] def bounds(
        geometry: GeometryCollection,
        accessor: CoordAccessor): (Double, Double) = {
<span class="nc bnc" id="L182" title="All 2 branches missed.">      var (min, max) = geometry.getGeometryN(0) match {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        case g: Point              =&gt; (accessor(g.getCoordinate), accessor(g.getCoordinate))</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        case g: LineString         =&gt; LineStringBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        case g: Polygon            =&gt; PolygonBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        case g: MultiPoint         =&gt; MultiPointBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        case g: MultiLineString    =&gt; MultiLineStringBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        case g: MultiPolygon       =&gt; MultiPolygonBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        case g: GeometryCollection =&gt; GeometryCollectionBounds.bounds(g, accessor)</span>
      }
<span class="nc" id="L191">      var i = 1</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">      while (i &lt; geometry.getNumGeometries) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        val (mini, maxi) = geometry.getGeometryN(i) match {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">          case g: Point              =&gt; (accessor(g.getCoordinate), accessor(g.getCoordinate))</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">          case g: LineString         =&gt; LineStringBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">          case g: Polygon            =&gt; PolygonBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">          case g: MultiPoint         =&gt; MultiPointBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">          case g: MultiLineString    =&gt; MultiLineStringBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">          case g: MultiPolygon       =&gt; MultiPolygonBounds.bounds(g, accessor)</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">          case g: GeometryCollection =&gt; GeometryCollectionBounds.bounds(g, accessor)</span>
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (mini &lt; min) {</span>
<span class="nc" id="L203">          min = min</span>
        }
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (maxi &gt; max) {</span>
<span class="nc" id="L206">          max = maxi</span>
        }
<span class="nc" id="L208">        i += 1</span>
      }
<span class="nc" id="L210">      (min, max)</span>
    }
  }

  private trait CoordAccessor {
    def apply(c: Coordinate): Double
  }

<span class="nc" id="L218">  private object ZAccessor extends CoordAccessor {</span>
<span class="nc" id="L219">    override def apply(c: Coordinate): Double = c.getZ</span>
  }

<span class="nc" id="L222">  private object MAccessor extends CoordAccessor {</span>
<span class="nc" id="L223">    override def apply(c: Coordinate): Double = c.getM</span>
  }
<span class="nc" id="L225">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>