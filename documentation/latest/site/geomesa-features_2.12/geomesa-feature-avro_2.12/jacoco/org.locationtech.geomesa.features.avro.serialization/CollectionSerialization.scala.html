<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CollectionSerialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Avro</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.avro.serialization</a> &gt; <span class="el_source">CollectionSerialization.scala</span></div><h1>CollectionSerialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0 
 ***********************************************************************/

package org.locationtech.geomesa.features.avro.serialization

import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets
import java.util.{Date, Locale, UUID}

/**
 * Serialization of lists and map types as opaque byte arrays, previously contained in AvroSimpleFeatureUtils
 */
<span class="nc" id="L18">object CollectionSerialization {</span>

  import scala.collection.JavaConverters._

  /**
   * Encodes a list of primitives or Dates into a byte buffer. The list items must be all of the same
   * class.
   *
   * @param list list
   * @return
   */
  def encodeList(list: java.util.List[_], binding: String): ByteBuffer = {
<span class="nc" id="L30">    val size = Option(list).map(_.size)</span>
<span class="nc" id="L31">    size match {</span>
<span class="nc bnc" id="L32" title="All 4 branches missed.">      case Some(s) if s == 0 =&gt; encodeEmptyCollection</span>
<span class="nc bnc" id="L33" title="All 2 branches missed.">      case Some(s)           =&gt; encodeNonEmptyList(list, s, binding)</span>
<span class="nc bnc" id="L34" title="All 2 branches missed.">      case None              =&gt; encodeNullCollection</span>
    }
  }

  /**
   * Decodes a byte buffer created with @see encodeList back into a list
   *
   * @param bb buffer
   * @return
   */
  def decodeList(bb: ByteBuffer): java.util.List[AnyRef] = {
<span class="nc" id="L45">    val size = bb.getInt</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">    if (size &lt; 0) {</span>
<span class="nc" id="L47">      null</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">    } else if (size == 0) {</span>
<span class="nc" id="L49">      java.util.Collections.emptyList()</span>
    } else {
<span class="nc" id="L51">      val list = new java.util.ArrayList[Object](size)</span>
<span class="nc" id="L52">      val label = getString(bb)</span>
<span class="nc" id="L53">      val readMethod = getReadMethod(label, bb)</span>
<span class="nc" id="L54">      var i = 0</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">      while (i &lt; size) {</span>
<span class="nc" id="L56">        list.add(readMethod())</span>
<span class="nc" id="L57">        i += 1</span>
      }
<span class="nc" id="L59">      list</span>
    }
  }

  /**
   * Encodes a map of primitives or Dates into a byte buffer. The map keys must be all of the same
   * class, and the map values must all be of the same class.
   *
   * @param map map
   * @return
   */
  def encodeMap(map: java.util.Map[_, _], keyBinding: String, valueBinding: String): ByteBuffer = {
<span class="nc" id="L71">    val size = Option(map).map(_.size)</span>
<span class="nc" id="L72">    size match {</span>
<span class="nc bnc" id="L73" title="All 4 branches missed.">      case Some(s) if s == 0 =&gt; encodeEmptyCollection</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">      case Some(s)           =&gt; encodeNonEmptyMap(map, s, keyBinding, valueBinding)</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">      case None              =&gt; encodeNullCollection</span>
    }
  }

  /**
   * Decodes a byte buffer created with @see encodeMap back into a map.
   *
   * @param bb buffer
   * @return
   */
  def decodeMap(bb: ByteBuffer): java.util.Map[AnyRef, AnyRef] = {
<span class="nc" id="L86">    val size = bb.getInt</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">    if (size &lt; 0) {</span>
<span class="nc" id="L88">      null</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    } else if (size == 0) {</span>
<span class="nc" id="L90">      java.util.Collections.emptyMap()</span>
    } else {
<span class="nc" id="L92">      val map = new java.util.HashMap[Object, Object](size)</span>
<span class="nc" id="L93">      val keyType = getString(bb)</span>
<span class="nc" id="L94">      val valueType = getString(bb)</span>
<span class="nc" id="L95">      val keyReadMethod = getReadMethod(keyType, bb)</span>
<span class="nc" id="L96">      val valueReadMethod = getReadMethod(valueType, bb)</span>
<span class="nc" id="L97">      var i = 0</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">      while (i &lt; size) {</span>
<span class="nc" id="L99">        val key = keyReadMethod()</span>
<span class="nc" id="L100">        val value = valueReadMethod()</span>
<span class="nc" id="L101">        map.put(key, value)</span>
<span class="nc" id="L102">        i += 1</span>
      }
<span class="nc" id="L104">      map</span>
    }
  }

  private def encodeNullCollection: ByteBuffer =
<span class="nc" id="L109">    ByteBuffer.allocate(4).putInt(-1).flip.asInstanceOf[ByteBuffer]</span>

  private def encodeEmptyCollection: ByteBuffer =
<span class="nc" id="L112">    ByteBuffer.allocate(4).putInt(0).flip.asInstanceOf[ByteBuffer]</span>

  /**
   * Encodes a list that has entries.
   *
   * @param list list
   * @param size size of list
   * @return
   */
  private def encodeNonEmptyList(list: java.util.List[_], size: Int, label: String): ByteBuffer = {
    // get the appropriate write method for the list type
<span class="nc bnc" id="L123" title="All 2 branches missed.">    val (bytesPerItem, putMethod): (Int, (ByteBuffer, Any) =&gt; Unit) = getWriteMethod(label)</span>
    // calculate the total size needed to encode the list
<span class="nc" id="L125">    val totalBytes = getTotalBytes(bytesPerItem, size, list.iterator().asScala, label)</span>

<span class="nc" id="L127">    val labelBytes = label.getBytes(StandardCharsets.UTF_8)</span>
    // 4 bytes for list size + 4 bytes for label bytes size + label bytes + item bytes
<span class="nc" id="L129">    val bb = ByteBuffer.allocate(4 + 4 + labelBytes.size + totalBytes)</span>
    // first put the size of the list
<span class="nc" id="L131">    bb.putInt(size)</span>
    // put the type of the list
<span class="nc" id="L133">    putString(bb, label)</span>
    // put each item
<span class="nc" id="L135">    list.asScala.foreach(v =&gt; putMethod(bb, v))</span>
    // flip (reset) the buffer so that it's ready for reading
<span class="nc" id="L137">    bb.flip</span>
<span class="nc" id="L138">    bb</span>
  }

  /**
   * Encodes a map that has entries.
   *
   * @param map map
   * @param size size of map
   * @return
   */
  private def encodeNonEmptyMap(
      map: java.util.Map[_, _],
      size: Int,
      keyLabel: String,
      valueLabel: String): ByteBuffer = {
    // get the appropriate write methods and approximate sizes for keys and values
<span class="nc bnc" id="L154" title="All 2 branches missed.">    val (bytesPerKeyItem, keyPutMethod)     = getWriteMethod(keyLabel)</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">    val (bytesPerValueItem, valuePutMethod) = getWriteMethod(valueLabel)</span>

    // get the exact size in bytes for keys and values
<span class="nc" id="L158">    val totalKeyBytes   = getTotalBytes(bytesPerKeyItem, size, map.asScala.keysIterator, keyLabel)</span>
<span class="nc" id="L159">    val totalValueBytes = getTotalBytes(bytesPerValueItem, size, map.asScala.valuesIterator, valueLabel)</span>

<span class="nc" id="L161">    val keyLabelBytes = keyLabel.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L162">    val valueLabelBytes = valueLabel.getBytes(StandardCharsets.UTF_8)</span>
    // 4 bytes for map size + 8 bytes for label bytes size + label bytes + key bytes + value bytes
<span class="nc" id="L164">    val totalBytes = 4 + 8 + keyLabelBytes.size + valueLabelBytes.size + totalKeyBytes + totalValueBytes</span>
<span class="nc" id="L165">    val bb = ByteBuffer.allocate(totalBytes)</span>
    // first put the size of the map
<span class="nc" id="L167">    bb.putInt(size)</span>
    // put the types of the keys and values
<span class="nc" id="L169">    putString(bb, keyLabel)</span>
<span class="nc" id="L170">    putString(bb, valueLabel)</span>
    // put each key value pair
<span class="nc bnc" id="L172" title="All 2 branches missed.">    map.asScala.foreach { case (k, v) =&gt;</span>
<span class="nc" id="L173">      keyPutMethod(bb, k)</span>
<span class="nc" id="L174">      valuePutMethod(bb, v)</span>
    }
    // flip (reset) the buffer so that it's ready for reading
<span class="nc" id="L177">    bb.flip</span>
<span class="nc" id="L178">    bb</span>
  }

  /**
   * Gets the appropriate byte buffer method for the given object type.
   *
   * @param label class type
   * @return size per item (if known, otherwise -1) + read method
   */
  private def getWriteMethod(label: String): (Int, (ByteBuffer, Any) =&gt; Unit) =
<span class="nc" id="L188">    label.toLowerCase(Locale.US) match {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">      case &quot;string&quot;  =&gt; (-1, (bb, v) =&gt; putString(bb, v.asInstanceOf[String]))</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">      case &quot;int&quot; |</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">           &quot;integer&quot; =&gt; (4, (bb, v) =&gt; bb.putInt(v.asInstanceOf[Int]))</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">      case &quot;double&quot;  =&gt; (8, (bb, v) =&gt; bb.putDouble(v.asInstanceOf[Double]))</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">      case &quot;long&quot;    =&gt; (8, (bb, v) =&gt; bb.putLong(v.asInstanceOf[Long]))</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      case &quot;float&quot;   =&gt; (4, (bb, v) =&gt; bb.putFloat(v.asInstanceOf[Float]))</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      case &quot;date&quot;    =&gt; (8, (bb, v) =&gt; bb.putLong(v.asInstanceOf[Date].getTime))</span>
<span class="nc bnc" id="L196" title="All 4 branches missed.">      case &quot;boolean&quot; =&gt; (1, (bb, v) =&gt; if (v.asInstanceOf[Boolean]) bb.put(1.toByte) else bb.put(0.toByte))</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">      case &quot;uuid&quot;    =&gt; (16, (bb, v) =&gt; putUUID(bb, v.asInstanceOf[UUID]))</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">      case &quot;byte[]&quot;  =&gt; (-1, (bb, v) =&gt; putBytes(bb, v.asInstanceOf[Array[Byte]]))</span>
      case _         =&gt;
<span class="nc" id="L200">        val msg = s&quot;Invalid collection type: '$label'. Only primitives and Dates are supported.&quot;</span>
<span class="nc" id="L201">        throw new IllegalArgumentException(msg)</span>
    }

  /**
   * Gets the appropriate byte buffer method for the given object type.
   *
   * @param label class type
   * @param bb buffer
   * @return
   */
  private def getReadMethod(label: String, bb: ByteBuffer): () =&gt; Object =
<span class="nc" id="L212">    label.toLowerCase(Locale.US) match {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">      case &quot;string&quot;  =&gt; () =&gt; getString(bb)</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">      case &quot;int&quot; |</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">           &quot;integer&quot; =&gt; () =&gt; bb.getInt.asInstanceOf[Object]</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">      case &quot;double&quot;  =&gt; () =&gt; bb.getDouble.asInstanceOf[Object]</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">      case &quot;long&quot;    =&gt; () =&gt; bb.getLong.asInstanceOf[Object]</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">      case &quot;float&quot;   =&gt; () =&gt; bb.getFloat.asInstanceOf[Object]</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">      case &quot;boolean&quot; =&gt; () =&gt; java.lang.Boolean.valueOf(bb.get &gt; 0)</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">      case &quot;date&quot;    =&gt; () =&gt; new Date(bb.getLong())</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">      case &quot;uuid&quot;    =&gt; () =&gt; getUUID(bb)</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">      case &quot;byte[]&quot;  =&gt; () =&gt; getBytes(bb)</span>
      case _         =&gt;
<span class="nc" id="L224">        val msg = s&quot;Invalid collection type: '$label'. Only primitives and Dates are supported.&quot;</span>
<span class="nc" id="L225">        throw new IllegalArgumentException(msg)</span>
    }

  /**
   * Gets the total bytes needed to encode the given values. For most types, the size is fixed, but
   * Strings and bytes are encoded with a dynamic length.
   *
   * @param bytesPerItem bytes per item
   * @param size number of items
   * @param values values
   * @return
   */
  private def getTotalBytes(bytesPerItem: Int, size: Int, values: Iterator[_], label: String): Int =
<span class="nc bnc" id="L238" title="All 2 branches missed.">    if (bytesPerItem == -1) {</span>
      // bytes are variable, we need to calculate them based on content
      // this only happens with strings
      // add 4 to each to use for length encoding
<span class="nc" id="L242">      label.toLowerCase match {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        case &quot;string&quot; =&gt; values.map(_.asInstanceOf[String].getBytes(StandardCharsets.UTF_8).length + 4).sum</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        case &quot;byte[]&quot; =&gt; values.map(_.asInstanceOf[Array[Byte]].length + 4).sum</span>
<span class="nc" id="L245">        case _ =&gt; throw new IllegalArgumentException(&quot;invalid type&quot;)</span>
      }
    } else {
<span class="nc" id="L248">      bytesPerItem * size</span>
    }

  /**
   * Reads a string from a byte buffer that has been written using @see putString.
   *
   * @param bb buffer
   * @return
   */
  private def getString(bb: ByteBuffer): String = {
<span class="nc" id="L258">    val size = bb.getInt</span>
<span class="nc" id="L259">    val buf = new Array[Byte](size)</span>
<span class="nc" id="L260">    bb.get(buf)</span>
<span class="nc" id="L261">    new String(buf, StandardCharsets.UTF_8)</span>
  }

  /**
   * Writes a string to a byte buffer by encoding the length first, then the bytes of the string.
   *
   * @param bb buffer
   * @param s string
   * @return
   */
<span class="nc" id="L271">  private def putString(bb: ByteBuffer, s: String): ByteBuffer = putBytes(bb, s.getBytes(StandardCharsets.UTF_8))</span>

  /**
    * Writes a byte array to a byte buffer by encoding the length first, then the bytes
    *
    * @param bb buffer
    * @param arr array
    * @return
    */
<span class="nc" id="L280">  private def putBytes(bb: ByteBuffer, arr: Array[Byte]): ByteBuffer = bb.putInt(arr.length).put(arr)</span>

  /**
    * Reads a byte array from a byte buffer that has been written using @see putBytes
    *
    * @param bb buffer
    * @return
    */
  private def getBytes(bb: ByteBuffer): Array[Byte] = {
<span class="nc" id="L289">    val sz = bb.getInt</span>
<span class="nc" id="L290">    val bytes = new Array[Byte](sz)</span>
<span class="nc" id="L291">    bb.get(bytes, 0, sz)</span>
<span class="nc" id="L292">    bytes</span>
  }

  private def putUUID(bb: ByteBuffer, uuid: UUID): ByteBuffer =
<span class="nc" id="L296">    bb.putLong(uuid.getMostSignificantBits).putLong(uuid.getLeastSignificantBits)</span>

<span class="nc" id="L298">  private def getUUID(bb: ByteBuffer): UUID = new UUID(bb.getLong, bb.getLong)</span>
<span class="nc" id="L299">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>