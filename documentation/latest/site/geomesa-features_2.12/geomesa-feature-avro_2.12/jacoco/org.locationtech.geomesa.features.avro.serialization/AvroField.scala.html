<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AvroField.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Avro</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.avro.serialization</a> &gt; <span class="el_source">AvroField.scala</span></div><h1>AvroField.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.avro
package serialization

import org.apache.avro.LogicalTypes.LogicalTypeFactory
import org.apache.avro.io.{Decoder, Encoder}
import org.apache.avro.{LogicalType, LogicalTypes, Schema, SchemaBuilder}
import org.geotools.api.feature.`type`.AttributeDescriptor
import org.locationtech.geomesa.utils.cache.SoftThreadLocal
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.text.{WKBUtils, WKTUtils}
import org.locationtech.jts.geom.Geometry

import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets
import java.util
import java.util.{Date, Locale, UUID}

/**
 * Trait for reading an avro field, corresponding to a simple feature attribute
 *
 * @tparam T type of attribute
 */
<span class="nc" id="L32">trait AvroField[T] {</span>

  /**
   * Schema of the field
   *
   * @return
   */
  def schema: Schema

  /**
   * Read the field value
   *
   * @param in input
   * @return
   */
  def read(in: Decoder): T = {
<span class="nc bnc" id="L48" title="All 2 branches missed.">    if (in.readIndex() == 1) {</span>
<span class="nc" id="L49">      in.readNull()</span>
<span class="nc" id="L50">      null.asInstanceOf[T]</span>
    } else {
<span class="nc" id="L52">      readNonNull(in)</span>
    }
  }

  /**
   * Skip over the field value - may be more efficient than reading and discarding it
   *
   * @param in input
   */
  def skip(in: Decoder): Unit = {
<span class="nc bnc" id="L62" title="All 2 branches missed.">    if (in.readIndex() == 1) {</span>
<span class="nc" id="L63">      in.readNull()</span>
    } else {
<span class="nc" id="L65">      skipNonNull(in)</span>
    }
  }

  /**
   * Write the field value
   *
   * @param out output
   * @param value value to write
   */
  def write(out: Encoder, value: T): Unit = {
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L77">      out.writeIndex(1)</span>
<span class="nc" id="L78">      out.writeNull()</span>
    } else {
<span class="nc" id="L80">      out.writeIndex(0)</span>
<span class="nc" id="L81">      writeNonNull(out, value)</span>
    }
  }

  /**
   * Gets a version-specific instance of this field.
   * See org.locationtech.geomesa.features.avro.SerializationVersions
   *
   * @param version version
   * @return
   */
<span class="nc" id="L92">  def withVersion(version: Int): AvroField[T] = this</span>

  protected def readNonNull(in: Decoder): T
  protected def skipNonNull(in: Decoder): Unit
  protected def writeNonNull(out: Encoder, value: T): Unit
}

<span class="nc" id="L99">object AvroField {</span>

<span class="nc" id="L101">  private val buffers = new SoftThreadLocal[(ByteBuffer, Array[Byte])]</span>

<span class="nc" id="L103">  Seq(WkbLogicalType, WktLogicalType, ListLogicalType, MapLogicalType)</span>
<span class="nc" id="L104">      .foreach(lt =&gt; LogicalTypes.register(lt.getName, lt))</span>

  /**
   * Get the field corresponding to the attribute descriptor
   *
   * @param descriptor descriptor
   * @return
   */
<span class="nc" id="L112">  def apply(descriptor: AttributeDescriptor): AvroField[AnyRef] = apply(ObjectType.selectType(descriptor))</span>

  private def apply(types: Seq[ObjectType]): AvroField[AnyRef] = {
<span class="nc" id="L115">    val field = types.head match {</span>
<span class="nc bnc" id="L116" title="All 6 branches missed.">      case ObjectType.STRING   =&gt; StringField</span>
<span class="nc bnc" id="L117" title="All 6 branches missed.">      case ObjectType.INT      =&gt; IntField</span>
<span class="nc bnc" id="L118" title="All 6 branches missed.">      case ObjectType.LONG     =&gt; LongField</span>
<span class="nc bnc" id="L119" title="All 6 branches missed.">      case ObjectType.FLOAT    =&gt; FloatField</span>
<span class="nc bnc" id="L120" title="All 6 branches missed.">      case ObjectType.DOUBLE   =&gt; DoubleField</span>
<span class="nc bnc" id="L121" title="All 6 branches missed.">      case ObjectType.BOOLEAN  =&gt; BooleanField</span>
<span class="nc bnc" id="L122" title="All 6 branches missed.">      case ObjectType.DATE     =&gt; DateField</span>
<span class="nc bnc" id="L123" title="All 6 branches missed.">      case ObjectType.UUID     =&gt; UuidBinaryField</span>
<span class="nc bnc" id="L124" title="All 6 branches missed.">      case ObjectType.GEOMETRY =&gt; GeometryField</span>
<span class="nc bnc" id="L125" title="All 6 branches missed.">      case ObjectType.LIST     =&gt; new ListOpaqueField(types(1))</span>
<span class="nc bnc" id="L126" title="All 6 branches missed.">      case ObjectType.MAP      =&gt; new MapOpaqueField(types(1), types(2))</span>
<span class="nc bnc" id="L127" title="All 6 branches missed.">      case ObjectType.BYTES    =&gt; BytesField</span>
<span class="nc" id="L128">      case t =&gt; throw new IllegalStateException(s&quot;Unexpected descriptor type: $t&quot;)</span>
    }
<span class="nc" id="L130">    field.asInstanceOf[AvroField[AnyRef]]</span>
  }

<span class="nc" id="L133">  abstract class StandardField[T](val name: String) extends AvroField[T] {</span>
<span class="nc" id="L134">    override def read(in: Decoder): T = readNonNull(in)</span>
<span class="nc" id="L135">    override def skip(in: Decoder): Unit = skipNonNull(in)</span>
<span class="nc" id="L136">    override def write(out: Encoder, value: T): Unit = writeNonNull(out, value)</span>
  }

  /**
   * The serialization version
   */
<span class="nc" id="L142">  case object VersionField extends StandardField[Int](&quot;__version__&quot;) {</span>
<span class="nc" id="L143">    override val schema: Schema = SchemaBuilder.builder().intType()</span>
<span class="nc" id="L144">    override protected def readNonNull(in: Decoder): Int = in.readInt()</span>
<span class="nc" id="L145">    override protected def skipNonNull(in: Decoder): Unit = in.readInt()</span>
<span class="nc" id="L146">    override protected def writeNonNull(out: Encoder, value: Int): Unit = out.writeInt(value)</span>
  }

  /**
   * The feature id
   */
<span class="nc" id="L152">  case object FidField extends StandardField[String](&quot;__fid__&quot;) {</span>
<span class="nc" id="L153">    override val schema: Schema = SchemaBuilder.builder().stringType()</span>
<span class="nc" id="L154">    override protected def readNonNull(in: Decoder): String = in.readString()</span>
<span class="nc" id="L155">    override protected def skipNonNull(in: Decoder): Unit = in.readString()</span>
<span class="nc" id="L156">    override protected def writeNonNull(out: Encoder, value: String): Unit = out.writeString(value)</span>
  }

  /**
   * The feature user data
   */
<span class="nc" id="L162">  case object UserDataField extends StandardField[java.util.Map[AnyRef, AnyRef]](&quot;__userdata__&quot;) {</span>
<span class="nc" id="L163">    override val schema: Schema = UserDataSchema.schema</span>
    override protected def readNonNull(in: Decoder): java.util.Map[AnyRef, AnyRef] =
<span class="nc" id="L165">      AvroUserDataSerialization.deserialize(in)</span>
<span class="nc" id="L166">    override protected def skipNonNull(in: Decoder): Unit = AvroUserDataSerialization.deserialize(in)</span>
    override protected def writeNonNull(out: Encoder, value: java.util.Map[AnyRef, AnyRef]): Unit =
<span class="nc" id="L168">      AvroUserDataSerialization.serialize(out, value)</span>
    override def withVersion(version: Int): AvroField[util.Map[AnyRef, AnyRef]] =
<span class="nc bnc" id="L170" title="All 2 branches missed.">      if (version &lt; 5) { UserDataFieldV4 } else { this }</span>
  }

  /**
   * Deprecated feature user data serialization
   */
<span class="nc" id="L176">  case object UserDataFieldV4 extends StandardField[java.util.Map[AnyRef, AnyRef]](&quot;__userdata__&quot;) {</span>
    // note that for versions &lt; 4 the schema is incorrect and a bug
<span class="nc" id="L178">    override val schema: Schema = UserDataSchema.schema</span>
    override protected def readNonNull(in: Decoder): java.util.Map[AnyRef, AnyRef] =
<span class="nc" id="L180">      AvroUserDataSerializationV4.deserialize(in)</span>
<span class="nc" id="L181">    override protected def skipNonNull(in: Decoder): Unit = AvroUserDataSerializationV4.deserialize(in)</span>
    // noinspection ScalaDeprecation
    override protected def writeNonNull(out: Encoder, value: java.util.Map[AnyRef, AnyRef]): Unit =
<span class="nc" id="L184">      AvroUserDataSerializationV4.serialize(out, value)</span>
    override def withVersion(version: Int): AvroField[util.Map[AnyRef, AnyRef]] =
<span class="nc bnc" id="L186" title="All 2 branches missed.">      if (version &lt; 5) { this } else { UserDataField }</span>
  }

<span class="nc" id="L189">  private object UserDataSchema {</span>

<span class="nc" id="L191">    private val kvType =</span>
<span class="nc" id="L192">      SchemaBuilder.builder().unionOf</span>
          .nullType.and
          .stringType.and
          .intType.and
          .longType.and
          .floatType.and
          .doubleType.and
          .booleanType.and
          .bytesType
          .endUnion()

<span class="nc" id="L203">    private val itemType =</span>
<span class="nc" id="L204">      SchemaBuilder.builder().record(&quot;userDataItem&quot;).fields()</span>
<span class="nc" id="L205">          .name(&quot;key&quot;).`type`(kvType).noDefault()</span>
<span class="nc" id="L206">          .name(&quot;value&quot;).`type`(kvType).noDefault()</span>
          .endRecord()

<span class="nc" id="L209">    val schema: Schema = SchemaBuilder.builder().array().items(itemType)</span>
  }

  /**
   * String type field
   */
<span class="nc" id="L215">  case object StringField extends AvroField[String] {</span>
<span class="nc" id="L216">    override val schema: Schema = SchemaBuilder.nullable().stringType()</span>
    override protected def readNonNull(in: Decoder): String = {
      // note: we don't use the string reading methods, as internal avro state can get corrupted and cause
      // exceptions in BinaryDecoder.scratchUtf8
<span class="nc bnc" id="L220" title="All 2 branches missed.">      var (bb, bytes) = buffers.getOrElseUpdate((ByteBuffer.allocate(16), Array.empty))</span>
<span class="nc" id="L221">      bb = in.readBytes(bb)</span>
<span class="nc" id="L222">      val length = bb.remaining</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">      if (bytes.length &lt; length) {</span>
<span class="nc" id="L224">        bytes = Array.ofDim(length)</span>
      }
<span class="nc" id="L226">      buffers.put((bb, bytes))</span>
<span class="nc" id="L227">      bb.get(bytes, 0, length)</span>
<span class="nc" id="L228">      new String(bytes, 0, length, StandardCharsets.UTF_8)</span>
    }
<span class="nc" id="L230">    override protected def skipNonNull(in: Decoder): Unit = in.skipBytes()</span>
<span class="nc" id="L231">    override protected def writeNonNull(out: Encoder, value: String): Unit = out.writeString(value)</span>
  }

  /**
   * Int type field
   */
<span class="nc" id="L237">  case object IntField extends AvroField[java.lang.Integer] {</span>
<span class="nc" id="L238">    override val schema: Schema = SchemaBuilder.nullable().intType()</span>
<span class="nc" id="L239">    override protected def readNonNull(in: Decoder): java.lang.Integer = Int.box(in.readInt())</span>
<span class="nc" id="L240">    override protected def skipNonNull(in: Decoder): Unit = in.readInt()</span>
<span class="nc" id="L241">    override protected def writeNonNull(out: Encoder, value: java.lang.Integer): Unit = out.writeInt(value)</span>
  }

  /**
   * Long type field
   */
<span class="nc" id="L247">  case object LongField extends AvroField[java.lang.Long] {</span>
<span class="nc" id="L248">    override val schema: Schema = SchemaBuilder.nullable().longType()</span>
<span class="nc" id="L249">    override protected def readNonNull(in: Decoder): java.lang.Long = Long.box(in.readLong())</span>
<span class="nc" id="L250">    override protected def skipNonNull(in: Decoder): Unit = in.readLong()</span>
<span class="nc" id="L251">    override protected def writeNonNull(out: Encoder, value: java.lang.Long): Unit = out.writeLong(value)</span>
  }

  /**
   * Float type field
   */
<span class="nc" id="L257">  case object FloatField extends AvroField[java.lang.Float] {</span>
<span class="nc" id="L258">    override val schema: Schema = SchemaBuilder.nullable().floatType()</span>
<span class="nc" id="L259">    override protected def readNonNull(in: Decoder): java.lang.Float = Float.box(in.readFloat())</span>
<span class="nc" id="L260">    override protected def skipNonNull(in: Decoder): Unit = in.readFloat()</span>
<span class="nc" id="L261">    override protected def writeNonNull(out: Encoder, value: java.lang.Float): Unit = out.writeFloat(value)</span>
  }

  /**
   * Double type field
   */
<span class="nc" id="L267">  case object DoubleField extends AvroField[java.lang.Double] {</span>
<span class="nc" id="L268">    override val schema: Schema = SchemaBuilder.nullable().doubleType()</span>
<span class="nc" id="L269">    override protected def readNonNull(in: Decoder): java.lang.Double = Double.box(in.readDouble())</span>
<span class="nc" id="L270">    override protected def skipNonNull(in: Decoder): Unit = in.readDouble()</span>
<span class="nc" id="L271">    override protected def writeNonNull(out: Encoder, value: java.lang.Double): Unit = out.writeDouble(value)</span>
  }

  /**
   * Boolean type field
   */
<span class="nc" id="L277">  case object BooleanField extends AvroField[java.lang.Boolean] {</span>
<span class="nc" id="L278">    override val schema: Schema = SchemaBuilder.nullable().booleanType()</span>
<span class="nc" id="L279">    override protected def readNonNull(in: Decoder): java.lang.Boolean = Boolean.box(in.readBoolean())</span>
<span class="nc" id="L280">    override protected def skipNonNull(in: Decoder): Unit = in.readBoolean()</span>
<span class="nc" id="L281">    override protected def writeNonNull(out: Encoder, value: java.lang.Boolean): Unit = out.writeBoolean(value)</span>
  }

  /**
   * Date type field, stored as millis since epoch
   */
<span class="nc" id="L287">  case object DateField extends AvroField[Date] {</span>
<span class="nc" id="L288">    override val schema: Schema =</span>
<span class="nc" id="L289">      SchemaBuilder.nullable().`type`(LogicalTypes.timestampMillis.addToSchema(SchemaBuilder.builder().longType()))</span>
<span class="nc" id="L290">    override protected def readNonNull(in: Decoder): Date = new Date(in.readLong())</span>
<span class="nc" id="L291">    override protected def skipNonNull(in: Decoder): Unit = in.readLong()</span>
<span class="nc" id="L292">    override protected def writeNonNull(out: Encoder, value: Date): Unit = out.writeLong(value.getTime)</span>
  }

  /**
   * UUID type field, stored as binary two longs
   */
<span class="nc" id="L298">  case object UuidBinaryField extends AvroField[UUID] {</span>

<span class="nc" id="L300">    override val schema: Schema = SchemaBuilder.nullable().bytesType()</span>

<span class="nc" id="L302">    def decode(buf: ByteBuffer): UUID = new UUID(buf.getLong, buf.getLong)</span>

    override protected def readNonNull(in: Decoder): UUID = {
<span class="nc bnc" id="L305" title="All 2 branches missed.">      var (bb, bytes) = buffers.getOrElseUpdate((ByteBuffer.allocate(16), Array.empty))</span>
<span class="nc" id="L306">      bb = in.readBytes(bb)</span>
<span class="nc" id="L307">      buffers.put((bb, bytes))</span>
<span class="nc" id="L308">      decode(bb)</span>
    }

<span class="nc" id="L311">    override protected def skipNonNull(in: Decoder): Unit = in.skipBytes()</span>

    override protected def writeNonNull(out: Encoder, value: UUID): Unit = {
      val buf =
<span class="nc" id="L315">        ByteBuffer.allocate(16)</span>
<span class="nc" id="L316">          .putLong(value.getMostSignificantBits)</span>
<span class="nc" id="L317">          .putLong(value.getLeastSignificantBits)</span>
          .flip.asInstanceOf[ByteBuffer]
<span class="nc" id="L319">      out.writeBytes(buf)</span>
    }

    override def withVersion(version: Int): AvroField[UUID] =
<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (version == SerializationVersions.NativeCollectionVersion) { UuidRecordField } else { this }</span>
  }

  /**
   * UUID type field, stored as a record with two longs
   */
<span class="nc" id="L329">  case object UuidRecordField extends AvroField[UUID] {</span>

<span class="nc" id="L331">    override val schema: Schema =</span>
<span class="nc" id="L332">      SchemaBuilder.nullable().record(&quot;uuid&quot;).fields()</span>
<span class="nc" id="L333">        .name(&quot;msb&quot;).`type`().longType().noDefault()</span>
<span class="nc" id="L334">        .name(&quot;lsb&quot;).`type`().longType().noDefault()</span>
        .endRecord()

<span class="nc" id="L337">    override protected def readNonNull(in: Decoder): UUID = new UUID(in.readLong(), in.readLong())</span>

    override protected def skipNonNull(in: Decoder): Unit = {
<span class="nc" id="L340">      in.readLong()</span>
<span class="nc" id="L341">      in.readLong()</span>
    }

    override protected def writeNonNull(out: Encoder, value: UUID): Unit = {
<span class="nc" id="L345">      out.writeLong(value.getMostSignificantBits)</span>
<span class="nc" id="L346">      out.writeLong(value.getLeastSignificantBits)</span>
    }

    override def withVersion(version: Int): AvroField[UUID] =
<span class="nc bnc" id="L350" title="All 2 branches missed.">      if (version == SerializationVersions.NativeCollectionVersion) { this } else { UuidBinaryField }</span>
  }

  /**
   * Base trait for Geometry type fields
   */
<span class="nc" id="L356">  trait GeomField extends AvroField[Geometry] {</span>

    override protected def readNonNull(in: Decoder): Geometry = {
<span class="nc bnc" id="L359" title="All 2 branches missed.">      var (bb, bytes) = buffers.getOrElseUpdate((ByteBuffer.allocate(16), Array.empty))</span>
<span class="nc" id="L360">      bb = in.readBytes(bb)</span>
<span class="nc" id="L361">      val length = bb.remaining</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">      if (bytes.length &lt; length) {</span>
<span class="nc" id="L363">        bytes = Array.ofDim(length)</span>
      }
<span class="nc" id="L365">      buffers.put((bb, bytes))</span>
<span class="nc" id="L366">      bb.get(bytes, 0, length)</span>

<span class="nc" id="L368">      parse(bytes, length)</span>
    }

    protected def parse(bytes: Array[Byte], length: Int): Geometry

<span class="nc" id="L373">    override protected def skipNonNull(in: Decoder): Unit = in.skipBytes()</span>
  }

  /**
   * Geometry type field, stored as WKB
   */
<span class="nc" id="L379">  case object GeometryField extends GeomField {</span>

<span class="nc" id="L381">    override val schema: Schema =</span>
<span class="nc" id="L382">      SchemaBuilder.nullable().`type`(WkbLogicalType.addToSchema(SchemaBuilder.builder().bytesType()))</span>

    // note: WKBReader ignores any bytes after the geom
<span class="nc" id="L385">    override protected def parse(bytes: Array[Byte], length: Int): Geometry = WKBUtils.read(bytes)</span>

    override protected def writeNonNull(out: Encoder, value: Geometry): Unit =
<span class="nc" id="L388">      out.writeBytes(ByteBuffer.wrap(WKBUtils.write(value)))</span>

    override def withVersion(version: Int): AvroField[Geometry] =
<span class="nc bnc" id="L391" title="All 2 branches missed.">      if (version == 1) { GeometryFieldV1 } else { this }</span>
  }

  /**
   * Deprecated geometry type field, stored as WKT
   */
<span class="nc" id="L397">  case object GeometryFieldV1 extends GeomField {</span>

<span class="nc" id="L399">    override val schema: Schema =</span>
<span class="nc" id="L400">      SchemaBuilder.nullable().`type`(WktLogicalType.addToSchema(SchemaBuilder.builder().bytesType()))</span>

    override protected def parse(bytes: Array[Byte], length: Int): Geometry =
<span class="nc" id="L403">      WKTUtils.read(new String(bytes, 0, length, StandardCharsets.UTF_8))</span>

    override protected def writeNonNull(out: Encoder, value: Geometry): Unit =
<span class="nc" id="L406">      out.writeBytes(ByteBuffer.wrap(WKTUtils.write(value).getBytes(StandardCharsets.UTF_8)))</span>

    override def withVersion(version: Int): AvroField[Geometry] =
<span class="nc bnc" id="L409" title="All 2 branches missed.">      if (version == 1) { this } else { GeometryField }</span>
  }

  /**
   * Byte array type field
   */
<span class="nc" id="L415">  case object BytesField extends AvroField[Array[Byte]] {</span>

<span class="nc" id="L417">    override val schema: Schema = SchemaBuilder.nullable().bytesType()</span>

    override protected def readNonNull(in: Decoder): Array[Byte] = {
<span class="nc bnc" id="L420" title="All 2 branches missed.">      var (bb, bytes) = buffers.getOrElseUpdate((ByteBuffer.allocate(16), Array.empty))</span>
<span class="nc" id="L421">      bb = in.readBytes(bb)</span>
<span class="nc" id="L422">      buffers.put((bb, bytes))</span>
<span class="nc" id="L423">      val value = Array.ofDim[Byte](bb.remaining)</span>
<span class="nc" id="L424">      bb.get(value)</span>
<span class="nc" id="L425">      value</span>
    }

<span class="nc" id="L428">    override protected def skipNonNull(in: Decoder): Unit = in.skipBytes()</span>

    override protected def writeNonNull(out: Encoder, value: Array[Byte]): Unit =
<span class="nc" id="L431">      out.writeBytes(ByteBuffer.wrap(value))</span>
  }

  /**
   * List-type field, stored as binary using a custom serialization format
   *
   * @param items type of list items
   */
<span class="nc" id="L439">  class ListOpaqueField(items: ObjectType) extends AvroField[java.util.List[AnyRef]] {</span>

<span class="nc" id="L441">    private val binding = items match {</span>
<span class="nc bnc" id="L442" title="All 6 branches missed.">      case ObjectType.BYTES =&gt; &quot;byte[]&quot;</span>
<span class="nc" id="L443">      case t =&gt; t.toString.toLowerCase(Locale.US)</span>
    }

<span class="nc" id="L446">    override val schema: Schema =</span>
<span class="nc" id="L447">      SchemaBuilder.nullable().`type`(ListLogicalType.addToSchema(SchemaBuilder.builder().bytesType()))</span>

    override protected def readNonNull(in: Decoder): java.util.List[AnyRef] = {
<span class="nc bnc" id="L450" title="All 2 branches missed.">      var (bb, bytes) = buffers.getOrElseUpdate((ByteBuffer.allocate(16), Array.empty))</span>
<span class="nc" id="L451">      bb = in.readBytes(bb)</span>
<span class="nc" id="L452">      buffers.put((bb, bytes))</span>
<span class="nc" id="L453">      CollectionSerialization.decodeList(bb)</span>
    }

<span class="nc" id="L456">    override protected def skipNonNull(in: Decoder): Unit = in.skipBytes()</span>

    override protected def writeNonNull(out: Encoder, value: java.util.List[AnyRef]): Unit =
<span class="nc" id="L459">      out.writeBytes(CollectionSerialization.encodeList(value.asInstanceOf[java.util.List[_]], binding))</span>

    override def withVersion(version: Int): AvroField[util.List[AnyRef]] =
<span class="nc bnc" id="L462" title="All 2 branches missed.">      if (version == SerializationVersions.NativeCollectionVersion) { new ListNativeField(items) } else { this }</span>
  }

  /**
   * List-type field, stored as a native avro array
   *
   * @param items type of list items
   */
<span class="nc" id="L470">  class ListNativeField(items: ObjectType) extends AvroField[java.util.List[AnyRef]] {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L474">    private val field = AvroField.apply(Seq(items))</span>

<span class="nc" id="L476">    override val schema: Schema = SchemaBuilder.nullable().array().items(field.schema)</span>

    override protected def readNonNull(in: Decoder): java.util.List[AnyRef] = {
<span class="nc" id="L479">      var i = in.readArrayStart()</span>
<span class="nc" id="L480">      val result = new java.util.ArrayList[AnyRef](i.toInt)</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">      while (i != 0) {</span>
<span class="nc" id="L482">        var j = 0</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        while (j &lt; i) {</span>
<span class="nc" id="L484">          result.add(field.read(in))</span>
<span class="nc" id="L485">          j += 1</span>
        }
<span class="nc" id="L487">        i = in.arrayNext()</span>
      }
<span class="nc" id="L489">      result</span>
    }

    override protected def skipNonNull(in: Decoder): Unit = {
<span class="nc" id="L493">      var i = in.skipArray()</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">      while (i != 0) {</span>
<span class="nc" id="L495">        var j = 0</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        while (j &lt; i) {</span>
<span class="nc" id="L497">          field.skip(in)</span>
<span class="nc" id="L498">          j += 1</span>
        }
<span class="nc" id="L500">        i = in.arrayNext()</span>
      }
    }

    override protected def writeNonNull(out: Encoder, value: java.util.List[AnyRef]): Unit = {
<span class="nc" id="L505">      out.writeArrayStart()</span>
<span class="nc" id="L506">      out.setItemCount(value.size)</span>
<span class="nc" id="L507">      value.asScala.foreach { v =&gt;</span>
<span class="nc" id="L508">        out.startItem()</span>
<span class="nc" id="L509">        field.write(out, v)</span>
      }
<span class="nc" id="L511">      out.writeArrayEnd()</span>
    }

    override def withVersion(version: Int): AvroField[java.util.List[AnyRef]] =
<span class="nc bnc" id="L515" title="All 2 branches missed.">      if (version == SerializationVersions.NativeCollectionVersion) { this } else { new ListOpaqueField(items) }</span>
  }

  /**
   * Map type field, stored as binary using a custom serialization format
   *
   * @param keys key type
   * @param values value type
   */
<span class="nc" id="L524">  class MapOpaqueField(keys: ObjectType, values: ObjectType) extends AvroField[java.util.Map[AnyRef, AnyRef]] {</span>

<span class="nc" id="L526">    private val keyBinding = keys match {</span>
<span class="nc bnc" id="L527" title="All 6 branches missed.">      case ObjectType.BYTES =&gt; &quot;byte[]&quot;</span>
<span class="nc" id="L528">      case t =&gt; t.toString.toLowerCase(Locale.US)</span>
    }

<span class="nc" id="L531">    private val valueBinding = values match {</span>
<span class="nc bnc" id="L532" title="All 6 branches missed.">      case ObjectType.BYTES =&gt; &quot;byte[]&quot;</span>
<span class="nc" id="L533">      case t =&gt; t.toString.toLowerCase(Locale.US)</span>
    }

<span class="nc" id="L536">    override val schema: Schema =</span>
<span class="nc" id="L537">      SchemaBuilder.nullable().`type`(MapLogicalType.addToSchema(SchemaBuilder.builder().bytesType()))</span>

    override protected def readNonNull(in: Decoder): java.util.Map[AnyRef, AnyRef] = {
<span class="nc bnc" id="L540" title="All 2 branches missed.">      var (bb, bytes) = buffers.getOrElseUpdate((ByteBuffer.allocate(16), Array.empty))</span>
<span class="nc" id="L541">      bb = in.readBytes(bb)</span>
<span class="nc" id="L542">      buffers.put((bb, bytes))</span>
<span class="nc" id="L543">      CollectionSerialization.decodeMap(bb)</span>
    }

<span class="nc" id="L546">    override protected def skipNonNull(in: Decoder): Unit = in.skipBytes()</span>

    override protected def writeNonNull(out: Encoder, value: java.util.Map[AnyRef, AnyRef]): Unit =
<span class="nc" id="L549">      out.writeBytes(CollectionSerialization.encodeMap(value, keyBinding, valueBinding))</span>

    override def withVersion(version: Int): AvroField[java.util.Map[AnyRef, AnyRef]] = {
<span class="nc bnc" id="L552" title="All 2 branches missed.">      if (version == SerializationVersions.NativeCollectionVersion) {</span>
<span class="nc bnc" id="L553" title="All 6 branches missed.">        if (keys == ObjectType.STRING) {</span>
<span class="nc" id="L554">          new MapNativeField(values)</span>
        } else {
<span class="nc" id="L556">          new MapNativeRecordField(keys, values)</span>
        }
      } else {
<span class="nc" id="L559">        this</span>
      }
    }
  }

  /**
   * Map type field, stored as native avro using an array of key-value records
   *
   * @param keys key type
   * @param values value type
   */
<span class="nc" id="L570">  class MapNativeRecordField(keys: ObjectType, values: ObjectType)</span>
<span class="nc" id="L571">      extends AvroField[java.util.Map[AnyRef, AnyRef]] {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L575">    private val keyField = AvroField.apply(Seq(keys))</span>
<span class="nc" id="L576">    private val valueField = AvroField.apply(Seq(values))</span>

<span class="nc" id="L578">    override val schema: Schema =</span>
<span class="nc" id="L579">      SchemaBuilder.builder().array().items().record(&quot;entry&quot;).fields()</span>
<span class="nc" id="L580">        .name(&quot;key&quot;).`type`(keyField.schema).noDefault()</span>
<span class="nc" id="L581">        .name(&quot;value&quot;).`type`(valueField.schema).noDefault()</span>
        .endRecord()

    override protected def readNonNull(in: Decoder): java.util.Map[AnyRef, AnyRef] = {
<span class="nc" id="L585">      var i = in.readArrayStart()</span>
<span class="nc" id="L586">      val result = new java.util.HashMap[AnyRef, AnyRef](i.toInt)</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">      while (i != 0) {</span>
<span class="nc" id="L588">        var j = 0</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        while (j &lt; i) {</span>
<span class="nc" id="L590">          result.put(keyField.read(in), valueField.read(in))</span>
<span class="nc" id="L591">          j += 1</span>
        }
<span class="nc" id="L593">        i = in.arrayNext()</span>
      }
<span class="nc" id="L595">      result</span>
    }

    override protected def skipNonNull(in: Decoder): Unit = {
<span class="nc" id="L599">      var i = in.skipArray()</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">      while (i != 0) {</span>
<span class="nc" id="L601">        var j = 0</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        while (j &lt; i) {</span>
<span class="nc" id="L603">          keyField.skip(in)</span>
<span class="nc" id="L604">          valueField.skip(in)</span>
<span class="nc" id="L605">          j += 1</span>
        }
<span class="nc" id="L607">        i = in.arrayNext()</span>
      }
    }

    override protected def writeNonNull(out: Encoder, value: java.util.Map[AnyRef, AnyRef]): Unit = {
<span class="nc" id="L612">      out.writeArrayStart()</span>
<span class="nc" id="L613">      out.setItemCount(value.size)</span>
<span class="nc" id="L614">      value.asScala.foreach { v =&gt;</span>
<span class="nc" id="L615">        out.startItem()</span>
<span class="nc" id="L616">        keyField.write(out, v)</span>
<span class="nc" id="L617">        valueField.write(out, v)</span>
      }
<span class="nc" id="L619">      out.writeArrayEnd()</span>
    }

    override def withVersion(version: Int): AvroField[java.util.Map[AnyRef, AnyRef]] = {
<span class="nc bnc" id="L623" title="All 2 branches missed.">      if (version == SerializationVersions.NativeCollectionVersion) { this } else {</span>
<span class="nc" id="L624">        new MapOpaqueField(keys, values)</span>
      }
    }
  }

  /**
   * Map type field, stored as a native avro map (which requires strings for keys)
   *
   * @param values value type
   */
<span class="nc" id="L634">  class MapNativeField(values: ObjectType) extends AvroField[java.util.Map[AnyRef, AnyRef]]{</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L638">    private val field = AvroField.apply(Seq(values))</span>

<span class="nc" id="L640">    override val schema: Schema = SchemaBuilder.nullable().map().values(field.schema)</span>

    override protected def readNonNull(in: Decoder): java.util.Map[AnyRef, AnyRef] = {
<span class="nc" id="L643">      var i = in.readMapStart()</span>
<span class="nc" id="L644">      val result = new java.util.HashMap[AnyRef, AnyRef](i.toInt)</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">      while (i != 0) {</span>
<span class="nc" id="L646">        var j = 0</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">        while (j &lt; i) {</span>
<span class="nc" id="L648">          val key = in.readString</span>
<span class="nc" id="L649">          result.put(key, field.read(in))</span>
<span class="nc" id="L650">          j += 1</span>
        }
<span class="nc" id="L652">        i = in.mapNext()</span>
      }
<span class="nc" id="L654">      result</span>
    }

    override protected def skipNonNull(in: Decoder): Unit = {
<span class="nc" id="L658">      var i = in.skipMap()</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">      while (i != 0) {</span>
<span class="nc" id="L660">        var j = 0</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">        while (j &lt; i) {</span>
<span class="nc" id="L662">          in.skipString()</span>
<span class="nc" id="L663">          field.skip(in)</span>
<span class="nc" id="L664">          j += 1</span>
        }
<span class="nc" id="L666">        i = in.skipMap()</span>
      }
    }

    override protected def writeNonNull(out: Encoder, value: java.util.Map[AnyRef, AnyRef]): Unit = {
<span class="nc" id="L671">      out.writeMapStart()</span>
<span class="nc" id="L672">      out.setItemCount(value.size)</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">      value.asScala.foreach { case (k, v) =&gt;</span>
<span class="nc" id="L674">        out.startItem()</span>
<span class="nc" id="L675">        out.writeString(k.asInstanceOf[String])</span>
<span class="nc" id="L676">        field.write(out, v)</span>
      }
<span class="nc" id="L678">      out.writeMapEnd()</span>
    }

    override def withVersion(version: Int): AvroField[java.util.Map[AnyRef, AnyRef]] = {
<span class="nc bnc" id="L682" title="All 2 branches missed.">      if (version == SerializationVersions.NativeCollectionVersion) { this } else {</span>
<span class="nc" id="L683">        new MapOpaqueField(ObjectType.STRING, values)</span>
      }
    }
  }

<span class="nc" id="L688">  object WkbLogicalType extends LogicalType(&quot;wkb&quot;) with LogicalTypeFactory {</span>

<span class="nc" id="L690">    override def fromSchema(schema: Schema): LogicalType = this</span>

    override def validate(schema: Schema): Unit = {
<span class="nc" id="L693">      super.validate(schema)</span>
<span class="nc bnc" id="L694" title="All 6 branches missed.">      if (schema.getType != Schema.Type.BYTES) {</span>
<span class="nc" id="L695">        throw new IllegalArgumentException(&quot;WKB geometries can only be used with an underlying binary type&quot;)</span>
      }
    }
  }

<span class="nc" id="L700">  object WktLogicalType extends LogicalType(&quot;wkt&quot;) with LogicalTypeFactory {</span>

<span class="nc" id="L702">    override def fromSchema(schema: Schema): LogicalType = this</span>

    override def validate(schema: Schema): Unit = {
<span class="nc" id="L705">      super.validate(schema)</span>
<span class="nc bnc" id="L706" title="All 12 branches missed.">      if (schema.getType != Schema.Type.BYTES &amp;&amp; schema.getType != Schema.Type.STRING) {</span>
<span class="nc" id="L707">        throw new IllegalArgumentException(&quot;WKT geometries can only be used with an underlying binary or string type&quot;)</span>
      }
    }
  }

<span class="nc" id="L712">  object ListLogicalType extends LogicalType(&quot;list&quot;) with LogicalTypeFactory {</span>

<span class="nc" id="L714">    override def fromSchema(schema: Schema): LogicalType = this</span>

    override def validate(schema: Schema): Unit = {
<span class="nc" id="L717">      super.validate(schema)</span>
<span class="nc bnc" id="L718" title="All 6 branches missed.">      if (schema.getType != Schema.Type.BYTES) {</span>
<span class="nc" id="L719">        throw new IllegalArgumentException(&quot;List can only be used with an underlying binary type&quot;)</span>
      }
    }
  }

<span class="nc" id="L724">  object MapLogicalType extends LogicalType(&quot;map&quot;) with LogicalTypeFactory {</span>

<span class="nc" id="L726">    override def fromSchema(schema: Schema): LogicalType = this</span>

    override def validate(schema: Schema): Unit = {
<span class="nc" id="L729">      super.validate(schema)</span>
<span class="nc bnc" id="L730" title="All 6 branches missed.">      if (schema.getType != Schema.Type.BYTES) {</span>
<span class="nc" id="L731">        throw new IllegalArgumentException(&quot;Map can only be used with an underlying binary type&quot;)</span>
      }
    }
  }
<span class="nc" id="L735">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>