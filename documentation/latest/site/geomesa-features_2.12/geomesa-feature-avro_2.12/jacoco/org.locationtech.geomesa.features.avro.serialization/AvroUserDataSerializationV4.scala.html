<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AvroUserDataSerializationV4.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Avro</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.avro.serialization</a> &gt; <span class="el_source">AvroUserDataSerializationV4.scala</span></div><h1>AvroUserDataSerializationV4.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.avro.serialization

import com.typesafe.scalalogging.LazyLogging
import org.apache.avro.io.{Decoder, Encoder}
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.serialization.HintKeySerialization
import org.locationtech.geomesa.utils.text.WKBUtils
import org.locationtech.jts.geom.Geometry

import java.util.{Date, UUID}

<span class="nc bnc" id="L20" title="All 4 branches missed.">object AvroUserDataSerializationV4 extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L24">  val NullMarkerString = &quot;&lt;null&gt;&quot;</span>

  @deprecated(&quot;does not match declared schema&quot;)
  private[serialization] def serialize(out: Encoder, map: java.util.Map[_ &lt;: AnyRef, _ &lt;: AnyRef]): Unit = {
    // may not be able to write all entries - must pre-filter to know correct count
<span class="nc bnc" id="L29" title="All 2 branches missed.">    val filtered = map.asScala.filter { case (key, value) =&gt;</span>
<span class="nc bnc" id="L30" title="All 2 branches missed.">      if (canSerialize(key)) {</span>
<span class="nc" id="L31">        true</span>
      } else {
<span class="nc bnc" id="L33" title="All 2 branches missed.">        logger.warn(s&quot;Can't serialize Map entry ($key,$value) - it will be skipped.&quot;)</span>
<span class="nc" id="L34">        false</span>
      }
    }

<span class="nc" id="L38">    out.writeArrayStart()</span>
<span class="nc" id="L39">    out.setItemCount(filtered.size)</span>

<span class="nc bnc" id="L41" title="All 2 branches missed.">    filtered.foreach { case (key, value) =&gt;</span>
<span class="nc" id="L42">      out.startItem()</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">      if (key == null) {</span>
<span class="nc" id="L44">        out.writeString(NullMarkerString)</span>
      } else {
<span class="nc" id="L46">        out.writeString(key.getClass.getName)</span>
<span class="nc" id="L47">        write(out, key)</span>
      }
<span class="nc bnc" id="L49" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L50">        out.writeString(NullMarkerString)</span>
      } else {
<span class="nc" id="L52">        out.writeString(value.getClass.getName)</span>
<span class="nc" id="L53">        write(out, value)</span>
      }
    }

<span class="nc" id="L57">    out.writeArrayEnd()</span>
  }

  def deserialize(in: Decoder): java.util.Map[AnyRef, AnyRef] = {
<span class="nc" id="L61">    val size = in.readArrayStart().toInt</span>
<span class="nc" id="L62">    val map = new java.util.HashMap[AnyRef, AnyRef](size)</span>
<span class="nc" id="L63">    deserializeWithSize(in, size, map)</span>
<span class="nc" id="L64">    map</span>
  }

  def deserialize(in: Decoder, map: java.util.Map[AnyRef, AnyRef]): Unit = {
<span class="nc" id="L68">    deserializeWithSize(in, in.readArrayStart().toInt, map)</span>
  }

  private def deserializeWithSize(in: Decoder, size: Int, map: java.util.Map[AnyRef, AnyRef]): Unit = {
<span class="nc" id="L72">    var remaining = size</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">    while (remaining &gt; 0) {</span>
<span class="nc" id="L74">      val keyClass = in.readString()</span>
      val key =
<span class="nc bnc" id="L76" title="All 6 branches missed.">        if (keyClass == NullMarkerString) { null }</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">        else if (keyClass == &quot;org.geotools.factory.Hints$Key&quot;) { HintKeySerialization.idToKey(in.readString()) }</span>
<span class="nc" id="L78">        else { read(in, Class.forName(keyClass)) }</span>
<span class="nc" id="L79">      val valueClass = in.readString()</span>
<span class="nc bnc" id="L80" title="All 6 branches missed.">      val value = if (valueClass == NullMarkerString) { null } else { read(in, Class.forName(valueClass))}</span>
<span class="nc" id="L81">      map.put(key, value)</span>
<span class="nc" id="L82">      remaining -= 1</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      if (remaining == 0) {</span>
<span class="nc" id="L84">        remaining = in.arrayNext().toInt</span>
      }
    }
  }

<span class="nc" id="L89">  private def write(out: Encoder, value: AnyRef): Unit = value match {</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">    case v: String                 =&gt; out.writeString(v)</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">    case v: java.lang.Integer      =&gt; out.writeInt(v)</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">    case v: java.lang.Long         =&gt; out.writeLong(v)</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">    case v: java.lang.Float        =&gt; out.writeFloat(v)</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">    case v: java.lang.Double       =&gt; out.writeDouble(v)</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">    case v: java.lang.Boolean      =&gt; out.writeBoolean(v)</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">    case v: Date                   =&gt; out.writeLong(v.getTime)</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">    case v: Array[Byte]            =&gt; out.writeBytes(v)</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    case v: Geometry               =&gt; out.writeBytes(WKBUtils.write(v))</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">    case v: UUID                   =&gt; out.writeLong(v.getMostSignificantBits); out.writeLong(v.getLeastSignificantBits)</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">    case v: java.util.List[AnyRef] =&gt; writeList(out, v)</span>
<span class="nc" id="L101">    case _ =&gt; throw new IllegalArgumentException(s&quot;Unsupported value: $value (${value.getClass})&quot;)</span>
  }

  /**
   * Read a key or value. Strings will be interned, as we expect a lot of duplication in user data,
   * i.e keys but also visibilities, which is the only user data we generally store
   *
   * @param in input
   * @param clas class of the item to read
   * @return
   */
<span class="nc" id="L112">  private def read(in: Decoder, clas: Class[_]): AnyRef = clas match {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">    case c if classOf[java.lang.String].isAssignableFrom(c)  =&gt; in.readString().intern()</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; Int.box(in.readInt())</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">    case c if classOf[java.lang.Long].isAssignableFrom(c)    =&gt; Long.box(in.readLong())</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">    case c if classOf[java.lang.Float].isAssignableFrom(c)   =&gt; Float.box(in.readFloat())</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">    case c if classOf[java.lang.Double].isAssignableFrom(c)  =&gt; Double.box(in.readDouble())</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">    case c if classOf[java.lang.Boolean].isAssignableFrom(c) =&gt; Boolean.box(in.readBoolean())</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">    case c if classOf[java.util.Date].isAssignableFrom(c)    =&gt; new java.util.Date(in.readLong())</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">    case c if classOf[Array[Byte]] == c                      =&gt; readBytes(in)</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">    case c if classOf[Geometry].isAssignableFrom(c)          =&gt; WKBUtils.read(readBytes(in))</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">    case c if classOf[UUID].isAssignableFrom(c)              =&gt; new UUID(in.readLong(), in.readLong())</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">    case c if classOf[java.util.List[_]].isAssignableFrom(c) =&gt; readList(in)</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    case c if classOf[Hints.Key].isAssignableFrom(c)         =&gt; HintKeySerialization.idToKey(in.readString())</span>
<span class="nc" id="L125">    case _ =&gt; throw new IllegalArgumentException(s&quot;Unsupported value class: $clas&quot;)</span>
  }

  private def readBytes(in: Decoder): Array[Byte] = {
<span class="nc" id="L129">    val buffer = in.readBytes(null)</span>
<span class="nc" id="L130">    val bytes = Array.ofDim[Byte](buffer.remaining())</span>
<span class="nc" id="L131">    buffer.get(bytes)</span>
<span class="nc" id="L132">    bytes</span>
  }

  private def writeList(out: Encoder, list: java.util.List[AnyRef]): Unit = {
<span class="nc" id="L136">    out.writeArrayStart()</span>
<span class="nc" id="L137">    out.setItemCount(list.size())</span>
<span class="nc" id="L138">    list.asScala.foreach { value =&gt;</span>
<span class="nc" id="L139">      out.startItem()</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L141">        out.writeString(NullMarkerString)</span>
      } else {
<span class="nc" id="L143">        out.writeString(value.getClass.getName)</span>
<span class="nc" id="L144">        write(out, value)</span>
      }
    }
<span class="nc" id="L147">    out.writeArrayEnd()</span>
  }

  private def readList(in: Decoder): java.util.List[AnyRef] = {
<span class="nc" id="L151">    val size = in.readArrayStart().toInt</span>
<span class="nc" id="L152">    val list = new java.util.ArrayList[AnyRef](size)</span>
<span class="nc" id="L153">    var remaining = size</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">    while (remaining &gt; 0) {</span>
<span class="nc" id="L155">      val clas = in.readString()</span>
<span class="nc bnc" id="L156" title="All 6 branches missed.">      val value = if (clas == NullMarkerString) { null } else { read(in, Class.forName(clas)) }</span>
<span class="nc" id="L157">      list.add(value)</span>
<span class="nc" id="L158">      remaining -= 1</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">      if (remaining == 0) {</span>
<span class="nc" id="L160">        remaining = in.arrayNext().toInt</span>
      }
    }
<span class="nc" id="L163">    list</span>
  }

<span class="nc" id="L166">  private def canSerialize(obj: AnyRef): Boolean = obj match {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">    case key: Hints.Key =&gt; HintKeySerialization.canSerialize(key)</span>
<span class="nc" id="L168">    case _ =&gt; true</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>