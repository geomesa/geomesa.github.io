<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AvroSerialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Avro</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.avro.serialization</a> &gt; <span class="el_source">AvroSerialization.scala</span></div><h1>AvroSerialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.avro
package serialization

import org.apache.avro.{Schema, SchemaBuilder}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.features.SerializationOption.SerializationOption
import org.locationtech.geomesa.features.avro.serialization.AvroField.VersionField

/**
 * Config used for serializing simple features
 *
 * @param version serialization version, see org.locationtech.geomesa.features.avro.SerializationVersions
 * @param schema the avro schema
 * @param fid the feature id field, if present
 * @param fields fields for each attribute in the feature
 * @param userData the user data field, if present
 */
<span class="nc bnc" id="L26" title="All 42 branches missed.">case class AvroSerialization(</span>
<span class="nc" id="L27">    version: Int,</span>
<span class="nc" id="L28">    schema: Schema,</span>
<span class="nc" id="L29">    fid: Option[AvroField[String]],</span>
<span class="nc" id="L30">    fields: Seq[AvroField[AnyRef]],</span>
<span class="nc" id="L31">    userData: Option[AvroField[java.util.Map[AnyRef, AnyRef]]]</span>
  )

<span class="nc" id="L34">object AvroSerialization {</span>

  import org.locationtech.geomesa.features.avro.serialization.AvroField.{FidField, UserDataField}
  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  import scala.collection.JavaConverters._

  // array of name encoders, indexed by the encoder version (minus 1)
<span class="nc" id="L42">  private val nameEncoders = Array.tabulate(SerializationVersions.MaxVersion)(i =&gt; new FieldNameEncoder(i + 1))</span>

  /**
   * Create a serialization config
   *
   * @param sft simple feature type
   * @param opts options
   * @return
   */
  def apply(sft: SimpleFeatureType, opts: Set[SerializationOption]): AvroSerialization = {
    val version: Int =
<span class="nc bnc" id="L53" title="All 8 branches missed.">      if (opts.useNativeCollections &amp;&amp; sft.getAttributeDescriptors.asScala.exists(d =&gt; d.isList || d.isMap)) {</span>
<span class="nc" id="L54">        SerializationVersions.NativeCollectionVersion</span>
      } else {
<span class="nc" id="L56">        SerializationVersions.DefaultVersion</span>
      }

<span class="nc" id="L59">    val fields = sft.getAttributeDescriptors.asScala.map(AvroField.apply(_).withVersion(version)).toSeq</span>

<span class="nc bnc" id="L61" title="All 2 branches missed.">    val fid = if (opts.withoutId) { None } else { Some(FidField.withVersion(version)) }</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">    val userData = if (opts.withUserData) { Some(UserDataField.withVersion(version)) } else { None }</span>

<span class="nc" id="L64">    val schema = AvroSerialization.schema(sft, version, fields, fid.isDefined, userData.isDefined)</span>

<span class="nc" id="L66">    AvroSerialization(version, schema, fid, fields, userData)</span>
  }

  /**
   * Calculate the schema corresponding to a given feature type
   *
   * @param sft feature type
   * @param version serialization version
   * @param fields field definitions
   * @param includeFid include feature id
   * @param includeUserData include user data
   * @return
   */
  def schema(
      sft: SimpleFeatureType,
      version: Int,
      fields: Seq[AvroField[AnyRef]],
      includeFid: Boolean,
      includeUserData: Boolean): Schema = {

    import AvroField.{FidField, UserDataField, VersionField}

<span class="nc bnc" id="L88" title="All 4 branches missed.">    require(version &gt; 0 &amp;&amp; version &lt;= SerializationVersions.MaxVersion,</span>
<span class="nc" id="L89">      s&quot;Unknown version $version - valid versions are 1 to ${SerializationVersions.MaxVersion}&quot;)</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">    require(fields.length == sft.getAttributeCount, &quot;Mismatch between fields and feature type&quot;)</span>

<span class="nc" id="L92">    val nameEncoder = nameEncoders(version - 1)</span>
    val builder =
<span class="nc" id="L94">      SchemaBuilder.record(nameEncoder.encode(sft.getTypeName))</span>
<span class="nc" id="L95">          .namespace(Option(sft.getName.getNamespaceURI).getOrElse(AvroNamespace))</span>
          .fields

<span class="nc" id="L98">    builder.name(VersionField.name).`type`(VersionField.schema).withDefault(version)</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">    if (includeFid) {</span>
<span class="nc" id="L100">      builder.name(FidField.name).`type`(FidField.schema).noDefault</span>
    }

<span class="nc" id="L103">    val types = fields.map(_.schema).iterator</span>
<span class="nc" id="L104">    sft.getAttributeDescriptors.asScala.foreach { d =&gt;</span>
<span class="nc" id="L105">      builder.name(nameEncoder.encode(d.getLocalName)).`type`(types.next).noDefault()</span>
    }

<span class="nc bnc" id="L108" title="All 2 branches missed.">    if (includeUserData) {</span>
<span class="nc" id="L109">      builder.name(UserDataField.name).`type`(UserDataField.schema).noDefault()</span>
    }

<span class="nc" id="L112">    builder.endRecord()</span>
  }

  /**
   * For a given schema, checks if collections are encoded natively or as binary
   *
   * @param schema schema
   * @return
   */
  def usesNativeCollections(schema: Schema): Boolean = {
<span class="nc" id="L122">    Option(schema.getField(VersionField.name))</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        .exists(_.defaultVal() == SerializationVersions.NativeCollectionVersion)</span>
  }
<span class="nc" id="L125">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>