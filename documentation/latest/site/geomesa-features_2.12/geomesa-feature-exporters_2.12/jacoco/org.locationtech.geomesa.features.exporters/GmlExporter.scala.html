<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GmlExporter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Feature Exporters</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.exporters</a> &gt; <span class="el_source">GmlExporter.scala</span></div><h1>GmlExporter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.exporters

import net.opengis.wfs.WfsFactory
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.data.simple.{SimpleFeatureCollection, SimpleFeatureIterator}
import org.geotools.data.store.{DataFeatureCollection, ReTypingFeatureCollection}
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.wfs.WFSConfiguration
import org.geotools.xsd.Encoder
import org.locationtech.geomesa.features.exporters.GmlExporter.AsyncFeatureCollection

import java.io.OutputStream
import java.nio.charset.StandardCharsets
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock
import java.util.concurrent.{ConcurrentLinkedQueue, Executors, TimeUnit}

/**
  * GML exporter implementation.
  *
  * The geotools GML export classes only support encoding a feature collection. To support our usage
  * pattern (start, export n times, end), we create an asynchronous feature collection and do the actual
  * encoding in a separate thread. The encoder thread will block until there are more features to export,
  * so that we only get a single feature collection in the xml.
  *
  * @param out output stream
  * @param configuration wfs configuration (gml3 vs gml2)
  */
<span class="nc" id="L38">class GmlExporter private (out: OutputStream, configuration: WFSConfiguration)</span>
<span class="nc" id="L39">    extends FeatureExporter {</span>

<span class="nc" id="L41">  private val encoder: Encoder = {</span>
<span class="nc" id="L42">    val props = configuration.getProperties</span>
<span class="nc" id="L43">    props.add(org.geotools.gml2.GMLConfiguration.OPTIMIZED_ENCODING)</span>
<span class="nc" id="L44">    props.add(org.geotools.gml2.GMLConfiguration.NO_FEATURE_BOUNDS)</span>
<span class="nc" id="L45">    val e = new Encoder(configuration)</span>
<span class="nc" id="L46">    e.getNamespaces.declarePrefix(&quot;geomesa&quot;, &quot;https://geomesa.org&quot;)</span>
<span class="nc" id="L47">    e.setEncoding(StandardCharsets.UTF_8)</span>
<span class="nc" id="L48">    e.setIndenting(true)</span>
<span class="nc" id="L49">    e</span>
  }

<span class="nc" id="L52">  private val es = Executors.newSingleThreadExecutor()</span>
<span class="nc" id="L53">  private var fc: AsyncFeatureCollection = _</span>

  override def start(sft: SimpleFeatureType): Unit = {
<span class="nc" id="L56">    fc = new AsyncFeatureCollection(sft)</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">    val features = if (sft.getName.getNamespaceURI != null) { fc } else {</span>
<span class="nc" id="L58">      val builder = new SimpleFeatureTypeBuilder()</span>
<span class="nc" id="L59">      builder.init(sft)</span>
<span class="nc" id="L60">      builder.setNamespaceURI(&quot;https://geomesa.org&quot;)</span>
<span class="nc" id="L61">      new ReTypingFeatureCollection(fc, builder.buildFeatureType())</span>
    }
<span class="nc" id="L63">    val collection = WfsFactory.eINSTANCE.createFeatureCollectionType()</span>
<span class="nc" id="L64">    collection.getFeature.asInstanceOf[java.util.List[SimpleFeatureCollection]].add(features)</span>

<span class="nc" id="L66">    def encode(): Unit = encoder.encode(collection, org.geotools.wfs.WFS.FeatureCollection, out)</span>

<span class="nc bnc" id="L68" title="All 2 branches missed.">    val runnable = new Runnable() {</span>
      override def run(): Unit = {
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (System.getProperty(GmlExporter.TransformerProperty) != null) { encode() } else {</span>
          // explicitly set the default java transformer, to avoid picking up saxon (which causes errors)
          // the default class is hard-coded in javax.xml.transform.TransformerFactory.newInstance() ...
<span class="nc" id="L73">          System.setProperty(GmlExporter.TransformerProperty,</span>
<span class="nc" id="L74">            &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl&quot;)</span>
<span class="nc" id="L75">          try { encode() } finally {</span>
<span class="nc" id="L76">            System.clearProperty(GmlExporter.TransformerProperty)</span>
          }
        }
      }
    }

<span class="nc" id="L82">    es.execute(runnable)</span>
  }

  override def export(features: Iterator[SimpleFeature]): Option[Long] = {
<span class="nc" id="L86">    var count = 0L</span>
<span class="nc" id="L87">    val counting = features.map { f =&gt; count += 1; f }</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">    while (counting.nonEmpty) {</span>
      // export in chunks of 100 so that the exporter thread gets notified and doesn't keep blocking
<span class="nc" id="L90">      fc.addAsync(counting.take(100))</span>
    }
<span class="nc" id="L92">    Some(count)</span>
  }

  override def close(): Unit = {
    try {
<span class="nc bnc" id="L97" title="All 2 branches missed.">      if (fc != null) {</span>
<span class="nc" id="L98">        fc.endAsync()</span>
      }
<span class="nc" id="L100">      es.shutdown()</span>
<span class="nc" id="L101">      es.awaitTermination(Long.MaxValue, TimeUnit.MILLISECONDS)</span>
    } finally {
<span class="nc" id="L103">      out.close()</span>
    }
  }
}

<span class="nc" id="L108">object GmlExporter {</span>

<span class="nc" id="L110">  private val TransformerProperty = classOf[javax.xml.transform.TransformerFactory].getName</span>

  /**
    * Create a GML3 exporter
    *
    * @param out output stream
    * @return
    */
  def apply(out: OutputStream): GmlExporter =
<span class="nc" id="L119">    new GmlExporter(out, new org.geotools.wfs.v1_1.WFSConfiguration())</span>

  /**
    * Create a GML2 exporter
    *
    * @param out output stream
    * @return
    */
  def gml2(out: OutputStream): GmlExporter =
<span class="nc" id="L128">    new GmlExporter(out, new org.geotools.wfs.v1_0.WFSConfiguration_1_0())</span>

  /**
    * Feature collection that lets us add additional features in an asynchronous fashion. The consumer
    * thread will be blocked on calls to 'hasNext' until the producer thread adds features or indicates
    * completion
    *
    * @param sft simple feature type
    */
<span class="nc" id="L137">  private class AsyncFeatureCollection(sft: SimpleFeatureType) extends DataFeatureCollection(null, sft) {</span>

<span class="nc" id="L139">    private val buffer = new ConcurrentLinkedQueue[SimpleFeature]()</span>
<span class="nc" id="L140">    private val done = new AtomicBoolean(false)</span>
<span class="nc" id="L141">    private val lock = new ReentrantLock()</span>
<span class="nc" id="L142">    private val condition = lock.newCondition()</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">    private val iter: SimpleFeatureIterator = new SimpleFeatureIterator() {</span>

<span class="nc" id="L146">      private var current: SimpleFeature = _</span>

      override def hasNext: Boolean = {
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (current != null) {</span>
<span class="nc" id="L150">          return true</span>
        }
<span class="nc" id="L152">        lock.lock()</span>
        try {
<span class="nc" id="L154">          current = buffer.poll()</span>
          // note: we need to loop here to skip 'spurious wake-ups'
<span class="nc bnc" id="L156" title="All 2 branches missed.">          while (current == null) {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (done.get) {</span>
<span class="nc" id="L158">              return false</span>
            }
<span class="nc" id="L160">            condition.await()</span>
<span class="nc" id="L161">            current = buffer.poll()</span>
          }
<span class="nc" id="L163">          true</span>
        } finally {
<span class="nc" id="L165">          lock.unlock()</span>
        }
      }

      override def next(): SimpleFeature = {
        // note: we shouldn't need to synchronize this as next/hasNext should be a single caller thread
<span class="nc" id="L171">        val result = current</span>
<span class="nc" id="L172">        current = null</span>
<span class="nc" id="L173">        result</span>
      }

<span class="nc" id="L176">      override def close(): Unit = endAsync()</span>
    }

    /**
      * Add features to be returned from this feature collection
      *
      * @param features features
      */
    def addAsync(features: Iterator[SimpleFeature]): Unit = {
<span class="nc" id="L185">      lock.lock()</span>
      try {
<span class="nc" id="L187">        features.foreach(buffer.add)</span>
<span class="nc" id="L188">        condition.signal()</span>
      } finally {
<span class="nc" id="L190">        lock.unlock()</span>
      }
    }

    /**
      * Signal that there are no more features that will be added
      */
    def endAsync(): Unit = {
<span class="nc" id="L198">      lock.lock()</span>
      try {
<span class="nc" id="L200">        done.set(true)</span>
<span class="nc" id="L201">        condition.signal()</span>
      } finally {
<span class="nc" id="L203">        lock.unlock()</span>
      }
    }

<span class="nc" id="L207">    override def features(): SimpleFeatureIterator = iter</span>

<span class="nc" id="L209">    override def getBounds: ReferencedEnvelope = org.locationtech.geomesa.utils.geotools.wholeWorldEnvelope</span>
<span class="nc" id="L210">    override def getCount: Int = 0</span>
  }
<span class="nc" id="L212">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>