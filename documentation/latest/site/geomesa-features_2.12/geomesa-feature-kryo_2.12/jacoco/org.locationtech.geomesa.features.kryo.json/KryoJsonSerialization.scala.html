<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KryoJsonSerialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo.json</a> &gt; <span class="el_source">KryoJsonSerialization.scala</span></div><h1>KryoJsonSerialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo.json

import com.esotericsoftware.kryo.io.{Input, Output}
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.node.{ArrayNode, ObjectNode}
import com.typesafe.scalalogging.LazyLogging
import org.locationtech.geomesa.features.kryo.json.JsonPathParser._

import java.nio.charset.StandardCharsets
import scala.util.control.NonFatal

/**
 * Serializes into bson (https://bsonspec.org/). Note this is a limited form of bson that only matches
 * the existing json types - does not cover the bson extensions like binary data, etc. Also note endianness,
 * etc might not match the spec 100%.
 *
 * The bson serialized value is preceded by a single byte, `\x00` to indicate null, or `\x01` to indicate non-null.
 * Additionally, non-document top-level values are supported, indicated with the prefix byte `\x02`. Top-level,
 * non-document values are encoded as a jsonb `element` with an empty name.
 *
 * Reduced BSON spec - only native JSON elements supported:
 *
 * byte    1 byte (8-bits)
 * int32   4 bytes (32-bit signed integer, two's complement)
 * int64   8 bytes (64-bit signed integer, two's complement)
 * double  8 bytes (64-bit IEEE 754-2008 binary floating point)
 *
 * document  ::= int32 e_list &quot;\x00&quot; BSON Document. int32 is the total number of bytes comprising the document.
 * e_list    ::= element e_list
 *           |	&quot;&quot;
 * element   ::= &quot;\x01&quot; e_name double	64-bit binary floating point
 *           | &quot;\x02&quot; e_name string	UTF-8 string
 *           | &quot;\x03&quot; e_name document	Embedded document
 *           |	&quot;\x04&quot; e_name document	Array
 *           |	&quot;\x08&quot; e_name &quot;\x00&quot;	Boolean &quot;false&quot;
 *           |	&quot;\x08&quot; e_name &quot;\x01&quot;	Boolean &quot;true&quot;
 *           |	&quot;\x09&quot; e_name int64	UTC datetime
 *           |	&quot;\x0A&quot; e_name	Null value
 *           |	&quot;\x10&quot; e_name int32	32-bit integer
 *           |	&quot;\x11&quot; e_name int64	Timestamp
 *           |	&quot;\x12&quot; e_name int64	64-bit integer
 * e_name    ::= cstring	Key name
 * string    ::= int32 (byte*) &quot;\x00&quot;	String - The int32 is the number bytes in the (byte*) + 1 (for the trailing '\x00').
 *                                              The (byte*) is zero or more UTF-8 encoded characters.
 * cstring   ::= (byte*) &quot;\x00&quot;	Zero or more modified UTF-8 encoded characters followed by '\x00'. The (byte*)
 *                               MUST NOT contain '\x00', hence it is not full UTF-8.
 *
 * Note:
 *   Array - The document for an array is a normal BSON document with integer values for the keys,
 *   starting with 0 and continuing sequentially. For example, the array ['red', 'blue'] would be
 *   encoded as the document {'0': 'red', '1': 'blue'}. The keys must be in ascending numerical order.
 */
<span class="nc bnc" id="L61" title="All 4 branches missed.">object KryoJsonSerialization extends LazyLogging {</span>

<span class="nc" id="L63">  private[json] val TerminalByte :Byte = 0x00</span>
<span class="nc" id="L64">  private[json] val DoubleByte   :Byte = 0x01</span>
<span class="nc" id="L65">  private[json] val StringByte   :Byte = 0x02</span>
<span class="nc" id="L66">  private[json] val DocByte      :Byte = 0x03</span>
<span class="nc" id="L67">  private[json] val ArrayByte    :Byte = 0x04</span>
<span class="nc" id="L68">  private[json] val BooleanByte  :Byte = 0x08</span>
<span class="nc" id="L69">  private[json] val NullByte     :Byte = 0x0A</span>
<span class="nc" id="L70">  private[json] val IntByte      :Byte = 0x10</span>
<span class="nc" id="L71">  private[json] val LongByte     :Byte = 0x12</span>

<span class="nc" id="L73">  private[json] val BooleanFalse :Byte = 0x00</span>
<span class="nc" id="L74">  private[json] val BooleanTrue  :Byte = 0x01</span>
<span class="nc" id="L75">  private[json] val NonDoc       :Byte = 0x02</span>

<span class="nc" id="L77">  private val nameBuffers = new ThreadLocal[Array[Byte]] {</span>
<span class="nc" id="L78">    override def initialValue(): Array[Byte] = Array.ofDim[Byte](32)</span>
  }

  /**
    * Serialize a json object
    *
    * @param out output to write to
    * @param json json string to serialize - must be a json object
    */
  def serialize(out: Output, json: String): Unit = {
<span class="nc bnc" id="L88" title="All 2 branches missed.">    val obj = if (json == null) { null } else {</span>
<span class="nc" id="L89">      try {</span>
<span class="nc" id="L90">        mapper.readTree(json)</span>
      } catch {
<span class="nc bnc" id="L92" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">          logger.warn(s&quot;Error parsing json:\n$json&quot;, e)</span>
<span class="nc" id="L94">          null</span>
      }
    }
<span class="nc" id="L97">    serialize(out, obj)</span>
  }

  /**
    * Serialize a json object
    *
    * @param out output to write to
    * @param json object to serialize
    */
  def serialize(out: Output, json: JsonNode): Unit = {
<span class="nc bnc" id="L107" title="All 4 branches missed.">    if (json == null || json.isNull) {</span>
<span class="nc" id="L108">      out.write(BooleanFalse)</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">    } else if (json.isObject) {</span>
<span class="nc" id="L110">      out.write(BooleanTrue); writeDocument(out, json)</span>
    } else {
<span class="nc" id="L112">      out.write(NonDoc); writeValue(out, &quot;&quot;, json)</span>
    }
  }

  /**
    * Deserialize the given input. The input should be pointing to the start of
    * the bytes written by `serialize`. Upon completion, the input will be pointing
    * to the first byte after the bytes written by `serialize`.
    *
    * @param in input, pointing to the start of the json object
    * @return json as a string
    */
  def deserializeAndRender(in: Input): String = {
<span class="nc" id="L125">    val json = deserialize(in)</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">    if (json == null) {</span>
<span class="nc" id="L127">      null</span>
    } else {
<span class="nc" id="L129">      mapper.writeValueAsString(json)</span>
    }
  }

  /**
    * Deserialize the given input. The input should be pointing to the start of
    * the bytes written by `serialize`. Upon completion, the input will be pointing
    * to the first byte after the bytes written by `serialize`.
    *
    * @param in input, pointing to the start of the json object
    * @return parsed json object
    */
  def deserialize(in: Input): JsonNode = {
<span class="nc" id="L142">    try {</span>
<span class="nc" id="L143">      in.readByte match {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        case BooleanFalse =&gt; null</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        case BooleanTrue  =&gt; readDocument(in: Input)</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        case NonDoc       =&gt; readValue(in)._2</span>
      }
    } catch {
<span class="nc bnc" id="L149" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.error(&quot;Error reading serialized kryo json&quot;, e); null</span>
    }
  }

  /**
    * Deserialize the result of a json-path. The input should be pointing to the start of
    * the bytes written by `serialize`. There is no guarantee where the input will be
    * pointing after completion.
    *
    * If the path selects leaf elements, they will be returned as primitives. If the path
    * selects objects, they will be returned as json strings. If more than one item is
    * selected, they will be returned in a java.util.List. If nothing is selected, it will return null.
    *
    * @param in input, pointing to the start of the json object
    * @param path pre-parsed json path to evaluate
    * @return result of the path, if any
    */
  def deserialize(in: Input, path: JsonPath): Any = {
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (path.isEmpty) {</span>
<span class="nc" id="L168">      deserializeAndRender(in)</span>
    } else {
<span class="nc" id="L170">      try { new KryoJsonPath(in).deserialize(path) } catch {</span>
<span class="nc bnc" id="L171" title="All 4 branches missed.">        case NonFatal(e) =&gt; logger.error(&quot;Error reading serialized kryo json&quot;, e); null</span>
      }
    }
  }

  // primitive writing functions - in general will write a byte identifying the type, the key and then the value

  private def writeDocument(out: Output, name: String, value: JsonNode): Unit = {
<span class="nc" id="L179">    out.writeByte(DocByte)</span>
<span class="nc" id="L180">    out.writeName(name)</span>
<span class="nc" id="L181">    writeDocument(out, value)</span>
  }

  // write a document without a name - used for the outermost object which doesn't have a key
  private def writeDocument(out: Output, value: JsonNode): Unit = {
<span class="nc" id="L186">    val start = out.position()</span>
    // write a placeholder that we will overwrite when we go back to write total length
    // note: don't just modify position, as that doesn't expand the buffer correctly
<span class="nc" id="L189">    out.writeInt(0)</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">    value.forEachEntry { case (name, elem) =&gt; writeValue(out, name, elem) }</span>
<span class="nc" id="L191">    out.writeByte(TerminalByte) // marks the end of our object</span>
    // go back and write the total length
<span class="nc" id="L193">    val end = out.position()</span>
<span class="nc" id="L194">    out.setPosition(start)</span>
<span class="nc" id="L195">    out.writeInt(end - start)</span>
<span class="nc" id="L196">    out.setPosition(end)</span>
  }

  private def writeValue(out: Output, name: String, value: JsonNode): Unit = {
<span class="nc bnc" id="L200" title="All 4 branches missed.">    if (value.isTextual || value.isBinary) {</span>
<span class="nc" id="L201">      writeString(out, name, value.asText())</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">    } else if (value.isObject) {</span>
<span class="nc" id="L203">      writeDocument(out, name, value)</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">    } else if (value.isArray) {</span>
<span class="nc" id="L205">      writeArray(out, name, value)</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">    } else if (value.isDouble || value.isFloat) {</span>
<span class="nc" id="L207">      writeDouble(out, name, value.asDouble())</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">    } else if (value.isInt || value.isShort) {</span>
<span class="nc" id="L209">      writeInt(out, name, value.intValue())</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">    } else if (value.isLong) {</span>
<span class="nc" id="L211">      writeLong(out, name, value.longValue())</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">    } else if (value.isNull) {</span>
<span class="nc" id="L213">      writeNull(out, name)</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">    } else if (value.isBoolean) {</span>
<span class="nc" id="L215">      writeBoolean(out, name, value.booleanValue())</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    } else if (value.isBigDecimal) {</span>
<span class="nc" id="L217">      writeDouble(out, name, value.asDouble())</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">    } else if (value.isBigInteger) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">      if (value.canConvertToInt) {</span>
<span class="nc" id="L220">        writeInt(out, name, value.intValue())</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">      } else if (value.canConvertToLong) {</span>
<span class="nc" id="L222">        writeLong(out, name, value.longValue())</span>
      } else {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        logger.warn(s&quot;Skipping int value that does not fit in a long: $value&quot;)</span>
      }
    } else {
<span class="nc bnc" id="L227" title="All 2 branches missed.">      logger.warn(s&quot;Unhandled JsonNode: $value&quot;)</span>
    }
  }

  private def writeArray(out: Output, name: String, value: JsonNode): Unit = {
<span class="nc" id="L232">    out.writeByte(ArrayByte)</span>
<span class="nc" id="L233">    out.writeName(name)</span>
    // we store as an object where array index is the key
<span class="nc" id="L235">    var i = 0</span>
<span class="nc" id="L236">    val obj = mapper.createObjectNode()</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">    while (i &lt; value.size()) {</span>
<span class="nc" id="L238">      obj.set(i.toString, value.get(i))</span>
<span class="nc" id="L239">      i += 1</span>
    }
<span class="nc" id="L241">    writeDocument(out, obj)</span>
  }

  private def writeString(out: Output, name: String, value: String): Unit = {
<span class="nc" id="L245">    out.writeByte(StringByte)</span>
<span class="nc" id="L246">    out.writeName(name)</span>
<span class="nc" id="L247">    val bytes = value.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L248">    out.writeInt(bytes.length)</span>
<span class="nc" id="L249">    out.write(bytes)</span>
<span class="nc" id="L250">    out.writeByte(TerminalByte)</span>
  }

  private def writeDouble(out: Output, name: String, value: Double): Unit = {
<span class="nc" id="L254">    out.writeByte(DoubleByte)</span>
<span class="nc" id="L255">    out.writeName(name)</span>
<span class="nc" id="L256">    out.writeDouble(value)</span>
  }

  private def writeInt(out: Output, name: String, value: Int): Unit = {
<span class="nc" id="L260">    out.writeByte(IntByte)</span>
<span class="nc" id="L261">    out.writeName(name)</span>
<span class="nc" id="L262">    out.writeInt(value)</span>
  }

  private def writeLong(out: Output, name: String, value: Long): Unit = {
<span class="nc" id="L266">    out.writeByte(LongByte)</span>
<span class="nc" id="L267">    out.writeName(name)</span>
<span class="nc" id="L268">    out.writeLong(value)</span>
  }

  private def writeBoolean(out: Output, name: String, value: Boolean): Unit = {
<span class="nc" id="L272">    out.writeByte(BooleanByte)</span>
<span class="nc" id="L273">    out.writeName(name)</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">    out.writeByte(if (value) BooleanTrue else BooleanFalse)</span>
  }

  private def writeNull(out: Output, name: String): Unit = {
<span class="nc" id="L278">    out.writeByte(NullByte)</span>
<span class="nc" id="L279">    out.writeName(name)</span>
  }

  // primitive reading/skipping methods corresponding to the write methods above
  // assumes that the indicator byte and name have already been read

  private[json] def readDocument(in: Input): ObjectNode = {
<span class="nc" id="L286">    val end = in.position() + in.readInt() - 1 // last byte is the terminal byte</span>
<span class="nc" id="L287">    val obj = mapper.createObjectNode()</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">    while (in.position() &lt; end) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">      val (k, v) = readValue(in)</span>
<span class="nc" id="L290">      obj.set(k, v)</span>
    }
<span class="nc" id="L292">    in.skip(1) // skip over terminal byte</span>
<span class="nc" id="L293">    obj</span>
  }

  private[json] def readValue(in: Input): (String, JsonNode) = {
<span class="nc" id="L297">    val switch = in.readByte()</span>
<span class="nc" id="L298">    val name = in.readName()</span>
<span class="nc" id="L299">    val value = switch match {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">      case StringByte   =&gt; mapper.getNodeFactory.textNode(readString(in))</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">      case DocByte      =&gt; readDocument(in)</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">      case ArrayByte    =&gt; readArray(in)</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">      case DoubleByte   =&gt; mapper.getNodeFactory.numberNode(in.readDouble())</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      case IntByte      =&gt; mapper.getNodeFactory.numberNode(in.readInt())</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">      case LongByte     =&gt; mapper.getNodeFactory.numberNode(in.readLong())</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">      case NullByte     =&gt; mapper.getNodeFactory.nullNode()</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">      case BooleanByte  =&gt; mapper.getNodeFactory.booleanNode(readBoolean(in))</span>
    }
<span class="nc" id="L309">    (name, value)</span>
  }

  private[json] def readArray(in: Input): ArrayNode = {
<span class="nc" id="L313">    val obj = readDocument(in)</span>
<span class="nc" id="L314">    val array = mapper.getNodeFactory.arrayNode(obj.size())</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">    obj.forEachEntry { case (_, v) =&gt; array.add(v) }</span>
<span class="nc" id="L316">    array</span>
  }

<span class="nc" id="L319">  private[json] def skipDocument(in: Input): Unit = in.skip(in.readInt - 4) // length includes bytes storing length</span>

  private[json] def readString(in: Input): String = {
<span class="nc" id="L322">    val bytes = Array.ofDim[Byte](in.readInt())</span>
<span class="nc" id="L323">    in.read(bytes)</span>
<span class="nc" id="L324">    in.skip(1) // skip TerminalByte</span>
<span class="nc" id="L325">    new String(bytes, StandardCharsets.UTF_8)</span>
  }

<span class="nc" id="L328">  private[json] def skipString(in: Input): Unit = in.skip(in.readInt() + 1) // skip TerminalByte</span>

<span class="nc bnc" id="L330" title="All 2 branches missed.">  private[json] def readBoolean(in: Input): Boolean = in.readByte == BooleanTrue</span>

<span class="nc" id="L332">  private[json] def skipBoolean(in: Input): Unit = in.skip(1)</span>

<span class="nc" id="L334">  private[json] implicit class RichOutput(val out: Output) extends AnyRef {</span>
    def writeName(name: String): Unit = {
      // note: names are not allowed to contain the terminal byte (0x00) but we don't check for it
<span class="nc" id="L337">      out.write(name.getBytes(StandardCharsets.UTF_8))</span>
<span class="nc" id="L338">      out.writeByte(TerminalByte)</span>
    }
  }

<span class="nc" id="L342">  private[json] implicit class RichInput(val in: Input) extends AnyRef {</span>
    def readName(): String = {
<span class="nc" id="L344">      var buffer = nameBuffers.get()</span>
<span class="nc" id="L345">      var i = 0</span>
<span class="nc" id="L346">      var byte: Byte = in.readByte()</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">      while (byte != TerminalByte) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (i == buffer.length) {</span>
          // expand our cached buffer to accommodate the name
<span class="nc" id="L350">          val copy = Array.ofDim[Byte](buffer.length * 2)</span>
<span class="nc" id="L351">          System.arraycopy(buffer, 0, copy, 0, i)</span>
<span class="nc" id="L352">          buffer = copy</span>
<span class="nc" id="L353">          nameBuffers.set(buffer)</span>
        }
<span class="nc" id="L355">        buffer(i) = byte</span>
<span class="nc" id="L356">        i += 1</span>
<span class="nc" id="L357">        byte = in.readByte()</span>
      }
<span class="nc" id="L359">      new String(buffer, 0, i, StandardCharsets.UTF_8)</span>
    }

<span class="nc bnc" id="L362" title="All 2 branches missed.">    def skipName(): Unit = while (in.readByte() != TerminalByte) {}</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>