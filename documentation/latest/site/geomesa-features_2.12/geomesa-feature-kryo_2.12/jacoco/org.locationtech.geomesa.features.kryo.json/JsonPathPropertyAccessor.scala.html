<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonPathPropertyAccessor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo.json</a> &gt; <span class="el_source">JsonPathPropertyAccessor.scala</span></div><h1>JsonPathPropertyAccessor.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo.json

import com.github.benmanes.caffeine.cache.{CacheLoader, Caffeine, LoadingCache}
import com.jayway.jsonpath.Configuration
import com.jayway.jsonpath.Option.{ALWAYS_RETURN_LIST, SUPPRESS_EXCEPTIONS}
import com.typesafe.scalalogging.LazyLogging
import net.minidev.json.JSONObject
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.feature.AttributeTypeBuilder
import org.geotools.filter.expression.{PropertyAccessor, PropertyAccessorFactory}
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.kryo.KryoBufferSimpleFeature
import org.locationtech.geomesa.features.kryo.json.JsonPathParser._
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.converters.FastConverter

import java.util.concurrent.TimeUnit
import scala.util.control.NonFatal

/**
  * Access values from a json-type string field. Syntax must start with '$.'. The first part of the path
  * selects the simple feature attribute, and the rest of the path selects within the json contained in
  * that attribute.
  *
  * Note: this class is optimized for `KryoBufferSimpleFeature`s. It will work on standard simple features,
  * but will incur a serialization cost.
  */
<span class="nc" id="L37">trait JsonPathPropertyAccessor extends PropertyAccessor with LazyLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

  import scala.collection.JavaConverters._

  override def canHandle(obj: AnyRef, xpath: String, target: Class[_]): Boolean = {
    val path =
<span class="nc" id="L45">      try {</span>
<span class="nc" id="L46">        JsonPathPropertyAccessor.paths.get(xpath)</span>
      } catch {
<span class="nc bnc" id="L48" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">          logger.warn(s&quot;Error parsing path: $xpath&quot;, e)</span>
<span class="nc" id="L50">          JsonPath(Seq.empty, None)</span>
      }

<span class="nc bnc" id="L53" title="All 2 branches missed.">    if (path.isEmpty) { false } else {</span>
<span class="nc" id="L54">      path.head match {</span>
<span class="nc bnc" id="L55" title="All 4 branches missed.">        case PathAttribute(name: String, _) =&gt;</span>
<span class="nc" id="L56">          val descriptor = obj match {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">            case s: SimpleFeature =&gt; s.getFeatureType.getDescriptor(name)</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">            case s: SimpleFeatureType =&gt; s.getDescriptor(name)</span>
<span class="nc" id="L59">            case _ =&gt; null</span>
          }
<span class="nc bnc" id="L61" title="All 8 branches missed.">          descriptor != null &amp;&amp; descriptor.getType.getBinding == classOf[String]</span>

<span class="nc bnc" id="L63" title="All 6 branches missed.">        case PathAttributeWildCard | PathDeepScan =&gt;</span>
<span class="nc" id="L64">          val sft = obj match {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            case s: SimpleFeature =&gt; s.getFeatureType</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">            case s: SimpleFeatureType =&gt; s</span>
<span class="nc" id="L67">            case _ =&gt; null</span>
          }
<span class="nc bnc" id="L69" title="All 10 branches missed.">          sft != null &amp;&amp; sft.getAttributeDescriptors.asScala.exists(_.getType.getBinding == classOf[String])</span>

<span class="nc" id="L71">        case _ =&gt; false</span>
      }
    }
  }

  override def get[T](obj: AnyRef, xpath: String, target: Class[T]): T = {

<span class="nc" id="L78">    val path = JsonPathPropertyAccessor.paths.get(xpath)</span>

<span class="nc" id="L80">    val result = obj match {</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      case s: KryoBufferSimpleFeature =&gt;</span>
<span class="nc" id="L82">        val i = attribute(s.getFeatureType, path.head)</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (s.getFeatureType.getDescriptor(i).isJson()) {</span>
<span class="nc" id="L84">          s.getInput(i).map(KryoJsonSerialization.deserialize(_, path.tail)).orNull</span>
        } else {
<span class="nc" id="L86">          JsonPathPropertyAccessor.evaluateJsonPath(s.getAttribute(i).asInstanceOf[String], path.tail)</span>
        }

<span class="nc bnc" id="L89" title="All 2 branches missed.">      case s: SimpleFeature =&gt;</span>
<span class="nc" id="L90">        JsonPathPropertyAccessor.evaluateJsonPath(s.getAttribute(attribute(s.getFeatureType, path.head)).asInstanceOf[String], path.tail)</span>

<span class="nc bnc" id="L92" title="All 2 branches missed.">      case s: SimpleFeatureType =&gt;</span>
        // remove the json flag, so that transform serializations don't try to serialize
        // json path results that aren't valid json objects or arrays
<span class="nc" id="L95">        val descriptor = s.getDescriptor(attribute(s, path.head))</span>
<span class="nc" id="L96">        val builder = new AttributeTypeBuilder()</span>
<span class="nc" id="L97">        builder.init(descriptor)</span>
<span class="nc" id="L98">        val result = builder.buildDescriptor(descriptor.getLocalName)</span>
<span class="nc" id="L99">        result.getUserData.remove(SimpleFeatureTypes.AttributeOptions.OptJson)</span>
<span class="nc" id="L100">        result</span>
    }

<span class="nc bnc" id="L103" title="All 2 branches missed.">    if (target == null) {</span>
<span class="nc" id="L104">      result.asInstanceOf[T]</span>
    } else {
<span class="nc" id="L106">      FastConverter.convert(result, target)</span>
    }
  }

<span class="nc" id="L110">  override def set[T](obj: Any, xpath: String, value: T, target: Class[T]): Unit = throw new UnsupportedOperationException()</span>

  private def attribute(sft: SimpleFeatureType, head: PathElement): Int = {
<span class="nc" id="L113">    head match {</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">      case PathAttribute(name: String, _) =&gt;</span>
<span class="nc" id="L115">        sft.indexOf(name)</span>

      case _ =&gt;
        // we know it will be a wildcard due to canHandle
        // prioritize fields marked json over generic strings
        // note: will only match first json attribute if more than 1
<span class="nc" id="L121">        val i = sft.getAttributeDescriptors.asScala.indexWhere(_.isJson())</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (i != -1) { i } else {</span>
<span class="nc bnc" id="L123" title="All 6 branches missed.">          sft.getAttributeDescriptors.asScala.indexWhere(_.getType.getBinding == classOf[String])</span>
        }
    }
  }
}

<span class="nc bnc" id="L129" title="All 4 branches missed.">object JsonPathPropertyAccessor extends JsonPathPropertyAccessor {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L133">  val CacheExpiry: SystemProperty = SystemProperty(&quot;geomesa.json.cache.expiry&quot;, &quot;10 minutes&quot;)</span>

  // cached references to parsed json path expressions
<span class="nc" id="L136">  private val paths: LoadingCache[String, JsonPath] =</span>
<span class="nc" id="L137">    Caffeine.newBuilder()</span>
<span class="nc" id="L138">      .expireAfterAccess(CacheExpiry.toDuration.get.toMillis, TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L139">      .build(new CacheLoader[String, JsonPath]() {</span>
<span class="nc" id="L140">        override def load(path: String): JsonPath = JsonPathParser.parse(path, report = false)</span>
      })

<span class="nc" id="L143">  private val pathConfig: Configuration = Configuration.builder.options(ALWAYS_RETURN_LIST, SUPPRESS_EXCEPTIONS).build()</span>

<span class="nc" id="L145">  class JsonPropertyAccessorFactory extends PropertyAccessorFactory {</span>

    override def createPropertyAccessor(
        typ: Class[_],
        xpath: String,
        target: Class[_],
        hints: Hints): PropertyAccessor = {
<span class="nc bnc" id="L152" title="All 2 branches missed.">      if (xpath != null &amp;&amp;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">          xpath.startsWith(&quot;$.&quot;) &amp;&amp;</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">          (classOf[SimpleFeature].isAssignableFrom(typ) || classOf[SimpleFeatureType].isAssignableFrom(typ))) {</span>
<span class="nc" id="L155">        JsonPathPropertyAccessor</span>
      } else {
<span class="nc" id="L157">        null</span>
      }
    }
  }

  /**
   * Evaluate a json path using the json-path lib. This method is a fallback for our custom kryo-deserialization,
   * and requires parsing the input into the json-path AST. The result has been modified to be consistent
   * with our custom serialization (for better interop with geotools), i.e. json objects are serialized to json
   * strings.
   *
   * @param json json doc
   * @param path json path
   * @return
   */
  private[json] def evaluateJsonPath(json: String, path: JsonPath): AnyRef = {
<span class="nc" id="L173">    val parsed = com.jayway.jsonpath.JsonPath.using(pathConfig).parse(json)</span>
<span class="nc" id="L174">    val list = parsed.read[java.util.List[AnyRef]](JsonPathParser.print(path))</span>
<span class="nc bnc" id="L175" title="All 4 branches missed.">    if (list == null || list.isEmpty) {</span>
      // special handling to return 0 for length functions without matches
<span class="nc" id="L177">      path.function match {</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">        case Some(PathFunction.LengthFunction) =&gt; Int.box(0)</span>
<span class="nc" id="L179">        case _ =&gt; null</span>
      }
    } else {
<span class="nc" id="L182">      val transformed = list.asScala.map {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        case o: java.util.Map[String, AnyRef] =&gt; JSONObject.toJSONString(o)</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        case a: java.util.List[AnyRef] =&gt; unwrapArray(a)</span>
<span class="nc" id="L185">        case p =&gt; p</span>
      }
<span class="nc bnc" id="L187" title="All 2 branches missed.">      if (transformed.lengthCompare(1) == 0) { transformed.head } else { transformed.asJava }</span>
    }
  }

  private def unwrapArray(array: java.util.List[AnyRef]): java.util.List[AnyRef] = {
<span class="nc" id="L192">    array.asScala.map {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">      case o: java.util.Map[String, AnyRef] =&gt; JSONObject.toJSONString(o)</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      case a: java.util.List[AnyRef] =&gt; unwrapArray(a)</span>
<span class="nc" id="L195">      case p =&gt; p</span>
    }.asJava
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>