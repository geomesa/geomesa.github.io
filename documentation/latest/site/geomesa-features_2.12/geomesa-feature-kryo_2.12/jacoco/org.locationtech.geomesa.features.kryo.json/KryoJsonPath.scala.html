<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KryoJsonPath.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo.json</a> &gt; <span class="el_source">KryoJsonPath.scala</span></div><h1>KryoJsonPath.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo.json

import com.esotericsoftware.kryo.io.Input
import com.fasterxml.jackson.databind.node.ArrayNode
import com.typesafe.scalalogging.LazyLogging
import org.locationtech.geomesa.features.kryo.json.KryoJsonPath.ValuePointer

import java.util.Collections

/**
 * Deserializes the results of json-paths. Not thread-safe. The input may end up positioned at arbitrary locations
 *
 * @param in input containing the serialized json
 * @param root pointer to the root document/array
 */
<span class="nc bnc" id="L24" title="All 4 branches missed.">class KryoJsonPath(in: Input, root: ValuePointer) extends LazyLogging {</span>

  import JsonPathParser._
  import KryoJsonPath._
  import KryoJsonSerialization._

  import scala.collection.JavaConverters._

  /**
   * Deserializes the results of json-paths. Not thread-safe. The input may end up positioned at arbitrary locations
   *
   * @param in input, positioned at the start of the json object
   */
<span class="nc" id="L37">  def this(in: Input) = this(in, KryoJsonPath.root(in))</span>

  /**
    * Deserialize the result of a json-path.
    *
    * If the path selects leaf elements, they will be returned as primitives. If the path
    * selects objects, they will be returned as strings of json. If more than one item is
    * selected, they will be returned in a java List. If nothing is selected, it will return null.
    *
    * @param path json path to evaluate
    * @return result of the path, if any
    */
  def deserialize(path: JsonPath): Any = {
<span class="nc" id="L50">    require(path.nonEmpty, &quot;Path must not be empty&quot;)</span>

<span class="nc bnc" id="L52" title="All 4 branches missed.">    if (root == null || root.typ == NullByte) {</span>
<span class="nc" id="L53">      return null</span>
    }

<span class="nc bnc" id="L56" title="All 16 branches missed.">    val matches = path.elements.foldLeft(Seq(root)) {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">      case (nodes, _) if nodes.isEmpty       =&gt; nodes</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">      case (nodes, PathAttribute(name, _))   =&gt; matchPathAttribute(nodes, Some(name))</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">      case (nodes, PathAttributeWildCard)    =&gt; matchPathAttribute(nodes, None)</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      case (nodes, PathIndices(indices))     =&gt; matchPathIndex(nodes, indices)</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">      case (nodes, PathIndexRange(from, to)) =&gt; matchPathIndexRange(nodes, from, to)</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">      case (nodes, PathIndexWildCard)        =&gt; matchAllPathIndices(nodes)</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">      case (nodes, PathDeepScan)             =&gt; matchDeep(nodes)</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">      case (nodes, PathFilter(op))           =&gt; matchFilter(nodes, op)</span>
    }

<span class="nc bnc" id="L67" title="All 2 branches missed.">    if (matches.isEmpty) {</span>
      // special handling to return 0 for length functions without matches
<span class="nc" id="L69">      path.function match {</span>
<span class="nc bnc" id="L70" title="All 4 branches missed.">        case Some(PathFunction.LengthFunction) =&gt; 0</span>
<span class="nc" id="L71">        case _ =&gt; null</span>
      }
    } else {
<span class="nc" id="L74">      val values = matches.map(m =&gt; KryoJsonPath.readPathValue(in, m.typ, m.pos))</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">      val result = if (values.lengthCompare(1) == 0) { values.head } else { values.asJava }</span>
<span class="nc" id="L76">      path.function match {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        case None =&gt; result</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        case Some(f) =&gt; f.apply(result)</span>
      }
    }
  }

  // matching reads - will select further nodes to process based on an input predicate

  /**
    * Given a set of input nodes defined by their types and offsets, return a list of output nodes which
    * match the given attribute name
    *
    * @param nodes input node types and offsets
    * @param name attribute name to match - if None will match all names
    * @return matching node types and offsets
    */
  private def matchPathAttribute(nodes: Seq[ValuePointer], name: Option[String]): Seq[ValuePointer] = {
<span class="nc bnc" id="L94" title="All 12 branches missed.">    val docs = nodes.collect { case ValuePointer(t, p) if t == DocByte || t == ArrayByte =&gt; p }</span>
<span class="nc bnc" id="L95" title="All 6 branches missed.">    matchObjectPath(docs, name.map(n =&gt; () =&gt; n == in.readName()))</span>
  }

  /**
    * Given a set of input nodes defined by their types and offsets, return a list of output nodes which
    * match the given index
    *
    * @param nodes input node types and offsets
    * @param indices array indices to match
    * @return matching node types and offsets
    */
  private def matchPathIndex(nodes: Seq[ValuePointer], indices: Seq[Int]): Seq[ValuePointer] = {
<span class="nc bnc" id="L107" title="All 4 branches missed.">    if (indices.forall(_ &gt;= 0)) {</span>
<span class="nc" id="L108">      matchPathIndices(nodes, Some(() =&gt; indices.contains(in.readName().toInt)))</span>
    } else {
      // have to do post-filtering to read backwards from end
<span class="nc" id="L111">      val all = matchPathIndices(nodes, None)</span>
<span class="nc" id="L112">      val res = Seq.newBuilder[ValuePointer]</span>
<span class="nc" id="L113">      indices.foreach { i =&gt;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        res += (if (i &lt; 0) { all(all.length + i) } else { all(i) })</span>
      }
<span class="nc" id="L116">      res.result()</span>
    }
  }

  /**
   * Given a set of input nodes defined by their types and offsets, return a list of output nodes which
   * match the given index range
   *
   * @param nodes input node types and offsets
   * @param from from index, inclusive, or None to start from the first element
   * @param to to index, exclusive, or None to end with the last element
   * @return matching node types and offsets
   */
  private def matchPathIndexRange(nodes: Seq[ValuePointer], from: Option[Int], to: Option[Int]): Seq[ValuePointer] = {
<span class="nc bnc" id="L130" title="All 8 branches missed.">    if (from.forall(_ &gt;= 0) &amp;&amp; to.forall(_ &gt;= 0)) {</span>
<span class="nc bnc" id="L131" title="All 8 branches missed.">      matchPathIndices(nodes, Some(() =&gt; { val i = in.readName().toInt; from.forall(_ &lt;= i) &amp;&amp; to.forall(_ &gt; i) }))</span>
    } else {
      // have to do post-filtering to read backwards from end
<span class="nc" id="L134">      val all = matchPathIndices(nodes, None)</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      def offset(bound: Int): Int = if (bound &gt;= 0) { bound } else { all.length + bound }</span>
<span class="nc" id="L136">      all.slice(from.map(offset).getOrElse(0), to.map(offset).getOrElse(all.length))</span>
    }
  }

  /**
   * Given a set of input nodes defined by their types and offsets, return a list of output nodes
   *
   * @param nodes input node types and offsets
   * @return matching node types and offsets
   */
  private def matchAllPathIndices(nodes: Seq[ValuePointer]): Seq[ValuePointer] =
<span class="nc" id="L147">    matchPathIndices(nodes, None)</span>

  private def matchPathIndices(nodes: Seq[ValuePointer], predicate: Option[() =&gt; Boolean]): Seq[ValuePointer] =
<span class="nc bnc" id="L150" title="All 8 branches missed.">    matchObjectPath(nodes.collect { case ValuePointer(ArrayByte, p) =&gt; p }, predicate)</span>

  /**
    * Given a set of input nodes defined by their offsets, return a list of matching nodes
    * which match the predicate. Input nodes must be either arrays or objects
    *
    * Note: predicate must consume the 'name' from the input stream
    *
    * @param positions input node offsets - must be arrays or objects
    * @param nameConsumingPredicate optional predicate to match - must consume the object name from the input stream
    * @return matching node types and offsets
    */
  private def matchObjectPath(positions: Seq[Int], nameConsumingPredicate: Option[() =&gt; Boolean]): Seq[ValuePointer] = {
<span class="nc" id="L163">    val predicate: () =&gt; Boolean = nameConsumingPredicate.getOrElse(() =&gt; { in.skipName(); true })</span>
<span class="nc" id="L164">    val result = Seq.newBuilder[ValuePointer]</span>
<span class="nc" id="L165">    positions.foreach { position =&gt;</span>
<span class="nc" id="L166">      in.setPosition(position)</span>
<span class="nc" id="L167">      val end = position + in.readInt() - 1 // last byte is the terminal byte</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">      while (in.position() &lt; end) {</span>
<span class="nc" id="L169">        val switch = in.readByte()</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (predicate()) {</span>
<span class="nc" id="L171">          result += ValuePointer(switch, in.position())</span>
        }
<span class="nc" id="L173">        switch match {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">          case StringByte   =&gt; skipString(in)</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">          case DocByte      =&gt; skipDocument(in)</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">          case ArrayByte    =&gt; skipDocument(in) // arrays are stored as docs</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">          case DoubleByte   =&gt; in.skip(8)</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">          case IntByte      =&gt; in.skip(4)</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">          case LongByte     =&gt; in.skip(8)</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">          case NullByte     =&gt; // no-op</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">          case BooleanByte  =&gt; skipBoolean(in)</span>
        }
      }
    }
<span class="nc" id="L185">    result.result()</span>
  }

  /**
   * Given a set of input nodes defined by their types and offsets, returns all nodes contained by the inputs.
   *
   * Note: this is implemented as a depth-first search to match jayway json-path behavior
   *
   * @param nodes input node types and offsets
   * @return matching node types and offsets
   */
  private def matchDeep(nodes: Seq[ValuePointer]): Seq[ValuePointer] = {
<span class="nc" id="L197">    nodes.flatMap { node =&gt;</span>
<span class="nc" id="L198">      node.typ match {</span>
<span class="nc bnc" id="L199" title="All 6 branches missed.">        case DocByte | ArrayByte =&gt; Seq(node) ++ matchDeep(matchObjectPath(Seq(node.pos), None))</span>
<span class="nc" id="L200">        case _ =&gt; Seq(node) // primitives</span>
      }
    }
  }

  /**
   * Given a set of input nodes defined by their types and offsets, return all nodes which match the given filter
   *
   * @param nodes input node types and offsets
   * @param op filter op
   * @return matching node types and offsets
   */
  private def matchFilter(nodes: Seq[ValuePointer], op: PathFilter.FilterOp): Seq[ValuePointer] = {
<span class="nc" id="L213">    val predicate = KryoJsonPathFilter(in, root, op)</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">    nodes.flatMap {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">      case ValuePointer(ArrayByte, pos) =&gt; matchObjectPath(Seq(pos), None).filter(predicate.apply)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">      case p if predicate(p) =&gt; Seq(p)</span>
<span class="nc" id="L217">      case _ =&gt; Nil</span>
    }
  }
}

<span class="nc bnc" id="L222" title="All 4 branches missed.">object KryoJsonPath extends LazyLogging {</span>

  import KryoJsonSerialization._

  /**
   * Pointer to a serialized value
   *
   * @param typ the type of the value, one of the constants defined in KryoJsonSerialization
   * @param pos the start position of the value in the serialized json bytes
   */
<span class="nc bnc" id="L232" title="All 17 branches missed.">  private[json] case class ValuePointer(typ: Byte, pos: Int)</span>

  /**
   * Gets the root element that the input is currently pointing to
   *
   * @param in input
   * @return
   */
  private def root(in: Input): ValuePointer = {
<span class="nc" id="L241">    in.readByte match {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">      case BooleanTrue  =&gt; ValuePointer(DocByte, in.position())</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">      case BooleanFalse =&gt; ValuePointer(NullByte, -1)</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">      case NonDoc =&gt;</span>
<span class="nc" id="L245">        val switch = in.readByte()</span>
<span class="nc" id="L246">        in.skipName()</span>
<span class="nc" id="L247">        ValuePointer(switch, in.position())</span>
    }
  }

  /**
   * Read the value for a given node path - does not return the wrapped JElement
   *
   * @param in input
   * @param typed type of value being read
   * @param position position of the value being read in the input
   * @return value
   */
  private def readPathValue(in: Input, typed: Byte, position: Int): Any = {
<span class="nc" id="L260">    in.setPosition(position)</span>
<span class="nc" id="L261">    typed match {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">      case StringByte   =&gt; readString(in)</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">      case DocByte      =&gt; mapper.writeValueAsString(readDocument(in))</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">      case ArrayByte    =&gt; unwrapArray(readArray(in))</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">      case DoubleByte   =&gt; in.readDouble()</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">      case IntByte      =&gt; in.readInt()</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      case LongByte     =&gt; in.readLong()</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      case NullByte     =&gt; null</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      case BooleanByte  =&gt; readBoolean(in)</span>
    }
  }

  /**
   * Unwrap a JArray into the primitive types contained within. Compared to JArray.values, this
   * serializes documents into strings
   *
   * @param array array to unwrap
   * @return
   */
  private def unwrapArray(array: ArrayNode): java.util.List[Any] = {
<span class="nc" id="L281">    val list = new java.util.ArrayList[Any](array.size())</span>
<span class="nc" id="L282">    var i = 0</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">    while (i &lt; array.size()) {</span>
<span class="nc" id="L284">      val value = array.get(i)</span>
      val unwrapped =
<span class="nc bnc" id="L286" title="All 4 branches missed.">        if (value.isTextual || value.isBinary) {</span>
<span class="nc" id="L287">          value.asText()</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        } else if (value.isObject) {</span>
<span class="nc" id="L289">          mapper.writeValueAsString(value)</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">        } else if (value.isArray) {</span>
<span class="nc" id="L291">          unwrapArray(value.asInstanceOf[ArrayNode])</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">        } else if (value.isDouble || value.isFloat) {</span>
<span class="nc" id="L293">          value.asDouble()</span>
<span class="nc bnc" id="L294" title="All 4 branches missed.">        } else if (value.isInt || value.isShort) {</span>
<span class="nc" id="L295">          value.intValue()</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        } else if (value.isLong) {</span>
<span class="nc" id="L297">          value.longValue()</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        } else if (value.isNull) {</span>
<span class="nc" id="L299">          null</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        } else if (value.isBoolean) {</span>
<span class="nc" id="L301">          value.booleanValue()</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        } else if (value.isBigDecimal) {</span>
<span class="nc" id="L303">          value.asDouble()</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        } else if (value.isBigInteger) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">          if (value.canConvertToInt) {</span>
<span class="nc" id="L306">            value.intValue()</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">          } else if (value.canConvertToLong) {</span>
<span class="nc" id="L308">            value.longValue()</span>
          } else {
<span class="nc bnc" id="L310" title="All 2 branches missed.">            logger.warn(s&quot;Skipping int value that does not fit in a long: $value&quot;)</span>
<span class="nc" id="L311">            null</span>
          }
        } else {
<span class="nc bnc" id="L314" title="All 2 branches missed.">          logger.warn(s&quot;Unhandled JsonNode: $value&quot;)</span>
<span class="nc" id="L315">          null</span>
        }
<span class="nc bnc" id="L317" title="All 2 branches missed.">      if (unwrapped != null) {</span>
<span class="nc" id="L318">        list.add(unwrapped)</span>
      }
<span class="nc" id="L320">      i += 1</span>
    }
<span class="nc" id="L322">    Collections.unmodifiableList(list)</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>