<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonPathParser.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo.json</a> &gt; <span class="el_source">JsonPathParser.scala</span></div><h1>JsonPathParser.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo.json

import org.apache.commons.text.StringEscapeUtils
import org.locationtech.geomesa.features.kryo.json.JsonPathParser._
import org.locationtech.geomesa.utils.text.BasicParser
import org.parboiled.Context
import org.parboiled.errors.{ErrorUtils, ParsingException}
import org.parboiled.scala._

import java.util.Objects
import java.util.regex.Pattern

/**
  * Parses a json path string into a sequence of selectors. See https://github.com/jayway/JsonPath for examples.
  */
<span class="nc" id="L24">object JsonPathParser {</span>

<span class="nc" id="L26">  private val Parser = new JsonPathParser()</span>

  @throws(classOf[ParsingException])
<span class="nc" id="L29">  def parse(path: String, report: Boolean = true): JsonPath = {</span>
<span class="nc bnc" id="L30" title="All 2 branches missed.">    if (path == null) {</span>
<span class="nc" id="L31">      throw new IllegalArgumentException(&quot;Path must not be null&quot;)</span>
    }
<span class="nc bnc" id="L33" title="All 2 branches missed.">    val runner = if (report) { ReportingParseRunner(Parser.Path) } else { BasicParseRunner(Parser.Path) }</span>
<span class="nc bnc" id="L34" title="All 2 branches missed.">    val fixedPath = if (path.startsWith(&quot;$&quot;)) { path } else s&quot;$$.$path&quot;</span>
<span class="nc" id="L35">    val parsing = runner.run(fixedPath)</span>
<span class="nc" id="L36">    parsing.result.getOrElse {</span>
<span class="nc" id="L37">      throw new ParsingException(s&quot;Invalid json path: ${ErrorUtils.printParseErrors(parsing)}&quot;)</span>
    }
  }

  /**
   * Prints a parsed path back into a path string
   *
   * @param path path
   * @param prefix prefix
   * @return
   */
<span class="nc" id="L48">  def print(path: JsonPath, prefix: Char = '$'): String = {</span>
<span class="nc" id="L49">    require(path.elements.nonEmpty, &quot;Path must not be empty&quot;)</span>

<span class="nc" id="L51">    val builder = new StringBuilder()</span>

    def append(e: Any): Unit = {
<span class="nc" id="L54">      val s = e.toString</span>
      // handle deep scans followed by dot selectors
<span class="nc bnc" id="L56" title="All 4 branches missed.">      if (s.startsWith(&quot;.&quot;) &amp;&amp; builder.endsWith(Seq('.', '.'))) {</span>
<span class="nc" id="L57">        builder.append(s.substring(1))</span>
      } else {
<span class="nc" id="L59">        builder.append(s)</span>
      }
    }

<span class="nc" id="L63">    builder.append(prefix)</span>
<span class="nc" id="L64">    path.elements.foreach(append)</span>
<span class="nc" id="L65">    path.function.foreach(append)</span>
<span class="nc" id="L66">    builder.toString()</span>
  }

  /**
   * A parsed json path
   *
   * @param elements selector elements in the path
   * @param function an optional trailing function (per spec, may only be 1 trailing function in a path)
   */
<span class="nc bnc" id="L75" title="All 25 branches missed.">  case class JsonPath(elements: Seq[PathElement], function: Option[PathFunction] = None) {</span>
<span class="nc" id="L76">    def isEmpty: Boolean = elements.isEmpty</span>
<span class="nc" id="L77">    def nonEmpty: Boolean = elements.nonEmpty</span>
<span class="nc" id="L78">    def head: PathElement = elements.head</span>
<span class="nc" id="L79">    def tail: JsonPath = JsonPath(elements.tail, function)</span>
  }

  sealed trait PathElement

  // attribute: .foo or ['foo']
<span class="nc bnc" id="L85" title="All 23 branches missed.">  case class PathAttribute(name: String, bracketed: Boolean = false) extends PathElement {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    override def toString: String = if (bracketed) { s&quot;['$name']&quot; } else { s&quot;.$name&quot; }</span>
  }

  // index range [1:5] (inclusive on start, exclusive on end, either side can be empty to indicate from start/to end)
<span class="nc bnc" id="L90" title="All 25 branches missed.">  case class PathIndexRange(from: Option[Int], to: Option[Int]) extends PathElement {</span>
<span class="nc" id="L91">    override def toString: String = s&quot;[${from.getOrElse(&quot;&quot;)}:${to.getOrElse(&quot;&quot;)}]&quot;</span>
  }

  // enumerated indices: [1,2,5]
<span class="nc bnc" id="L95" title="All 18 branches missed.">  case class PathIndices(indices: Seq[Int]) extends PathElement {</span>
<span class="nc" id="L96">    override def toString: String = indices.mkString(&quot;[&quot;, &quot;,&quot;, &quot;]&quot;)</span>
  }

  // any attribute: .*
<span class="nc" id="L100">  case object PathAttributeWildCard extends PathElement {</span>
<span class="nc" id="L101">    override val toString: String = &quot;.*&quot;</span>
  }

  // any index: [*]
<span class="nc" id="L105">  case object PathIndexWildCard extends PathElement {</span>
<span class="nc" id="L106">    override val toString: String = &quot;[*]&quot;</span>
  }

  // deep scan: ..
<span class="nc" id="L110">  case object PathDeepScan extends PathElement {</span>
<span class="nc" id="L111">    override val toString: String = &quot;..&quot;</span>
  }

  // path function: .min(), .max(), .avg(), .length(), .sum(), .first(), .last()
  // not implemented: stddev, concat, append, keys
  sealed trait PathFunction extends (Any =&gt; Any)

<span class="nc" id="L118">  object PathFunction {</span>

    import scala.collection.JavaConverters._

    /**
     * Function over a seq of numbers
     *
     * @param name name of the function
     * @param op operation
     */
<span class="nc" id="L128">    abstract class NumericFunction(name: String, op: Seq[Double] =&gt; Double) extends PathFunction {</span>
<span class="nc" id="L129">      private def toNum(v: Any): Double = v match {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        case n: Number =&gt; n.doubleValue</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        case null =&gt; 0.0</span>
<span class="nc" id="L132">        case n =&gt; n.toString.toDouble</span>
      }
      override def apply(args: Any): Any = {
<span class="nc" id="L135">        args match {</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">          case s: java.util.List[_] if !s.isEmpty =&gt; op(s.asScala.toSeq.map(toNum))</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">          case s: Seq[_] if s.nonEmpty =&gt; op(s.map(toNum))</span>
<span class="nc" id="L138">          case _ =&gt; null</span>
        }
      }
<span class="nc" id="L141">      override def toString: String = s&quot;.$name()&quot;</span>
    }

<span class="nc" id="L144">    case object MinFunction extends NumericFunction(&quot;min&quot;, _.min)</span>
<span class="nc" id="L145">    case object MaxFunction extends NumericFunction(&quot;max&quot;, _.max)</span>
<span class="nc" id="L146">    case object SumFunction extends NumericFunction(&quot;sum&quot;, _.sum)</span>
<span class="nc" id="L147">    case object AvgFunction extends NumericFunction(&quot;avg&quot;, a =&gt; a.sum / a.length)</span>

<span class="nc" id="L149">    case object LengthFunction extends PathFunction {</span>
<span class="nc" id="L150">      override def apply(obj: Any): Any = obj match {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        case s: java.util.List[_] =&gt; s.size</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        case s: Seq[_] =&gt; s.size</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        case s: String =&gt; s.length</span>
<span class="nc" id="L154">        case _ =&gt; null</span>
      }
<span class="nc" id="L156">      override def toString: String = &quot;.length()&quot;</span>
    }

<span class="nc" id="L159">    case object FirstFunction extends PathFunction {</span>
<span class="nc" id="L160">      override def apply(obj: Any): Any = obj match {</span>
<span class="nc bnc" id="L161" title="All 4 branches missed.">        case s: java.util.List[_] if !s.isEmpty =&gt; s.get(0)</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">        case s: Seq[_] if s.nonEmpty =&gt; s.head</span>
<span class="nc bnc" id="L163" title="All 4 branches missed.">        case s: String if s.nonEmpty =&gt; s.substring(0, 1)</span>
<span class="nc" id="L164">        case _ =&gt; null</span>
      }
<span class="nc" id="L166">      override def toString: String = &quot;.first()&quot;</span>
    }

<span class="nc" id="L169">    case object LastFunction extends PathFunction {</span>
<span class="nc" id="L170">      override def apply(obj: Any): Any = obj match {</span>
<span class="nc bnc" id="L171" title="All 4 branches missed.">        case s: java.util.List[_] if !s.isEmpty =&gt; s.get(s.size() - 1)</span>
<span class="nc bnc" id="L172" title="All 4 branches missed.">        case s: Seq[_] if s.nonEmpty =&gt; s.last</span>
<span class="nc bnc" id="L173" title="All 4 branches missed.">        case s: String if s.nonEmpty =&gt; s.substring(s.length - 1, s.length)</span>
<span class="nc" id="L174">        case _ =&gt; null</span>
      }
<span class="nc" id="L176">      override def toString: String = &quot;.last()&quot;</span>
    }

    // note: negative indices count backwards from the end
<span class="nc bnc" id="L180" title="All 14 branches missed.">    case class IndexFunction(i: Int) extends PathFunction {</span>
<span class="nc" id="L181">      override def apply(obj: Any): Any = obj match {</span>
<span class="nc bnc" id="L182" title="All 6 branches missed.">        case s: java.util.List[_] if i &gt;= 0 &amp;&amp; i &lt; s.size =&gt; s.get(i)</span>
<span class="nc bnc" id="L183" title="All 6 branches missed.">        case s: java.util.List[_] if i &lt; 0 &amp;&amp; s.size + i &gt;= 0 =&gt; s.get(s.size + i)</span>
<span class="nc bnc" id="L184" title="All 6 branches missed.">        case s: Seq[_] if i &gt;= 0 &amp;&amp; i &lt; s.size =&gt; s(i)</span>
<span class="nc bnc" id="L185" title="All 6 branches missed.">        case s: Seq[_] if i &lt; 0 &amp;&amp; s.size + i &gt;= 0 =&gt; s(s.size + i)</span>
<span class="nc bnc" id="L186" title="All 6 branches missed.">        case s: String if i &gt;= 0 &amp;&amp; i &lt; s.length =&gt; s.substring(i, i + 1)</span>
<span class="nc bnc" id="L187" title="All 6 branches missed.">        case s: String if i &lt; 0 &amp;&amp; s.length + i &gt;= 0 =&gt; s.substring(0, s.length + i + 1)</span>
<span class="nc" id="L188">        case _ =&gt; null</span>
      }
<span class="nc" id="L190">      override def toString: String = s&quot;.index($i)&quot;</span>
    }
  }

  // filter ops: [?(&lt;exp&gt;)]
<span class="nc bnc" id="L195" title="All 18 branches missed.">  case class PathFilter(op: PathFilter.FilterOp) extends PathElement {</span>
    override def toString: String = {
<span class="nc" id="L197">      val filter = op.toString</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">      if (filter.startsWith(&quot;(&quot;) &amp;&amp; filter.endsWith(&quot;)&quot;)) { s&quot;[?$filter]&quot; } else { s&quot;[?($filter)]&quot; }</span>
    }
  }

<span class="nc" id="L202">  object PathFilter {</span>

    /**
     * A filter operation (equals, less than, etc)
     */
    sealed trait FilterOp

    // == left is equal to right (note that 1 is not equal to '1')
<span class="nc bnc" id="L210" title="All 25 branches missed.">    case class EqualsOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L211">      override def toString: String = s&quot;$left == $right&quot;</span>
    }

    // != left is not equal to right
<span class="nc bnc" id="L215" title="All 25 branches missed.">    case class NotEqualsOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L216">      override def toString: String = s&quot;$left != $right&quot;</span>
    }

    // &lt; left is less than right
<span class="nc bnc" id="L220" title="All 25 branches missed.">    case class LessThanOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L221">      override def toString: String = s&quot;$left &lt; $right&quot;</span>
    }

    // &lt;= left is less or equal to right
<span class="nc bnc" id="L225" title="All 25 branches missed.">    case class LessThanOrEqualsOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L226">      override def toString: String = s&quot;$left &lt;= $right&quot;</span>
    }

    // &gt; left is greater than right
<span class="nc bnc" id="L230" title="All 25 branches missed.">    case class GreaterThanOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L231">      override def toString: String = s&quot;$left &gt; $right&quot;</span>
    }

    // &gt;= left is greater than or equal to right
<span class="nc bnc" id="L235" title="All 25 branches missed.">    case class GreaterThanOrEqualsOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L236">      override def toString: String = s&quot;$left &gt;= $right&quot;</span>
    }

    // =~ left matches regular expression [?(@.name =~ /foo.*?/i)]
<span class="nc bnc" id="L240" title="All 5 branches missed.">    case class RegexOp(left: PathExpression, regex: Pattern) extends FilterOp {</span>

      override def toString: String = {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        val flag = if ((regex.flags() &amp; Pattern.CASE_INSENSITIVE) != 0) { &quot;i&quot; } else { &quot;&quot; }</span>
<span class="nc" id="L244">        s&quot;$left =~ /${regex.pattern()}/$flag&quot;</span>
      }

      // note: we implement equals and hash code since Pattern does not (mainly for unit tests)
<span class="nc" id="L248">      override def hashCode(): Int = Objects.hash(left, regex.pattern(), Int.box(regex.flags()))</span>

<span class="nc" id="L250">      override def equals(obj: Any): Boolean = obj match {</span>
<span class="nc bnc" id="L251" title="All 16 branches missed.">        case r: RegexOp =&gt; left == r.left &amp;&amp; regex.pattern() == r.regex.pattern() &amp;&amp; regex.flags() == r.regex.flags()</span>
<span class="nc" id="L252">        case _ =&gt; false</span>
      }

<span class="nc" id="L255">      override def canEqual(that: Any): Boolean = that.isInstanceOf[RegexOp]</span>
    }

    // in left exists in right [?(@.size in ['S', 'M'])]
<span class="nc bnc" id="L259" title="All 25 branches missed.">    case class InOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L260">      override def toString: String = s&quot;$left in $right&quot;</span>
    }

    // nin left does not exists in right
<span class="nc bnc" id="L264" title="All 25 branches missed.">    case class NotInOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L265">      override def toString: String = s&quot;$left nin $right&quot;</span>
    }

    // subsetof left is a subset of right [?(@.sizes subsetof ['S', 'M', 'L'])]
<span class="nc bnc" id="L269" title="All 25 branches missed.">    case class IsSubsetOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L270">      override def toString: String = s&quot;$left subsetof $right&quot;</span>
    }

    // anyof left has an intersection with right [?(@.sizes anyof ['M', 'L'])]
<span class="nc bnc" id="L274" title="All 25 branches missed.">    case class AnyOfOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L275">      override def toString: String = s&quot;$left anyof $right&quot;</span>
    }

    // noneof left has no intersection with right [?(@.sizes noneof ['M', 'L'])]
<span class="nc bnc" id="L279" title="All 25 branches missed.">    case class NoneOfOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L280">      override def toString: String = s&quot;$left noneof $right&quot;</span>
    }

    // size size of left (array or string) should match right
<span class="nc bnc" id="L284" title="All 25 branches missed.">    case class EqualSizeOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L285">      override def toString: String = s&quot;$left size $right&quot;</span>
    }

    // empty left (array or string) should be empty (specified by right)
<span class="nc bnc" id="L289" title="All 25 branches missed.">    case class IsEmptyOp(left: FilterExpression, right: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L290">      override def toString: String = s&quot;$left empty $right&quot;</span>
    }

    // value exists
<span class="nc bnc" id="L294" title="All 18 branches missed.">    case class ExistsOp(value: FilterExpression) extends FilterOp {</span>
<span class="nc" id="L295">      override def toString: String = value.toString</span>
    }

<span class="nc bnc" id="L298" title="All 18 branches missed.">    case class AndFilterOp(filters: Seq[FilterOp]) extends FilterOp {</span>
<span class="nc" id="L299">      override def toString: String = filters.mkString(&quot;(&quot;, &quot; &amp;&amp; &quot;, &quot;)&quot;)</span>
    }

<span class="nc bnc" id="L302" title="All 18 branches missed.">    case class OrFilterOp(filters: Seq[FilterOp]) extends FilterOp {</span>
<span class="nc" id="L303">      override def toString: String = filters.mkString(&quot;(&quot;, &quot; || &quot;, &quot;)&quot;)</span>
    }

<span class="nc bnc" id="L306" title="All 18 branches missed.">    case class NotFilterOp(filter: FilterOp) extends FilterOp {</span>
<span class="nc" id="L307">      override def toString: String = s&quot;!$filter&quot;</span>
    }

    /**
     * An argument in a filter
     */
    sealed trait FilterExpression

    /**
     * A json-path argument in a filter
     *
     * @param path json path
     * @param absolute relative to current node, or absolute (@ vs $)
     */
<span class="nc bnc" id="L321" title="All 23 branches missed.">    case class PathExpression(path: JsonPath, absolute: Boolean = false) extends FilterExpression {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">      override def toString: String = JsonPathParser.print(path, if (absolute) { '$' } else { '@' })</span>
    }

    /**
     * A literal argument in a filter
     */
    sealed trait LiteralExpression extends FilterExpression {
      def value: Any
    }

<span class="nc bnc" id="L332" title="All 18 branches missed.">    case class NumericLiteral(value: BigDecimal) extends LiteralExpression {</span>
<span class="nc" id="L333">      override def toString: String = value.toString</span>
    }
<span class="nc bnc" id="L335" title="All 18 branches missed.">    case class StringLiteral(value: String) extends LiteralExpression {</span>
<span class="nc" id="L336">      override def toString: String = s&quot;'${value.replaceAll(&quot;'&quot;, &quot;\\'&quot;)}'&quot;</span>
    }
<span class="nc bnc" id="L338" title="All 16 branches missed.">    case class BooleanLiteral(value: Boolean) extends LiteralExpression {</span>
<span class="nc" id="L339">      override def toString: String = value.toString</span>
    }
<span class="nc bnc" id="L341" title="All 18 branches missed.">    case class ArrayLiteral[T &lt;: LiteralExpression](wrapped: Seq[T]) extends LiteralExpression {</span>
<span class="nc" id="L342">      override val value: Seq[Any] = wrapped.map(_.value)</span>
<span class="nc" id="L343">      override def toString: String = wrapped.mkString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;)</span>
    }
  }
<span class="nc" id="L346">}</span>

<span class="nc" id="L348">private class JsonPathParser extends BasicParser {</span>

  import PathFilter._

  // main parsing rule
  def Path: Rule1[JsonPath] =
<span class="nc" id="L354">    rule { &quot;$&quot; ~ zeroOrMore(Element) ~ optional(Function) ~~&gt; ((e, f) =&gt; JsonPath(e, f)) ~ EOI }</span>

<span class="nc" id="L356">  def Element: Rule1[PathElement] = rule {</span>
<span class="nc" id="L357">    Attribute | ArrayIndices | ArrayIndexRange | BracketedAttribute | AttributeWildCard | IndexWildCard | DeepScan | FilterOp</span>
  }

<span class="nc" id="L360">  def IndexWildCard: Rule1[PathElement] = rule { &quot;[*]&quot; ~ push(PathIndexWildCard) }</span>

<span class="nc" id="L362">  def AttributeWildCard: Rule1[PathElement] = rule { &quot;.*&quot; ~ push(PathAttributeWildCard) }</span>

  // we have to push the deep scan directly onto the stack as there is no forward matching and
  // it's ridiculous trying to combine Rule1's and Rule2's
<span class="nc" id="L366">  def DeepScan: Rule1[PathElement] = rule { &quot;.&quot; ~ toRunAction(pushDeepScan) ~ (Attribute | BracketedAttribute | AttributeWildCard) }</span>

  // note: this assumes that we are inside a zeroOrMore, which is currently the case
  // the zeroOrMore will have pushed a single list onto the value stack - we append our value to that
  private def pushDeepScan(context: Context[Any]): Unit =
<span class="nc" id="L371">    context.getValueStack.push(PathDeepScan :: context.getValueStack.pop.asInstanceOf[List[_]])</span>

  def ArrayIndices: Rule1[PathIndices] =
<span class="nc" id="L374">    rule { &quot;[&quot; ~ oneOrMore(int, &quot;,&quot;) ~ &quot;]&quot; ~~&gt; PathIndices.apply }</span>

  def ArrayIndexRange: Rule1[PathIndexRange] =
<span class="nc" id="L377">    rule { &quot;[&quot; ~ optional(int) ~ &quot;:&quot; ~ optional(int) ~ &quot;]&quot; ~~&gt; ((from, to) =&gt; PathIndexRange(from, to)) }</span>

<span class="nc" id="L379">  def Attribute: Rule1[PathAttribute] = rule { &quot;.&quot; ~ oneOrMore(char) ~&gt; { s =&gt; PathAttribute(s) } ~ !&quot;(&quot; }</span>

  def BracketedAttribute: Rule1[PathAttribute] =
<span class="nc" id="L382">    rule { &quot;[&quot; ~ (unquotedString | singleQuotedString) ~~&gt; { s =&gt; PathAttribute(s, bracketed = true) } ~ &quot;]&quot; }</span>

  def Function: Rule1[PathFunction] =
<span class="nc" id="L385">    functionMin | functionMax | functionAvg | functionLength | functionSum | functionFirst | functionLast | functionIndex</span>

<span class="nc" id="L387">  private def functionMin: Rule1[PathFunction] = rule { &quot;.min()&quot; ~ push(PathFunction.MinFunction) }</span>
<span class="nc" id="L388">  private def functionMax: Rule1[PathFunction] = rule { &quot;.max()&quot; ~ push(PathFunction.MaxFunction) }</span>
<span class="nc" id="L389">  private def functionAvg: Rule1[PathFunction] = rule { &quot;.avg()&quot; ~ push(PathFunction.AvgFunction) }</span>
<span class="nc" id="L390">  private def functionLength: Rule1[PathFunction] = rule { &quot;.length()&quot; ~ push(PathFunction.LengthFunction) }</span>
<span class="nc" id="L391">  private def functionSum: Rule1[PathFunction] = rule { &quot;.sum()&quot; ~ push(PathFunction.SumFunction) }</span>
<span class="nc" id="L392">  private def functionFirst: Rule1[PathFunction] = rule { &quot;.first()&quot; ~ push(PathFunction.FirstFunction) }</span>
<span class="nc" id="L393">  private def functionLast: Rule1[PathFunction] = rule { &quot;.last()&quot; ~ push(PathFunction.LastFunction) }</span>
<span class="nc" id="L394">  private def functionIndex: Rule1[PathFunction] = rule { &quot;.index(&quot; ~ int ~ &quot;)&quot; ~~&gt; PathFunction.IndexFunction.apply }</span>

  /*
   * from jayway's impl:
   *
   *  LogicalOR               = LogicalAND { '||' LogicalAND }
   *  LogicalAND              = LogicalANDOperand { '&amp;&amp;' LogicalANDOperand }
   *  LogicalANDOperand       = RelationalExpression | '(' LogicalOR ')' | '!' LogicalANDOperand
   *  RelationalExpression    = Value [ RelationalOperator Value ]
   */

  // filter op on a path
<span class="nc" id="L406">  def FilterOp: Rule1[PathFilter] = rule { &quot;[?(&quot; ~ whitespace ~ logicalOr ~ whitespace ~ &quot;)]&quot; ~~&gt; PathFilter.apply  }</span>

<span class="nc" id="L408">  private def logicalOr: Rule1[FilterOp] = rule {</span>
<span class="nc" id="L409">    oneOrMore(logicalAnd, whitespace ~ &quot;||&quot; ~ whitespace) ~~&gt; { ops =&gt;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">      if (ops.lengthCompare(1) == 0) { ops.head } else { OrFilterOp(ops) }</span>
    }
  }
<span class="nc" id="L413">  private def logicalAnd: Rule1[FilterOp] = rule {</span>
<span class="nc" id="L414">    oneOrMore(andOperand, whitespace ~ &quot;&amp;&amp;&quot; ~ whitespace) ~~&gt; { ops =&gt;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">      if (ops.lengthCompare(1) == 0) { ops.head } else { AndFilterOp(ops) }</span>
    }
  }
<span class="nc" id="L418">  private def andOperand: Rule1[FilterOp] = rule { filter | &quot;(&quot; ~ whitespace ~ logicalOr ~ whitespace ~ &quot;)&quot; | logicalNot }</span>
<span class="nc" id="L419">  private def logicalNot: Rule1[FilterOp] = rule { &quot;!&quot; ~ whitespace ~ andOperand ~~&gt; NotFilterOp.apply  }</span>

  private def filter: Rule1[FilterOp] =
<span class="nc" id="L422">    equalsFilter | notEqualsFilter | lessThanOrEqualsFilter | lessThanFilter | greaterThanOrEqualsFilter |</span>
<span class="nc" id="L423">      greaterThanFilter | inFilter | ninFilter | subsetFilter | anyOfFilter | noneOfFilter | sizeFilter |</span>
<span class="nc" id="L424">      regexFilter | isEmptyFilter | existsFilter</span>

<span class="nc" id="L426">  private def equalsFilter: Rule1[EqualsOp] = rule { binaryFilter(&quot;==&quot;, EqualsOp.apply) }</span>
<span class="nc" id="L427">  private def notEqualsFilter: Rule1[NotEqualsOp] = rule { binaryFilter(&quot;!=&quot;, NotEqualsOp.apply) }</span>
<span class="nc" id="L428">  private def lessThanOrEqualsFilter: Rule1[LessThanOrEqualsOp] = rule { binaryFilter(&quot;&lt;=&quot;, LessThanOrEqualsOp.apply) }</span>
<span class="nc" id="L429">  private def lessThanFilter: Rule1[LessThanOp] = rule { binaryFilter(&quot;&lt;&quot;, LessThanOp.apply) }</span>
<span class="nc" id="L430">  private def greaterThanOrEqualsFilter: Rule1[GreaterThanOrEqualsOp] = rule { binaryFilter(&quot;&gt;=&quot;, GreaterThanOrEqualsOp.apply) }</span>
<span class="nc" id="L431">  private def greaterThanFilter: Rule1[GreaterThanOp] = rule { binaryFilter(&quot;&gt;&quot;, GreaterThanOp.apply) }</span>
<span class="nc" id="L432">  private def inFilter: Rule1[InOp] = rule { binaryStringOpFilter(&quot;in&quot;, InOp.apply) }</span>
<span class="nc" id="L433">  private def ninFilter: Rule1[NotInOp] = rule { binaryStringOpFilter(&quot;nin&quot;, NotInOp.apply) }</span>
<span class="nc" id="L434">  private def subsetFilter: Rule1[IsSubsetOp] = rule { binaryStringOpFilter(&quot;subsetof&quot;, IsSubsetOp.apply) }</span>
<span class="nc" id="L435">  private def anyOfFilter: Rule1[AnyOfOp] = rule { binaryStringOpFilter(&quot;anyof&quot;, AnyOfOp.apply) }</span>
<span class="nc" id="L436">  private def noneOfFilter: Rule1[NoneOfOp] = rule { binaryStringOpFilter(&quot;noneof&quot;, NoneOfOp.apply) }</span>
<span class="nc" id="L437">  private def sizeFilter: Rule1[EqualSizeOp] = rule { binaryStringOpFilter(&quot;size&quot;, EqualSizeOp.apply) }</span>
<span class="nc" id="L438">  private def isEmptyFilter: Rule1[IsEmptyOp] = rule { binaryStringOpFilter(&quot;empty&quot;, IsEmptyOp.apply) }</span>

  private def binaryFilter[T](op: String, builder: (FilterExpression, FilterExpression) =&gt; T) =
<span class="nc" id="L441">    (filterExpression ~ whitespace ~ op ~ whitespace ~ filterExpression) ~~&gt; { (left, right) =&gt; builder(left, right) }</span>
  private def binaryStringOpFilter[T](op: String, builder: (FilterExpression, FilterExpression) =&gt; T) =
<span class="nc" id="L443">    (filterExpression ~ space ~ op ~ space ~ filterExpression) ~~&gt; { (left, right) =&gt; builder(left, right) }</span>

<span class="nc" id="L445">  private def regexFilter: Rule1[RegexOp] = rule {</span>
<span class="nc" id="L446">    (pathFilterExpression ~ whitespace ~ &quot;=~&quot; ~ whitespace ~ &quot;/&quot; ~ regexPattern ~ &quot;/&quot; ~ optional(&quot;i&quot; ~ push(true))) ~~&gt; {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">      (left, pattern, i) =&gt; RegexOp(left, Pattern.compile(pattern, if (i.contains(true)) { Pattern.CASE_INSENSITIVE } else { 0 }))</span>
    }
  }
<span class="nc" id="L450">  private def regexPattern: Rule1[String] = rule {</span>
<span class="nc" id="L451">    oneOrMore((noneOf(&quot;/&quot;) ~? notControlChar) | escapedChar) ~&gt; StringEscapeUtils.unescapeJava</span>
  }

<span class="nc" id="L454">  private def existsFilter: Rule1[ExistsOp] = rule { filterExpression ~~&gt; ExistsOp.apply }</span>

  // an argument in a filter - a path or literal
  private def filterExpression: Rule1[FilterExpression] =
<span class="nc" id="L458">    pathFilterExpression | literalFilterString | literalFilterNumber | literalFilterBoolean |</span>
<span class="nc" id="L459">      literalFilterStringArray | literalFilterNumberArray | literalFilterBooleanArray</span>

<span class="nc" id="L461">  private def pathFilterExpression: Rule1[PathExpression] = rule {</span>
<span class="nc" id="L462">    (&quot;$&quot;  ~ push(true) | &quot;@&quot; ~ push(false)) ~ zeroOrMore(Element) ~ optional(Function) ~~&gt; { (absolute, e, f) =&gt;</span>
<span class="nc" id="L463">      PathExpression(JsonPath(e, f), absolute = absolute)</span>
    }
  }

  private def literalFilterNumber: Rule1[NumericLiteral] =
<span class="nc" id="L468">    (double | float | long | int) ~~&gt; (n =&gt; NumericLiteral(BigDecimal(n.toString)))</span>
<span class="nc" id="L469">  private def literalFilterString: Rule1[StringLiteral] = (quotedString | singleQuotedString) ~~&gt; StringLiteral.apply</span>
<span class="nc" id="L470">  private def literalFilterBoolean: Rule1[BooleanLiteral] = boolean ~~&gt; BooleanLiteral.apply</span>
  private def literalFilterNumberArray: Rule1[ArrayLiteral[NumericLiteral]] =
<span class="nc" id="L472">    &quot;[&quot; ~ whitespace ~ oneOrMore(literalFilterNumber, &quot;,&quot; ~ whitespace) ~ whitespace ~ &quot;]&quot; ~~&gt; ArrayLiteral.apply</span>
  private def literalFilterStringArray: Rule1[ArrayLiteral[StringLiteral]] =
<span class="nc" id="L474">    &quot;[&quot; ~ whitespace ~ oneOrMore(literalFilterString, &quot;,&quot; ~ whitespace) ~ whitespace ~ &quot;]&quot; ~~&gt; ArrayLiteral.apply</span>
  private def literalFilterBooleanArray: Rule1[ArrayLiteral[BooleanLiteral]] =
<span class="nc" id="L476">    &quot;[&quot; ~ whitespace ~ oneOrMore(literalFilterBoolean, &quot;,&quot; ~ whitespace) ~ whitespace ~ &quot;]&quot; ~~&gt; ArrayLiteral.apply</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>