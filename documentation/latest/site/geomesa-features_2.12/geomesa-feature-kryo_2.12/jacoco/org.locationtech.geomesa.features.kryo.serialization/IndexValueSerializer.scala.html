<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexValueSerializer.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo.serialization</a> &gt; <span class="el_source">IndexValueSerializer.scala</span></div><h1>IndexValueSerializer.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo.serialization

import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.geotools.filter.identity.FeatureIdImpl
import org.locationtech.geomesa.features.SerializationOption.SerializationOption
import org.locationtech.geomesa.features.SimpleFeatureSerializer.LimitedSerialization
import org.locationtech.geomesa.features.kryo.{KryoFeatureSerializer, ProjectingKryoFeatureSerializer}
import org.locationtech.geomesa.features.{ScalaSimpleFeature, SerializationOption}
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.sft.ImmutableSimpleFeatureType

import java.util.concurrent.ConcurrentHashMap

/**
 * Serializer for attribute join indices
 */
<span class="nc" id="L27">object IndexValueSerializer extends IndexValueSerializer {</span>

  /**
   * Encoder/decoder for index values. Allows customizable fields to be encoded. Not thread-safe.
   *
   * @param sft simple feature type
   */
  @deprecated
<span class="nc" id="L35">  class IndexValueEncoderImpl(sft: SimpleFeatureType)</span>
<span class="nc" id="L36">    extends org.locationtech.geomesa.features.SimpleFeatureSerializer with LimitedSerialization {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L40">    private val indexSft = getIndexSft(sft)</span>
<span class="nc" id="L41">    private val encoder = KryoFeatureSerializer(indexSft)</span>
<span class="nc" id="L42">    private val reusableFeature = new ScalaSimpleFeature(indexSft, &quot;&quot;)</span>
<span class="nc" id="L43">    private val indices = indexSft.getAttributeDescriptors.asScala.map(ad =&gt; sft.indexOf(ad.getLocalName)).toArray</span>

<span class="nc" id="L45">    override val options: Set[SerializationOption] = Set.empty</span>

    override def serialize(sf: SimpleFeature): Array[Byte] = {
<span class="nc" id="L48">      reusableFeature.getIdentifier.asInstanceOf[FeatureIdImpl].setID(sf.getID)</span>
<span class="nc" id="L49">      var i = 0</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">      while (i &lt; indices.length) {</span>
<span class="nc" id="L51">        reusableFeature.setAttribute(i, sf.getAttribute(indices(i)))</span>
<span class="nc" id="L52">        i += 1</span>
      }
<span class="nc" id="L54">      encoder.serialize(reusableFeature)</span>
    }

<span class="nc" id="L57">    override def deserialize(value: Array[Byte]): SimpleFeature = encoder.deserialize(value)</span>
  }
}

<span class="nc" id="L61">trait IndexValueSerializer {</span>

  import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

<span class="nc" id="L68">  private val cache = new ConcurrentHashMap[ImmutableSimpleFeatureType, ImmutableSimpleFeatureType]()</span>

  def apply(sft: SimpleFeatureType): org.locationtech.geomesa.features.SimpleFeatureSerializer =
<span class="nc" id="L71">    new ProjectingKryoFeatureSerializer(sft, getIndexSft(sft), SerializationOption.WithoutId)</span>

  /**
   * Gets a feature type compatible with the stored index value
   *
   * @param sft simple feature type
   * @return
   */
  def getIndexSft(sft: SimpleFeatureType): SimpleFeatureType = {
<span class="nc" id="L80">    sft match {</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      case immutable: ImmutableSimpleFeatureType =&gt;</span>
<span class="nc" id="L82">        var indexSft = cache.get(immutable)</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (indexSft == null) {</span>
<span class="nc" id="L84">          indexSft = SimpleFeatureTypes.immutable(buildIndexSft(sft)).asInstanceOf[ImmutableSimpleFeatureType]</span>
<span class="nc" id="L85">          cache.put(immutable, indexSft)</span>
        }
<span class="nc" id="L87">        indexSft</span>

<span class="nc" id="L89">      case _ =&gt; buildIndexSft(sft)</span>
    }
  }

  private def buildIndexSft(sft: SimpleFeatureType): SimpleFeatureType = {
<span class="nc" id="L94">    val builder = new SimpleFeatureTypeBuilder()</span>
<span class="nc" id="L95">    builder.setNamespaceURI(null: String)</span>
<span class="nc" id="L96">    builder.setName(sft.getTypeName + &quot;--index&quot;)</span>
<span class="nc" id="L97">    builder.setAttributes(getIndexValueAttributes(sft).asJava)</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (sft.getGeometryDescriptor != null) {</span>
<span class="nc" id="L99">      builder.setDefaultGeometry(sft.getGeometryDescriptor.getLocalName)</span>
    }
<span class="nc" id="L101">    builder.setCRS(sft.getCoordinateReferenceSystem)</span>
<span class="nc" id="L102">    val indexSft = builder.buildFeatureType()</span>
<span class="nc" id="L103">    indexSft.getUserData.putAll(sft.getUserData)</span>
<span class="nc" id="L104">    indexSft</span>
  }

  /**
   * Gets the attributes that are stored in the index value
   *
   * @param sft simple feature type
   * @return
   */
  private def getIndexValueAttributes(sft: SimpleFeatureType): Seq[AttributeDescriptor] = {
<span class="nc" id="L114">    val geom = sft.getGeometryDescriptor</span>
<span class="nc" id="L115">    val dtg = sft.getDtgField</span>
<span class="nc" id="L116">    val attributes = scala.collection.mutable.Buffer.empty[AttributeDescriptor]</span>
<span class="nc" id="L117">    var i = 0</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">    while (i &lt; sft.getAttributeCount) {</span>
<span class="nc" id="L119">      val ad = sft.getDescriptor(i)</span>
<span class="nc bnc" id="L120" title="All 10 branches missed.">      if (ad == geom || dtg.contains(ad.getLocalName) || ad.isIndexValue()) {</span>
<span class="nc" id="L121">        attributes.append(ad)</span>
      }
<span class="nc" id="L123">      i += 1</span>
    }
<span class="nc" id="L125">    attributes.toSeq</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>