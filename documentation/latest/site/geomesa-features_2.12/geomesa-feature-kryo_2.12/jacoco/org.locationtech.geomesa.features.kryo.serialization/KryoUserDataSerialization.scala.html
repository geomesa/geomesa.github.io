<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KryoUserDataSerialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo.serialization</a> &gt; <span class="el_source">KryoUserDataSerialization.scala</span></div><h1>KryoUserDataSerialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo.serialization

import com.esotericsoftware.kryo.io.{Input, Output}
import com.typesafe.scalalogging.LazyLogging
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.serialization.HintKeySerialization
import org.locationtech.jts.geom.{Geometry, LineString, Point, Polygon}

import java.util.{Date, UUID}
import scala.util.control.NonFatal

<span class="nc bnc" id="L20" title="All 4 branches missed.">object KryoUserDataSerialization extends LazyLogging {</span>

<span class="nc" id="L22">  private val nullMapping = &quot;$_&quot;</span>

<span class="nc" id="L24">  private val baseClassMappings: Map[Class[_], String] = Map(</span>
<span class="nc" id="L25">    classOf[String]            -&gt; &quot;$s&quot;,</span>
<span class="nc" id="L26">    classOf[Int]               -&gt; &quot;$i&quot;,</span>
<span class="nc" id="L27">    classOf[java.lang.Integer] -&gt; &quot;$i&quot;,</span>
<span class="nc" id="L28">    classOf[Long]              -&gt; &quot;$l&quot;,</span>
<span class="nc" id="L29">    classOf[java.lang.Long]    -&gt; &quot;$l&quot;,</span>
<span class="nc" id="L30">    classOf[Float]             -&gt; &quot;$f&quot;,</span>
<span class="nc" id="L31">    classOf[java.lang.Float]   -&gt; &quot;$f&quot;,</span>
<span class="nc" id="L32">    classOf[Double]            -&gt; &quot;$d&quot;,</span>
<span class="nc" id="L33">    classOf[java.lang.Double]  -&gt; &quot;$d&quot;,</span>
<span class="nc" id="L34">    classOf[Boolean]           -&gt; &quot;$b&quot;,</span>
<span class="nc" id="L35">    classOf[java.lang.Boolean] -&gt; &quot;$b&quot;,</span>
<span class="nc" id="L36">    classOf[java.util.Date]    -&gt; &quot;$D&quot;,</span>
<span class="nc" id="L37">    classOf[Array[Byte]]       -&gt; &quot;$B&quot;,</span>
<span class="nc" id="L38">    classOf[UUID]              -&gt; &quot;$u&quot;,</span>
<span class="nc" id="L39">    classOf[Point]             -&gt; &quot;$pt&quot;,</span>
<span class="nc" id="L40">    classOf[LineString]        -&gt; &quot;$ls&quot;,</span>
<span class="nc" id="L41">    classOf[Polygon]           -&gt; &quot;$pl&quot;,</span>
<span class="nc" id="L42">    classOf[Hints.Key]         -&gt; &quot;$h&quot;</span>
  )

<span class="nc" id="L45">  private val baseClassLookups: Map[String, Class[_]] = {</span>
<span class="nc" id="L46">    val m1 = baseClassMappings.filterNot(_._1.isPrimitive).map(_.swap)</span>
    // support hints generated with geotools versions &lt;= 20
<span class="nc" id="L48">    val m2 = m1 + (&quot;org.geotools.factory.Hints$Key&quot; -&gt; classOf[Hints.Key])</span>
<span class="nc" id="L49">    m2</span>
  }

<span class="nc" id="L52">  private implicit val ordering: Ordering[(AnyRef, AnyRef)] = Ordering.by(_._1.toString)</span>

  def serialize(out: Output, javaMap: java.util.Map[_ &lt;: AnyRef, _ &lt;: AnyRef]): Unit =
<span class="nc" id="L55">    serialize(out, javaMap, withoutFidHints = false, writeAscii = false)</span>

  def serialize(out: Output, javaMap: java.util.Map[_ &lt;: AnyRef, _ &lt;: AnyRef], withoutFidHints: Boolean): Unit =
<span class="nc" id="L58">    serialize(out, javaMap, withoutFidHints, writeAscii = false)</span>

  def serializeAscii(out: Output, javaMap: java.util.Map[_ &lt;: AnyRef, _ &lt;: AnyRef]): Unit =
<span class="nc" id="L61">    serialize(out, javaMap, withoutFidHints = true, writeAscii = true)</span>

  private def serialize(
      out: Output,
      javaMap: java.util.Map[_ &lt;: AnyRef, _ &lt;: AnyRef],
      withoutFidHints: Boolean,
      writeAscii: Boolean): Unit = {
    import scala.collection.JavaConverters._

    // write in sorted order to keep consistent output
<span class="nc" id="L71">    val toWrite = scala.collection.mutable.SortedSet.empty[(AnyRef, AnyRef)]</span>

<span class="nc bnc" id="L73" title="All 8 branches missed.">    javaMap.asScala.foreach {</span>
<span class="nc bnc" id="L74" title="All 4 branches missed.">      case (k, v) if k != null &amp;&amp; !k.isInstanceOf[Hints.Key] =&gt; toWrite += k -&gt; v</span>
<span class="nc bnc" id="L75" title="All 8 branches missed.">      case (Hints.USE_PROVIDED_FID, _) if withoutFidHints =&gt; // no-op</span>
<span class="nc bnc" id="L76" title="All 8 branches missed.">      case (Hints.PROVIDED_FID, _) if withoutFidHints =&gt; // no-op</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      case (k, v) =&gt; logger.warn(s&quot;Skipping serialization of entry: $k -&gt; $v&quot;)</span>
    }

<span class="nc" id="L80">    out.writeInt(toWrite.size) // don't use positive optimized version for back compatibility</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">    toWrite.foreach { case (key, value) =&gt;</span>
<span class="nc" id="L83">      out.writeString(baseClassMappings.getOrElse(key.getClass, key.getClass.getName))</span>
<span class="nc" id="L84">      write(out, key, writeAscii)</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L86">        out.writeString(nullMapping)</span>
      } else {
<span class="nc" id="L88">        out.writeString(baseClassMappings.getOrElse(value.getClass, value.getClass.getName))</span>
<span class="nc" id="L89">        write(out, value, writeAscii)</span>
      }
    }
  }

  def deserialize(in: Input): java.util.Map[AnyRef, AnyRef] = {
<span class="nc" id="L95">    try {</span>
<span class="nc" id="L96">      val size = in.readInt()</span>
<span class="nc" id="L97">      val map = new java.util.HashMap[AnyRef, AnyRef](size)</span>
<span class="nc" id="L98">      deserializeWithSize(in, map, size)</span>
<span class="nc" id="L99">      map</span>
    } catch {
<span class="nc bnc" id="L101" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        logger.error(&quot;Error reading serialized kryo user data:&quot;, e)</span>
<span class="nc" id="L103">        new java.util.HashMap[AnyRef, AnyRef]()</span>
    }
  }

  def deserialize(in: Input, map: java.util.Map[AnyRef, AnyRef]): Unit = {
<span class="nc" id="L108">    try {</span>
<span class="nc" id="L109">      deserializeWithSize(in, map, in.readInt())</span>
    } catch {
<span class="nc bnc" id="L111" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        logger.error(&quot;Error reading serialized kryo user data:&quot;, e)</span>
<span class="nc" id="L113">        new java.util.HashMap[AnyRef, AnyRef]()</span>
    }
  }

  private def deserializeWithSize(in: Input, map: java.util.Map[AnyRef, AnyRef], size: Int): Unit = {
<span class="nc" id="L118">    var i = 0</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">    while (i &lt; size) {</span>
<span class="nc" id="L120">      val keyClass = in.readString()</span>
<span class="nc" id="L121">      val key = read(in, baseClassLookups.getOrElse(keyClass, Class.forName(keyClass)))</span>
<span class="nc" id="L122">      val valueClass = in.readString()</span>
<span class="nc bnc" id="L123" title="All 6 branches missed.">      val value = if (valueClass == nullMapping) { null } else {</span>
<span class="nc" id="L124">        read(in, baseClassLookups.getOrElse(valueClass, Class.forName(valueClass)))</span>
      }
<span class="nc" id="L126">      map.put(key, value)</span>
<span class="nc" id="L127">      i += 1</span>
    }
  }

<span class="nc" id="L131">  private def write(out: Output, value: AnyRef, writeAscii: Boolean = false): Unit = value match {</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">    case v: String                 =&gt; if (writeAscii) { out.writeAscii(v) } else { out.writeString(v) }</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">    case v: java.lang.Integer      =&gt; out.writeInt(v)</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">    case v: java.lang.Long         =&gt; out.writeLong(v)</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">    case v: java.lang.Float        =&gt; out.writeFloat(v)</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    case v: java.lang.Double       =&gt; out.writeDouble(v)</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">    case v: java.lang.Boolean      =&gt; out.writeBoolean(v)</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">    case v: Date                   =&gt; out.writeLong(v.getTime)</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">    case v: Array[Byte]            =&gt; writeBytes(out, v)</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">    case v: Geometry               =&gt; KryoGeometrySerialization.serializeWkb(out, v)</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">    case v: UUID                   =&gt; out.writeLong(v.getMostSignificantBits); out.writeLong(v.getLeastSignificantBits)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    case v: java.util.List[AnyRef] =&gt; writeList(out, v)</span>
<span class="nc" id="L143">    case _ =&gt; throw new IllegalArgumentException(s&quot;Unsupported value: $value (${value.getClass})&quot;)</span>
  }

  /**
   * Read a key or value. Strings will be interned, as we expect a lot of duplication in user data,
   * i.e keys but also visibilities, which is the only user data we generally store
   *
   * @param in input
   * @param clas class of the item to read
   * @return
   */
<span class="nc" id="L154">  private def read(in: Input, clas: Class[_]): AnyRef = clas match {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">    case c if classOf[java.lang.String].isAssignableFrom(c)  =&gt; in.readString().intern()</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; Int.box(in.readInt())</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">    case c if classOf[java.lang.Long].isAssignableFrom(c)    =&gt; Long.box(in.readLong())</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">    case c if classOf[java.lang.Float].isAssignableFrom(c)   =&gt; Float.box(in.readFloat())</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">    case c if classOf[java.lang.Double].isAssignableFrom(c)  =&gt; Double.box(in.readDouble())</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">    case c if classOf[java.lang.Boolean].isAssignableFrom(c) =&gt; Boolean.box(in.readBoolean())</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">    case c if classOf[java.util.Date].isAssignableFrom(c)    =&gt; new java.util.Date(in.readLong())</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">    case c if classOf[Array[Byte]] == c                      =&gt; readBytes(in)</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">    case c if classOf[Geometry].isAssignableFrom(c)          =&gt; KryoGeometrySerialization.deserializeWkb(in, checkNull = true)</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">    case c if classOf[UUID].isAssignableFrom(c)              =&gt; new UUID(in.readLong(), in.readLong())</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">    case c if classOf[java.util.List[_]].isAssignableFrom(c) =&gt; readList(in)</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">    case c if classOf[Hints.Key].isAssignableFrom(c)         =&gt; HintKeySerialization.idToKey(in.readString())</span>
<span class="nc" id="L167">    case _ =&gt; throw new IllegalArgumentException(s&quot;Unsupported value class: $clas&quot;)</span>
  }

  private def writeBytes(out: Output, bytes: Array[Byte]): Unit = {
<span class="nc" id="L171">    out.writeInt(bytes.length)</span>
<span class="nc" id="L172">    out.writeBytes(bytes)</span>
  }

  private def readBytes(in: Input): Array[Byte] = {
<span class="nc" id="L176">    val bytes = Array.ofDim[Byte](in.readInt)</span>
<span class="nc" id="L177">    in.readBytes(bytes)</span>
<span class="nc" id="L178">    bytes</span>
  }

  private def writeList(out: Output, list: java.util.List[AnyRef]): Unit = {
<span class="nc" id="L182">    out.writeInt(list.size)</span>
<span class="nc" id="L183">    val iterator = list.iterator()</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">    while (iterator.hasNext) {</span>
<span class="nc" id="L185">      val value = iterator.next()</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L187">        out.writeString(nullMapping)</span>
      } else {
<span class="nc" id="L189">        out.writeString(baseClassMappings.getOrElse(value.getClass, value.getClass.getName))</span>
<span class="nc" id="L190">        write(out, value)</span>
      }
    }
  }

  private def readList(in: Input): java.util.List[AnyRef] = {
<span class="nc" id="L196">    val size = in.readInt()</span>
<span class="nc" id="L197">    val list = new java.util.ArrayList[AnyRef](size)</span>
<span class="nc" id="L198">    var i = 0</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">    while (i &lt; size) {</span>
<span class="nc" id="L200">      val clas = in.readString()</span>
<span class="nc bnc" id="L201" title="All 6 branches missed.">      if (clas == nullMapping) { list.add(null) } else {</span>
<span class="nc" id="L202">        list.add(read(in, baseClassLookups.getOrElse(clas, Class.forName(clas))))</span>
      }
<span class="nc" id="L204">      i += 1</span>
    }
<span class="nc" id="L206">    list</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>