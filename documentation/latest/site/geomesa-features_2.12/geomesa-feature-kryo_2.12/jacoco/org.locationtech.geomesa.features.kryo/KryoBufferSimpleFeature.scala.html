<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KryoBufferSimpleFeature.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo</a> &gt; <span class="el_source">KryoBufferSimpleFeature.scala</span></div><h1>KryoBufferSimpleFeature.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo

import com.esotericsoftware.kryo.io.{Input, Output}
import org.geotools.api.feature.`type`.{AttributeDescriptor, Name}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.feature.{GeometryAttribute, Property}
import org.geotools.api.filter.identity.FeatureId
import org.geotools.api.geometry.BoundingBox
import org.geotools.geometry.jts.ReferencedEnvelope
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.features.SerializationOption.SerializationOption
import org.locationtech.geomesa.features.geotools.ImmutableFeatureId
import org.locationtech.geomesa.features.kryo.KryoBufferSimpleFeature._
import org.locationtech.geomesa.features.kryo.impl.KryoFeatureDeserialization.KryoLongReader
import org.locationtech.geomesa.features.kryo.impl.{IntBitSet, KryoFeatureDeserialization, KryoFeatureDeserializationV2, NonMutatingInput}
import org.locationtech.geomesa.features.kryo.serialization.KryoUserDataSerialization
import org.locationtech.geomesa.utils.geotools.Transform
import org.locationtech.geomesa.utils.geotools.Transform.{PropertyTransform, RenameTransform, Transforms}
import org.locationtech.jts.geom.Geometry

<span class="nc" id="L29">class KryoBufferSimpleFeature(serializer: KryoFeatureDeserialization) extends SimpleFeature {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L33">  private val input = new NonMutatingInput()</span>

<span class="nc bnc" id="L35" title="All 2 branches missed.">  private val idParser = if (serializer.withoutId) { new IdParser() } else { new WithIdParser() }</span>
<span class="nc" id="L36">  private val delegateV3 = new KryoBufferV3(serializer, input)</span>

  @volatile
<span class="nc" id="L39">  private var seenV2 = false</span>
<span class="nc bnc" id="L40" title="All 4 branches missed.">  private lazy val delegateV2 = {</span>
<span class="nc" id="L41">    seenV2 = true</span>
<span class="nc" id="L42">    val buf = new KryoBufferV2(serializer, input)</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    if (transforms != null) {</span>
<span class="nc" id="L44">      buf.setTransforms(transformSchema, transformDefinitions)</span>
    }
<span class="nc" id="L46">    buf</span>
  }

<span class="nc bnc" id="L49" title="All 4 branches missed.">  private lazy val geomIndex = serializer.out.getGeomIndex</span>

<span class="nc" id="L51">  private var delegate: KryoBufferDelegate = _</span>

<span class="nc" id="L53">  private var transforms: String = _</span>
<span class="nc" id="L54">  private var transformSchema: SimpleFeatureType = _</span>
<span class="nc" id="L55">  private var transformDefinitions: Array[Transform] = _</span>

<span class="nc" id="L57">  private var userData: java.util.Map[AnyRef, AnyRef] = _</span>

  /**
    * Creates a new feature for later use - does not copy attribute bytes
    *
    * @return
    */
  def copy(): KryoBufferSimpleFeature = {
<span class="nc" id="L65">    val sf = new KryoBufferSimpleFeature(serializer)</span>
<span class="nc" id="L66">    sf.setIdParser(idParser.parse)</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    if (transforms != null) {</span>
<span class="nc" id="L68">      sf.setTransforms(transforms, transformSchema)</span>
    }
<span class="nc" id="L70">    sf</span>
  }

  /**
    * Sets the parser for reading feature ids out of the id buffer
    *
    * @param parse parse method
    */
<span class="nc" id="L78">  def setIdParser(parse: (Array[Byte], Int, Int) =&gt; String): Unit = idParser.parse = parse</span>

  /**
    * Sets the transform to be applied to this feature when calling `transform`
    *
    * @param transforms transform definition, per geotools format
    * @param transformSchema schema that results from applying the transform
    */
  def setTransforms(transforms: String, transformSchema: SimpleFeatureType): Unit = {
<span class="nc" id="L87">    this.transforms = transforms</span>
<span class="nc" id="L88">    this.transformSchema = transformSchema</span>
<span class="nc" id="L89">    this.transformDefinitions = Transforms(serializer.out, transforms).toArray</span>
<span class="nc" id="L90">    delegateV3.setTransforms(transformSchema, transformDefinitions)</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">    if (seenV2) {</span>
<span class="nc" id="L92">      delegateV2.setTransforms(transformSchema, transformDefinitions)</span>
    }
  }

  /**
    * Gets any transforms applied to this feature
    *
    * @return
    */
  def getTransform: Option[(String, SimpleFeatureType)] =
<span class="nc" id="L102">    for { t &lt;- Option(transforms); s &lt;- Option(transformSchema) } yield { (t, s) }</span>

  /**
    * Set the serialized bytes to use for reading attributes
    *
    * @param bytes serialized byte array
    */
<span class="nc" id="L109">  def setBuffer(bytes: Array[Byte]): Unit = setBuffer(bytes, 0, bytes.length)</span>

  /**
    * Set the serialized bytes to use for reading attributes
    *
    * @param bytes serialized byte array
    * @param offset offset into the byte array of valid bytes
    * @param length number of valid bytes to read from the byte array
    */
  def setBuffer(bytes: Array[Byte], offset: Int, length: Int): Unit = {
<span class="nc" id="L119">    input.setBuffer(bytes, offset, length)</span>
<span class="nc" id="L120">    delegate = input.readByte() match {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">      case KryoFeatureSerializer.Version3 =&gt; delegateV3</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">      case KryoFeatureSerializer.Version2 =&gt; delegateV2</span>
<span class="nc" id="L123">      case b =&gt; throw new IllegalArgumentException(s&quot;Can't process features serialized with version: $b&quot;)</span>
    }
<span class="nc" id="L125">    delegate.reset()</span>
<span class="nc" id="L126">    userData = null</span>
  }

  /**
    * Sets the serialized bytes containing the feature ID (i.e. the row key)
    *
    * @param bytes bytes
    */
<span class="nc" id="L134">  def setIdBuffer(bytes: Array[Byte]): Unit = setIdBuffer(bytes, 0, bytes.length)</span>

  /**
    * Sets the serialized bytes containing the feature ID (i.e. the row key)
    *
    * @param bytes bytes
    * @param offset offset into the byte array of valid bytes
    * @param length number of valid bytes to read from the byte array
    */
  def setIdBuffer(bytes: Array[Byte], offset: Int, length: Int): Unit = {
<span class="nc" id="L144">    idParser.buffer = bytes</span>
<span class="nc" id="L145">    idParser.offset = offset</span>
<span class="nc" id="L146">    idParser.length = length</span>
  }

  /**
    * Transform the feature into a serialized byte array
    *
    * @return
    */
<span class="nc" id="L154">  def transform(): Array[Byte] = delegate.transform(this)</span>

  /**
    * Get a date attribute as a raw long
    *
    * @param index attribute index
    * @return
    */
<span class="nc" id="L162">  def getDateAsLong(index: Int): Long = delegate.getDateAsLong(index)</span>

  /**
    * Get the underlying kryo input, positioned to read the attribute at the given index
    *
    * @param index attribute index
    * @return input, if the attribute is not null
    */
<span class="nc" id="L170">  def getInput(index: Int): Option[Input] = delegate.getInput(index)</span>

<span class="nc" id="L172">  override def getAttribute(index: Int): AnyRef = delegate.getAttribute(index)</span>

<span class="nc" id="L174">  override def getType: SimpleFeatureType = serializer.out</span>
<span class="nc" id="L175">  override def getFeatureType: SimpleFeatureType = serializer.out</span>
<span class="nc" id="L176">  override def getName: Name = serializer.out.getName</span>

<span class="nc" id="L178">  override def getID: String = idParser.id()</span>
<span class="nc" id="L179">  override def getIdentifier: FeatureId = new ImmutableFeatureId(idParser.id())</span>

<span class="nc" id="L181">  override def getAttribute(name: Name): AnyRef = getAttribute(name.getLocalPart)</span>
  override def getAttribute(name: String): Object = {
<span class="nc" id="L183">    val index = serializer.out.indexOf(name)</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">    if (index == -1) { null } else { getAttribute(index) }</span>
  }

<span class="nc bnc" id="L187" title="All 2 branches missed.">  override def getDefaultGeometry: AnyRef = if (geomIndex == -1) { null } else { getAttribute(geomIndex) }</span>
<span class="nc" id="L188">  override def getAttributeCount: Int = serializer.out.getAttributeCount</span>

<span class="nc" id="L190">  override def getBounds: BoundingBox = getDefaultGeometry match {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">    case g: Geometry =&gt; new ReferencedEnvelope(g.getEnvelopeInternal, serializer.out.getCoordinateReferenceSystem)</span>
<span class="nc" id="L192">    case _           =&gt; new ReferencedEnvelope(serializer.out.getCoordinateReferenceSystem)</span>
  }

  override def getAttributes: java.util.List[AnyRef] = {
<span class="nc" id="L196">    val attributes = new java.util.ArrayList[AnyRef](serializer.out.getAttributeCount)</span>
<span class="nc" id="L197">    var i = 0</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">    while (i &lt; serializer.out.getAttributeCount) {</span>
<span class="nc" id="L199">      attributes.add(getAttribute(i))</span>
<span class="nc" id="L200">      i += 1</span>
    }
<span class="nc" id="L202">    attributes</span>
  }

  override def getUserData: java.util.Map[AnyRef, AnyRef] = {
<span class="nc bnc" id="L206" title="All 2 branches missed.">    if (userData == null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">      userData = if (serializer.withoutUserData) { new java.util.HashMap(1) } else { delegate.getUserData }</span>
    }
<span class="nc" id="L209">    userData</span>
  }

<span class="nc" id="L212">  override def getDefaultGeometryProperty: GeometryAttribute = throw new UnsupportedOperationException()</span>
<span class="nc" id="L213">  override def getProperties: java.util.Collection[Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L214">  override def getProperties(name: Name): java.util.Collection[Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L215">  override def getProperties(name: String): java.util.Collection[Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L216">  override def getProperty(name: Name): Property = throw new UnsupportedOperationException()</span>
<span class="nc" id="L217">  override def getProperty(name: String): Property = throw new UnsupportedOperationException()</span>
<span class="nc" id="L218">  override def getValue: java.util.Collection[_ &lt;: Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L219">  override def getDescriptor: AttributeDescriptor = throw new UnsupportedOperationException()</span>

<span class="nc" id="L221">  override def setAttribute(name: Name, value: Object): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L222">  override def setAttribute(name: String, value: Object): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L223">  override def setAttribute(index: Int, value: Object): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L224">  override def setAttributes(vals: java.util.List[Object]): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L225">  override def setAttributes(vals: Array[Object]): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L226">  override def setDefaultGeometry(geo: Object): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L227">  override def setDefaultGeometryProperty(geoAttr: GeometryAttribute): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L228">  override def setValue(newValue: Object): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L229">  override def setValue(values: java.util.Collection[Property]): Unit = throw new UnsupportedOperationException()</span>

<span class="nc" id="L231">  override def isNillable: Boolean = true</span>
<span class="nc" id="L232">  override def validate(): Unit = throw new UnsupportedOperationException()</span>

<span class="nc" id="L234">  override def toString: String = s&quot;KryoBufferSimpleFeature:$getID&quot;</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">  private class WithIdParser extends IdParser {</span>
<span class="nc" id="L237">    override def id(): String = delegate.id()</span>
  }
}

<span class="nc" id="L241">object KryoBufferSimpleFeature {</span>

<span class="nc" id="L243">  private class IdParser {</span>
<span class="nc" id="L244">    var parse: (Array[Byte], Int, Int) =&gt; String = (_, _, _) =&gt; null</span>
<span class="nc" id="L245">    var buffer: Array[Byte] = _</span>
<span class="nc" id="L246">    var offset: Int = 0</span>
<span class="nc" id="L247">    var length: Int = 0</span>

<span class="nc" id="L249">    def id(): String = parse(buffer, offset, length)</span>
  }

  /**
    * Common interface for handling serialization versions
    */
<span class="nc" id="L255">  private sealed trait KryoBufferDelegate extends Transformer {</span>

    /**
      * Invoked after the underlying kryo buffer has been updated with a new serialized feature
      */
    def reset(): Unit

    /**
      * Sets the transform to be applied to the feature
      *
      * @param schema schema that results from applying the transform
      * @param transforms transform definitions
      */
    def setTransforms(schema: SimpleFeatureType, transforms: Array[Transform]): Unit

    /**
      * Deserialize the feature ID (assuming options.withId)
      *
      * @return
      */
    def id(): String

    /**
      * Deserialize an attribute
      *
      * @param index attribute number
      * @return
      */
    def getAttribute(index: Int): AnyRef

    /**
      * Deserialize user data
      *
      * @return
      */
    def getUserData: java.util.Map[AnyRef, AnyRef]

    /**
      * Optimized method to get a date attribute as millis without creating a new Date object
      *
      * @param index attribute number
      * @return
      */
    def getDateAsLong(index: Int): Long

    /**
      * Gets the input, positioned to read the given attribute
      *
      * @param index attribute index
      * @return
      */
    def getInput(index: Int): Option[Input]
  }

  /**
    * Abstraction over transformer impls
    */
  private sealed trait Transformer {

    /**
      * Transform a feature, based on previously set transform schema
      *
      * @param original original feature being transformed
      * @return
      */
    def transform(original: SimpleFeature): Array[Byte]
  }

  /**
    * Serialization version 3 delegate
    *
    * @param serializer serializer
    * @param input input
    */
<span class="nc" id="L329">  private class KryoBufferV3(serializer: KryoFeatureDeserialization, input: Input) extends KryoBufferDelegate {</span>

<span class="nc" id="L331">    private var metadata: Metadata = _</span>
<span class="nc" id="L332">    private var transformer: Transformer = _</span>

<span class="nc" id="L334">    override def reset(): Unit = metadata = Metadata(input) // reads count, size, nulls, etc</span>

    override def setTransforms(schema: SimpleFeatureType, transforms: Array[Transform]): Unit = {
<span class="nc" id="L337">      val indices = transforms.map {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        case t: PropertyTransform =&gt; t.i</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        case t: RenameTransform =&gt; t.i</span>
<span class="nc" id="L340">        case _ =&gt; -1</span>
      }
<span class="nc bnc" id="L342" title="All 2 branches missed.">      if (indices.contains(-1)) {</span>
<span class="nc" id="L343">        transformer = new ReserializeTransformer(schema, transforms, serializer.options)</span>
      } else {
<span class="nc" id="L345">        transformer = new BinaryTransformer(indices)</span>
      }
    }

    override def id(): String = {
<span class="nc" id="L350">      metadata.setIdPosition()</span>
<span class="nc" id="L351">      input.readString()</span>
    }

    override def getAttribute(index: Int): AnyRef = {
<span class="nc bnc" id="L355" title="All 4 branches missed.">      if (index &gt;= metadata.count || metadata.nulls.contains(index)) { null } else {</span>
<span class="nc" id="L356">        metadata.setPosition(index)</span>
<span class="nc" id="L357">        serializer.readers(index).apply(input)</span>
      }
    }

    override def getUserData: java.util.Map[AnyRef, AnyRef] = {
<span class="nc" id="L362">      metadata.setUserDataPosition()</span>
<span class="nc" id="L363">      KryoUserDataSerialization.deserialize(input)</span>
    }

    override def getDateAsLong(index: Int): Long = {
<span class="nc bnc" id="L367" title="All 4 branches missed.">      if (index &gt;= metadata.count || metadata.nulls.contains(index)) { 0L } else {</span>
<span class="nc" id="L368">        metadata.setPosition(index)</span>
<span class="nc" id="L369">        KryoLongReader.apply(input)</span>
      }
    }

    override def getInput(index: Int): Option[Input] = {
<span class="nc bnc" id="L374" title="All 4 branches missed.">      if (index &gt;= metadata.count || metadata.nulls.contains(index)) { None } else {</span>
<span class="nc" id="L375">        metadata.setPosition(index)</span>
<span class="nc" id="L376">        Some(input)</span>
      }
    }

<span class="nc" id="L380">    override def transform(original: SimpleFeature): Array[Byte] = transformer.transform(original)</span>

    // if we are just returning a subset of attributes, we can copy the bytes directly
<span class="nc bnc" id="L383" title="All 2 branches missed.">    private class BinaryTransformer(indices: Array[Int]) extends Transformer {</span>

<span class="nc" id="L385">      private val positionsAndLengths = Array.ofDim[(Int, Int)](indices.length)</span>

      override def transform(original: SimpleFeature): Array[Byte] = {
        // +1 for version, +2 for count, +1 for size
<span class="nc" id="L389">        var length = (metadata.size * (indices.length + 1)) + (IntBitSet.size(indices.length) * 4) + 4</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        val id = if (serializer.withoutId) { null } else {</span>
<span class="nc" id="L391">          val pos = metadata.setIdPosition() + metadata.offset</span>
<span class="nc" id="L392">          val id = input.readString()</span>
<span class="nc" id="L393">          length += input.position() - pos</span>
<span class="nc" id="L394">          id</span>
        }

<span class="nc" id="L397">        val nulls = IntBitSet(indices.length)</span>

        // track the write position for copying attributes in the transformed array
<span class="nc" id="L400">        var resultCursor = length</span>

<span class="nc" id="L402">        var i = 0</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        while (i &lt; indices.length) {</span>
<span class="nc" id="L404">          val index = indices(i) // the index of the attribute in the original feature</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">          if (index &gt;= metadata.count || metadata.nulls.contains(index)) { nulls.add(i) } else {</span>
            // read the offset and the subsequent offset to get the length
<span class="nc" id="L407">            val pos = metadata.setPosition(index)</span>
<span class="nc" id="L408">            val len = metadata.setPosition(index + 1) - pos</span>
<span class="nc" id="L409">            length += len</span>
<span class="nc" id="L410">            positionsAndLengths(i) = (metadata.offset + pos, len)</span>
          }
<span class="nc" id="L412">          i += 1</span>
        }

        // note: the input buffer is the raw buffer. we need to ensure that we use the
        // offset into the raw buffer rather than the raw buffer directly
<span class="nc" id="L417">        val buf = input.getBuffer</span>

<span class="nc" id="L419">        val result = Array.ofDim[Byte](length)</span>
<span class="nc" id="L420">        val output = new Output(result, length)</span>
<span class="nc" id="L421">        output.writeByte(KryoFeatureSerializer.Version3)</span>
<span class="nc" id="L422">        output.writeShort(indices.length) // track the number of attributes</span>
<span class="nc" id="L423">        output.write(metadata.size)</span>
<span class="nc" id="L424">        i = 0</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        while (i &lt; positionsAndLengths.length) {</span>
          // note: offset is always 4 here since we're using the full result array
<span class="nc bnc" id="L427" title="All 2 branches missed.">          if (metadata.size == 2) {</span>
<span class="nc" id="L428">            output.writeShort(resultCursor - 4)</span>
          } else {
<span class="nc" id="L430">            output.writeInt(resultCursor - 4)</span>
          }
<span class="nc bnc" id="L432" title="All 2 branches missed.">          if (!nulls.contains(i)) {</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            val (pos, len) = positionsAndLengths(i)</span>
<span class="nc" id="L434">            System.arraycopy(buf, pos, result, resultCursor, len)</span>
<span class="nc" id="L435">            resultCursor += len</span>
          }
<span class="nc" id="L437">          i += 1</span>
        }
        // user data offset
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (metadata.size == 2) {</span>
<span class="nc" id="L441">          output.writeShort(resultCursor)</span>
        } else {
<span class="nc" id="L443">          output.writeInt(resultCursor)</span>
        }

        // TODO user data?

        // write out nulls
<span class="nc" id="L449">        nulls.serialize(output)</span>

        // we're already positioned to write out the feature id
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (id != null) {</span>
<span class="nc" id="L453">          output.writeString(id)</span>
        }

<span class="nc" id="L456">        result</span>
      }
    }
  }

  /**
    * Serialiation version 2 delegate
    *
    * @param serializer serializer
    * @param input input
    */
<span class="nc" id="L467">  private class KryoBufferV2(serializer: KryoFeatureDeserialization, input: Input) extends KryoBufferDelegate {</span>

<span class="nc" id="L469">    private val offsets = Array.ofDim[Int](serializer.out.getAttributeCount)</span>
<span class="nc" id="L470">    private var offset: Int = -1</span>
<span class="nc" id="L471">    private var startOfOffsets: Int = -1</span>
<span class="nc" id="L472">    private var missingAttributes: Boolean = false</span>
<span class="nc" id="L473">    private var userDataOffset: Int = -1</span>

<span class="nc" id="L475">    private var reserializeTransform: Transformer = _</span>
<span class="nc" id="L476">    private var binaryTransform: Transformer = _</span>

    override def reset(): Unit = {
      // reset our offsets
<span class="nc" id="L480">      offset = input.position() - 1 // we've already read the version byte</span>
<span class="nc" id="L481">      startOfOffsets = offset + input.readInt()</span>
<span class="nc" id="L482">      input.setPosition(startOfOffsets) // set to offsets start</span>
<span class="nc" id="L483">      var i = 0</span>
<span class="nc bnc" id="L484" title="All 4 branches missed.">      while (i &lt; offsets.length &amp;&amp; input.position &lt; input.limit) {</span>
<span class="nc" id="L485">        offsets(i) = offset + input.readInt(true)</span>
<span class="nc" id="L486">        i += 1</span>
      }
<span class="nc bnc" id="L488" title="All 2 branches missed.">      if (i &lt; offsets.length) {</span>
        // attributes have been added to the sft since this feature was serialized
<span class="nc" id="L490">        missingAttributes = true</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        while ({{ offsets(i) = -1; i += 1 }; i &lt; offsets.length })()</span>
      } else {
<span class="nc" id="L493">        missingAttributes = false</span>
      }
<span class="nc" id="L495">      userDataOffset = input.position()</span>
    }

    override def setTransforms(schema: SimpleFeatureType, transforms: Array[Transform]): Unit = {
<span class="nc" id="L499">      val indices = transforms.map {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        case t: PropertyTransform =&gt; t.i</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        case t: RenameTransform =&gt; t.i</span>
<span class="nc" id="L502">        case _ =&gt; -1</span>
      }

      // transforms by evaluating the transform expressions and then serializing the resulting feature
      // we use this for transform expressions and for data that was written using an old schema
<span class="nc" id="L507">      reserializeTransform = new ReserializeTransformer(schema, transforms, serializer.options)</span>
      // if we are just returning a subset of attributes, we can copy the bytes directly
      // and avoid creating new objects, reserializing, etc
<span class="nc" id="L510">      binaryTransform =</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">          if (indices.contains(-1)) { reserializeTransform } else { new BinaryTransformerV2(input, indices, offsets) }</span>
    }

    override def id(): String = {
<span class="nc" id="L515">      input.setPosition(5)</span>
<span class="nc" id="L516">      input.readString()</span>
    }

    override def getAttribute(index: Int): AnyRef = {
<span class="nc" id="L520">      val offset = offsets(index)</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">      if (offset == -1) { null } else {</span>
<span class="nc" id="L522">        input.setPosition(offset)</span>
<span class="nc" id="L523">        serializer.readersV2(index)(input)</span>
      }
    }

    override def getUserData: java.util.Map[AnyRef, AnyRef] = {
<span class="nc" id="L528">      input.setPosition(userDataOffset)</span>
<span class="nc" id="L529">      KryoUserDataSerialization.deserialize(input)</span>
    }

    override def getDateAsLong(index: Int): Long = {
<span class="nc" id="L533">      val offset = offsets(index)</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">      if (offset == -1) { 0L } else {</span>
<span class="nc" id="L535">        input.setPosition(offset)</span>
<span class="nc" id="L536">        KryoFeatureDeserializationV2.LongReader.apply(input)</span>
      }
    }

    override def getInput(index: Int): Option[Input] = {
<span class="nc" id="L541">      val offset = offsets(index)</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">      if (offset == -1) { None } else {</span>
<span class="nc" id="L543">        input.setPosition(offset)</span>
<span class="nc" id="L544">        Some(input)</span>
      }
    }

    override def transform(original: SimpleFeature): Array[Byte] = {
      // if attributes have been added to the sft, we have to reserialize to get the null serialized values
<span class="nc bnc" id="L550" title="All 2 branches missed.">      val transformer = if (missingAttributes) { reserializeTransform } else { binaryTransform }</span>
<span class="nc" id="L551">      transformer.transform(original)</span>
    }

    /**
      * Serialization version 2 binary transformer. Copies serialized attribute bytes directly without
      * deserializing them
      *
      * @param input input
      * @param indices transform indices
      * @param offsets attribute offsets
      */
<span class="nc bnc" id="L562" title="All 2 branches missed.">    private class BinaryTransformerV2(input: Input, indices: Array[Int], offsets: Array[Int]) extends Transformer {</span>

<span class="nc" id="L564">      private val mutableOffsetsAndLength = Array.ofDim[(Int,Int)](indices.length)</span>

      override def transform(original: SimpleFeature): Array[Byte] = {
        // NOTE: the input buffer is the raw buffer. we need to ensure that we use the
        // offset into the raw buffer rather than the raw buffer directly
<span class="nc" id="L569">        val buf = input.getBuffer</span>
<span class="nc" id="L570">        var length = offsets(0) - offset // space for version, offset block and ID</span>
<span class="nc" id="L571">        var idx = 0</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        while (idx &lt; mutableOffsetsAndLength.length) {</span>
<span class="nc" id="L573">          val i = indices(idx)</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">          val el = (if (i &lt; offsets.length - 1) { offsets(i + 1) } else { startOfOffsets }) - offsets(i)</span>
<span class="nc" id="L575">          length += el</span>
<span class="nc" id="L576">          mutableOffsetsAndLength(idx) = (offsets(i), el)</span>
<span class="nc" id="L577">          idx += 1</span>
        }

<span class="nc" id="L580">        val dst = Array.ofDim[Byte](length)</span>
        // copy the version, offset block and id
<span class="nc" id="L582">        var dstPos = offsets(0) - offset</span>
<span class="nc" id="L583">        System.arraycopy(buf, offset, dst, 0, dstPos)</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        mutableOffsetsAndLength.foreach { case (o, l) =&gt;</span>
<span class="nc" id="L585">          System.arraycopy(buf, o, dst, dstPos, l)</span>
<span class="nc" id="L586">          dstPos += l</span>
        }
        // note that the offset block is incorrect - we couldn't use this in another lazy feature
        // but the normal serializer doesn't care
<span class="nc" id="L590">        dst</span>
      }
    }
  }

  /**
    * For non-attribute expressions, we have evaluate them, then serialize the resulting feature
    *
    * @param schema transform schema
    * @param transforms transform definitions
    * @param options serialization options
    */
<span class="nc" id="L602">  private class ReserializeTransformer(</span>
      schema: SimpleFeatureType,
<span class="nc" id="L604">      transforms: Array[Transform],</span>
      options: Set[SerializationOption]
<span class="nc" id="L606">    ) extends Transformer {</span>

<span class="nc" id="L608">    private val serializer = KryoFeatureSerializer(schema, options)</span>
<span class="nc" id="L609">    private val sf = new ScalaSimpleFeature(schema, &quot;&quot;)</span>

    override def transform(original: SimpleFeature): Array[Byte] = {
<span class="nc" id="L612">      sf.setId(original.getID)</span>
<span class="nc" id="L613">      var i = 0</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">      while (i &lt; transforms.length) {</span>
<span class="nc" id="L615">        sf.setAttribute(i, transforms(i).evaluate(original))</span>
<span class="nc" id="L616">        i += 1</span>
      }
<span class="nc" id="L618">      serializer.serialize(sf)</span>
    }
  }
<span class="nc" id="L621">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>