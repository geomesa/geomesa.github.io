<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LazyDeserialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Features Kryo</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.features.kryo.impl</a> &gt; <span class="el_source">LazyDeserialization.scala</span></div><h1>LazyDeserialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.features.kryo
package impl

import com.esotericsoftware.kryo.io.Input
import org.geotools.api.feature.simple.SimpleFeature
import org.locationtech.geomesa.features.ScalaSimpleFeature.{LazyAttributeReader, LazyImmutableSimpleFeature, LazyMutableSimpleFeature, LazyUserDataReader}
import org.locationtech.geomesa.features.kryo.impl.KryoFeatureDeserialization.KryoAttributeReader
import org.locationtech.geomesa.features.kryo.impl.LazyDeserialization._
import org.locationtech.geomesa.features.kryo.serialization.KryoUserDataSerialization
import org.locationtech.geomesa.utils.io.Sizable

import java.io.InputStream

<span class="nc" id="L22">object LazyDeserialization {</span>

  /**
    * Creates mutable features, lazily evaluated
    */
<span class="nc" id="L27">  trait MutableLazyDeserialization extends LazyDeserialization {</span>
    override protected def createFeature(
        id: String,
        reader: LazyAttributeReader,
        userData: LazyUserDataReader): SimpleFeature = {
<span class="nc" id="L32">      new LazyMutableSimpleFeature(out, id, reader, userData)</span>
    }
  }

  /**
    * Creates immutable features, lazily evaluated
    */
<span class="nc" id="L39">  trait ImmutableLazyDeserialization extends LazyDeserialization {</span>
    override protected def createFeature(
        id: String,
        reader: LazyAttributeReader,
        userData: LazyUserDataReader): SimpleFeature = {
<span class="nc" id="L44">      new LazyImmutableSimpleFeature(out, id, reader, userData)</span>
    }
  }

  /**
    * Attribute reader for v3 serialization
    *
    * @param readers readers
    * @param nulls null set
    * @param count number of attributes
    * @param bytes raw serialized bytes
    * @param offset offset into the byte array
    * @param length number of valid bytes in the byte array
    */
<span class="nc" id="L58">  class LazyShortReaderV3(</span>
<span class="nc" id="L59">      readers: Array[KryoAttributeReader],</span>
<span class="nc" id="L60">      nulls: IntBitSet,</span>
<span class="nc" id="L61">      count: Int,</span>
<span class="nc" id="L62">      bytes: Array[Byte],</span>
<span class="nc" id="L63">      offset: Int,</span>
<span class="nc" id="L64">      length: Int</span>
<span class="nc" id="L65">    ) extends LazyAttributeReader {</span>

    override def read(i: Int): AnyRef = {
<span class="nc bnc" id="L68" title="All 4 branches missed.">      if (i &gt;= count || nulls.contains(i)) { null } else {</span>
        // read the offset and go to the position for reading
        // to make it thread safe, we create a new kryo input each time,
        // so that position and offset are not affected by other reads
<span class="nc" id="L72">        val input = new NonMutatingInput()</span>
<span class="nc" id="L73">        input.setBuffer(bytes, offset + (2 * i), length - (2 * i))</span>
<span class="nc" id="L74">        input.setPosition(offset + input.readShortUnsigned())</span>
<span class="nc" id="L75">        readers(i).apply(input)</span>
      }
    }

    override def calculateSizeOf(): Long = {
      // doesn't count shared readers
<span class="nc" id="L81">      Sizable.sizeOf(this) + Sizable.deepSizeOf(bytes, offset, length, count, nulls)</span>
    }
  }

  /**
    * Attribute reader for v3 serialization
    *
    * @param readers readers
    * @param nulls null set
    * @param count number of attributes
    * @param bytes raw serialized bytes
    * @param offset offset into the byte array
    * @param length number of valid bytes in the byte array
    */
<span class="nc" id="L95">  class LazyIntReaderV3(</span>
<span class="nc" id="L96">      readers: Array[KryoAttributeReader],</span>
<span class="nc" id="L97">      nulls: IntBitSet,</span>
<span class="nc" id="L98">      count: Int,</span>
<span class="nc" id="L99">      bytes: Array[Byte],</span>
<span class="nc" id="L100">      offset: Int,</span>
<span class="nc" id="L101">      length: Int</span>
<span class="nc" id="L102">  ) extends LazyAttributeReader {</span>

    override def read(i: Int): AnyRef = {
<span class="nc bnc" id="L105" title="All 4 branches missed.">      if (i &gt;= count || nulls.contains(i)) { null } else {</span>
        // read the offset and go to the position for reading
        // to make it thread safe, we create a new kryo input each time,
        // so that position and offset are not affected by other reads
<span class="nc" id="L109">        val input = new NonMutatingInput()</span>
<span class="nc" id="L110">        input.setBuffer(bytes, offset + (4 * i), length - (4 * i))</span>
<span class="nc" id="L111">        input.setPosition(offset + input.readInt())</span>
<span class="nc" id="L112">        readers(i).apply(input)</span>
      }
    }

    override def calculateSizeOf(): Long = {
      // doesn't count shared readers
<span class="nc" id="L118">      Sizable.sizeOf(this) + Sizable.deepSizeOf(bytes, offset, length, count, nulls)</span>
    }
  }

  /**
    * User data reader for v3 serialization
    *
    * @param count number of attributes
    * @param bytes raw serialized bytes
    * @param offset offset into the byte array
    * @param length number of valid bytes in the byte array
    */
<span class="nc" id="L130">  class LazyShortUserDataReaderV3(count: Int, bytes: Array[Byte], offset: Int, length: Int)</span>
<span class="nc" id="L131">      extends LazyUserDataReader {</span>

    override def read(): java.util.Map[AnyRef, AnyRef] = {
      // read the offset and go to the position for reading
      // we create a new kryo input each time, so that position and offset are not affected by other reads
      // this should be thread-safe, as long as the user data is not being read in multiple threads
      // (since kryo can mutate the bytes during read)
<span class="nc" id="L138">      val input = new NonMutatingInput()</span>
<span class="nc" id="L139">      input.setBuffer(bytes, offset + (2 * count), length - (2 * count))</span>
      // read the offset and go to the position for reading
<span class="nc" id="L141">      input.setPosition(offset + input.readShortUnsigned())</span>
<span class="nc" id="L142">      KryoUserDataSerialization.deserialize(input)</span>
    }

<span class="nc" id="L145">    override def calculateSizeOf(): Long = Sizable.sizeOf(this) + Sizable.deepSizeOf(bytes, offset, length, count)</span>
  }

  /**
    * User data reader for v3 serialization
    *
    * @param count number of attributes
    * @param bytes raw serialized bytes
    * @param offset offset into the byte array
    * @param length number of valid bytes in the byte array
    */
<span class="nc" id="L156">  class LazyIntUserDataReaderV3(count: Int, bytes: Array[Byte], offset: Int, length: Int)</span>
<span class="nc" id="L157">      extends LazyUserDataReader {</span>

    override def read(): java.util.Map[AnyRef, AnyRef] = {
      // read the offset and go to the position for reading
      // we create a new kryo input each time, so that position and offset are not affected by other reads
      // this should be thread-safe, as long as the user data is not being read in multiple threads
      // (since kryo can mutate the bytes during read)
<span class="nc" id="L164">      val input = new NonMutatingInput()</span>
<span class="nc" id="L165">      input.setBuffer(bytes, offset + (4 * count), length - (4 * count))</span>
      // read the offset and go to the position for reading
<span class="nc" id="L167">      input.setPosition(offset + input.readInt())</span>
<span class="nc" id="L168">      KryoUserDataSerialization.deserialize(input)</span>
    }

<span class="nc" id="L171">    override def calculateSizeOf(): Long = Sizable.sizeOf(this) + Sizable.deepSizeOf(bytes, offset, length, count)</span>
  }

  /**
    * Attribute reader for v2 serialization
    *
    * @param readers readers
    * @param offsets offsets for each attribute
    * @param bytes raw serialized bytes
    * @param length number of valid bytes in the byte array
    */
<span class="nc" id="L182">  class LazyReaderV2(readers: Array[Input =&gt; AnyRef], offsets: Array[Int], bytes: Array[Byte], length: Int)</span>
<span class="nc" id="L183">      extends LazyAttributeReader {</span>

    override def read(i: Int): AnyRef = {
<span class="nc" id="L186">      val offset = offsets(i)</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">      if (offset == -1) { null } else {</span>
        // we create a new kryo input each time, so that position and offset are not affected by other reads
        // this should be thread-safe, as long as the same attribute is not being read in multiple threads
        // (since kryo can mutate the bytes during read)
<span class="nc" id="L191">        val input = new NonMutatingInput()</span>
<span class="nc" id="L192">        input.setBuffer(bytes, offset, length - offset)</span>
<span class="nc" id="L193">        readers(i).apply(input)</span>
      }
    }

    override def calculateSizeOf(): Long = {
      // doesn't count shared readers
<span class="nc" id="L199">      Sizable.sizeOf(this) + Sizable.deepSizeOf(bytes, offsets, length)</span>
    }
  }

  /**
    * User data reader for v2 serialization
    *
    * @param bytes raw serialized bytes
    * @param userDataOffset offset to the serialized user data
    * @param length number of valid bytes in the byte array
    */
<span class="nc" id="L210">  class LazyUserDataReaderV2(bytes: Array[Byte], userDataOffset: Int, length: Int) extends LazyUserDataReader {</span>

    override def read(): java.util.Map[AnyRef, AnyRef] = {
      // we create a new kryo input each time, so that position and offset are not affected by other reads
      // this should be thread-safe, as long as the user data is not being read in multiple threads
      // (since kryo can mutate the bytes during read)
<span class="nc" id="L216">      val input = new NonMutatingInput()</span>
<span class="nc" id="L217">      input.setBuffer(bytes, userDataOffset, length - userDataOffset)</span>
<span class="nc" id="L218">      KryoUserDataSerialization.deserialize(input)</span>
    }

<span class="nc" id="L221">    override def calculateSizeOf(): Long = Sizable.sizeOf(this) + Sizable.deepSizeOf(bytes, userDataOffset, length)</span>
  }

  /**
    * Reader for serialization without user data
    */
<span class="nc" id="L227">  case object WithoutUserDataReader extends LazyUserDataReader {</span>
<span class="nc" id="L228">    override def read(): java.util.Map[AnyRef, AnyRef] = new java.util.HashMap[AnyRef, AnyRef](1)</span>
<span class="nc" id="L229">    override def calculateSizeOf(): Long = 0L // technically not true but this is a shared reference</span>
  }
}

/**
  * Wraps the input but defers deserialization until an attribute is required
  */
<span class="nc" id="L236">trait LazyDeserialization extends KryoFeatureDeserialization {</span>

  override def deserialize(bytes: Array[Byte]): SimpleFeature =
<span class="nc" id="L239">    deserialize(&quot;&quot;, bytes, 0, bytes.length)</span>

  override def deserialize(id: String, bytes: Array[Byte]): SimpleFeature =
<span class="nc" id="L242">    deserialize(id, bytes, 0, bytes.length)</span>

  override def deserialize(bytes: Array[Byte], offset: Int, length: Int): SimpleFeature =
<span class="nc" id="L245">    deserialize(&quot;&quot;, bytes, offset, length)</span>

  override def deserialize(id: String, bytes: Array[Byte], offset: Int, length: Int): SimpleFeature = {
<span class="nc" id="L248">    bytes(offset) match {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">      case KryoFeatureSerializer.Version3 =&gt; readFeatureV3(id, bytes, offset, length)</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">      case KryoFeatureSerializer.Version2 =&gt; readFeatureV2(id, bytes, offset, length)</span>
<span class="nc" id="L251">      case b =&gt; throw new IllegalArgumentException(s&quot;Can't process features serialized with version: $b&quot;)</span>
    }
  }

  // TODO read into a byte array so we can lazily evaluate it
  // user data is tricky here as we don't know the length...
<span class="nc" id="L257">  override def deserialize(in: InputStream): SimpleFeature = throw new UnsupportedOperationException()</span>
<span class="nc" id="L258">  override def deserialize(id: String, in: InputStream): SimpleFeature = throw new UnsupportedOperationException()</span>

  protected def createFeature(id: String, reader: LazyAttributeReader, userData: LazyUserDataReader): SimpleFeature

  private def readFeatureV3(id: String, bytes: Array[Byte], offset: Int, length: Int): SimpleFeature = {
    // skip the version byte, which we've already read
<span class="nc" id="L264">    val input = new NonMutatingInput()</span>
<span class="nc" id="L265">    input.setBuffer(bytes, offset + 1, length - 1)</span>
<span class="nc" id="L266">    val metadata = Metadata(input) // read count, size, nulls, etc</span>

    // we should now be positioned to read the feature id
<span class="nc bnc" id="L269" title="All 2 branches missed.">    val finalId = if (withoutId) { id } else { input.readString() }</span>

<span class="nc" id="L271">    val remaining = input.limit - metadata.offset</span>

<span class="nc" id="L273">    var reader: LazyAttributeReader = null</span>
<span class="nc" id="L274">    var userData: LazyUserDataReader = null</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">    if (metadata.size == 2) {</span>
<span class="nc" id="L277">      reader = new LazyShortReaderV3(readers, metadata.nulls, metadata.count, bytes, metadata.offset, remaining)</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">      userData = if (withoutUserData) { WithoutUserDataReader } else {</span>
<span class="nc" id="L279">        new LazyShortUserDataReaderV3(metadata.count, bytes, metadata.offset, remaining)</span>
      }
    } else {
<span class="nc" id="L282">      reader = new LazyIntReaderV3(readers, metadata.nulls, metadata.count, bytes, metadata.offset, remaining)</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">      userData = if (withoutUserData) { WithoutUserDataReader } else {</span>
<span class="nc" id="L284">        new LazyIntUserDataReaderV3(metadata.count, bytes, metadata.offset, remaining)</span>
      }
    }

<span class="nc" id="L288">    createFeature(finalId, reader, userData)</span>
  }

  private def readFeatureV2(id: String, bytes: Array[Byte], offset: Int, length: Int): SimpleFeature = {
<span class="nc" id="L292">    val input = new NonMutatingInput()</span>
<span class="nc" id="L293">    input.setBuffer(bytes, offset + 1, length - 1) // skip the version byte</span>
    // read the start of the offsets, then the feature id
<span class="nc" id="L295">    val offsets = Array.ofDim[Int](readersV2.length)</span>
<span class="nc" id="L296">    val offsetStarts = offset + input.readInt()</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">    val finalId = if (withoutId) { id } else { input.readString() }</span>
    // now read our offsets
<span class="nc" id="L299">    input.setPosition(offsetStarts) // set to offsets start</span>
<span class="nc" id="L300">    var i = 0</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">    while (i &lt; offsets.length &amp;&amp; input.position &lt; input.limit) {</span>
<span class="nc" id="L302">      offsets(i) = offset + input.readInt(true)</span>
<span class="nc" id="L303">      i += 1</span>
    }
<span class="nc bnc" id="L305" title="All 2 branches missed.">    if (i &lt; offsets.length) {</span>
      // attributes have been added to the sft since this feature was serialized
<span class="nc bnc" id="L307" title="All 2 branches missed.">      while ({{ offsets(i) = -1; i += 1 }; i &lt; offsets.length })()</span>
    }
<span class="nc" id="L309">    val userDataOffset = input.position()</span>

<span class="nc" id="L311">    val reader = new LazyReaderV2(readersV2, offsets, bytes, length)</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">    val userData = if (withoutUserData) { WithoutUserDataReader } else {</span>
<span class="nc" id="L313">      new LazyUserDataReaderV2(bytes, userDataOffset, length)</span>
    }

<span class="nc" id="L316">    createFeature(finalId, reader, userData)</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>