<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpatialRelationFunctions.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Spark JTS</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.spark.jts.udf</a> &gt; <span class="el_source">SpatialRelationFunctions.scala</span></div><h1>SpatialRelationFunctions.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.spark.jts.udf

import org.apache.spark.sql.SQLContext
import org.locationtech.geomesa.spark.jts.udaf.ConvexHull
import org.locationtech.geomesa.spark.jts.util.SQLFunctionHelper._
import org.locationtech.jts.geom._
import org.locationtech.jts.geom.util.AffineTransformation
import org.locationtech.jts.operation.distance.DistanceOp
import org.locationtech.spatial4j.context.jts.JtsSpatialContext
import org.locationtech.spatial4j.distance.{DistanceCalculator, DistanceUtils}

<span class="nc" id="L20">object SpatialRelationFunctions {</span>
  import java.{lang =&gt; jl}

  // Geometry editors
<span class="nc" id="L24">  val ST_Translate: (Geometry, Double, Double) =&gt; Geometry =</span>
<span class="nc" id="L25">    (g, deltaX, deltaY) =&gt; translate(g, deltaX, deltaY)</span>

  // Spatial relationships
  // DE-9IM relations
<span class="nc" id="L29">  val ST_Contains:   (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.contains(geom2))</span>
<span class="nc" id="L30">  val ST_Covers:     (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.covers(geom2))</span>
<span class="nc" id="L31">  val ST_Crosses:    (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.crosses(geom2))</span>
<span class="nc" id="L32">  val ST_Disjoint:   (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.disjoint(geom2))</span>
<span class="nc" id="L33">  val ST_Equals:     (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.equals(geom2))</span>
<span class="nc" id="L34">  val ST_Intersects: (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.intersects(geom2))</span>
<span class="nc" id="L35">  val ST_Overlaps:   (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.overlaps(geom2))</span>
<span class="nc" id="L36">  val ST_Touches:    (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.touches(geom2))</span>
<span class="nc" id="L37">  val ST_Within:     (Geometry, Geometry) =&gt; jl.Boolean = nullableUDF((geom1, geom2) =&gt; geom1.within(geom2))</span>
<span class="nc" id="L38">  val ST_Relate:     (Geometry, Geometry) =&gt; String = nullableUDF((geom1, geom2) =&gt; geom1.relate(geom2).toString)</span>
<span class="nc" id="L39">  val ST_RelateBool: (Geometry, Geometry, String) =&gt; jl.Boolean = nullableUDF((geom1, geom2, pattern) =&gt; geom1.relate(geom2, pattern))</span>

<span class="nc" id="L41">  val ST_Area: Geometry =&gt; jl.Double = nullableUDF(g =&gt; g.getArea)</span>
<span class="nc" id="L42">  val ST_Centroid: Geometry =&gt; Point = nullableUDF(g =&gt; g.getCentroid)</span>
<span class="nc" id="L43">  val ST_ClosestPoint: (Geometry, Geometry) =&gt; Point =</span>
<span class="nc" id="L44">    nullableUDF((g1, g2) =&gt; closestPoint(g1, g2))</span>
<span class="nc" id="L45">  val ST_Distance: (Geometry, Geometry) =&gt; jl.Double =</span>
<span class="nc" id="L46">    nullableUDF((g1, g2) =&gt; g1.distance(g2))</span>
<span class="nc" id="L47">  val ST_DistanceSphere: (Geometry, Geometry) =&gt; jl.Double =</span>
<span class="nc" id="L48">    nullableUDF((s, e) =&gt; fastDistance(s.getCoordinate, e.getCoordinate))</span>
<span class="nc" id="L49">  val ST_Length: Geometry =&gt; jl.Double = nullableUDF(g =&gt; g.getLength)</span>

  // Assumes input is two points, for use with collect_list and window functions
<span class="nc" id="L52">  val ST_AggregateDistanceSphere: Seq[Geometry] =&gt; jl.Double = a =&gt; ST_DistanceSphere(a(0), a(1))</span>

<span class="nc" id="L54">  val ST_LengthSphere: LineString =&gt; jl.Double =</span>
<span class="nc bnc" id="L55" title="All 6 branches missed.">    nullableUDF(line =&gt; line.getCoordinates.sliding(2).map { case Array(l, r) =&gt; fastDistance(l, r) }.sum)</span>

<span class="nc" id="L57">  val ST_Intersection: (Geometry, Geometry) =&gt; Geometry = nullableUDF((geom1, geom2) =&gt; geom1.intersection(geom2))</span>

<span class="nc" id="L59">  val ST_Difference: (Geometry, Geometry) =&gt; Geometry = nullableUDF((geom1, geom2) =&gt; geom1.difference(geom2))</span>

<span class="nc" id="L61">  private[geomesa] val relationNames = Map(</span>
<span class="nc" id="L62">    ST_Translate -&gt; &quot;st_translate&quot; ,</span>
<span class="nc" id="L63">    ST_Contains -&gt; &quot;st_contains&quot;,</span>
<span class="nc" id="L64">    ST_Covers -&gt; &quot;st_covers&quot;,</span>
<span class="nc" id="L65">    ST_Crosses -&gt; &quot;st_crosses&quot;,</span>
<span class="nc" id="L66">    ST_Disjoint -&gt; &quot;st_disjoint&quot;,</span>
<span class="nc" id="L67">    ST_Equals -&gt; &quot;st_equals&quot;,</span>
<span class="nc" id="L68">    ST_Intersects -&gt; &quot;st_intersects&quot;,</span>
<span class="nc" id="L69">    ST_Overlaps -&gt; &quot;st_overlaps&quot;,</span>
<span class="nc" id="L70">    ST_Touches -&gt; &quot;st_touches&quot;,</span>
<span class="nc" id="L71">    ST_Within -&gt; &quot;st_within&quot;,</span>
<span class="nc" id="L72">    ST_Relate -&gt; &quot;st_relate&quot;,</span>
<span class="nc" id="L73">    ST_RelateBool -&gt; &quot;st_relateBool&quot;,</span>
<span class="nc" id="L74">    ST_Area -&gt; &quot;st_area&quot;,</span>
<span class="nc" id="L75">    ST_Centroid -&gt; &quot;st_centroid&quot;,</span>
<span class="nc" id="L76">    ST_ClosestPoint -&gt; &quot;st_closestPoint&quot;,</span>
<span class="nc" id="L77">    ST_Distance -&gt; &quot;st_distance&quot;,</span>
<span class="nc" id="L78">    ST_DistanceSphere -&gt; &quot;st_distanceSphere&quot;,</span>
<span class="nc" id="L79">    ST_Length -&gt; &quot;st_length&quot;,</span>
<span class="nc" id="L80">    ST_AggregateDistanceSphere -&gt; &quot;st_aggregateDistanceSphere&quot;,</span>
<span class="nc" id="L81">    ST_LengthSphere -&gt; &quot;st_lengthSphere&quot;,</span>
<span class="nc" id="L82">    ST_Intersection -&gt; &quot;st_intersection&quot;,</span>
<span class="nc" id="L83">    ST_Difference -&gt; &quot;st_difference&quot;</span>
  )

  // Geometry Processing
<span class="nc" id="L87">  private[geomesa] val ch = new ConvexHull</span>

  private[jts] def registerFunctions(sqlContext: SQLContext): Unit = {
    // Register geometry editors
<span class="nc" id="L91">    sqlContext.udf.register(relationNames(ST_Translate), ST_Translate)</span>

    // Register spatial relationships
<span class="nc" id="L94">    sqlContext.udf.register(relationNames(ST_Contains), ST_Contains)</span>
<span class="nc" id="L95">    sqlContext.udf.register(relationNames(ST_Covers), ST_Covers)</span>
<span class="nc" id="L96">    sqlContext.udf.register(relationNames(ST_Crosses), ST_Crosses)</span>
<span class="nc" id="L97">    sqlContext.udf.register(relationNames(ST_Disjoint), ST_Disjoint)</span>
<span class="nc" id="L98">    sqlContext.udf.register(relationNames(ST_Equals), ST_Equals)</span>
<span class="nc" id="L99">    sqlContext.udf.register(relationNames(ST_Intersects), ST_Intersects)</span>
<span class="nc" id="L100">    sqlContext.udf.register(relationNames(ST_Overlaps), ST_Overlaps)</span>
<span class="nc" id="L101">    sqlContext.udf.register(relationNames(ST_Touches), ST_Touches)</span>
<span class="nc" id="L102">    sqlContext.udf.register(relationNames(ST_Within), ST_Within)</span>
    // renamed st_relate variant that returns a boolean since
    // Spark SQL doesn't seem to support polymorphic UDFs
<span class="nc" id="L105">    sqlContext.udf.register(relationNames(ST_Relate), ST_Relate)</span>
<span class="nc" id="L106">    sqlContext.udf.register(relationNames(ST_RelateBool), ST_RelateBool)</span>

<span class="nc" id="L108">    sqlContext.udf.register(relationNames(ST_Area), ST_Area)</span>
<span class="nc" id="L109">    sqlContext.udf.register(relationNames(ST_ClosestPoint), ST_ClosestPoint)</span>
<span class="nc" id="L110">    sqlContext.udf.register(relationNames(ST_Centroid), ST_Centroid)</span>
<span class="nc" id="L111">    sqlContext.udf.register(relationNames(ST_Distance), ST_Distance)</span>
<span class="nc" id="L112">    sqlContext.udf.register(relationNames(ST_Length), ST_Length)</span>

<span class="nc" id="L114">    sqlContext.udf.register(relationNames(ST_DistanceSphere), ST_DistanceSphere)</span>
<span class="nc" id="L115">    sqlContext.udf.register(relationNames(ST_AggregateDistanceSphere), ST_AggregateDistanceSphere)</span>
<span class="nc" id="L116">    sqlContext.udf.register(relationNames(ST_LengthSphere), ST_LengthSphere)</span>

    // Register geometry Processing
<span class="nc" id="L119">    sqlContext.udf.register(&quot;st_convexhull&quot;, ch)</span>
<span class="nc" id="L120">    sqlContext.udf.register(relationNames(ST_Intersection),ST_Intersection)</span>
<span class="nc" id="L121">    sqlContext.udf.register(relationNames(ST_Difference),ST_Difference)</span>
  }

<span class="nc bnc" id="L124" title="All 4 branches missed.">  @transient private lazy val spatialContext = JtsSpatialContext.GEO</span>

<span class="nc" id="L126">  @transient private val geoCalcs = new ThreadLocal[DistanceCalculator] {</span>
<span class="nc" id="L127">    override def initialValue(): DistanceCalculator = spatialContext.getDistCalc</span>
  }
<span class="nc" id="L129">  @transient private[geomesa] val geomFactory = new GeometryFactory()</span>

  def closestPoint(g1: Geometry, g2: Geometry): Point = {
<span class="nc" id="L132">    val op = new DistanceOp(g1, g2)</span>
<span class="nc" id="L133">    val coord = op.nearestPoints()</span>
<span class="nc" id="L134">    geomFactory.createPoint(coord(0))</span>
  }

  def fastDistance(c1: Coordinate, c2: Coordinate): Double = {
<span class="nc" id="L138">    val calc = geoCalcs.get()</span>
<span class="nc" id="L139">    val startPoint = spatialContext.getShapeFactory.pointXY(c1.x, c1.y)</span>
<span class="nc" id="L140">    DistanceUtils.DEG_TO_KM * calc.distance(startPoint, c2.x, c2.y) * 1000</span>
  }

  def translate(g: Geometry, deltax: Double, deltay: Double): Geometry = {
<span class="nc" id="L144">    val affineTransform = new AffineTransformation()</span>
<span class="nc" id="L145">    affineTransform.setToTranslation(deltax, deltay)</span>
<span class="nc" id="L146">    affineTransform.transform(g)</span>
  }
<span class="nc" id="L148">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>