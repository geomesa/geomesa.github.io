<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoHashUtils.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Spark JTS</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.spark.jts.util</a> &gt; <span class="el_source">GeoHashUtils.scala</span></div><h1>GeoHashUtils.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.spark.jts.util

import org.locationtech.jts.geom.{Envelope, Geometry, GeometryFactory, PrecisionModel}

import java.{lang =&gt; jl}
import scala.collection.BitSet
import scala.collection.immutable.{BitSet =&gt; IBitSet}

/**
  * Exposes the two methods needed by ST_GeoHash and ST_GeomFromGeoHash
  * to convert between geometries and Geohashes.
  * This is different from GeoHashUtils in geomesa-utils which provides operations
  * on geohashes not required by these UDFs
  */
<span class="nc" id="L23">object GeoHashUtils {</span>

  def encode(geom: Geometry, precision: Int): String = {
<span class="nc" id="L26">    val centroid = geom.getCentroid</span>
<span class="nc bnc" id="L27" title="All 4 branches missed.">    val safeCentroid = if (jl.Double.isNaN(centroid.getCoordinate.x) || jl.Double.isNaN(centroid.getCoordinate.y)) {</span>
<span class="nc" id="L28">      geom.getEnvelope.getCentroid</span>
    } else {
<span class="nc" id="L30">      centroid</span>
    }
<span class="nc" id="L32">    GeoHash.encode(safeCentroid.getX, safeCentroid.getY, precision)</span>
  }

  def decode(geohash: String, precision: Int): Geometry = {
<span class="nc" id="L36">    GeoHash.decode(geohash, Some(precision))</span>
  }
}

<span class="nc bnc" id="L40" title="All 17 branches missed.">case class Bounds(low: Double,</span>
<span class="nc" id="L41">                  high: Double) {</span>
<span class="nc bnc" id="L42" title="All 4 branches missed.">  lazy val mid = (low+high)/2.0</span>
}

// This object is composed of minimal pieces from org.locationtech.geomesa.utils.geohash.GeoHash
// to support geohash UDFs while avoiding depending on that module.
<span class="nc" id="L47">private[util] object GeoHash {</span>

<span class="nc" id="L49">  val MAX_PRECISION = 63 // our bitset operations assume all bits fit in one Long</span>

<span class="nc" id="L51">  private val latBounds = Bounds(-90.0,90.0)</span>
<span class="nc" id="L52">  private val lonBounds = Bounds(-180.0,180.0)</span>
<span class="nc bnc" id="L53" title="All 4 branches missed.">  private lazy val latRange: Double = latBounds.high - latBounds.low</span>
<span class="nc bnc" id="L54" title="All 4 branches missed.">  private lazy val lonRange: Double = lonBounds.high - lonBounds.low</span>

<span class="nc bnc" id="L56" title="All 4 branches missed.">  private lazy val powersOf2Map: Map[Int, Long] =</span>
<span class="nc" id="L57">    (0 to   MAX_PRECISION).map(i =&gt; (i, 1L &lt;&lt; i)).toMap // 1L &lt;&lt; i == math.pow(2,i).toLong</span>
<span class="nc bnc" id="L58" title="All 4 branches missed.">  private lazy val latDeltaMap: Map[Int, Double]  =</span>
<span class="nc" id="L59">    (0 to MAX_PRECISION).map(i =&gt; (i, latRange / powersOf2Map(i / 2))).toMap</span>
<span class="nc bnc" id="L60" title="All 4 branches missed.">  private lazy val lonDeltaMap: Map[Int, Double] =</span>
<span class="nc" id="L61">    (0 to MAX_PRECISION).map(i =&gt; (i, lonRange / powersOf2Map(i / 2 + i % 2))).toMap</span>

  def latitudeDeltaForPrecision(prec: Int): Double = {
<span class="nc" id="L64">    checkPrecision(prec)</span>
<span class="nc" id="L65">    latDeltaMap(prec)</span>
  }

  def longitudeDeltaForPrecision(prec: Int): Double = {
<span class="nc" id="L69">    checkPrecision(prec)</span>
<span class="nc" id="L70">    lonDeltaMap(prec)</span>
  }

<span class="nc" id="L73">  private val lonMax = 360 - math.pow(0.5, 32)</span>
<span class="nc" id="L74">  private val latMax = 180 - math.pow(0.5, 32)</span>

<span class="nc" id="L76">  private val bits = Array(16,8,4,2,1)</span>
<span class="nc" id="L77">  protected[util] val base32 = &quot;0123456789bcdefghjkmnpqrstuvwxyz&quot;</span>
<span class="nc" id="L78">  private val characterMap: Map[Char, BitSet] =</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">    base32.zipWithIndex.map { case (c, i) =&gt; c -&gt; bitSetFromBase32Character(i) }.toMap</span>

<span class="nc bnc" id="L81" title="All 4 branches missed.">  lazy val latLonGeoFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326)</span>

  private def envFromIndiciesDeltas(lonIndex: Long,
                                    latIndex: Long,
                                    lonDelta: Double,
                                    latDelta: Double): Envelope =
<span class="nc" id="L87">    new Envelope(lonBounds.low+lonDelta*lonIndex, lonBounds.low+lonDelta*(lonIndex+1),</span>
<span class="nc" id="L88">      latBounds.low+latDelta*latIndex, latBounds.low+latDelta*(latIndex+1))</span>

  private def interleaveReverseBits(first: Long, second: Long, numBits: Int): Long = {
    /* We start with the first value of the interleaved long, coming from first if
       numBits is odd or from second if numBits is even */
<span class="nc bnc" id="L93" title="All 2 branches missed.">    val even = (numBits &amp; 0x01) == 0</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">    val (actualFirst, actualSecond) = if(even) (second, first) else (first, second)</span>
<span class="nc" id="L95">    val numPairs = numBits &gt;&gt; 1</span>
<span class="nc" id="L96">    var result = 0L</span>
<span class="nc" id="L97">    (0 until numPairs).foreach{ pairNum =&gt;</span>
<span class="nc" id="L98">      result = (result &lt;&lt; 1) | ((actualFirst &gt;&gt; pairNum) &amp; 1L)</span>
<span class="nc" id="L99">      result = (result &lt;&lt; 1) | ((actualSecond &gt;&gt; pairNum) &amp; 1L)</span>
    }
<span class="nc bnc" id="L101" title="All 2 branches missed.">    if (!even) (result &lt;&lt; 1) | ((actualFirst &gt;&gt; numPairs) &amp; 1L) else result</span>
  }

  private def extractReverseBits(value: Long, numBits: Int): (Long, Long) = {
<span class="nc" id="L105">    val numPairs = numBits &gt;&gt; 1</span>
<span class="nc" id="L106">    var first = 0L</span>
<span class="nc" id="L107">    var second = 0L</span>
<span class="nc" id="L108">    (0 until numPairs).foreach{ pairNum =&gt;</span>
<span class="nc" id="L109">      first = (first &lt;&lt; 1) | ((value &gt;&gt; pairNum * 2) &amp; 1L)</span>
<span class="nc" id="L110">      second = (second &lt;&lt; 1) | ((value &gt;&gt; (pairNum * 2 + 1)) &amp; 1L)</span>
    }
<span class="nc bnc" id="L112" title="All 2 branches missed.">    ((if((numBits &amp; 0x01) == 1) ((first &lt;&lt; 1) | ((value &gt;&gt; (numBits - 1)) &amp; 1L)) else first), second)</span>
  }

<span class="nc" id="L115">  private def shift(n: Int, bs: BitSet): BitSet = bs.map(_ + n)</span>

  private def bitSetFromBase32Character(charIndex: Long): BitSet =
<span class="nc bnc" id="L118" title="All 4 branches missed.">    BitSet(toPaddedBinaryString(charIndex, 5).zipWithIndex.filter { case (c,idx) =&gt; c == '1' }.map(_._2): _*)</span>

  private def toPaddedBinaryString(i: Long, length: Int): String =
<span class="nc" id="L121">    String.format(&quot;%&quot; + length + &quot;s&quot;, i.toBinaryString).replace(' ', '0')</span>

  private def toBase32(bitset: BitSet, prec: Int): String = {
    // compute the precision padded to the next 5-bit boundary
<span class="nc" id="L125">    val numLeftoverBits = prec % 5</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">    val precision = prec + (numLeftoverBits match {</span>
<span class="nc" id="L127">      case 0 =&gt; 0</span>
<span class="nc" id="L128">      case _ =&gt; (5-numLeftoverBits)</span>
    })

    // take the bit positions in groups of 5, and map each set to a character
    // (based on the current bit-set); this works for off-5 precisions, because
    // the additional bits will simply not be there (assumed to be zero)
<span class="nc" id="L134">    (0 until precision).grouped(5).map(i=&gt;ch(i, bitset)).mkString</span>
  }

  private def ch(v: IndexedSeq[Int], bitset: BitSet) =
<span class="nc bnc" id="L138" title="All 2 branches missed.">    base32(v.foldLeft(0)((cur,i) =&gt; cur + (if (bitset(i)) bits(i%bits.length) else 0)))</span>

  def checkPrecision(precision: Int) =
<span class="nc bnc" id="L141" title="All 2 branches missed.">    require(precision &lt;= MAX_PRECISION,</span>
<span class="nc" id="L142">      s&quot;GeoHash precision of $precision requested, but precisions above $MAX_PRECISION are not supported&quot;)</span>

<span class="nc" id="L144">  def encode(lon: Double, lat: Double, prec: Int = 25): String = {</span>
<span class="nc bnc" id="L145" title="All 4 branches missed.">    require(lon &gt;= -180.0 &amp;&amp; lon &lt;= 180.0)</span>
<span class="nc bnc" id="L146" title="All 4 branches missed.">    require(lat &gt;= -90.0 &amp;&amp; lat &lt;= 90.0)</span>
<span class="nc" id="L147">    checkPrecision(prec)</span>

<span class="nc" id="L149">    val lonDelta = lonDeltaMap(prec)</span>
<span class="nc" id="L150">    val latDelta = latDeltaMap(prec)</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">    val lonIndex = if (lon == 180.0) (lonMax / lonDelta).toLong else ((lon - lonBounds.low) / lonDelta).toLong</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">    val latIndex = if (lat == 90.0) (latMax / latDelta).toLong else ((lat - latBounds.low) / latDelta).toLong</span>

<span class="nc" id="L154">    val bitSet = IBitSet.fromBitMaskNoCopy(Array(interleaveReverseBits(lonIndex, latIndex, prec)))</span>
<span class="nc" id="L155">    toBase32(bitSet, prec)</span>
  }

<span class="nc" id="L158">  def decode(string: String, precisionOption: Option[Int] = None): Geometry = {</span>
    // figure out what precision we should use
<span class="nc" id="L160">    val prec = precisionOption.getOrElse(5*string.length)</span>
<span class="nc" id="L161">    checkPrecision(prec)</span>

    // compute bit-sets for both the full and partial characters
<span class="nc bnc" id="L164" title="All 2 branches missed.">    val bitsets = string.zipWithIndex.map { case (c: Char, i: Int) =&gt; shift(i*5, characterMap(c)) }</span>

    // OR all of these bit-sets together
<span class="nc bnc" id="L167" title="All 3 branches missed.">    val finalBitset: BitSet = bitsets.size match {</span>
<span class="nc" id="L168">      case 0 =&gt; BitSet()</span>
<span class="nc" id="L169">      case 1 =&gt; bitsets(0)</span>
<span class="nc" id="L170">      case _ =&gt; bitsets.reduce(_|_)</span>
    }

<span class="nc bnc" id="L173" title="All 2 branches missed.">    val (lonIndex, latIndex) = extractReverseBits(finalBitset.toBitMask.head, prec)</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    val (lonDelta, latDelta) = (lonDeltaMap(prec), latDeltaMap(prec))</span>

<span class="nc" id="L176">    val envelope = envFromIndiciesDeltas(lonIndex, latIndex, lonDelta, latDelta)</span>

<span class="nc" id="L178">    latLonGeoFactory.toGeometry(envelope)</span>
  }

<span class="nc" id="L181">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>