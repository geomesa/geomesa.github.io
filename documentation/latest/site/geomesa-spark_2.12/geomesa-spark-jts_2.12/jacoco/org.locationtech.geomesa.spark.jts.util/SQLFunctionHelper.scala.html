<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SQLFunctionHelper.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Spark JTS</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.spark.jts.util</a> &gt; <span class="el_source">SQLFunctionHelper.scala</span></div><h1>SQLFunctionHelper.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.spark.jts.util

import org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute
import org.apache.spark.sql.catalyst.expressions.{Alias, AttributeReference}
import org.apache.spark.sql.functions.udf
import org.apache.spark.sql.{Column, Encoder, TypedColumn}

import scala.reflect.runtime.universe._

// This should be some level of package private, but there's a dependency on it
// from org.apache.spark.sql.SQLGeometricConstructorFunctions, which could/should be moved
// into a org.locationtech.geomesa package eventually, and this access restriction reenabled
<span class="nc" id="L21">/*private[geomesa]*/ object SQLFunctionHelper {</span>
<span class="nc" id="L22">  def nullableUDF[A1, RT](f: A1 =&gt; RT): A1 =&gt; RT = {</span>
<span class="nc bnc" id="L23" title="All 2 branches missed.">    case null =&gt; null.asInstanceOf[RT]</span>
<span class="nc" id="L24">    case out1 =&gt; f(out1)</span>
  }

  def nullableUDF[A1, A2, RT](f: (A1, A2) =&gt; RT): (A1, A2) =&gt; RT = {
<span class="nc bnc" id="L28" title="All 6 branches missed.">    (in1, in2) =&gt; (in1, in2) match {</span>
<span class="nc bnc" id="L29" title="All 2 branches missed.">      case (null, _) =&gt; null.asInstanceOf[RT]</span>
<span class="nc bnc" id="L30" title="All 2 branches missed.">      case (_, null) =&gt; null.asInstanceOf[RT]</span>
<span class="nc" id="L31">      case (out1, out2) =&gt; f(out1, out2)</span>
    }
  }

  def nullableUDF[A1, A2, A3, RT](f: (A1, A2, A3) =&gt; RT): (A1, A2, A3) =&gt; RT = {
<span class="nc bnc" id="L36" title="All 8 branches missed.">    (in1, in2, in3) =&gt; (in1, in2, in3) match {</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">      case (null, _, _) =&gt; null.asInstanceOf[RT]</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">      case (_, null, _) =&gt; null.asInstanceOf[RT]</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">      case (_, _, null) =&gt; null.asInstanceOf[RT]</span>
<span class="nc" id="L40">      case (out1, out2, out3) =&gt; f(out1, out2, out3)</span>
    }
  }

  def nullableUDF[A1, A2, A3, A4, RT](f: (A1, A2, A3, A4) =&gt; RT): (A1, A2, A3, A4) =&gt; RT = {
<span class="nc bnc" id="L45" title="All 10 branches missed.">    (in1, in2, in3, in4) =&gt; (in1, in2, in3, in4) match {</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">      case (null, _, _, _) =&gt; null.asInstanceOf[RT]</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">      case (_, null, _, _) =&gt; null.asInstanceOf[RT]</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">      case (_, _, null, _) =&gt; null.asInstanceOf[RT]</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">      case (_, _, _, null) =&gt; null.asInstanceOf[RT]</span>
<span class="nc" id="L50">      case (out1, out2, out3, out4) =&gt; f(out1, out2, out3, out4)</span>
    }
  }

  def udfToColumn[A1: TypeTag, RT: TypeTag: Encoder, N &gt;: (A1 =&gt; RT)](
    f: A1 =&gt; RT, namer: N =&gt; String, col: Column): TypedColumn[Any, RT] = {
<span class="nc" id="L56">    withAlias(namer(f), col)(udf(f).apply(col)).as[RT]</span>
  }

  def udfToColumn[A1: TypeTag, A2: TypeTag, RT: TypeTag: Encoder, N &gt;: (A1, A2) =&gt; RT](
    f: (A1, A2) =&gt; RT, namer: N =&gt; String, colA: Column, colB: Column): TypedColumn[Any, RT] = {
<span class="nc" id="L61">    withAlias(namer(f), colA, colB)(udf(f).apply(colA, colB)).as[RT]</span>
  }

  def udfToColumn[A1: TypeTag, A2: TypeTag, A3: TypeTag, RT: TypeTag: Encoder, N &gt;: (A1, A2, A3) =&gt; RT](
    f: (A1, A2, A3) =&gt; RT, namer: N =&gt; String, colA: Column, colB: Column, colC: Column): TypedColumn[Any, RT] = {
<span class="nc" id="L66">    withAlias(namer(f), colA, colB, colC)(udf(f).apply(colA, colB, colC)).as[RT]</span>
  }

  def udfToColumn[A1: TypeTag, A2: TypeTag, A3: TypeTag, A4: TypeTag, RT: TypeTag: Encoder, N &gt;: (A1, A2, A3, A4) =&gt; RT](
    f: (A1, A2, A3, A4) =&gt; RT, namer: N =&gt; String,
    colA: Column, colB: Column, colC: Column, colD: Column): TypedColumn[Any, RT] = {
<span class="nc" id="L72">    withAlias(namer(f), colA, colB, colC)(udf(f).apply(colA, colB, colC, colD)).as[RT]</span>
  }

  def columnName(column: Column): String = {
<span class="nc" id="L76">    column.expr match {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      case ua: UnresolvedAttribute ⇒ ua.name</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      case ar: AttributeReference ⇒ ar.name</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">      case as: Alias ⇒ as.name</span>
<span class="nc" id="L80">      case o ⇒ o.prettyName</span>
    }
  }

  def withAlias(name: String, inputs: Column*)(output: Column): Column = {
<span class="nc" id="L85">    val paramNames = inputs.map(columnName).mkString(&quot;,&quot;)</span>
<span class="nc" id="L86">    output.as(s&quot;$name($paramNames)&quot;)</span>
  }
<span class="nc" id="L88">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>