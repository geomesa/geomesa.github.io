<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataFrameFunctions.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Spark JTS</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.spark.jts</a> &gt; <span class="el_source">DataFrameFunctions.scala</span></div><h1>DataFrameFunctions.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.spark.jts

import org.apache.spark.sql.catalyst.expressions.Literal
import org.apache.spark.sql.functions.{array, lit}
import org.apache.spark.sql.jts._
import org.apache.spark.sql.{Column, Encoder, Encoders, TypedColumn}
import org.locationtech.geomesa.spark.jts.encoders.SpatialEncoders
import org.locationtech.geomesa.spark.jts.util.SQLFunctionHelper._
import org.locationtech.jts.geom._

import java.{lang =&gt; jl}


/**
 * DataFrame DSL functions for working with JTS types
 */
<span class="nc" id="L25">object DataFrameFunctions extends SpatialEncoders {</span>
  import org.locationtech.geomesa.spark.jts.encoders.SparkDefaultEncoders._

<span class="nc" id="L28">  implicit def integerEncoder: Encoder[Integer] = Encoders.INT</span>

  /**
   * Group of DataFrame DSL functions associated with constructing and encoding
   * JTS types in Spark SQL.
   */
<span class="nc" id="L34">  trait SpatialConstructors {</span>
    import org.locationtech.geomesa.spark.jts.udf.GeometricConstructorFunctions._

    /** Constructs a geometric literal from a value  and JTS UDT */
    private def udtlit[T &gt;: Null &lt;: Geometry: Encoder, U &lt;: AbstractGeometryUDT[T]](t: T, u: U): TypedColumn[Any, T] =
<span class="nc" id="L39">      new Column(Literal.create(u.serialize(t), u)).as[T]</span>

    /** Create a generic geometry literal, encoded as a GeometryUDT. */
<span class="nc" id="L42">    def geomLit(g: Geometry): TypedColumn[Any, Geometry] = udtlit(g, GeometryUDT)</span>
    /** Create a point literal, encoded as a PointUDT. */
<span class="nc" id="L44">    def pointLit(g: Point): TypedColumn[Any, Point] = udtlit(g, PointUDT)</span>
    /** Create a line literal, encoded as a LineUDT. */
<span class="nc" id="L46">    def lineLit(g: LineString): TypedColumn[Any, LineString] = udtlit(g, LineStringUDT)</span>
    /** Create a polygon literal, encoded as a PolygonUDT. */
<span class="nc" id="L48">    def polygonLit(g: Polygon): TypedColumn[Any, Polygon] = udtlit(g, PolygonUDT)</span>
    /** Create a multi-point literal, encoded as a MultiPointUDT. */
<span class="nc" id="L50">    def mPointLit(g: MultiPoint): TypedColumn[Any, MultiPoint] = udtlit(g, MultiPointUDT)</span>
    /** Create a multi-line literal, encoded as a MultiPointUDT. */
<span class="nc" id="L52">    def mLineLit(g: MultiLineString): TypedColumn[Any, MultiLineString] = udtlit(g, MultiLineStringUDT)</span>
    /** Create a multi-polygon literal, encoded as a MultiPolygonUDT. */
<span class="nc" id="L54">    def mPolygonLit(g: MultiPolygon): TypedColumn[Any, MultiPolygon] = udtlit(g, MultiPolygonUDT)</span>
    /** create a geometry collection literal, encoded as a GeometryCollectionUDT. */
<span class="nc" id="L56">    def geomCollLit(g: GeometryCollection): TypedColumn[Any, GeometryCollection] = udtlit(g, GeometryCollectionUDT)</span>

    def st_geomFromGeoHash(geohash: Column, precision: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L59">      udfToColumn(ST_GeomFromGeoHash, constructorNames, geohash, precision)</span>
    def st_geomFromGeoHash(geohash: Column, precision: Int): TypedColumn[Any, Geometry] =
<span class="nc" id="L61">      st_geomFromGeoHash(geohash, lit(precision))</span>

    def st_geomFromGeoJSON(wkt: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L64">      udfToColumn(ST_GeomFromGeoJSON, constructorNames, wkt)</span>
    def st_geomFromGeoJSON(wkt: String): TypedColumn[Any, Geometry] =
<span class="nc" id="L66">      st_geomFromGeoJSON(lit(wkt))</span>

    def st_geomFromWKT(wkt: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L69">      udfToColumn(ST_GeomFromWKT, constructorNames, wkt)</span>
    def st_geomFromWKT(wkt: String): TypedColumn[Any, Geometry] =
<span class="nc" id="L71">      st_geomFromWKT(lit(wkt))</span>

    def st_geomFromWKB(wkb: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L74">      udfToColumn(ST_GeomFromWKB, constructorNames, wkb)</span>
    def st_geomFromWKB(wkb: Array[Byte]): TypedColumn[Any, Geometry] =
<span class="nc" id="L76">      st_geomFromWKB(lit(wkb))</span>

    def st_lineFromText(wkt: Column): TypedColumn[Any, LineString] =
<span class="nc" id="L79">      udfToColumn(ST_LineFromText, constructorNames, wkt)</span>
    def st_lineFromText(wkt: String): TypedColumn[Any, LineString] =
<span class="nc" id="L81">      st_lineFromText(lit(wkt))</span>

    def st_makeBox2D(lowerLeft: Column, upperRight: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L84">      udfToColumn(ST_MakeBox2D, constructorNames, lowerLeft, upperRight)</span>
    def st_makeBox2D(lowerLeft: Point, upperRight: Point): TypedColumn[Any, Geometry] =
<span class="nc" id="L86">      st_makeBox2D(pointLit(lowerLeft), pointLit(upperRight))</span>

    def st_makeBBOX(lowerX: Column, lowerY: Column, upperX: Column, upperY: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L89">      udfToColumn(ST_MakeBBOX, constructorNames, lowerX, lowerY, upperX, upperY)</span>
    def st_makeBBOX(lowerX: Double, lowerY: Double, upperX: Double, upperY: Double): TypedColumn[Any, Geometry] =
<span class="nc" id="L91">      st_makeBBOX(lit(lowerX), lit(lowerY), lit(upperX), lit(upperY))</span>

    def st_makePolygon(lineString: Column): TypedColumn[Any, Polygon] =
<span class="nc" id="L94">      udfToColumn(ST_MakePolygon, constructorNames, lineString)</span>
    def st_makePolygon(lineString: LineString): TypedColumn[Any, Polygon] =
<span class="nc" id="L96">      st_makePolygon(lineLit(lineString))</span>

    def st_makePoint(x: Column, y: Column): TypedColumn[Any, Point] =
<span class="nc" id="L99">      udfToColumn(ST_MakePoint, constructorNames, x, y)</span>
    def st_makePoint(x: Double, y: Double): TypedColumn[Any, Point] =
<span class="nc" id="L101">      st_makePoint(lit(x), lit(y))</span>

    def st_makeLine(pointSeq: Column): TypedColumn[Any, LineString] =
<span class="nc" id="L104">      udfToColumn(ST_MakeLine, constructorNames, pointSeq)</span>
    def st_makeLine(pointSeq: Seq[Point]): TypedColumn[Any, LineString] =
<span class="nc" id="L106">      st_makeLine(array(pointSeq.map(pointLit): _*))</span>

    def st_makePointM(x: Column, y: Column, m: Column): TypedColumn[Any, Point] =
<span class="nc" id="L109">      udfToColumn(ST_MakePointM, constructorNames, x, y, m)</span>
    def st_makePointM(x: Double, y: Double, m: Double): TypedColumn[Any, Point] =
<span class="nc" id="L111">      st_makePointM(lit(x), lit(y), lit(m))</span>

    def st_mLineFromText(wkt: Column): TypedColumn[Any, MultiLineString] =
<span class="nc" id="L114">      udfToColumn(ST_MLineFromText, constructorNames, wkt)</span>
    def st_mLineFromText(wkt: String): TypedColumn[Any, MultiLineString] =
<span class="nc" id="L116">      st_mLineFromText(lit(wkt))</span>

    def st_mPointFromText(wkt: Column): TypedColumn[Any, MultiPoint] =
<span class="nc" id="L119">      udfToColumn(ST_MPointFromText, constructorNames, wkt)</span>
    def st_mPointFromText(wkt: String): TypedColumn[Any, MultiPoint] =
<span class="nc" id="L121">      st_mPointFromText(lit(wkt))</span>

    def st_mPolyFromText(wkt: Column): TypedColumn[Any, MultiPolygon] =
<span class="nc" id="L124">      udfToColumn(ST_MPolyFromText, constructorNames, wkt)</span>
    def st_mPolyFromText(wkt: String): TypedColumn[Any, MultiPolygon] =
<span class="nc" id="L126">      st_mPolyFromText(lit(wkt))</span>

    def st_point(x: Column, y: Column): TypedColumn[Any, Point] =
<span class="nc" id="L129">      udfToColumn(ST_Point, constructorNames, x, y)</span>
    def st_point(x: Double, y: Double): TypedColumn[Any, Point] =
<span class="nc" id="L131">      st_point(lit(x), lit(y))</span>

    def st_pointFromGeoHash(geohash: Column, precision: Column): TypedColumn[Any, Point] =
<span class="nc" id="L134">      udfToColumn(ST_PointFromGeoHash, constructorNames, geohash, precision)</span>
    def st_pointFromGeoHash(geohash: Column, precision: Int): TypedColumn[Any, Point] =
<span class="nc" id="L136">      st_pointFromGeoHash(geohash, lit(precision))</span>

    def st_pointFromText(wkt: Column): TypedColumn[Any, Point] =
<span class="nc" id="L139">      udfToColumn(ST_PointFromText, constructorNames, wkt)</span>
    def st_pointFromText(wkt: String): TypedColumn[Any, Point] =
<span class="nc" id="L141">      st_pointFromText(lit(wkt))</span>

    def st_pointFromWKB(wkb: Column): TypedColumn[Any, Point] =
<span class="nc" id="L144">      udfToColumn(ST_PointFromWKB, constructorNames, wkb)</span>
    def st_pointFromWKB(wkb: Array[Byte]): TypedColumn[Any, Point] =
<span class="nc" id="L146">      st_pointFromWKB(lit(wkb))</span>

    def st_polygon(lineString: Column): TypedColumn[Any, Polygon] =
<span class="nc" id="L149">      udfToColumn(ST_Polygon, constructorNames, lineString)</span>
    def st_polygon(lineString: LineString): TypedColumn[Any, Polygon] =
<span class="nc" id="L151">      st_polygon(lineLit(lineString))</span>

    def st_polygonFromText(wkt: Column): TypedColumn[Any, Polygon] =
<span class="nc" id="L154">      udfToColumn(ST_PolygonFromText, constructorNames, wkt)</span>
    def st_polygonFromText(wkt: String): TypedColumn[Any, Polygon] =
<span class="nc" id="L156">      st_polygonFromText(lit(wkt))</span>
  }

  /**
   * Group of DataFrame DSL functions associated with converting JTS types
   * from one type to another.
   */
<span class="nc" id="L163">  trait SpatialConverters {</span>
    import org.locationtech.geomesa.spark.jts.udf.GeometricCastFunctions._

    def st_castToPoint(geom: Column): TypedColumn[Any, Point] =
<span class="nc" id="L167">      udfToColumn(ST_CastToPoint, castingNames, geom)</span>

    def st_castToPolygon(geom: Column): TypedColumn[Any, Polygon] =
<span class="nc" id="L170">      udfToColumn(ST_CastToPolygon, castingNames, geom)</span>

    def st_castToLineString(geom: Column): TypedColumn[Any, LineString] =
<span class="nc" id="L173">      udfToColumn(ST_CastToLineString, castingNames, geom)</span>

    def st_castToGeometry(geom: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L176">      udfToColumn(ST_CastToGeometry, castingNames, geom)</span>

    def st_byteArray(str: Column): TypedColumn[Any, Array[Byte]] =
<span class="nc" id="L179">      udfToColumn(ST_ByteArray, castingNames, str)</span>
  }

  /**
   * Group of DataFrame DSL functions associated with fetching components
   * of JTS values.
   */
<span class="nc" id="L186">  trait SpatialAccessors {</span>
    import org.locationtech.geomesa.spark.jts.udf.GeometricAccessorFunctions._

    def st_boundary(geom: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L190">      udfToColumn(ST_Boundary, accessorNames, geom)</span>

    def st_coordDim(geom: Column): TypedColumn[Any, Integer] =
<span class="nc" id="L193">      udfToColumn(ST_CoordDim, accessorNames, geom)</span>

    def st_dimension(geom: Column): TypedColumn[Any, Integer] =
<span class="nc" id="L196">      udfToColumn(ST_Dimension, accessorNames, geom)</span>

    def st_envelope(geom: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L199">      udfToColumn(ST_Envelope, accessorNames, geom)</span>

    def st_exteriorRing(geom: Column): TypedColumn[Any, LineString] =
<span class="nc" id="L202">      udfToColumn(ST_ExteriorRing, accessorNames, geom)</span>

    def st_geometryN(geom: Column, n: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L205">      udfToColumn(ST_GeometryN, accessorNames, geom, n)</span>

    def st_geometryType(geom: Column): TypedColumn[Any, String] =
<span class="nc" id="L208">      udfToColumn(ST_GeometryType, accessorNames, geom)</span>

    def st_interiorRingN(geom: Column, n: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L211">      udfToColumn(ST_InteriorRingN, accessorNames, geom, n)</span>

    def st_isClosed(geom: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L214">      udfToColumn(ST_IsClosed, accessorNames, geom)</span>

      def st_isCollection(geom: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L217">      udfToColumn(ST_IsCollection, accessorNames, geom)</span>

    def st_isEmpty(geom: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L220">      udfToColumn(ST_IsEmpty, accessorNames, geom)</span>

    def st_isRing(geom: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L223">      udfToColumn(ST_IsRing, accessorNames, geom)</span>

    def st_isSimple(geom: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L226">      udfToColumn(ST_IsSimple, accessorNames, geom)</span>

    def st_isValid(geom: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L229">      udfToColumn(ST_IsValid, accessorNames, geom)</span>

    def st_numGeometries(geom: Column): TypedColumn[Any, Integer] =
<span class="nc" id="L232">      udfToColumn(ST_NumGeometries, accessorNames, geom)</span>

    def st_numPoints(geom: Column): TypedColumn[Any, Integer] =
<span class="nc" id="L235">      udfToColumn(ST_NumPoints, accessorNames, geom)</span>

    def st_pointN(geom: Column, n: Column): TypedColumn[Any, Point] =
<span class="nc" id="L238">      udfToColumn(ST_PointN, accessorNames, geom, n)</span>

    def st_x(geom: Column): TypedColumn[Any, jl.Float] =
<span class="nc" id="L241">      udfToColumn(ST_X, accessorNames, geom)</span>

    def st_y(geom: Column): TypedColumn[Any, jl.Float] =
<span class="nc" id="L244">      udfToColumn(ST_Y, accessorNames, geom)</span>
  }

  /**
   * Group of DataFrame DSL functions associated with converting JTS
   * types into external formats.
   */
<span class="nc" id="L251">  trait SpatialOutputs {</span>
    import org.locationtech.geomesa.spark.jts.udf.GeometricOutputFunctions._

    def st_asBinary(geom: Column): TypedColumn[Any, Array[Byte]] =
<span class="nc" id="L255">      udfToColumn(ST_AsBinary, outputNames, geom)</span>

    def st_asGeoJSON(geom: Column): TypedColumn[Any, String] =
<span class="nc" id="L258">      udfToColumn(ST_AsGeoJSON, outputNames, geom)</span>

    def st_asLatLonText(point: Column): TypedColumn[Any, String] =
<span class="nc" id="L261">      udfToColumn(ST_AsLatLonText, outputNames, point)</span>

    def st_asText(geom: Column): TypedColumn[Any, String] =
<span class="nc" id="L264">      udfToColumn(ST_AsText, outputNames, geom)</span>

    def st_geoHash(geom: Column, precision: Column): TypedColumn[Any, String] =
<span class="nc" id="L267">      udfToColumn(ST_GeoHash, outputNames, geom, precision)</span>
    def st_geoHash(geom: Column, precision: Int): TypedColumn[Any, String] =
<span class="nc" id="L269">      st_geoHash(geom, lit(precision))</span>
  }

  /**
    * Group of DataFrame DSL functions associated with processing
    * and manipulating JTS Types
    */
<span class="nc" id="L276">  trait SpatialProcessors {</span>
    import org.locationtech.geomesa.spark.jts.udf.GeometricProcessingFunctions._

    def st_antimeridianSafeGeom(geom: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L280">      udfToColumn(ST_antimeridianSafeGeom, processingNames, geom)</span>

    def st_bufferPoint(geom: Column, buffer: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L283">      udfToColumn(ST_BufferPoint, processingNames, geom, buffer)</span>
    def st_bufferPoint(geom: Column, buffer: Double): TypedColumn[Any, Geometry] =
<span class="nc" id="L285">      st_bufferPoint(geom, lit(buffer))</span>

    def st_makeValid(geom: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L288">      udfToColumn(ST_MakeValid, processingNames, geom)</span>

  }

  /**
   * Group of DataFrame DSL functions associated with determining the relationship
   * between two JTS values.
   */
<span class="nc" id="L296">  trait SpatialRelations {</span>
    import org.locationtech.geomesa.spark.jts.udf.SpatialRelationFunctions._

    def st_translate(geom: Column, deltaX: Column, deltaY: Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L300">      udfToColumn(ST_Translate, relationNames, geom, deltaX, deltaY)</span>
    def st_translate(geom: Column, deltaX: Double, deltaY: Double): TypedColumn[Any, Geometry] =
<span class="nc" id="L302">      st_translate(geom, lit(deltaX), lit(deltaY))</span>

    def st_contains(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L305">      udfToColumn(ST_Contains, relationNames, left, right)</span>

    def st_covers(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L308">      udfToColumn(ST_Covers, relationNames, left, right)</span>

    def st_crosses(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L311">      udfToColumn(ST_Crosses, relationNames, left, right)</span>

    def st_disjoint(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L314">      udfToColumn(ST_Disjoint, relationNames, left, right)</span>

    def st_equals(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L317">      udfToColumn(ST_Equals, relationNames, left, right)</span>

    def st_intersects(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L320">      udfToColumn(ST_Intersects, relationNames, left, right)</span>

    def st_overlaps(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L323">      udfToColumn(ST_Overlaps, relationNames, left, right)</span>

    def st_touches(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L326">      udfToColumn(ST_Touches, relationNames, left, right)</span>

    def st_within(left: Column, right: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L329">      udfToColumn(ST_Within, relationNames, left, right)</span>

    def st_relate(left: Column, right: Column): TypedColumn[Any, String] =
<span class="nc" id="L332">      udfToColumn(ST_Relate, relationNames, left, right)</span>

    def st_relateBool(left: Column, right: Column, pattern: Column): TypedColumn[Any, jl.Boolean] =
<span class="nc" id="L335">      udfToColumn(ST_RelateBool, relationNames, left, right, pattern)</span>

    def st_area(geom: Column): TypedColumn[Any, jl.Double] =
<span class="nc" id="L338">      udfToColumn(ST_Area, relationNames, geom)</span>

    def st_closestPoint(left: Column, right: Column): TypedColumn[Any, Point] =
<span class="nc" id="L341">      udfToColumn(ST_ClosestPoint, relationNames, left, right)</span>

    def st_centroid(geom: Column): TypedColumn[Any, Point] =
<span class="nc" id="L344">      udfToColumn(ST_Centroid, relationNames, geom)</span>

    def st_distance(left: Column, right: Column): TypedColumn[Any, jl.Double] =
<span class="nc" id="L347">      udfToColumn(ST_Distance, relationNames, left, right)</span>

    def st_distanceSphere(left: Column, right: Column): TypedColumn[Any, jl.Double] =
<span class="nc" id="L350">      udfToColumn(ST_DistanceSphere, relationNames, left, right)</span>

    def st_length(geom: Column): TypedColumn[Any, jl.Double] =
<span class="nc" id="L353">      udfToColumn(ST_Length, relationNames, geom)</span>

    def st_aggregateDistanceSphere(geomSeq: Column): TypedColumn[Any, jl.Double] =
<span class="nc" id="L356">      udfToColumn(ST_AggregateDistanceSphere, relationNames, geomSeq)</span>

    def st_lengthSphere(line: Column): TypedColumn[Any, jl.Double] =
<span class="nc" id="L359">      udfToColumn(ST_LengthSphere, relationNames, line)</span>

    def st_intersection(geom1:Column, geom2:Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L362">      udfToColumn(ST_Intersection, relationNames, geom1, geom2)</span>

    def st_difference(geom1:Column, geom2:Column): TypedColumn[Any, Geometry] =
<span class="nc" id="L365">      udfToColumn(ST_Difference, relationNames, geom1, geom2)</span>
  }

  /** Stack of all DataFrame DSL functions. */
  trait Library extends SpatialConstructors
    with SpatialConverters
    with SpatialAccessors
    with SpatialOutputs
    with SpatialProcessors
    with SpatialRelations
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>