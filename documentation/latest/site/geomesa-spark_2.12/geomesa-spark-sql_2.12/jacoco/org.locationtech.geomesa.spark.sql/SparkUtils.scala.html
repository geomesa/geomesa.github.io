<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SparkUtils.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Spark SQL</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.spark.sql</a> &gt; <span class="el_source">SparkUtils.scala</span></div><h1>SparkUtils.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.spark.sql

import com.typesafe.scalalogging.LazyLogging
import org.apache.spark.sql.Row
import org.apache.spark.sql.catalyst.expressions.GenericRowWithSchema
import org.apache.spark.sql.jts.JTSTypes
import org.apache.spark.sql.sources._
import org.apache.spark.sql.types._
import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.FilterFactory
import org.geotools.factory.CommonFactoryFinder
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec.{ListAttributeSpec, MapAttributeSpec}
import org.locationtech.geomesa.utils.uuid.TimeSortedUuidGenerator

import java.sql.Timestamp
import java.util.Date

<span class="nc bnc" id="L30" title="All 4 branches missed.">object SparkUtils extends LazyLogging {</span>

  import scala.collection.JavaConverters._

  @transient
<span class="nc" id="L35">  val ff: FilterFactory = CommonFactoryFinder.getFilterFactory</span>

  // the SFT attributes do not have the __fid__ so we have to translate accordingly
  def getExtractors(requiredColumns: Array[String], schema: StructType): Array[SimpleFeature =&gt; AnyRef] = {
<span class="nc bnc" id="L39" title="All 6 branches missed.">    val requiredAttributes = requiredColumns.filterNot(_ == &quot;__fid__&quot;)</span>

    type EXTRACTOR = SimpleFeature =&gt; AnyRef
<span class="nc" id="L42">    val IdExtractor: SimpleFeature =&gt; AnyRef = sf =&gt; sf.getID</span>

<span class="nc" id="L44">    requiredColumns.map {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      case &quot;__fid__&quot; =&gt; IdExtractor</span>
      case col       =&gt;
<span class="nc" id="L47">        val index = requiredAttributes.indexOf(col)</span>
<span class="nc" id="L48">        val schemaIndex = schema.fieldIndex(col)</span>
<span class="nc" id="L49">        val fieldType = schema.fields(schemaIndex).dataType</span>
<span class="nc" id="L50">        fieldType match {</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">          case _: TimestampType =&gt;</span>
<span class="nc" id="L52">            sf: SimpleFeature =&gt; {</span>
<span class="nc" id="L53">              val attr = sf.getAttribute(index)</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">              if (attr == null) { null } else {</span>
<span class="nc" id="L55">                new Timestamp(attr.asInstanceOf[Date].getTime)</span>
              }
            }

<span class="nc bnc" id="L59" title="All 2 branches missed.">          case arrayType: ArrayType =&gt;</span>
<span class="nc" id="L60">            val elementType = arrayType.elementType</span>
<span class="nc" id="L61">            sf: SimpleFeature =&gt; {</span>
<span class="nc" id="L62">              val attr = sf.getAttribute(index)</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">              if (attr == null) { null } else {</span>
<span class="nc" id="L64">                val array = attr.asInstanceOf[java.util.List[_]].asScala.toList</span>
<span class="nc bnc" id="L65" title="All 6 branches missed.">                if (elementType != TimestampType) { array } else {</span>
<span class="nc" id="L66">                  array.map(d =&gt; new Timestamp(d.asInstanceOf[Date].getTime))</span>
                }
              }
            }

<span class="nc bnc" id="L71" title="All 2 branches missed.">          case mapType: MapType =&gt;</span>
<span class="nc" id="L72">            val keyType = mapType.keyType</span>
<span class="nc" id="L73">            val valueType = mapType.valueType</span>
<span class="nc" id="L74">            sf: SimpleFeature =&gt; {</span>
<span class="nc" id="L75">              val attr = sf.getAttribute(index)</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">              if (attr == null) { null } else {</span>
<span class="nc" id="L77">                val map = attr.asInstanceOf[java.util.Map[Any, Any]].asScala.toMap</span>
<span class="nc bnc" id="L78" title="All 12 branches missed.">                if (keyType != TimestampType &amp;&amp; valueType != TimestampType) { map } else {</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                  map.map {</span>
<span class="nc" id="L80">                    case (key, value) =&gt;</span>
<span class="nc bnc" id="L81" title="All 6 branches missed.">                      val newKey = if (keyType == TimestampType) {</span>
<span class="nc" id="L82">                        new Timestamp(key.asInstanceOf[Date].getTime)</span>
<span class="nc" id="L83">                      } else key</span>
<span class="nc bnc" id="L84" title="All 6 branches missed.">                      val newValue = if (valueType == TimestampType) {</span>
<span class="nc" id="L85">                        new Timestamp(value.asInstanceOf[Date].getTime)</span>
<span class="nc" id="L86">                      } else value</span>
<span class="nc" id="L87">                      (newKey, newValue)</span>
                  }
                }
              }
            }

<span class="nc" id="L93">          case _ =&gt; sf: SimpleFeature =&gt; sf.getAttribute(index)</span>
        }
    }
  }

<span class="nc" id="L98">  def sparkFilterToCQLFilter(filt: org.apache.spark.sql.sources.Filter): Option[org.geotools.api.filter.Filter] = filt match {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">    case GreaterThanOrEqual(attribute, v) =&gt; Some(ff.greaterOrEqual(ff.property(attribute), ff.literal(v)))</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">    case GreaterThan(attr, v)             =&gt; Some(ff.greater(ff.property(attr), ff.literal(v)))</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">    case LessThanOrEqual(attr, v)         =&gt; Some(ff.lessOrEqual(ff.property(attr), ff.literal(v)))</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">    case LessThan(attr, v)                =&gt; Some(ff.less(ff.property(attr), ff.literal(v)))</span>
<span class="nc bnc" id="L103" title="All 8 branches missed.">    case EqualTo(attr, v) if attr == &quot;__fid__&quot; =&gt; Some(ff.id(ff.featureId(v.toString)))</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">    case EqualTo(attr, v)                      =&gt; Some(ff.equals(ff.property(attr), ff.literal(v)))</span>
<span class="nc bnc" id="L105" title="All 8 branches missed.">    case In(attr, values) if attr == &quot;__fid__&quot; =&gt; Some(ff.id(values.map(v =&gt; ff.featureId(v.toString)).toSet.asJava))</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">    case In(attr, values)                      =&gt;</span>
<span class="nc" id="L107">      Some(values.map(v =&gt; ff.equals(ff.property(attr), ff.literal(v))).reduce[org.geotools.api.filter.Filter]( (l,r) =&gt; ff.or(l,r)))</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">    case And(left, right)                 =&gt; Some(ff.and(sparkFilterToCQLFilter(left).get, sparkFilterToCQLFilter(right).get)) // TODO: can these be null</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">    case Or(left, right)                  =&gt; Some(ff.or(sparkFilterToCQLFilter(left).get, sparkFilterToCQLFilter(right).get))</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">    case Not(f)                           =&gt; Some(ff.not(sparkFilterToCQLFilter(f).get))</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">    case StringStartsWith(a, v)           =&gt; Some(ff.like(ff.property(a), s&quot;$v%&quot;))</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">    case StringEndsWith(a, v)             =&gt; Some(ff.like(ff.property(a), s&quot;%$v&quot;))</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">    case StringContains(a, v)             =&gt; Some(ff.like(ff.property(a), s&quot;%$v%&quot;))</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">    case IsNull(attr)                     =&gt; None</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">    case IsNotNull(attr)                  =&gt; None</span>
  }

  def createFeatureType(name: String, struct: StructType): SimpleFeatureType = {
<span class="nc" id="L119">    val builder = new SimpleFeatureTypeBuilder</span>
<span class="nc" id="L120">    builder.setName(name)</span>

<span class="nc" id="L122">    def basicTypeBinding(dataType: DataType): Class[_] = dataType match {</span>
<span class="nc bnc" id="L123" title="All 6 branches missed.">      case DataTypes.StringType              =&gt; classOf[java.lang.String]</span>
<span class="nc bnc" id="L124" title="All 6 branches missed.">      case DataTypes.DateType                =&gt; classOf[java.util.Date]</span>
<span class="nc bnc" id="L125" title="All 6 branches missed.">      case DataTypes.TimestampType           =&gt; classOf[java.util.Date]</span>
<span class="nc bnc" id="L126" title="All 6 branches missed.">      case DataTypes.IntegerType             =&gt; classOf[java.lang.Integer]</span>
<span class="nc bnc" id="L127" title="All 6 branches missed.">      case DataTypes.LongType                =&gt; classOf[java.lang.Long]</span>
<span class="nc bnc" id="L128" title="All 6 branches missed.">      case DataTypes.FloatType               =&gt; classOf[java.lang.Float]</span>
<span class="nc bnc" id="L129" title="All 6 branches missed.">      case DataTypes.DoubleType              =&gt; classOf[java.lang.Double]</span>
<span class="nc bnc" id="L130" title="All 6 branches missed.">      case DataTypes.BooleanType             =&gt; classOf[java.lang.Boolean]</span>
<span class="nc bnc" id="L131" title="All 6 branches missed.">      case DataTypes.BinaryType              =&gt; classOf[Array[Byte]]</span>
<span class="nc" id="L132">      case _                                 =&gt; null</span>
    }

<span class="nc" id="L135">    def geomTypeBinding(dataType: DataType): Class[_] = dataType match {</span>
<span class="nc bnc" id="L136" title="All 6 branches missed.">      case JTSTypes.PointTypeInstance        =&gt; classOf[org.locationtech.jts.geom.Point]</span>
<span class="nc bnc" id="L137" title="All 6 branches missed.">      case JTSTypes.MultiPointTypeInstance   =&gt; classOf[org.locationtech.jts.geom.MultiPoint]</span>
<span class="nc bnc" id="L138" title="All 6 branches missed.">      case JTSTypes.LineStringTypeInstance   =&gt; classOf[org.locationtech.jts.geom.LineString]</span>
<span class="nc bnc" id="L139" title="All 6 branches missed.">      case JTSTypes.MultiLineStringTypeInstance =&gt; classOf[org.locationtech.jts.geom.MultiLineString]</span>
<span class="nc bnc" id="L140" title="All 6 branches missed.">      case JTSTypes.PolygonTypeInstance      =&gt; classOf[org.locationtech.jts.geom.Polygon]</span>
<span class="nc bnc" id="L141" title="All 6 branches missed.">      case JTSTypes.MultipolygonTypeInstance =&gt; classOf[org.locationtech.jts.geom.MultiPolygon]</span>
<span class="nc bnc" id="L142" title="All 6 branches missed.">      case JTSTypes.GeometryCollectionTypeInstance =&gt; classOf[org.locationtech.jts.geom.GeometryCollection]</span>
<span class="nc bnc" id="L143" title="All 6 branches missed.">      case JTSTypes.GeometryTypeInstance     =&gt; classOf[org.locationtech.jts.geom.Geometry]</span>
<span class="nc" id="L144">      case _                                 =&gt; null</span>
    }

<span class="nc bnc" id="L147" title="All 6 branches missed.">    struct.fields.filter(_.name != &quot;__fid__&quot;).foreach { field =&gt;</span>
<span class="nc" id="L148">      field.dataType match {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        case ArrayType(elementType, _) =&gt;</span>
<span class="nc" id="L150">          val elementBinding = basicTypeBinding(elementType)</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">          if (elementBinding == null) {</span>
<span class="nc" id="L152">            throw new IllegalArgumentException(</span>
<span class="nc" id="L153">              s&quot;list element in field ${field.name} is not basic type: ${elementType.typeName}&quot;)</span>
          }
<span class="nc" id="L155">          val attributeSpec = ListAttributeSpec(field.name, elementBinding, Map.empty)</span>
<span class="nc" id="L156">          builder.add(attributeSpec.toDescriptor)</span>

<span class="nc bnc" id="L158" title="All 2 branches missed.">        case MapType(keyType, valueType, _) =&gt;</span>
<span class="nc" id="L159">          val keyBinding = basicTypeBinding(keyType)</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">          if (keyBinding == null) {</span>
<span class="nc" id="L161">            throw new IllegalArgumentException(</span>
<span class="nc" id="L162">              s&quot;map key in field ${field.name} is not basic type: ${keyType.typeName}&quot;)</span>
          }
<span class="nc" id="L164">          val valueBinding = basicTypeBinding(valueType)</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">          if (valueBinding == null) {</span>
<span class="nc" id="L166">            throw new IllegalArgumentException(</span>
<span class="nc" id="L167">              s&quot;map value in field ${field.name} is not basic type: ${valueType.typeName}&quot;)</span>
          }
<span class="nc" id="L169">          val attributeSpec = MapAttributeSpec(field.name, keyBinding, valueBinding, Map.empty)</span>
<span class="nc" id="L170">          builder.add(attributeSpec.toDescriptor)</span>

        case _ =&gt;
<span class="nc" id="L173">          var binding = basicTypeBinding(field.dataType)</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">          if (binding == null) binding = geomTypeBinding(field.dataType)</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">          if (binding == null) {</span>
<span class="nc" id="L176">            throw new IllegalArgumentException(</span>
<span class="nc" id="L177">              s&quot;Unexpected data type for field ${field.name}: ${field.dataType.typeName}&quot;)</span>
          }
<span class="nc" id="L179">          builder.add(field.name, binding)</span>
      }
    }

<span class="nc" id="L183">    builder.buildFeatureType()</span>
  }

  def createStructType(sft: SimpleFeatureType): StructType = {
<span class="nc" id="L187">    val fields = sft.getAttributeDescriptors.asScala.flatMap(createStructField).toList</span>
<span class="nc" id="L188">    StructType(StructField(&quot;__fid__&quot;, DataTypes.StringType, nullable = false) :: fields)</span>
  }

  private def createStructField(ad: AttributeDescriptor): Option[StructField] = {
    def basicTypeToSQLType(bindings: Seq[ObjectType.ObjectType]): Option[DataType] = {
<span class="nc" id="L193">      bindings.head match {</span>
<span class="nc bnc" id="L194" title="All 6 branches missed.">        case ObjectType.STRING   =&gt; Some(DataTypes.StringType)</span>
<span class="nc bnc" id="L195" title="All 6 branches missed.">        case ObjectType.INT      =&gt; Some(DataTypes.IntegerType)</span>
<span class="nc bnc" id="L196" title="All 6 branches missed.">        case ObjectType.LONG     =&gt; Some(DataTypes.LongType)</span>
<span class="nc bnc" id="L197" title="All 6 branches missed.">        case ObjectType.FLOAT    =&gt; Some(DataTypes.FloatType)</span>
<span class="nc bnc" id="L198" title="All 6 branches missed.">        case ObjectType.DOUBLE   =&gt; Some(DataTypes.DoubleType)</span>
<span class="nc bnc" id="L199" title="All 6 branches missed.">        case ObjectType.BOOLEAN  =&gt; Some(DataTypes.BooleanType)</span>
<span class="nc bnc" id="L200" title="All 6 branches missed.">        case ObjectType.DATE     =&gt; Some(DataTypes.TimestampType)</span>
<span class="nc bnc" id="L201" title="All 6 branches missed.">        case ObjectType.BYTES    =&gt; Some(DataTypes.BinaryType)</span>
<span class="nc bnc" id="L202" title="All 6 branches missed.">        case ObjectType.UUID     =&gt; None // not supported</span>
<span class="nc" id="L203">        case _                   =&gt; None // not basic type</span>
      }
    }

    def geomTypeToSQLType(bindings: Seq[ObjectType.ObjectType]): DataType = {
<span class="nc" id="L208">      bindings.last match {</span>
<span class="nc bnc" id="L209" title="All 6 branches missed.">        case ObjectType.POINT               =&gt; JTSTypes.PointTypeInstance</span>
<span class="nc bnc" id="L210" title="All 6 branches missed.">        case ObjectType.LINESTRING          =&gt; JTSTypes.LineStringTypeInstance</span>
<span class="nc bnc" id="L211" title="All 6 branches missed.">        case ObjectType.POLYGON             =&gt; JTSTypes.PolygonTypeInstance</span>
<span class="nc bnc" id="L212" title="All 6 branches missed.">        case ObjectType.MULTIPOINT          =&gt; JTSTypes.MultiPointTypeInstance</span>
<span class="nc bnc" id="L213" title="All 6 branches missed.">        case ObjectType.MULTILINESTRING     =&gt; JTSTypes.MultiLineStringTypeInstance</span>
<span class="nc bnc" id="L214" title="All 6 branches missed.">        case ObjectType.MULTIPOLYGON        =&gt; JTSTypes.MultipolygonTypeInstance</span>
<span class="nc bnc" id="L215" title="All 6 branches missed.">        case ObjectType.GEOMETRY_COLLECTION =&gt; JTSTypes.GeometryCollectionTypeInstance</span>
<span class="nc" id="L216">        case _                              =&gt; JTSTypes.GeometryTypeInstance</span>
      }
    }

    def listTypeToSQLType(bindings: Seq[ObjectType.ObjectType]): Option[DataType] =
<span class="nc" id="L221">      basicTypeToSQLType(bindings.tail).map(ArrayType(_))</span>

    def mapTypeToSQLType(bindings: Seq[ObjectType.ObjectType]): Option[DataType] = {
<span class="nc bnc" id="L224" title="All 2 branches missed.">      (basicTypeToSQLType(bindings.tail), basicTypeToSQLType(bindings.tail.tail)) match {</span>
<span class="nc bnc" id="L225" title="All 4 branches missed.">        case (Some(keyType), Some(valueType)) =&gt; Some(MapType(keyType, valueType))</span>
<span class="nc" id="L226">        case _ =&gt; None</span>
      }
    }

<span class="nc" id="L230">    val bindings = ObjectType.selectType(ad)</span>
<span class="nc" id="L231">    val dt = bindings.head match {</span>
<span class="nc bnc" id="L232" title="All 8 branches missed.">      case ObjectType.STRING   |</span>
<span class="nc bnc" id="L233" title="All 6 branches missed.">           ObjectType.INT      |</span>
<span class="nc bnc" id="L234" title="All 6 branches missed.">           ObjectType.LONG     |</span>
<span class="nc bnc" id="L235" title="All 6 branches missed.">           ObjectType.FLOAT    |</span>
<span class="nc bnc" id="L236" title="All 6 branches missed.">           ObjectType.DOUBLE   |</span>
<span class="nc bnc" id="L237" title="All 6 branches missed.">           ObjectType.BOOLEAN  |</span>
<span class="nc bnc" id="L238" title="All 6 branches missed.">           ObjectType.DATE     |</span>
<span class="nc bnc" id="L239" title="All 6 branches missed.">           ObjectType.UUID     |</span>
<span class="nc bnc" id="L240" title="All 6 branches missed.">           ObjectType.BYTES    =&gt; basicTypeToSQLType(bindings)</span>
<span class="nc bnc" id="L241" title="All 6 branches missed.">      case ObjectType.LIST     =&gt; listTypeToSQLType(bindings)</span>
<span class="nc bnc" id="L242" title="All 6 branches missed.">      case ObjectType.MAP      =&gt; mapTypeToSQLType(bindings)</span>
<span class="nc bnc" id="L243" title="All 6 branches missed.">      case ObjectType.GEOMETRY =&gt; Some(geomTypeToSQLType(bindings))</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">      case _ =&gt; logger.warn(s&quot;Unexpected bindings for descriptor $ad: ${bindings.mkString(&quot;, &quot;)}&quot;); None</span>
    }
<span class="nc" id="L246">    dt.map(StructField(ad.getLocalName, _))</span>
  }

  /**
    * Creates a function to convert a row to a simple feature. Columns will be mapped to attributes based on
    * matching names.
    *
    * If the row has a `__fid__` column, it will be used for the feature id. Otherwise, it will
    * use a random id prefixed with the current time
    *
    * @param sft simple feature type
    * @param schema dataframe schema
    * @return
    */
  def rowsToFeatures(sft: SimpleFeatureType, schema: StructType): SimpleFeatureRowMapping = {
<span class="nc" id="L261">    val mappings = Seq.tabulate(sft.getAttributeCount) { i =&gt;</span>
<span class="nc" id="L262">      val descriptor = sft.getDescriptor(i)</span>
<span class="nc" id="L263">      val binding = descriptor.getType.getBinding</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">      val needConversion = (classOf[java.util.List[_]].isAssignableFrom(binding) ||</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        classOf[java.util.Map[_, _]].isAssignableFrom(binding))</span>
<span class="nc" id="L266">      (i, schema.fieldIndex(descriptor.getLocalName), needConversion)</span>
    }
<span class="nc bnc" id="L268" title="All 8 branches missed.">    val fid: Row =&gt; String = schema.fields.indexWhere(_.name == &quot;__fid__&quot;) match {</span>
<span class="nc" id="L269">      case -1 =&gt; _ =&gt; TimeSortedUuidGenerator.createUuid().toString</span>
<span class="nc" id="L270">      case i  =&gt; r =&gt; r.getString(i)</span>
    }
<span class="nc" id="L272">    SimpleFeatureRowMapping(sft, mappings, fid)</span>
  }

  /**
    * Creates a function to convert a row to a simple feature, which will be based on the columns in
    * the row schema.
    *
    * If the row has a `__fid__` column, it will be used for the feature id. Otherwise, it will
    * use a random id prefixed with the current time
    *
    * @param name simple feature type name to use
    * @param schema row schema
    * @return
    */
  def rowsToFeatures(name: String, schema: StructType): SimpleFeatureRowMapping =
<span class="nc" id="L287">    rowsToFeatures(createFeatureType(name, schema), schema)</span>

  def sf2row(schema: StructType, sf: SimpleFeature, extractors: Array[SimpleFeature =&gt; AnyRef]): Row = {
<span class="nc" id="L290">    val res = Array.ofDim[Any](extractors.length)</span>
<span class="nc" id="L291">    var i = 0</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">    while(i &lt; extractors.length) {</span>
<span class="nc" id="L293">      res(i) = extractors(i)(sf)</span>
<span class="nc" id="L294">      i += 1</span>
    }
<span class="nc" id="L296">    new GenericRowWithSchema(res, schema)</span>
  }

  def joinedSf2row(schema: StructType, sf1: SimpleFeature, sf2: SimpleFeature, extractors: Array[SimpleFeature =&gt; AnyRef]): Row = {
<span class="nc" id="L300">    val leftLength = sf1.getAttributeCount + 1</span>
<span class="nc" id="L301">    val res = Array.ofDim[Any](extractors.length)</span>
<span class="nc" id="L302">    var i = 0</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    while(i &lt; leftLength) {</span>
<span class="nc" id="L304">      res(i) = extractors(i)(sf1)</span>
<span class="nc" id="L305">      i += 1</span>
    }
<span class="nc bnc" id="L307" title="All 2 branches missed.">    while(i &lt; extractors.length) {</span>
<span class="nc" id="L308">      res(i) = extractors(i)(sf2)</span>
<span class="nc" id="L309">      i += 1</span>
    }
<span class="nc" id="L311">    new GenericRowWithSchema(res, schema)</span>
  }

<span class="nc bnc" id="L314" title="All 32 branches missed.">  case class SimpleFeatureRowMapping(sft: SimpleFeatureType, mappings: Seq[(Int, Int, Boolean)], id: Row =&gt; String) {</span>
    def apply(row: Row): SimpleFeature = {
<span class="nc" id="L316">      val feature = new ScalaSimpleFeature(sft, id(row))</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">      mappings.foreach { case (to, from, needConversion) =&gt;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (needConversion) feature.setAttribute(to, row.getAs[Object](from))</span>
<span class="nc" id="L319">        else feature.setAttributeNoConvert(to, row.getAs[Object](from))</span>
      }
<span class="nc" id="L321">      feature</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>