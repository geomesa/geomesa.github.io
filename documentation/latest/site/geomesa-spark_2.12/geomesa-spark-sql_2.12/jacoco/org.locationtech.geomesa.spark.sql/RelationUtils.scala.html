<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RelationUtils.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Spark SQL</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.spark.sql</a> &gt; <span class="el_source">RelationUtils.scala</span></div><h1>RelationUtils.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.spark.sql

import com.typesafe.scalalogging.LazyLogging
import org.apache.spark.rdd.RDD
import org.geotools.api.feature.simple.SimpleFeature
import org.geotools.api.filter.FilterFactory
import org.geotools.factory.CommonFactoryFinder
import org.locationtech.geomesa.spark.SpatialRDD
import org.locationtech.jts.geom.{Coordinate, Envelope, Geometry}
import org.locationtech.jts.index.strtree.{AbstractNode, Boundable, STRtree}

import scala.collection.mutable.ListBuffer

<span class="nc bnc" id="L22" title="All 4 branches missed.">object RelationUtils extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L26">  @transient val ff: FilterFactory = CommonFactoryFinder.getFilterFactory</span>

<span class="nc" id="L28">  implicit val CoordinateOrdering: Ordering[Coordinate] = Ordering.by {_.x}</span>

  def grid(rdd: SpatialRDD, envelopes: List[Envelope], parallelism: Int): RDD[(Int, Iterable[SimpleFeature])] = {
<span class="nc" id="L31">    val geom = rdd.schema.indexOf(rdd.schema.getGeometryDescriptor.getLocalName)</span>
<span class="nc" id="L32">    rdd.flatMap(RelationUtils.gridIdMapper(_, envelopes, geom)).groupByKey(new IndexPartitioner(parallelism))</span>
  }

  // Maps a SimpleFeature to the id of the envelope that contains it
  // Will duplicate features that belong to more than one envelope
  // Returns -1 if no match was found
  // TODO: Filter duplicates when querying
  def gridIdMapper(sf: SimpleFeature, envelopes: List[Envelope], geometryOrdinal: Int): List[(Int, SimpleFeature)] = {
<span class="nc" id="L40">    val geom = sf.getAttribute(geometryOrdinal).asInstanceOf[Geometry]</span>
<span class="nc" id="L41">    val mappings = envelopes.indices.flatMap { index =&gt;</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">      if (envelopes(index).intersects(geom.getEnvelopeInternal)) {</span>
<span class="nc" id="L43">        Some(index, sf)</span>
      } else {
<span class="nc" id="L45">        None</span>
      }
    }
<span class="nc bnc" id="L48" title="All 2 branches missed.">    if (mappings.isEmpty) {</span>
<span class="nc" id="L49">      List((-1, sf))</span>
    } else {
<span class="nc" id="L51">      mappings.toList</span>
    }
  }

  // Maps a geometry to the id of the envelope that contains it
  // Used to derive partition hints
  def gridIdMapper(geom: Geometry, envelopes: List[Envelope]): List[Int] = {
<span class="nc" id="L58">    val mappings = envelopes.indices.flatMap { index =&gt;</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">      if (envelopes(index).intersects(geom.getEnvelopeInternal)) {</span>
<span class="nc" id="L60">        Some(index)</span>
      } else {
<span class="nc" id="L62">        None</span>
      }
    }
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (mappings.isEmpty) {</span>
<span class="nc" id="L66">      List(-1)</span>
    } else {
<span class="nc" id="L68">      mappings.toList</span>
    }
  }

  def getBound(rdd: RDD[SimpleFeature]): Envelope = {
<span class="nc" id="L73">    rdd.aggregate[Envelope](new Envelope())(</span>
<span class="nc" id="L74">      (env: Envelope, sf: SimpleFeature) =&gt; {</span>
<span class="nc" id="L75">        env.expandToInclude(sf.getDefaultGeometry.asInstanceOf[Geometry].getEnvelopeInternal)</span>
<span class="nc" id="L76">        env</span>
      },
<span class="nc" id="L78">      (env1: Envelope, env2: Envelope) =&gt; {</span>
<span class="nc" id="L79">        env1.expandToInclude(env2)</span>
<span class="nc" id="L80">        env1</span>
      }
    )
  }

  def equalPartitioning(bound: Envelope, numPartitions: Int): List[Envelope] = {
    // Compute bounds of each partition
<span class="nc" id="L87">    val partitionsPerDim = Math.sqrt(numPartitions).toInt</span>
<span class="nc" id="L88">    val partitionWidth = bound.getWidth / partitionsPerDim</span>
<span class="nc" id="L89">    val partitionHeight = bound.getHeight / partitionsPerDim</span>
<span class="nc" id="L90">    val minX = bound.getMinX</span>
<span class="nc" id="L91">    val minY = bound.getMinY</span>
<span class="nc" id="L92">    val partitionEnvelopes: ListBuffer[Envelope] = ListBuffer()</span>

    // Build partitions
<span class="nc" id="L95">    for (xIndex &lt;- 0 until partitionsPerDim) {</span>
<span class="nc" id="L96">      val xPartitionStart = minX + (xIndex * partitionWidth)</span>
<span class="nc" id="L97">      val xPartitionEnd = xPartitionStart + partitionWidth</span>
<span class="nc" id="L98">      for (yIndex &lt;- 0 until partitionsPerDim) {</span>
<span class="nc" id="L99">        val yPartitionStart = minY + (yIndex * partitionHeight)</span>
<span class="nc" id="L100">        val yPartitionEnd = yPartitionStart+ partitionHeight</span>
<span class="nc" id="L101">        partitionEnvelopes += new Envelope(xPartitionStart, xPartitionEnd, yPartitionStart, yPartitionEnd)</span>
      }
    }
<span class="nc" id="L104">    partitionEnvelopes.toList</span>
  }

  def weightedPartitioning(rawRDD: RDD[SimpleFeature], bound: Envelope, numPartitions: Int, sampleSize: Int): List[Envelope] = {
<span class="nc" id="L108">    val width: Int = Math.sqrt(numPartitions).toInt</span>
<span class="nc" id="L109">    val sample = rawRDD.takeSample(withReplacement = false, sampleSize)</span>
<span class="nc" id="L110">    val binSize = sample.length / width</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">    if (binSize &gt; 0)  {</span>
<span class="nc" id="L112">      val xSample = sample.map{f =&gt; f.getDefaultGeometry.asInstanceOf[Geometry].getCoordinates.min.x}</span>
<span class="nc" id="L113">      val ySample = sample.map{f =&gt; f.getDefaultGeometry.asInstanceOf[Geometry].getCoordinates.min.y}</span>
<span class="nc" id="L114">      val xSorted = xSample.sorted</span>
<span class="nc" id="L115">      val ySorted = ySample.sorted</span>
<span class="nc" id="L116">      val partitionEnvelopes: ListBuffer[Envelope] = ListBuffer()</span>
<span class="nc" id="L117">      for (xBin &lt;- 0 until width) {</span>
<span class="nc" id="L118">        val minX = xSorted(xBin * binSize)</span>
<span class="nc" id="L119">        val maxX = xSorted(math.min((xBin + 1) * binSize, xSorted.length - 1))</span>
<span class="nc" id="L120">        for (yBin &lt;- 0 until width) {</span>
<span class="nc" id="L121">          val minY = ySorted(yBin * binSize)</span>
<span class="nc" id="L122">          val maxY = ySorted(math.min((yBin + 1) * binSize, ySorted.length - 1))</span>
<span class="nc" id="L123">          partitionEnvelopes += new Envelope(minX, maxX, minY, maxY)</span>
        }
      }
<span class="nc" id="L126">      partitionEnvelopes.toList</span>
<span class="nc" id="L127">    } else List(bound)</span>
  }

  def wholeEarthPartitioning(numPartitions: Int): List[Envelope] = {
<span class="nc" id="L131">    equalPartitioning(new Envelope(-180,180,-90,90), numPartitions)</span>
  }

  // Constructs an RTree based on a sample of the data and returns its bounds as envelopes
  // returns one less envelope than requested to account for the catch-all envelope
  def rtreePartitioning(
      rawRDD: RDD[SimpleFeature],
      numPartitions: Int,
      sampleSize: Int,
      thresholdMultiplier: Double): List[Envelope] = {
<span class="nc" id="L141">    val sample = rawRDD.takeSample(withReplacement = false, sampleSize)</span>
<span class="nc" id="L142">    val rtree = new STRtree()</span>

<span class="nc" id="L144">    sample.foreach{ sf =&gt;</span>
<span class="nc" id="L145">      rtree.insert(sf.getDefaultGeometry.asInstanceOf[Geometry].getEnvelopeInternal, sf)</span>
    }
<span class="nc" id="L147">    val envelopes: java.util.List[Envelope] = new java.util.ArrayList[Envelope]()</span>

    // get rtree envelopes, limited to those containing reasonable size
<span class="nc" id="L150">    val reasonableSize = sampleSize / numPartitions</span>
<span class="nc" id="L151">    val threshold = (reasonableSize * thresholdMultiplier).toInt</span>
<span class="nc" id="L152">    val minSize = reasonableSize - threshold</span>
<span class="nc" id="L153">    val maxSize = reasonableSize + threshold</span>
<span class="nc" id="L154">    rtree.build()</span>
<span class="nc" id="L155">    queryBoundary(rtree.getRoot, envelopes, minSize, maxSize)</span>
<span class="nc" id="L156">    envelopes.asScala.take(numPartitions - 1).toList</span>
  }

  // Helper method to get the envelopes of an RTree
  def queryBoundary(node: AbstractNode, boundaries: java.util.List[Envelope], minSize: Int, maxSize: Int): Int =  {
    // get node's immediate children
<span class="nc" id="L162">    val childBoundables: java.util.List[_] = node.getChildBoundables</span>

    // True if current node is leaf
<span class="nc" id="L165">    var flagLeafnode = true</span>
<span class="nc" id="L166">    var i = 0</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">    while (i &lt; childBoundables.size &amp;&amp; flagLeafnode) {</span>
<span class="nc" id="L168">      val childBoundable = childBoundables.get(i).asInstanceOf[Boundable]</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">      if (childBoundable.isInstanceOf[AbstractNode]) {</span>
<span class="nc" id="L170">        flagLeafnode = false</span>
      }
<span class="nc" id="L172">      i += 1</span>
    }

<span class="nc bnc" id="L175" title="All 2 branches missed.">    if (flagLeafnode) {</span>
<span class="nc" id="L176">      childBoundables.size</span>
    } else {
<span class="nc" id="L178">      var nodeCount = 0</span>
<span class="nc" id="L179">      for ( i &lt;- 0 until childBoundables.size ) {</span>
<span class="nc" id="L180">        val childBoundable = childBoundables.get(i).asInstanceOf[Boundable]</span>
<span class="nc" id="L181">        childBoundable match {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">          case child: AbstractNode =&gt;</span>
<span class="nc" id="L183">            val childSize = queryBoundary(child, boundaries, minSize, maxSize)</span>
            // check boundary for size and existence in chosen boundaries
<span class="nc bnc" id="L185" title="All 4 branches missed.">            if (childSize &lt; maxSize &amp;&amp; childSize &gt; minSize) {</span>
<span class="nc" id="L186">              var alreadyAdded = false</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">              if (node.getLevel != 1) {</span>
<span class="nc" id="L188">                child.getChildBoundables.asInstanceOf[java.util.List[AbstractNode]].asScala.foreach { c =&gt;</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">                  alreadyAdded = alreadyAdded || boundaries.contains(c.getBounds.asInstanceOf[Envelope])</span>
                }
              }
<span class="nc bnc" id="L192" title="All 2 branches missed.">              if (!alreadyAdded) {</span>
<span class="nc" id="L193">                boundaries.add(child.getBounds.asInstanceOf[Envelope])</span>
              }
            }
<span class="nc" id="L196">            nodeCount += childSize</span>

<span class="nc" id="L198">          case _ =&gt; nodeCount += 1 // negligible difference but accurate</span>
        }
      }
<span class="nc" id="L201">      nodeCount</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>