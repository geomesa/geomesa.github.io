<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConverterSpatialRDDProvider.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Spark Converter RDD Provider</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.spark.converter</a> &gt; <span class="el_source">ConverterSpatialRDDProvider.scala</span></div><h1>ConverterSpatialRDDProvider.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.spark.converter

import com.typesafe.config.{ConfigFactory, ConfigRenderOptions}
import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.io.LongWritable
import org.apache.hadoop.mapreduce.Job
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat
import org.apache.spark.SparkContext
import org.apache.spark.rdd.RDD
import org.geotools.api.data.Query
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.convert.ConverterConfigLoader
import org.locationtech.geomesa.convert2.SimpleFeatureConverter
import org.locationtech.geomesa.jobs.mapreduce.ConverterInputFormat
import org.locationtech.geomesa.spark.{SpatialRDD, SpatialRDDProvider}
import org.locationtech.geomesa.utils.geotools.{SftArgResolver, SftArgs, SimpleFeatureTypeLoader}

import scala.collection.JavaConverters._
import scala.util.control.NonFatal

/**
  * Takes files as inputs and runs them through a SimpleFeatureConverter
  *
  * Parameters:
  *   ``geomesa.converter`` - converter definition as typesafe config string
  *   ``geomesa.converter.inputs`` - input file paths, comma-delimited
  *   ``geomesa.sft`` - simple feature type, as spec string, config string, or environment lookup
  *   ``geomesa.sft.name`` - (optional) simple feature type name
  *   ``geomesa.ingest.type`` Alternative to giving the geomesa.converter and geomesa.sft values:
  *      This option requires that the Converter and SFT can be looked up on this provider's classpath.
  */
<span class="nc bnc" id="L44" title="All 4 branches missed.">class ConverterSpatialRDDProvider extends SpatialRDDProvider with LazyLogging {</span>

  import ConverterSpatialRDDProvider._

  override def canProcess(params: java.util.Map[String, _]): Boolean =
<span class="nc bnc" id="L49" title="All 4 branches missed.">    ((params.containsKey(ConverterKey) &amp;&amp; params.containsKey(SftKey))</span>
<span class="nc bnc" id="L50" title="All 4 branches missed.">      || params.containsKey(IngestTypeKey)) &amp;&amp; params.containsKey(InputFilesKey)</span>

  override def rdd(conf: Configuration,
                   sc: SparkContext,
                   params: Map[String, String],
                   query: Query): SpatialRDD = {
<span class="nc" id="L56">    val sft = loadSft(params, query.getTypeName)</span>
<span class="nc" id="L57">    val converterConf = loadConverter(sft, params)</span>

<span class="nc" id="L59">    ConverterInputFormat.setConverterConfig(conf, converterConf)</span>
<span class="nc" id="L60">    ConverterInputFormat.setSft(conf, sft)</span>
    // note: file input format requires a job object, but conf gets copied in job object creation,
    // so we have to copy the file paths back out
<span class="nc" id="L63">    val job = Job.getInstance(conf)</span>
<span class="nc" id="L64">    FileInputFormat.setInputPaths(job, params(InputFilesKey))</span>
<span class="nc" id="L65">    conf.set(FileInputFormat.INPUT_DIR, job.getConfiguration.get(FileInputFormat.INPUT_DIR))</span>
<span class="nc" id="L66">    val queryProperties = query.getPropertyNames</span>
<span class="nc" id="L67">    val sftProperties = sft.getAttributeDescriptors.asScala.map{_.getLocalName}</span>
<span class="nc bnc" id="L68" title="All 10 branches missed.">    if (queryProperties != null &amp;&amp; queryProperties.nonEmpty &amp;&amp; sftProperties != queryProperties.toSeq) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">      logger.debug(&quot;Query transform retyping results&quot;)</span>
<span class="nc" id="L70">      val modifiedSft = SimpleFeatureTypeBuilder.retype(sft, query.getPropertyNames: _*)</span>
<span class="nc" id="L71">      ConverterInputFormat.setRetypeSft(conf, modifiedSft)</span>
    }

<span class="nc bnc" id="L74" title="All 8 branches missed.">    if (query.getFilter != null &amp;&amp; query.getFilter != Filter.INCLUDE) {</span>
<span class="nc" id="L75">      ConverterInputFormat.setFilter(conf, ECQL.toCQL(query.getFilter))</span>
    }

<span class="nc" id="L78">    val rdd = sc.newAPIHadoopRDD(conf, classOf[ConverterInputFormat], classOf[LongWritable], classOf[SimpleFeature])</span>
<span class="nc" id="L79">    SpatialRDD(rdd.map(_._2), sft)</span>
  }

  override def sft(params: Map[String, String], typeName: String): Option[SimpleFeatureType] =
<span class="nc" id="L83">    Option(loadSft(params, typeName))</span>

  override def save(rdd: RDD[SimpleFeature], writeDataStoreParams: Map[String, String], writeTypeName: String): Unit =
<span class="nc" id="L86">    throw new UnsupportedOperationException(&quot;Converter provider is read-only&quot;)</span>

  private def loadSft(params: Map[String, String], typeName: String): SimpleFeatureType = {
<span class="nc" id="L89">    params.get(IngestTypeKey) match {</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">      case Some(sftName) =&gt;</span>
        // NB: Here we assume that the SFT name and Converter name match. (And there is no option to rename the SFT.)
        //  Further, it is assumed that they can loaded from the classpath.
<span class="nc" id="L93">        SimpleFeatureTypeLoader.sftForName(sftName).getOrElse {</span>
<span class="nc" id="L94">          throw new IllegalArgumentException(s&quot;Could not resolve Simple Feature Type by name for $sftName.&quot;)</span>
        }

<span class="nc bnc" id="L97" title="All 2 branches missed.">      case None =&gt;</span>
        // This is the general case where the SFT and Converter config strings are given.
<span class="nc" id="L99">        val sftName = params.get(FeatureNameKey).orElse(Option(typeName)).orNull</span>

<span class="nc" id="L101">        SftArgResolver.getArg(SftArgs(params(SftKey), sftName)) match {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">          case Right(s) =&gt; s</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">          case Left(e) =&gt; throw new IllegalArgumentException(&quot;Could not resolve simple feature type&quot;, e)</span>
        }
    }
  }

  // TODO:  Move the logic here and in the next function to utils (aka somewhere more general)
  //  GEOMESA-1644 Move logic to retrieve SFT/Converter config from classpath to utils
  private def loadConverter(sft: SimpleFeatureType, params: Map[String, String]): String = {
<span class="nc" id="L111">    params.get(IngestTypeKey) match {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">      case Some(sftName) =&gt;</span>
        // NB: Here we assume that the SFT name and Converter name match.  (And there is no option to rename the SFT.)
        //  Further, it is assumed that they can loaded from the classpath.
<span class="nc" id="L115">        val config = ConverterConfigLoader.confs.getOrElse(sftName,</span>
<span class="nc" id="L116">          throw new Exception(s&quot;Could not resolve Converter by name for $sftName.&quot;))</span>

        // Verify the config before returning.
<span class="nc" id="L119">        try { SimpleFeatureConverter(sft, config).close() } catch {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">          case NonFatal(e) =&gt; throw new IllegalArgumentException(&quot;Could not resolve converter&quot;, e)</span>
        }

<span class="nc" id="L123">        config.root().render(ConfigRenderOptions.concise())</span>

<span class="nc bnc" id="L125" title="All 2 branches missed.">      case None =&gt;</span>
<span class="nc" id="L126">        val config = params(ConverterKey)</span>
        // Verify the config before returning.
<span class="nc" id="L128">        try { SimpleFeatureConverter(sft, ConfigFactory.parseString(config)).close() } catch {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">          case NonFatal(e) =&gt; throw new IllegalArgumentException(&quot;Could not resolve converter&quot;, e)</span>
        }
<span class="nc" id="L131">        config</span>
    }
  }
}

<span class="nc" id="L136">object ConverterSpatialRDDProvider {</span>
  // converter definition as typesafe config string
<span class="nc" id="L138">  val ConverterKey     = &quot;geomesa.converter&quot;</span>
  // simple feature type name (optional)
<span class="nc" id="L140">  val FeatureNameKey   = &quot;geomesa.sft.name&quot;</span>
  // input file paths, comma-delimited
<span class="nc" id="L142">  val InputFilesKey    = &quot;geomesa.converter.inputs&quot;</span>
  // simple feature type, as spec string, config string, or environment lookup
<span class="nc" id="L144">  val SftKey           = &quot;geomesa.sft&quot;</span>
  // Converter name (to be looked up from the classpath).
<span class="nc" id="L146">  val IngestTypeKey = &quot;geomesa.ingest.type&quot;</span>
<span class="nc" id="L147">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>