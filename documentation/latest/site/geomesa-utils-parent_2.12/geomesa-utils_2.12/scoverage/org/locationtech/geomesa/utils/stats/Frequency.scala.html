<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          org/locationtech/geomesa/utils/stats/Frequency.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier, monospace;'>1 <span style=''>/***********************************************************************
</span>2 <span style=''> * Copyright (c) 2013-2025 Commonwealth Computer Research, Inc.
</span>3 <span style=''> * All rights reserved. This program and the accompanying materials
</span>4 <span style=''> * are made available under the terms of the Apache License, Version 2.0
</span>5 <span style=''> * which accompanies this distribution and is available at
</span>6 <span style=''> * http://www.opensource.org/licenses/apache2.0.php.
</span>7 <span style=''> ***********************************************************************/
</span>8 <span style=''>
</span>9 <span style=''>package org.locationtech.geomesa.utils.stats
</span>10 <span style=''>
</span>11 <span style=''>import com.clearspring.analytics.stream.frequency.IFrequency
</span>12 <span style=''>import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
</span>13 <span style=''>import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
</span>14 <span style=''>import org.locationtech.geomesa.curve.{BinnedTime, Z2SFC}
</span>15 <span style=''>import org.locationtech.geomesa.utils.clearspring.CountMinSketch
</span>16 <span style=''>import org.locationtech.geomesa.zorder.sfcurve.IndexRange
</span>17 <span style=''>import org.locationtech.jts.geom.Geometry
</span>18 <span style=''>
</span>19 <span style=''>import java.util.{Date, Locale}
</span>20 <span style=''>import scala.collection.immutable.ListMap
</span>21 <span style=''>import scala.reflect.ClassTag
</span>22 <span style=''>
</span>23 <span style=''>/**
</span>24 <span style=''>  *  Estimates frequency counts at scale
</span>25 <span style=''>  *
</span>26 <span style=''>  * @param sft simple feature type
</span>27 <span style=''>  * @param property attribute the sketch is being made for
</span>28 <span style=''>  * @param dtg primary date attribute of the sft, if there is one
</span>29 <span style=''>  * @param period time period to use for splitting by date
</span>30 <span style=''>  * @param eps (epsilon) with probability at least @see confidence, estimates will be within eps * N
</span>31 <span style=''>  * @param confidence percent - with probability at least confidence, estimates will be within @see eps * N
</span>32 <span style=''>  * @param precision for geometry types, this is the number of bits of z-index to keep (max of 64)
</span>33 <span style=''>  *                  (note: first 2 bits do not hold any info)
</span>34 <span style=''>  *                  for date types, this is the number of milliseconds to group for binning
</span>35 <span style=''>  *                  for number types, this is the number of digits that will be grouped together
</span>36 <span style=''>  *                  for floating point types, this is the number of decimal places that will be considered
</span>37 <span style=''>  *                  for string types, this is the number of characters that will be considered
</span>38 <span style=''>  * @param ct class tag
</span>39 <span style=''>  * @tparam T type parameter, should match the type binding of the attribute
</span>40 <span style=''>  */
</span>41 <span style=''>class Frequency[T](
</span>42 <span style=''>    val sft: SimpleFeatureType,
</span>43 <span style=''>    val property: String,
</span>44 <span style=''>    val dtg: Option[String],
</span>45 <span style=''>    val period: TimePeriod,
</span>46 <span style=''>    val precision: Int,
</span>47 <span style=''>    val eps: Double = 0.005,
</span>48 <span style=''>    val confidence: Double = 0.95
</span>49 <span style=''>  )(
</span>50 <span style=''>    implicit val ct: ClassTag[T]
</span>51 <span style=''>  ) extends Stat {
</span>52 <span style=''>
</span>53 <span style=''>  override type S = Frequency[T]
</span>54 <span style=''>
</span>55 <span style=''>  private val i = </span><span style='background: #AEF1AE'>sft.indexOf(property)</span><span style=''>
</span>56 <span style=''>  private val d = </span><span style='background: #AEF1AE'>dtg.map(sft.indexOf).getOrElse(-1)</span><span style=''>
</span>57 <span style=''>
</span>58 <span style=''>  private [stats] val sketchMap = </span><span style='background: #AEF1AE'>scala.collection.mutable.Map.empty[Short, CountMinSketch]</span><span style=''>
</span>59 <span style=''>  private [stats] def newSketch = </span><span style='background: #AEF1AE'>CountMinSketch(eps, confidence, Frequency.Seed)</span><span style=''>
</span>60 <span style=''>  private val timeToBin = </span><span style='background: #AEF1AE'>BinnedTime.timeToBinnedTime(period)</span><span style=''>
</span>61 <span style=''>
</span>62 <span style=''>  private val addAttribute = </span><span style='background: #AEF1AE'>Frequency.add[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span><span style=''>
</span>63 <span style=''>  private val getCount = </span><span style='background: #AEF1AE'>Frequency.count[T](ct.runtimeClass.asInstanceOf[Class[T]], precision)</span><span style=''>
</span>64 <span style=''>
</span>65 <span style=''>  /**
</span>66 <span style=''>    * Gets the time bins covered by this frequency
</span>67 <span style=''>    *
</span>68 <span style=''>    * @return
</span>69 <span style=''>    */
</span>70 <span style=''>  def timeBins: Seq[Short] = </span><span style='background: #F0ADAD'>sketchMap.keys.toSeq.sorted</span><span style=''>
</span>71 <span style=''>
</span>72 <span style=''>  /**
</span>73 <span style=''>    * Gets the count for a given value, across all time bins
</span>74 <span style=''>    *
</span>75 <span style=''>    * @param value value to consider
</span>76 <span style=''>    * @return count of the value
</span>77 <span style=''>    */
</span>78 <span style=''>  def count(value: T): Long = if (</span><span style='background: #AEF1AE'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #AEF1AE'>sketchMap.values.map(getCount(_, value)).sum</span><span style=''> }
</span>79 <span style=''>
</span>80 <span style=''>  /**
</span>81 <span style=''>    * Gets the count for a given value in a particular time bin
</span>82 <span style=''>    *
</span>83 <span style=''>    * @param timeBin period since the epoch
</span>84 <span style=''>    * @param value value to consider
</span>85 <span style=''>    * @return count of the value
</span>86 <span style=''>    */
</span>87 <span style=''>  def count(timeBin: Short, value: T): Long = </span><span style='background: #AEF1AE'>sketchMap.get(timeBin).map(getCount(_, value)).getOrElse(0L)</span><span style=''>
</span>88 <span style=''>
</span>89 <span style=''>  /**
</span>90 <span style=''>    * Gets the count for a given value, which has already been converted into a string, across all time bins.
</span>91 <span style=''>    * Useful if you know the string key space ahead of time.
</span>92 <span style=''>    *
</span>93 <span style=''>    * @param value value to consider, converted into an appropriate string key
</span>94 <span style=''>    * @return count of the value
</span>95 <span style=''>    */
</span>96 <span style=''>  def countDirect(value: String): Long =
</span>97 <span style=''>    if (</span><span style='background: #F0ADAD'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #F0ADAD'>sketchMap.values.map(_.estimateCount(value)).sum</span><span style=''> }
</span>98 <span style=''>
</span>99 <span style=''>  /**
</span>100 <span style=''>    * Gets the count for a given value, which has already been converted into a string. Useful
</span>101 <span style=''>    * if you know the string key space ahead of time.
</span>102 <span style=''>    *
</span>103 <span style=''>    * @param timeBin period since the epoch
</span>104 <span style=''>    * @param value value to consider, converted into an appropriate string key
</span>105 <span style=''>    * @return count of the value
</span>106 <span style=''>    */
</span>107 <span style=''>  def countDirect(timeBin: Short, value: String): Long =
</span>108 <span style=''>    </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span><span style=''>
</span>109 <span style=''>
</span>110 <span style=''>  /**
</span>111 <span style=''>    * Gets the count for a given value, which has already been converted into a long, across all time bins.
</span>112 <span style=''>    * Useful if you know the long key space ahead of time (e.g. with z-values).
</span>113 <span style=''>    *
</span>114 <span style=''>    * @param value value to consider, converted into an appropriate long key
</span>115 <span style=''>    * @return count of the value
</span>116 <span style=''>    */
</span>117 <span style=''>  def countDirect(value: Long): Long =
</span>118 <span style=''>    if (</span><span style='background: #F0ADAD'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #F0ADAD'>0L</span><span style=''> } else { </span><span style='background: #F0ADAD'>sketchMap.values.map(_.estimateCount(value)).sum</span><span style=''> }
</span>119 <span style=''>
</span>120 <span style=''>  /**
</span>121 <span style=''>    * Gets the count for a given value, which has already been converted into a long. Useful
</span>122 <span style=''>    * if you know the long key space ahead of time (e.g. with z-values).
</span>123 <span style=''>    *
</span>124 <span style=''>    * @param timeBin period since the epoch
</span>125 <span style=''>    * @param value value to consider, converted into an appropriate long key
</span>126 <span style=''>    * @return count of the value
</span>127 <span style=''>    */
</span>128 <span style=''>  def countDirect(timeBin: Short, value: Long): Long =
</span>129 <span style=''>    </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.estimateCount(value)).getOrElse(0L)</span><span style=''>
</span>130 <span style=''>
</span>131 <span style=''>  /**
</span>132 <span style=''>    * Number of observations in the frequency map
</span>133 <span style=''>    *
</span>134 <span style=''>    * @return number of observations
</span>135 <span style=''>    */
</span>136 <span style=''>  def size: Long = if (</span><span style='background: #AEF1AE'>sketchMap.isEmpty</span><span style=''>) { </span><span style='background: #AEF1AE'>0L</span><span style=''> } else { </span><span style='background: #AEF1AE'>sketchMap.values.map(_.size).sum</span><span style=''> }
</span>137 <span style=''>
</span>138 <span style=''>  /**
</span>139 <span style=''>    * Number of observations in the frequency map
</span>140 <span style=''>    *
</span>141 <span style=''>    * @return number of observations
</span>142 <span style=''>    */
</span>143 <span style=''>  def size(timeBin: Short): Long = </span><span style='background: #F0ADAD'>sketchMap.get(timeBin).map(_.size).getOrElse(0L)</span><span style=''>
</span>144 <span style=''>
</span>145 <span style=''>  /**
</span>146 <span style=''>    * Split the stat into a separate stat per time bin of z data. Allows for separate handling of the reduced
</span>147 <span style=''>    * data set.
</span>148 <span style=''>    *
</span>149 <span style=''>    * @return
</span>150 <span style=''>    */
</span>151 <span style=''>  def splitByTime: Seq[(Short, Frequency[T])] = {
</span>152 <span style=''>    </span><span style='background: #AEF1AE'>sketchMap.toSeq.map { case (w, sketch) =&gt;
</span>153 <span style=''></span><span style='background: #AEF1AE'>      val freq = new Frequency[T](sft, property, dtg, period, precision, eps, confidence)
</span>154 <span style=''></span><span style='background: #AEF1AE'>      freq.sketchMap.put(w, sketch)
</span>155 <span style=''></span><span style='background: #AEF1AE'>      (w, freq)
</span>156 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>157 <span style=''>  }
</span>158 <span style=''>
</span>159 <span style=''>  override def observe(sf: SimpleFeature): Unit = {
</span>160 <span style=''>    val value = </span><span style='background: #AEF1AE'>sf.getAttribute(i).asInstanceOf[T]</span><span style=''>
</span>161 <span style=''>    if (</span><span style='background: #AEF1AE'>value != null</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>162 <span style=''></span><span style='background: #AEF1AE'>      val timeBin: Short = if (d == -1) { Frequency.DefaultTimeBin } else {
</span>163 <span style=''></span><span style='background: #AEF1AE'>        val dtg = sf.getAttribute(d).asInstanceOf[Date]
</span>164 <span style=''></span><span style='background: #AEF1AE'>        if (dtg == null) { </span><span style='background: #F0ADAD'>Frequency.DefaultTimeBin</span><span style='background: #AEF1AE'> } else { timeToBin(dtg.getTime).bin }
</span>165 <span style=''></span><span style='background: #AEF1AE'>      }
</span>166 <span style=''></span><span style='background: #AEF1AE'>      addAttribute(sketchMap.getOrElseUpdate(timeBin, newSketch), value)
</span>167 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>168 <span style=''>  }
</span>169 <span style=''>
</span>170 <span style=''>  // no-op
</span>171 <span style=''>  override def unobserve(sf: SimpleFeature): Unit = </span><span style='background: #AEF1AE'>{}</span><span style=''>
</span>172 <span style=''>
</span>173 <span style=''>  override def +(other: Frequency[T]): Frequency[T] = {
</span>174 <span style=''>    val plus = </span><span style='background: #AEF1AE'>new Frequency[T](sft, property, dtg, period, precision, eps, confidence)</span><span style=''>
</span>175 <span style=''>    </span><span style='background: #AEF1AE'>plus += this</span><span style=''>
</span>176 <span style=''>    </span><span style='background: #AEF1AE'>plus += other</span><span style=''>
</span>177 <span style=''>    plus
</span>178 <span style=''>  }
</span>179 <span style=''>
</span>180 <span style=''>  override def +=(other: Frequency[T]): Unit = {
</span>181 <span style=''>    </span><span style='background: #AEF1AE'>other.sketchMap.foreach { case (w, sketch) =&gt;
</span>182 <span style=''></span><span style='background: #AEF1AE'>      sketchMap.get(w) match {
</span>183 <span style=''></span><span style='background: #AEF1AE'>        case None =&gt; sketchMap.put(w, sketch) // note: sharing a reference now
</span>184 <span style=''></span><span style='background: #AEF1AE'>        case Some(s) =&gt; s += sketch
</span>185 <span style=''></span><span style='background: #AEF1AE'>      }
</span>186 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>187 <span style=''>  }
</span>188 <span style=''>
</span>189 <span style=''>  override def clear(): Unit = </span><span style='background: #AEF1AE'>sketchMap.values.foreach(_.clear())</span><span style=''>
</span>190 <span style=''>
</span>191 <span style=''>  override def isEmpty: Boolean = </span><span style='background: #AEF1AE'>sketchMap.isEmpty || sketchMap.values.forall(_.size == 0)</span><span style=''>
</span>192 <span style=''>
</span>193 <span style=''>  override def toJsonObject = </span><span style='background: #AEF1AE'>ListMap(&quot;epsilon&quot; -&gt; eps, &quot;confidence&quot; -&gt; confidence, &quot;size&quot; -&gt; size)</span><span style=''>
</span>194 <span style=''>
</span>195 <span style=''>  override def isEquivalent(other: Stat): Boolean = {
</span>196 <span style=''>    other match {
</span>197 <span style=''>      case s: Frequency[T] =&gt;
</span>198 <span style=''>        </span><span style='background: #AEF1AE'>property == s.property &amp;&amp; dtg == s.dtg &amp;&amp; period == s.period &amp;&amp; precision == s.precision &amp;&amp; {
</span>199 <span style=''></span><span style='background: #AEF1AE'>          val sketches = sketchMap.filter(_._2.size != 0)
</span>200 <span style=''></span><span style='background: #AEF1AE'>          val otherSketches = s.sketchMap.filter(_._2.size != 0)
</span>201 <span style=''></span><span style='background: #AEF1AE'>          sketches.keySet == otherSketches.keySet &amp;&amp; sketches.forall {
</span>202 <span style=''></span><span style='background: #AEF1AE'>            case (w, sketch) =&gt; sketch.isEquivalent(otherSketches(w))
</span>203 <span style=''></span><span style='background: #AEF1AE'>          }
</span>204 <span style=''></span><span style='background: #AEF1AE'>        }</span><span style=''>
</span>205 <span style=''>      case _ =&gt; </span><span style='background: #F0ADAD'>false</span><span style=''>
</span>206 <span style=''>    }
</span>207 <span style=''>  }
</span>208 <span style=''>}
</span>209 <span style=''>
</span>210 <span style=''>object Frequency {
</span>211 <span style=''>
</span>212 <span style=''>  // the seed for our frequencies - frequencies can only be combined if they have the same seed.
</span>213 <span style=''>  val Seed: Int = </span><span style='background: #AEF1AE'>-27</span><span style=''>
</span>214 <span style=''>
</span>215 <span style=''>  // default time bin we use for features without a date
</span>216 <span style=''>  val DefaultTimeBin: Short = </span><span style='background: #AEF1AE'>0</span><span style=''>
</span>217 <span style=''>
</span>218 <span style=''>  /**
</span>219 <span style=''>    * Enumerate all the values contained in a sequence of ranges, using the supplied precision.
</span>220 <span style=''>    * Because frequency can only do point lookups, this can be used to convert a range into a sequence
</span>221 <span style=''>    * of points.
</span>222 <span style=''>    *
</span>223 <span style=''>    * For example, [1, 4] would be converted into Seq(1, 2, 3, 4)
</span>224 <span style=''>    *
</span>225 <span style=''>    * @param ranges ranges to enumerate
</span>226 <span style=''>    * @param precision precision of the ranges, in bits [1, 64]
</span>227 <span style=''>    * @return the enumerated values
</span>228 <span style=''>    */
</span>229 <span style=''>  def enumerate(ranges: Seq[IndexRange], precision: Long): Iterator[Long] = {
</span>230 <span style=''>    val shift = </span><span style='background: #AEF1AE'>64 - precision</span><span style=''>
</span>231 <span style=''>    </span><span style='background: #AEF1AE'>ranges.toIterator.flatMap { r =&gt;
</span>232 <span style=''></span><span style='background: #AEF1AE'>      val c = (r.upper &gt;&gt; shift) - (r.lower &gt;&gt; shift)
</span>233 <span style=''></span><span style='background: #AEF1AE'>      new Iterator[Long] {
</span>234 <span style=''></span><span style='background: #AEF1AE'>        var i = 0L
</span>235 <span style=''></span><span style='background: #AEF1AE'>        override def hasNext: Boolean = i &lt;= c
</span>236 <span style=''></span><span style='background: #AEF1AE'>        override def next(): Long = try { r.lower + (i &lt;&lt; shift) } finally { i += 1 }
</span>237 <span style=''></span><span style='background: #AEF1AE'>      }
</span>238 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>239 <span style=''>  }
</span>240 <span style=''>
</span>241 <span style=''>  private def add[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Unit = {
</span>242 <span style=''>    if (</span><span style='background: #AEF1AE'>classOf[Geometry].isAssignableFrom(clas)</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>243 <span style=''></span><span style='background: #AEF1AE'>      val mask = getMask(precision)
</span>244 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(geomToKey(value.asInstanceOf[Geometry], mask), 1L)
</span>245 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else </span><span style='background: #AEF1AE'>if (classOf[Date].isAssignableFrom(clas)) {
</span>246 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(dateToKey(value.asInstanceOf[Date], precision), 1L)
</span>247 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[String]) {
</span>248 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(stringToKey(value.asInstanceOf[String], precision), 1L)
</span>249 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Long]) {
</span>250 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(longToKey(value.asInstanceOf[Long], precision), 1L)
</span>251 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[Integer]) {
</span>252 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(intToKey(value.asInstanceOf[Int], precision), 1L)
</span>253 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Float]) {
</span>254 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(floatToKey(value.asInstanceOf[Float], precision), 1L)
</span>255 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Double]) {
</span>256 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.add(doubleToKey(value.asInstanceOf[Double], precision), 1L)
</span>257 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>258 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span><span style='background: #AEF1AE'>
</span>259 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>260 <span style=''>  }
</span>261 <span style=''>
</span>262 <span style=''>  private def count[T](clas: Class[T], precision: Int): (IFrequency, T) =&gt; Long = {
</span>263 <span style=''>    if (</span><span style='background: #AEF1AE'>classOf[Geometry].isAssignableFrom(clas)</span><span style=''>) </span><span style='background: #AEF1AE'>{
</span>264 <span style=''></span><span style='background: #AEF1AE'>      val mask = getMask(precision)
</span>265 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(geomToKey(value.asInstanceOf[Geometry], mask))
</span>266 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''> else </span><span style='background: #AEF1AE'>if (classOf[Date].isAssignableFrom(clas)) {
</span>267 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(dateToKey(value.asInstanceOf[Date], precision))
</span>268 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[String]) {
</span>269 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(stringToKey(value.asInstanceOf[String], precision))
</span>270 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Long]) {
</span>271 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(longToKey(value.asInstanceOf[Long], precision))
</span>272 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[Integer]) {
</span>273 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(intToKey(value.asInstanceOf[Int], precision))
</span>274 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Float]) {
</span>275 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(floatToKey(value.asInstanceOf[Float], precision))
</span>276 <span style=''></span><span style='background: #AEF1AE'>    } else if (clas == classOf[java.lang.Double]) {
</span>277 <span style=''></span><span style='background: #AEF1AE'>      (sketch, value) =&gt; sketch.estimateCount(doubleToKey(value.asInstanceOf[Double], precision))
</span>278 <span style=''></span><span style='background: #AEF1AE'>    } else {
</span>279 <span style=''></span><span style='background: #AEF1AE'>      </span><span style='background: #F0ADAD'>throw new IllegalArgumentException(s&quot;No CountMinSketch implementation for class binding ${clas.getName}&quot;)</span><span style='background: #AEF1AE'>
</span>280 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>281 <span style=''>  }
</span>282 <span style=''>
</span>283 <span style=''>  // mask for right-zeroing bits
</span>284 <span style=''>  private [stats] def getMask(precision: Int): Long = {
</span>285 <span style=''>    </span><span style='background: #AEF1AE'>require(precision &gt;= 0 &amp;&amp; precision &lt;= 64, </span><span style='background: #F0ADAD'>&quot;Precision must be in the range [0, 64]&quot;</span><span style='background: #AEF1AE'>)</span><span style=''>
</span>286 <span style=''>    </span><span style='background: #AEF1AE'>Long.MaxValue &lt;&lt; (64 - precision)</span><span style=''>
</span>287 <span style=''>  }
</span>288 <span style=''>
</span>289 <span style=''>  private [stats] def geomToKey(value: Geometry, mask: Long): Long = {
</span>290 <span style=''>    import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
</span>291 <span style=''>    val centroid = </span><span style='background: #AEF1AE'>value.safeCentroid()</span><span style=''>
</span>292 <span style=''>    </span><span style='background: #AEF1AE'>Z2SFC.index(centroid.getX, centroid.getY) &amp; mask</span><span style=''>
</span>293 <span style=''>  }
</span>294 <span style=''>
</span>295 <span style=''>  private [stats] def stringToKey(value: String, precision: Int): String = {
</span>296 <span style=''>    if (</span><span style='background: #AEF1AE'>value.length &gt; precision</span><span style=''>) {
</span>297 <span style=''>      </span><span style='background: #AEF1AE'>value.substring(0, precision).toLowerCase(Locale.US)</span><span style=''>
</span>298 <span style=''>    } else {
</span>299 <span style=''>      </span><span style='background: #AEF1AE'>value.toLowerCase(Locale.US)</span><span style=''>
</span>300 <span style=''>    }
</span>301 <span style=''>  }
</span>302 <span style=''>  private [stats] def dateToKey(value: Date, precision: Int): Long = </span><span style='background: #AEF1AE'>value.getTime / precision</span><span style=''>
</span>303 <span style=''>  private [stats] def longToKey(value: Long, precision: Int): Long = </span><span style='background: #AEF1AE'>value / precision</span><span style=''>
</span>304 <span style=''>  private [stats] def intToKey(value: Int, precision: Int): Long = </span><span style='background: #AEF1AE'>value / precision</span><span style=''>
</span>305 <span style=''>  private [stats] def floatToKey(value: Float, precision: Int): Long = </span><span style='background: #AEF1AE'>math.round(value * precision)</span><span style=''>
</span>306 <span style=''>  private [stats] def doubleToKey(value: Double, precision: Int): Long = </span><span style='background: #AEF1AE'>math.round(value * precision)</span><span style=''>
</span>307 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Tests</th>
        <th>Code</th>
      </tr><tr>
        <td>
          55
        </td>
        <td>
          11070
        </td>
        <td>
          2519
          -
          2527
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          55
        </td>
        <td>
          11071
        </td>
        <td>
          2507
          -
          2528
        </td>
        <td>
          Apply
        </td>
        <td>
          org.geotools.api.feature.simple.SimpleFeatureType.indexOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft.indexOf(Frequency.this.property)
        </td>
      </tr><tr>
        <td>
          56
        </td>
        <td>
          11072
        </td>
        <td>
          2547
          -
          2581
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg.map[Int]({
  ((x$1: String) =&gt; Frequency.this.sft.indexOf(x$1))
}).getOrElse[Int](-1)
        </td>
      </tr><tr>
        <td>
          58
        </td>
        <td>
          11073
        </td>
        <td>
          2617
          -
          2674
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.mutable.Map.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.mutable.Map.empty[Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch]
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          11074
        </td>
        <td>
          2724
          -
          2727
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          11075
        </td>
        <td>
          2729
          -
          2739
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          11076
        </td>
        <td>
          2741
          -
          2755
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.Seed
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.Seed
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          11077
        </td>
        <td>
          2709
          -
          2756
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.apply(Frequency.this.eps, Frequency.this.confidence, Frequency.Seed)
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          11078
        </td>
        <td>
          2811
          -
          2817
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          60
        </td>
        <td>
          11079
        </td>
        <td>
          2783
          -
          2818
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.timeToBinnedTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.BinnedTime.timeToBinnedTime(Frequency.this.period)
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          11080
        </td>
        <td>
          2866
          -
          2904
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]]
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          11081
        </td>
        <td>
          2906
          -
          2915
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          11082
        </td>
        <td>
          2849
          -
          2916
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.add[T](Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]], Frequency.this.precision)
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          11083
        </td>
        <td>
          2961
          -
          2999
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]]
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          11084
        </td>
        <td>
          3001
          -
          3010
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          63
        </td>
        <td>
          11085
        </td>
        <td>
          2942
          -
          3011
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.count
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.count[T](Frequency.this.ct.runtimeClass.asInstanceOf[Class[T]], Frequency.this.precision)
        </td>
      </tr><tr>
        <td>
          70
        </td>
        <td>
          11086
        </td>
        <td>
          3147
          -
          3147
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Ordering.Short
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Ordering.Short
        </td>
      </tr><tr>
        <td>
          70
        </td>
        <td>
          11087
        </td>
        <td>
          3126
          -
          3153
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.SeqLike.sorted
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.keys.toSeq.sorted[Short](math.this.Ordering.Short)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11088
        </td>
        <td>
          3339
          -
          3356
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11089
        </td>
        <td>
          3360
          -
          3362
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11090
        </td>
        <td>
          3360
          -
          3362
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11091
        </td>
        <td>
          3393
          -
          3411
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getCount.apply(x$1, value)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11092
        </td>
        <td>
          3392
          -
          3392
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11093
        </td>
        <td>
          3413
          -
          3413
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11094
        </td>
        <td>
          3372
          -
          3416
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$1: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$1, value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          11095
        </td>
        <td>
          3372
          -
          3416
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$1: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$1, value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          87
        </td>
        <td>
          11096
        </td>
        <td>
          3663
          -
          3723
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$2: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; Frequency.this.getCount.apply(x$2, value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11097
        </td>
        <td>
          4076
          -
          4093
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11098
        </td>
        <td>
          4097
          -
          4099
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11099
        </td>
        <td>
          4097
          -
          4099
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11100
        </td>
        <td>
          4130
          -
          4152
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          x$3.estimateCount(value)
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11101
        </td>
        <td>
          4129
          -
          4129
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11102
        </td>
        <td>
          4154
          -
          4154
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11103
        </td>
        <td>
          4109
          -
          4157
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$3: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$3.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          97
        </td>
        <td>
          11104
        </td>
        <td>
          4109
          -
          4157
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$3: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$3.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          11105
        </td>
        <td>
          4546
          -
          4610
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$4: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$4.estimateCount(value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11106
        </td>
        <td>
          4976
          -
          4993
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11107
        </td>
        <td>
          4997
          -
          4999
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11108
        </td>
        <td>
          4997
          -
          4999
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          0L
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11109
        </td>
        <td>
          5030
          -
          5052
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          x$5.estimateCount(value)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11110
        </td>
        <td>
          5029
          -
          5029
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11111
        </td>
        <td>
          5054
          -
          5054
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11112
        </td>
        <td>
          5009
          -
          5057
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$5: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$5.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          118
        </td>
        <td>
          11113
        </td>
        <td>
          5009
          -
          5057
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$5: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$5.estimateCount(value)))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          129
        </td>
        <td>
          11114
        </td>
        <td>
          5459
          -
          5523
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$6: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$6.estimateCount(value))).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11115
        </td>
        <td>
          5654
          -
          5671
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.isEmpty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11116
        </td>
        <td>
          5675
          -
          5677
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11117
        </td>
        <td>
          5675
          -
          5677
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11118
        </td>
        <td>
          5708
          -
          5714
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$7.size()
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11119
        </td>
        <td>
          5707
          -
          5707
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Iterable.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Iterable.canBuildFrom[Long]
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11120
        </td>
        <td>
          5716
          -
          5716
        </td>
        <td>
          Select
        </td>
        <td>
          scala.math.Numeric.LongIsIntegral
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          math.this.Numeric.LongIsIntegral
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11121
        </td>
        <td>
          5687
          -
          5719
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$7: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$7.size()))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          136
        </td>
        <td>
          11122
        </td>
        <td>
          5687
          -
          5719
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.TraversableOnce.sum
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.map[Long, Iterable[Long]](((x$7: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$7.size()))(collection.this.Iterable.canBuildFrom[Long]).sum[Long](math.this.Numeric.LongIsIntegral)
        </td>
      </tr><tr>
        <td>
          143
        </td>
        <td>
          11123
        </td>
        <td>
          5864
          -
          5912
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.this.sketchMap.get(timeBin).map[Long](((x$8: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$8.size())).getOrElse[Long](0L)
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          11135
        </td>
        <td>
          6166
          -
          6310
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val freq: org.locationtech.geomesa.utils.stats.Frequency[T] = new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct);
  freq.sketchMap.put(w, sketch);
  scala.Tuple2.apply[Short, org.locationtech.geomesa.utils.stats.Frequency[T]](w, freq)
}
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          11136
        </td>
        <td>
          6147
          -
          6147
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(Short, org.locationtech.geomesa.utils.stats.Frequency[T])]
        </td>
      </tr><tr>
        <td>
          152
        </td>
        <td>
          11137
        </td>
        <td>
          6127
          -
          6316
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.toSeq.map[(Short, org.locationtech.geomesa.utils.stats.Frequency[T]), Seq[(Short, org.locationtech.geomesa.utils.stats.Frequency[T])]](((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; {
    val freq: org.locationtech.geomesa.utils.stats.Frequency[T] = new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct);
    freq.sketchMap.put(w, sketch);
    scala.Tuple2.apply[Short, org.locationtech.geomesa.utils.stats.Frequency[T]](w, freq)
  }
}))(collection.this.Seq.canBuildFrom[(Short, org.locationtech.geomesa.utils.stats.Frequency[T])])
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11124
        </td>
        <td>
          6203
          -
          6206
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.sft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11125
        </td>
        <td>
          6208
          -
          6216
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11126
        </td>
        <td>
          6218
          -
          6221
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11127
        </td>
        <td>
          6223
          -
          6229
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11128
        </td>
        <td>
          6231
          -
          6240
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11129
        </td>
        <td>
          6242
          -
          6245
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11130
        </td>
        <td>
          6247
          -
          6257
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11131
        </td>
        <td>
          6186
          -
          6186
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.ct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct
        </td>
      </tr><tr>
        <td>
          153
        </td>
        <td>
          11132
        </td>
        <td>
          6186
          -
          6258
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct)
        </td>
      </tr><tr>
        <td>
          154
        </td>
        <td>
          11133
        </td>
        <td>
          6265
          -
          6294
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          freq.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          155
        </td>
        <td>
          11134
        </td>
        <td>
          6301
          -
          6310
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Short, org.locationtech.geomesa.utils.stats.Frequency[T]](w, freq)
        </td>
      </tr><tr>
        <td>
          160
        </td>
        <td>
          11138
        </td>
        <td>
          6406
          -
          6407
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.i
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.i
        </td>
      </tr><tr>
        <td>
          160
        </td>
        <td>
          11139
        </td>
        <td>
          6390
          -
          6424
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sf.getAttribute(Frequency.this.i).asInstanceOf[T]
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          11140
        </td>
        <td>
          6433
          -
          6446
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Any.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.!=(null)
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          11156
        </td>
        <td>
          6448
          -
          6758
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val timeBin: Short = if (Frequency.this.d.==(-1))
    Frequency.DefaultTimeBin
  else
    {
      val dtg: java.util.Date = sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date];
      if (dtg.==(null))
        Frequency.DefaultTimeBin
      else
        Frequency.this.timeToBin.apply(dtg.getTime()).bin
    };
  Frequency.this.addAttribute.apply(Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch), value)
}
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          11157
        </td>
        <td>
          6429
          -
          6429
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          161
        </td>
        <td>
          11158
        </td>
        <td>
          6429
          -
          6429
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          11141
        </td>
        <td>
          6481
          -
          6488
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.d.==(-1)
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          11142
        </td>
        <td>
          6492
          -
          6516
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          11143
        </td>
        <td>
          6492
          -
          6516
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          162
        </td>
        <td>
          11152
        </td>
        <td>
          6524
          -
          6679
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val dtg: java.util.Date = sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date];
  if (dtg.==(null))
    Frequency.DefaultTimeBin
  else
    Frequency.this.timeToBin.apply(dtg.getTime()).bin
}
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          11144
        </td>
        <td>
          6560
          -
          6561
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.d
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.d
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          11145
        </td>
        <td>
          6544
          -
          6581
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sf.getAttribute(Frequency.this.d).asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          11146
        </td>
        <td>
          6594
          -
          6605
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          dtg.==(null)
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          11147
        </td>
        <td>
          6609
          -
          6633
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          11148
        </td>
        <td>
          6609
          -
          6633
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.DefaultTimeBin
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          Frequency.DefaultTimeBin
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          11149
        </td>
        <td>
          6653
          -
          6664
        </td>
        <td>
          Apply
        </td>
        <td>
          java.util.Date.getTime
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          dtg.getTime()
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          11150
        </td>
        <td>
          6643
          -
          6669
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.bin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.timeToBin.apply(dtg.getTime()).bin
        </td>
      </tr><tr>
        <td>
          164
        </td>
        <td>
          11151
        </td>
        <td>
          6643
          -
          6669
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.curve.BinnedTime.bin
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.timeToBin.apply(dtg.getTime()).bin
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          11153
        </td>
        <td>
          6734
          -
          6743
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.newSketch
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.newSketch
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          11154
        </td>
        <td>
          6699
          -
          6744
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.getOrElseUpdate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch)
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          11155
        </td>
        <td>
          6686
          -
          6752
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Function2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.addAttribute.apply(Frequency.this.sketchMap.getOrElseUpdate(timeBin, Frequency.this.newSketch), value)
        </td>
      </tr><tr>
        <td>
          171
        </td>
        <td>
          11159
        </td>
        <td>
          6827
          -
          6829
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11160
        </td>
        <td>
          6919
          -
          6922
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.sft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sft
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11161
        </td>
        <td>
          6924
          -
          6932
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11162
        </td>
        <td>
          6934
          -
          6937
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11163
        </td>
        <td>
          6939
          -
          6945
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11164
        </td>
        <td>
          6947
          -
          6956
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11165
        </td>
        <td>
          6958
          -
          6961
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11166
        </td>
        <td>
          6963
          -
          6973
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11167
        </td>
        <td>
          6902
          -
          6902
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.ct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.ct
        </td>
      </tr><tr>
        <td>
          174
        </td>
        <td>
          11168
        </td>
        <td>
          6902
          -
          6974
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.geomesa.utils.stats.Frequency[T](Frequency.this.sft, Frequency.this.property, Frequency.this.dtg, Frequency.this.period, Frequency.this.precision, Frequency.this.eps, Frequency.this.confidence)(Frequency.this.ct)
        </td>
      </tr><tr>
        <td>
          175
        </td>
        <td>
          11169
        </td>
        <td>
          6979
          -
          6991
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          plus.+=(this)
        </td>
      </tr><tr>
        <td>
          176
        </td>
        <td>
          11170
        </td>
        <td>
          6996
          -
          7009
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          plus.+=(other)
        </td>
      </tr><tr>
        <td>
          181
        </td>
        <td>
          11177
        </td>
        <td>
          7077
          -
          7282
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          other.sketchMap.foreach[Any](((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; Frequency.this.sketchMap.get(w) match {
    case scala.None =&gt; Frequency.this.sketchMap.put(w, sketch)
    case (value: org.locationtech.geomesa.utils.clearspring.CountMinSketch)Some[org.locationtech.geomesa.utils.clearspring.CountMinSketch]((s @ _)) =&gt; s.+=(sketch)
  }
}))
        </td>
      </tr><tr>
        <td>
          182
        </td>
        <td>
          11171
        </td>
        <td>
          7129
          -
          7145
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.get
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(w)
        </td>
      </tr><tr>
        <td>
          182
        </td>
        <td>
          11176
        </td>
        <td>
          7129
          -
          7276
        </td>
        <td>
          Match
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.get(w) match {
  case scala.None =&gt; Frequency.this.sketchMap.put(w, sketch)
  case (value: org.locationtech.geomesa.utils.clearspring.CountMinSketch)Some[org.locationtech.geomesa.utils.clearspring.CountMinSketch]((s @ _)) =&gt; s.+=(sketch)
}
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          11172
        </td>
        <td>
          7175
          -
          7199
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          183
        </td>
        <td>
          11173
        </td>
        <td>
          7175
          -
          7199
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.mutable.MapLike.put
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.put(w, sketch)
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          11174
        </td>
        <td>
          7257
          -
          7268
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.+=(sketch)
        </td>
      </tr><tr>
        <td>
          184
        </td>
        <td>
          11175
        </td>
        <td>
          7257
          -
          7268
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.+=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.+=(sketch)
        </td>
      </tr><tr>
        <td>
          189
        </td>
        <td>
          11178
        </td>
        <td>
          7344
          -
          7353
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.clear
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$9.clear()
        </td>
      </tr><tr>
        <td>
          189
        </td>
        <td>
          11179
        </td>
        <td>
          7319
          -
          7354
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foreach
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.foreach[Unit](((x$9: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$9.clear()))
        </td>
      </tr><tr>
        <td>
          191
        </td>
        <td>
          11180
        </td>
        <td>
          7435
          -
          7446
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$10.size().==(0)
        </td>
      </tr><tr>
        <td>
          191
        </td>
        <td>
          11181
        </td>
        <td>
          7411
          -
          7447
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.values.forall(((x$10: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$10.size().==(0)))
        </td>
      </tr><tr>
        <td>
          191
        </td>
        <td>
          11182
        </td>
        <td>
          7390
          -
          7447
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.isEmpty.||(Frequency.this.sketchMap.values.forall(((x$10: org.locationtech.geomesa.utils.clearspring.CountMinSketch) =&gt; x$10.size().==(0))))
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11183
        </td>
        <td>
          7487
          -
          7496
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;epsilon&quot;
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11184
        </td>
        <td>
          7500
          -
          7503
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.eps
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.eps
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11185
        </td>
        <td>
          7487
          -
          7503
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;epsilon&quot;).-&gt;[Double](Frequency.this.eps)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11186
        </td>
        <td>
          7505
          -
          7517
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;confidence&quot;
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11187
        </td>
        <td>
          7521
          -
          7531
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.confidence
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.confidence
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11188
        </td>
        <td>
          7505
          -
          7531
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;confidence&quot;).-&gt;[Double](Frequency.this.confidence)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11189
        </td>
        <td>
          7533
          -
          7539
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;size&quot;
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11190
        </td>
        <td>
          7543
          -
          7547
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.size
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.size
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11191
        </td>
        <td>
          7533
          -
          7547
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.ArrowAssoc.-&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.ArrowAssoc[String](&quot;size&quot;).-&gt;[Long](Frequency.this.size)
        </td>
      </tr><tr>
        <td>
          193
        </td>
        <td>
          11192
        </td>
        <td>
          7479
          -
          7548
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenMapFactory.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.ListMap.apply[String, AnyVal](scala.Predef.ArrowAssoc[String](&quot;epsilon&quot;).-&gt;[Double](Frequency.this.eps), scala.Predef.ArrowAssoc[String](&quot;confidence&quot;).-&gt;[Double](Frequency.this.confidence), scala.Predef.ArrowAssoc[String](&quot;size&quot;).-&gt;[Long](Frequency.this.size))
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11193
        </td>
        <td>
          7672
          -
          7682
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.property
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.property
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11194
        </td>
        <td>
          7693
          -
          7698
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dtg
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.dtg
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11195
        </td>
        <td>
          7686
          -
          7698
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dtg.==(s.dtg)
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11196
        </td>
        <td>
          7712
          -
          7720
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.period
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.period
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11197
        </td>
        <td>
          7702
          -
          7720
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.period.==(s.period)
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11198
        </td>
        <td>
          7737
          -
          7748
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.precision
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.precision
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11199
        </td>
        <td>
          7724
          -
          7748
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.precision.==(s.precision)
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11210
        </td>
        <td>
          7660
          -
          8039
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property.==(s.property).&amp;&amp;(Frequency.this.dtg.==(s.dtg)).&amp;&amp;(Frequency.this.period.==(s.period)).&amp;&amp;(Frequency.this.precision.==(s.precision)).&amp;&amp;({
  val sketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)));
  val otherSketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)));
  sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
    case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
  })))
})
        </td>
      </tr><tr>
        <td>
          198
        </td>
        <td>
          11211
        </td>
        <td>
          7660
          -
          8039
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.property.==(s.property).&amp;&amp;(Frequency.this.dtg.==(s.dtg)).&amp;&amp;(Frequency.this.period.==(s.period)).&amp;&amp;(Frequency.this.precision.==(s.precision)).&amp;&amp;({
  val sketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)));
  val otherSketches: scala.collection.mutable.Map[Short,org.locationtech.geomesa.utils.clearspring.CountMinSketch] = s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)));
  sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
    case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
  })))
})
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          11200
        </td>
        <td>
          7796
          -
          7810
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$11._2.size().!=(0)
        </td>
      </tr><tr>
        <td>
          199
        </td>
        <td>
          11201
        </td>
        <td>
          7779
          -
          7811
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.sketchMap.filter(((x$11: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$11._2.size().!=(0)))
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          11202
        </td>
        <td>
          7861
          -
          7875
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.!=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$12._2.size().!=(0)
        </td>
      </tr><tr>
        <td>
          200
        </td>
        <td>
          11203
        </td>
        <td>
          7842
          -
          7876
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          s.sketchMap.filter(((x$12: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x$12._2.size().!=(0)))
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          11204
        </td>
        <td>
          7906
          -
          7926
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.MapLike.keySet
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          otherSketches.keySet
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          11208
        </td>
        <td>
          7930
          -
          8029
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.forall
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
}))
        </td>
      </tr><tr>
        <td>
          201
        </td>
        <td>
          11209
        </td>
        <td>
          7887
          -
          8029
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketches.keySet.==(otherSketches.keySet).&amp;&amp;(sketches.forall(((x0$1: (Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)) =&gt; x0$1 match {
  case (_1: Short, _2: org.locationtech.geomesa.utils.clearspring.CountMinSketch)(Short, org.locationtech.geomesa.utils.clearspring.CountMinSketch)((w @ _), (sketch @ _)) =&gt; sketch.isEquivalent(otherSketches.apply(w))
})))
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          11205
        </td>
        <td>
          8000
          -
          8016
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.MapLike.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          otherSketches.apply(w)
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          11206
        </td>
        <td>
          7980
          -
          8017
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.isEquivalent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.isEquivalent(otherSketches.apply(w))
        </td>
      </tr><tr>
        <td>
          202
        </td>
        <td>
          11207
        </td>
        <td>
          7980
          -
          8017
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.clearspring.CountMinSketch.isEquivalent
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.isEquivalent(otherSketches.apply(w))
        </td>
      </tr><tr>
        <td>
          205
        </td>
        <td>
          11212
        </td>
        <td>
          8056
          -
          8061
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          205
        </td>
        <td>
          11213
        </td>
        <td>
          8056
          -
          8061
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          false
        </td>
      </tr><tr>
        <td>
          213
        </td>
        <td>
          11214
        </td>
        <td>
          8210
          -
          8213
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          -27
        </td>
      </tr><tr>
        <td>
          216
        </td>
        <td>
          11215
        </td>
        <td>
          8302
          -
          8303
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          230
        </td>
        <td>
          11216
        </td>
        <td>
          8846
          -
          8860
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          64.-(precision)
        </td>
      </tr><tr>
        <td>
          231
        </td>
        <td>
          11228
        </td>
        <td>
          8865
          -
          9144
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.Iterator.flatMap
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ranges.toIterator.flatMap[Long](((r: org.locationtech.geomesa.zorder.sfcurve.IndexRange) =&gt; {
  val c: Long = r.upper.&gt;&gt;(shift).-(r.lower.&gt;&gt;(shift));
  {
    final class $anon extends AnyRef with Iterator[Long] {
      def &lt;init&gt;(): &lt;$anon: Iterator[Long]&gt; = {
        $anon.super.&lt;init&gt;();
        ()
      };
      private[this] var i: Long = 0L;
      &lt;accessor&gt; private def i: Long = $anon.this.i;
      &lt;accessor&gt; private def i_=(x$1: Long): Unit = $anon.this.i = x$1;
      override def hasNext: Boolean = $anon.this.i.&lt;=(c);
      override def next(): Long = try {
        r.lower.+($anon.this.i.&lt;&lt;(shift))
      } finally $anon.this.i_=($anon.this.i.+(1))
    };
    new $anon()
  }
}))
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          11217
        </td>
        <td>
          8934
          -
          8950
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&gt;&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.&gt;&gt;(shift)
        </td>
      </tr><tr>
        <td>
          232
        </td>
        <td>
          11218
        </td>
        <td>
          8912
          -
          8951
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.upper.&gt;&gt;(shift).-(r.lower.&gt;&gt;(shift))
        </td>
      </tr><tr>
        <td>
          233
        </td>
        <td>
          11227
        </td>
        <td>
          8958
          -
          8961
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anon.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new $anon()
        </td>
      </tr><tr>
        <td>
          234
        </td>
        <td>
          11219
        </td>
        <td>
          8995
          -
          8997
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0L
        </td>
      </tr><tr>
        <td>
          235
        </td>
        <td>
          11220
        </td>
        <td>
          9038
          -
          9044
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.&lt;=(c)
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          11221
        </td>
        <td>
          9098
          -
          9108
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.&lt;&lt;(shift)
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          11222
        </td>
        <td>
          9087
          -
          9109
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.+($anon.this.i.&lt;&lt;(shift))
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          11223
        </td>
        <td>
          9087
          -
          9109
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          r.lower.+($anon.this.i.&lt;&lt;(shift))
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          11224
        </td>
        <td>
          9122
          -
          9128
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i.+(1)
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          11225
        </td>
        <td>
          9122
          -
          9128
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anon.i_=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i_=($anon.this.i.+(1))
        </td>
      </tr><tr>
        <td>
          236
        </td>
        <td>
          11226
        </td>
        <td>
          9122
          -
          9128
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anon.i_=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          $anon.this.i_=($anon.this.i.+(1))
        </td>
      </tr><tr>
        <td>
          242
        </td>
        <td>
          11229
        </td>
        <td>
          9240
          -
          9280
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[org.locationtech.jts.geom.Geometry].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          242
        </td>
        <td>
          11235
        </td>
        <td>
          9282
          -
          9412
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val mask: Long = Frequency.this.getMask(precision);
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask), 1L))
}
        </td>
      </tr><tr>
        <td>
          243
        </td>
        <td>
          11230
        </td>
        <td>
          9301
          -
          9319
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.getMask
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getMask(precision)
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          11231
        </td>
        <td>
          9366
          -
          9394
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          11232
        </td>
        <td>
          9356
          -
          9401
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.geomToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          11233
        </td>
        <td>
          9403
          -
          9405
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          244
        </td>
        <td>
          11234
        </td>
        <td>
          9345
          -
          9406
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask), 1L)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          11236
        </td>
        <td>
          9422
          -
          9458
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[java.util.Date].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          11279
        </td>
        <td>
          9418
          -
          10366
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (classOf[java.util.Date].isAssignableFrom(clas))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L))
else
  if (clas.==(classOf[java.lang.String]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Long]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Integer]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
      else
        if (clas.==(classOf[java.lang.Float]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
        else
          if (clas.==(classOf[java.lang.Double]))
            ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
          else
            throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          11237
        </td>
        <td>
          9508
          -
          9532
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          11238
        </td>
        <td>
          9498
          -
          9544
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dateToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          11239
        </td>
        <td>
          9546
          -
          9548
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          11240
        </td>
        <td>
          9487
          -
          9549
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L)
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          11241
        </td>
        <td>
          9468
          -
          9549
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision), 1L))
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          11242
        </td>
        <td>
          9565
          -
          9588
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.String])
        </td>
      </tr><tr>
        <td>
          247
        </td>
        <td>
          11278
        </td>
        <td>
          9561
          -
          10366
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.String]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
else
  if (clas.==(classOf[java.lang.Long]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Integer]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Float]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
      else
        if (clas.==(classOf[java.lang.Double]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
        else
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          11243
        </td>
        <td>
          9640
          -
          9666
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[String]
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          11244
        </td>
        <td>
          9628
          -
          9678
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.stringToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.stringToKey(value.asInstanceOf[String], precision)
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          11245
        </td>
        <td>
          9680
          -
          9682
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          11246
        </td>
        <td>
          9617
          -
          9683
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L)
        </td>
      </tr><tr>
        <td>
          248
        </td>
        <td>
          11247
        </td>
        <td>
          9598
          -
          9683
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.stringToKey(value.asInstanceOf[String], precision), 1L))
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          11248
        </td>
        <td>
          9699
          -
          9730
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Long])
        </td>
      </tr><tr>
        <td>
          249
        </td>
        <td>
          11277
        </td>
        <td>
          9695
          -
          10366
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Long]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
else
  if (clas.==(classOf[java.lang.Integer]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Float]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
    else
      if (clas.==(classOf[java.lang.Double]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
      else
        throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          11249
        </td>
        <td>
          9780
          -
          9804
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Long]
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          11250
        </td>
        <td>
          9770
          -
          9816
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.longToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.longToKey(value.asInstanceOf[Long], precision)
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          11251
        </td>
        <td>
          9818
          -
          9820
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          11252
        </td>
        <td>
          9759
          -
          9821
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L)
        </td>
      </tr><tr>
        <td>
          250
        </td>
        <td>
          11253
        </td>
        <td>
          9740
          -
          9821
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.longToKey(value.asInstanceOf[Long], precision), 1L))
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          11254
        </td>
        <td>
          9837
          -
          9861
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Integer])
        </td>
      </tr><tr>
        <td>
          251
        </td>
        <td>
          11276
        </td>
        <td>
          9833
          -
          10366
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Integer]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
else
  if (clas.==(classOf[java.lang.Float]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
  else
    if (clas.==(classOf[java.lang.Double]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
    else
      throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          11255
        </td>
        <td>
          9910
          -
          9933
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Int]
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          11256
        </td>
        <td>
          9901
          -
          9945
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.intToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.intToKey(value.asInstanceOf[Int], precision)
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          11257
        </td>
        <td>
          9947
          -
          9949
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          11258
        </td>
        <td>
          9890
          -
          9950
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L)
        </td>
      </tr><tr>
        <td>
          252
        </td>
        <td>
          11259
        </td>
        <td>
          9871
          -
          9950
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.intToKey(value.asInstanceOf[Int], precision), 1L))
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          11260
        </td>
        <td>
          9966
          -
          9998
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Float])
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          11275
        </td>
        <td>
          9962
          -
          10366
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Float]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
else
  if (clas.==(classOf[java.lang.Double]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
  else
    throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          11261
        </td>
        <td>
          10049
          -
          10074
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Float]
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          11262
        </td>
        <td>
          10038
          -
          10086
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.floatToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.floatToKey(value.asInstanceOf[Float], precision)
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          11263
        </td>
        <td>
          10088
          -
          10090
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          11264
        </td>
        <td>
          10027
          -
          10091
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L)
        </td>
      </tr><tr>
        <td>
          254
        </td>
        <td>
          11265
        </td>
        <td>
          10008
          -
          10091
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.floatToKey(value.asInstanceOf[Float], precision), 1L))
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          11266
        </td>
        <td>
          10107
          -
          10140
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Double])
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          11274
        </td>
        <td>
          10103
          -
          10366
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Double]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
else
  throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          11267
        </td>
        <td>
          10192
          -
          10218
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Double]
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          11268
        </td>
        <td>
          10180
          -
          10230
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.doubleToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          11269
        </td>
        <td>
          10232
          -
          10234
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          11270
        </td>
        <td>
          10169
          -
          10235
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.add
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L)
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          11271
        </td>
        <td>
          10150
          -
          10235
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.add(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision), 1L))
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          11272
        </td>
        <td>
          10255
          -
          10360
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          11273
        </td>
        <td>
          10255
          -
          10360
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          263
        </td>
        <td>
          11280
        </td>
        <td>
          10464
          -
          10504
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[org.locationtech.jts.geom.Geometry].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          263
        </td>
        <td>
          11285
        </td>
        <td>
          10506
          -
          10642
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val mask: Long = Frequency.this.getMask(precision);
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)))
}
        </td>
      </tr><tr>
        <td>
          264
        </td>
        <td>
          11281
        </td>
        <td>
          10525
          -
          10543
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.getMask
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.getMask(precision)
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          11282
        </td>
        <td>
          10600
          -
          10628
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          11283
        </td>
        <td>
          10590
          -
          10635
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.geomToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask)
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          11284
        </td>
        <td>
          10569
          -
          10636
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.geomToKey(value.asInstanceOf[org.locationtech.jts.geom.Geometry], mask))
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          11286
        </td>
        <td>
          10652
          -
          10688
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Class.isAssignableFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          classOf[java.util.Date].isAssignableFrom(clas)
        </td>
      </tr><tr>
        <td>
          266
        </td>
        <td>
          11323
        </td>
        <td>
          10648
          -
          11632
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (classOf[java.util.Date].isAssignableFrom(clas))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)))
else
  if (clas.==(classOf[java.lang.String]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
  else
    if (clas.==(classOf[java.lang.Long]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
    else
      if (clas.==(classOf[java.lang.Integer]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
      else
        if (clas.==(classOf[java.lang.Float]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
        else
          if (clas.==(classOf[java.lang.Double]))
            ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
          else
            throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          11287
        </td>
        <td>
          10748
          -
          10772
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[java.util.Date]
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          11288
        </td>
        <td>
          10738
          -
          10784
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.dateToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          11289
        </td>
        <td>
          10717
          -
          10785
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision))
        </td>
      </tr><tr>
        <td>
          267
        </td>
        <td>
          11290
        </td>
        <td>
          10698
          -
          10785
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.dateToKey(value.asInstanceOf[java.util.Date], precision)))
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          11291
        </td>
        <td>
          10801
          -
          10824
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.String])
        </td>
      </tr><tr>
        <td>
          268
        </td>
        <td>
          11322
        </td>
        <td>
          10797
          -
          11632
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.String]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
else
  if (clas.==(classOf[java.lang.Long]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
  else
    if (clas.==(classOf[java.lang.Integer]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
    else
      if (clas.==(classOf[java.lang.Float]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
      else
        if (clas.==(classOf[java.lang.Double]))
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
        else
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          11292
        </td>
        <td>
          10886
          -
          10912
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[String]
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          11293
        </td>
        <td>
          10874
          -
          10924
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.stringToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.stringToKey(value.asInstanceOf[String], precision)
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          11294
        </td>
        <td>
          10853
          -
          10925
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision))
        </td>
      </tr><tr>
        <td>
          269
        </td>
        <td>
          11295
        </td>
        <td>
          10834
          -
          10925
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.stringToKey(value.asInstanceOf[String], precision)))
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          11296
        </td>
        <td>
          10941
          -
          10972
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Long])
        </td>
      </tr><tr>
        <td>
          270
        </td>
        <td>
          11321
        </td>
        <td>
          10937
          -
          11632
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Long]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
else
  if (clas.==(classOf[java.lang.Integer]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
  else
    if (clas.==(classOf[java.lang.Float]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
    else
      if (clas.==(classOf[java.lang.Double]))
        ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
      else
        throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          11297
        </td>
        <td>
          11032
          -
          11056
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Long]
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          11298
        </td>
        <td>
          11022
          -
          11068
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.longToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.longToKey(value.asInstanceOf[Long], precision)
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          11299
        </td>
        <td>
          11001
          -
          11069
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision))
        </td>
      </tr><tr>
        <td>
          271
        </td>
        <td>
          11300
        </td>
        <td>
          10982
          -
          11069
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.longToKey(value.asInstanceOf[Long], precision)))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          11301
        </td>
        <td>
          11085
          -
          11109
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Integer])
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          11320
        </td>
        <td>
          11081
          -
          11632
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Integer]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
else
  if (clas.==(classOf[java.lang.Float]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
  else
    if (clas.==(classOf[java.lang.Double]))
      ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
    else
      throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          11302
        </td>
        <td>
          11168
          -
          11191
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Int]
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          11303
        </td>
        <td>
          11159
          -
          11203
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.intToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.intToKey(value.asInstanceOf[Int], precision)
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          11304
        </td>
        <td>
          11138
          -
          11204
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision))
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          11305
        </td>
        <td>
          11119
          -
          11204
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.intToKey(value.asInstanceOf[Int], precision)))
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          11306
        </td>
        <td>
          11220
          -
          11252
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Float])
        </td>
      </tr><tr>
        <td>
          274
        </td>
        <td>
          11319
        </td>
        <td>
          11216
          -
          11632
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Float]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
else
  if (clas.==(classOf[java.lang.Double]))
    ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
  else
    throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          11307
        </td>
        <td>
          11313
          -
          11338
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Float]
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          11308
        </td>
        <td>
          11302
          -
          11350
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.floatToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.floatToKey(value.asInstanceOf[Float], precision)
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          11309
        </td>
        <td>
          11281
          -
          11351
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision))
        </td>
      </tr><tr>
        <td>
          275
        </td>
        <td>
          11310
        </td>
        <td>
          11262
          -
          11351
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.floatToKey(value.asInstanceOf[Float], precision)))
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          11311
        </td>
        <td>
          11367
          -
          11400
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Object.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          clas.==(classOf[java.lang.Double])
        </td>
      </tr><tr>
        <td>
          276
        </td>
        <td>
          11318
        </td>
        <td>
          11363
          -
          11632
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (clas.==(classOf[java.lang.Double]))
  ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
else
  throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          11312
        </td>
        <td>
          11462
          -
          11488
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.asInstanceOf[Double]
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          11313
        </td>
        <td>
          11450
          -
          11500
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.doubleToKey
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          11314
        </td>
        <td>
          11429
          -
          11501
        </td>
        <td>
          Apply
        </td>
        <td>
          com.clearspring.analytics.stream.frequency.IFrequency.estimateCount
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision))
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          11315
        </td>
        <td>
          11410
          -
          11501
        </td>
        <td>
          Function
        </td>
        <td>
          org.locationtech.geomesa.utils.stats.Frequency.$anonfun
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ((sketch: com.clearspring.analytics.stream.frequency.IFrequency, value: T) =&gt; sketch.estimateCount(Frequency.this.doubleToKey(value.asInstanceOf[Double], precision)))
        </td>
      </tr><tr>
        <td>
          279
        </td>
        <td>
          11316
        </td>
        <td>
          11521
          -
          11626
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          279
        </td>
        <td>
          11317
        </td>
        <td>
          11521
          -
          11626
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(scala.StringContext.apply(&quot;No CountMinSketch implementation for class binding &quot;, &quot;&quot;).s(clas.getName()))
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          11324
        </td>
        <td>
          11752
          -
          11753
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          11325
        </td>
        <td>
          11757
          -
          11772
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          precision.&lt;=(64)
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          11326
        </td>
        <td>
          11739
          -
          11772
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          precision.&gt;=(0).&amp;&amp;(precision.&lt;=(64))
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          11327
        </td>
        <td>
          11774
          -
          11814
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;Precision must be in the range [0, 64]&quot;
        </td>
      </tr><tr>
        <td>
          285
        </td>
        <td>
          11328
        </td>
        <td>
          11731
          -
          11815
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Predef.require
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.require(precision.&gt;=(0).&amp;&amp;(precision.&lt;=(64)), &quot;Precision must be in the range [0, 64]&quot;)
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          11329
        </td>
        <td>
          11820
          -
          11833
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          9223372036854775807L
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          11330
        </td>
        <td>
          11838
          -
          11852
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          64.-(precision)
        </td>
      </tr><tr>
        <td>
          286
        </td>
        <td>
          11331
        </td>
        <td>
          11820
          -
          11853
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          9223372036854775807L.&lt;&lt;(64.-(precision))
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          11332
        </td>
        <td>
          12025
          -
          12045
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry.safeCentroid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(value).safeCentroid()
        </td>
      </tr><tr>
        <td>
          292
        </td>
        <td>
          11333
        </td>
        <td>
          12050
          -
          12098
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.curve.Z2SFC.index(centroid.getX(), centroid.getY(), org.locationtech.geomesa.curve.Z2SFC.index$default$3).&amp;(mask)
        </td>
      </tr><tr>
        <td>
          296
        </td>
        <td>
          11334
        </td>
        <td>
          12189
          -
          12213
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.length().&gt;(precision)
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          11335
        </td>
        <td>
          12239
          -
          12240
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          11336
        </td>
        <td>
          12265
          -
          12274
        </td>
        <td>
          Select
        </td>
        <td>
          java.util.Locale.US
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Locale.US
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          11337
        </td>
        <td>
          12223
          -
          12275
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.substring(0, precision).toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          11338
        </td>
        <td>
          12223
          -
          12275
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.substring(0, precision).toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          11339
        </td>
        <td>
          12313
          -
          12322
        </td>
        <td>
          Select
        </td>
        <td>
          java.util.Locale.US
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.util.Locale.US
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          11340
        </td>
        <td>
          12295
          -
          12323
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          299
        </td>
        <td>
          11341
        </td>
        <td>
          12295
          -
          12323
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.String.toLowerCase
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.toLowerCase(java.util.Locale.US)
        </td>
      </tr><tr>
        <td>
          302
        </td>
        <td>
          11342
        </td>
        <td>
          12403
          -
          12428
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.getTime()./(precision)
        </td>
      </tr><tr>
        <td>
          303
        </td>
        <td>
          11343
        </td>
        <td>
          12498
          -
          12515
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value./(precision)
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          11344
        </td>
        <td>
          12583
          -
          12600
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value./(precision).toLong
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          11345
        </td>
        <td>
          12683
          -
          12700
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Float.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.*(precision)
        </td>
      </tr><tr>
        <td>
          305
        </td>
        <td>
          11346
        </td>
        <td>
          12672
          -
          12701
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.round(value.*(precision)).toLong
        </td>
      </tr><tr>
        <td>
          306
        </td>
        <td>
          11347
        </td>
        <td>
          12786
          -
          12803
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          value.*(precision)
        </td>
      </tr><tr>
        <td>
          306
        </td>
        <td>
          11348
        </td>
        <td>
          12775
          -
          12804
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.math.round
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.math.`package`.round(value.*(precision))
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>