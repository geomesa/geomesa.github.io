<html>
      <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title id="title">
          org/locationtech/geomesa/utils/geohash/GeohashUtils.scala.html
        </title>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/css/theme.default.min.css" type="text/css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.20.1/js/jquery.tablesorter.min.js"></script><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/><script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script><script type="text/javascript">
        $(document).ready(function() {$(".tablesorter").tablesorter();});
      </script>
        <style>
          table.codegrid { font-family: monospace; font-size: 12px; width: auto!important; }table.statementlist { width: auto!important; font-size: 13px; } table.codegrid td { padding: 0!important; border: 0!important } table td.linenumber { width: 40px!important; } 
        </style>
      </head>
      <body style="font-family: monospace;">
        <ul class="nav nav-tabs">
          <li>
            <a href="#codegrid" data-toggle="tab">Codegrid</a>
          </li>
          <li>
            <a href="#statementlist" data-toggle="tab">Statement List</a>
          </li>
        </ul>
        <div class="tab-content">
          <div class="tab-pane active" id="codegrid">
            <pre style='font-size: 12pt; font-family: courier, monospace;'>1 <span style=''>/***********************************************************************
</span>2 <span style=''> * Copyright (c) 2013-2025 Commonwealth Computer Research, Inc.
</span>3 <span style=''> * All rights reserved. This program and the accompanying materials
</span>4 <span style=''> * are made available under the terms of the Apache License, Version 2.0
</span>5 <span style=''> * which accompanies this distribution and is available at
</span>6 <span style=''> * http://www.opensource.org/licenses/apache2.0.php.
</span>7 <span style=''> ***********************************************************************/
</span>8 <span style=''>
</span>9 <span style=''>package org.locationtech.geomesa.utils.geohash
</span>10 <span style=''>
</span>11 <span style=''>import com.typesafe.scalalogging.LazyLogging
</span>12 <span style=''>import org.locationtech.geomesa.utils.geotools.GeometryUtils
</span>13 <span style=''>import org.locationtech.geomesa.utils.iterators.CartesianProductIterable
</span>14 <span style=''>import org.locationtech.geomesa.utils.text.WKTUtils
</span>15 <span style=''>import org.locationtech.jts.geom._
</span>16 <span style=''>import org.locationtech.spatial4j.context.jts.JtsSpatialContext
</span>17 <span style=''>
</span>18 <span style=''>import scala.collection.BitSet
</span>19 <span style=''>import scala.collection.immutable.HashSet
</span>20 <span style=''>import scala.collection.immutable.Range.Inclusive
</span>21 <span style=''>import scala.util.Try
</span>22 <span style=''>import scala.util.control.Exception.catching
</span>23 <span style=''>
</span>24 <span style=''>/**
</span>25 <span style=''> * The following bits of code are related to common operations involving
</span>26 <span style=''> * GeoHashes, such as recommending a GeoHash precision for an enclosing
</span>27 <span style=''> * polygon; decomposing a polygon into a fixed number of subordinate
</span>28 <span style=''> * GeoHashes; enumerating possible sub-strings within subordinate GeoHashes
</span>29 <span style=''> * for a given polygon; etc.
</span>30 <span style=''> */
</span>31 <span style=''>object GeohashUtils
</span>32 <span style=''>  extends GeomDistance
</span>33 <span style=''>  with LazyLogging {
</span>34 <span style=''>
</span>35 <span style=''>  // make sure the implicits related to distance are in-scope
</span>36 <span style=''>  import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry
</span>37 <span style=''>
</span>38 <span style=''>  // these three constants are used in identifying unique GeoHash sub-strings
</span>39 <span style=''>  val Base32Padding = </span><span style='background: #AEF1AE'>(0 to 7).map(i =&gt; List.fill(i)(GeoHash.base32.toSeq))</span><span style=''>
</span>40 <span style=''>  val BinaryPadding = </span><span style='background: #AEF1AE'>(0 to 4).map(i =&gt; List.fill(i)(Seq('0', '1')))</span><span style=''>
</span>41 <span style=''>
</span>42 <span style=''>  /**
</span>43 <span style=''>   * Simple place-holder for a pair of resolutions, minimum and maximum, along
</span>44 <span style=''>   * with an increment.
</span>45 <span style=''>   *
</span>46 <span style=''>   * @param minBitsResolution minimum number of bits (GeoHash) resolution to consider; must be ODD
</span>47 <span style=''>   * @param maxBitsResolution maximum number of bits (GeoHash) resolution to consider; must be ODD
</span>48 <span style=''>   */
</span>49 <span style=''>  case class ResolutionRange(minBitsResolution:Int=5,
</span>50 <span style=''>                             maxBitsResolution:Int=63,
</span>51 <span style=''>                             numBitsIncrement:Int=2) {
</span>52 <span style=''>    // validate resolution arguments
</span>53 <span style=''>    if (</span><span style='background: #AEF1AE'>minBitsResolution &gt;= maxBitsResolution</span><span style=''>)
</span>54 <span style=''>      </span><span style='background: #F0ADAD'>throw new IllegalArgumentException(&quot;Minimum resolution must be strictly greater than maximum resolution.&quot;)</span><span style=''>
</span>55 <span style=''>
</span>56 <span style=''>    lazy val range: Range = new Inclusive(minBitsResolution, maxBitsResolution, numBitsIncrement)
</span>57 <span style=''>    override def toString(): String = </span><span style='background: #F0ADAD'>&quot;{&quot; + minBitsResolution.toString + &quot;, +&quot; + numBitsIncrement + &quot;..., &quot; + maxBitsResolution.toString + &quot;}&quot;</span><span style=''>
</span>58 <span style=''>
</span>59 <span style=''>    def getNumChildren: Int = </span><span style='background: #AEF1AE'>1 &lt;&lt; numBitsIncrement</span><span style=''>
</span>60 <span style=''>
</span>61 <span style=''>    def getNextChildren(parent:BitSet, oldPrecision:Int) : List[BitSet] =
</span>62 <span style=''>      </span><span style='background: #AEF1AE'>Range(0, getNumChildren).map { i =&gt;
</span>63 <span style=''></span><span style='background: #AEF1AE'>        // compute bit-set corresponding to this integer,
</span>64 <span style=''></span><span style='background: #AEF1AE'>        // and add it to the left-shifted version of the parent
</span>65 <span style=''></span><span style='background: #AEF1AE'>        val bitString = i.toBinaryString
</span>66 <span style=''></span><span style='background: #AEF1AE'>
</span>67 <span style=''></span><span style='background: #AEF1AE'>        Range(0, numBitsIncrement).foldLeft(parent) { case (bs, j) =&gt;
</span>68 <span style=''></span><span style='background: #AEF1AE'>          val c = if (j &lt; bitString.length) bitString.charAt(j) else '0'
</span>69 <span style=''></span><span style='background: #AEF1AE'>          if (c == '1') bs + (oldPrecision + bitString.length - 1 - j)
</span>70 <span style=''></span><span style='background: #AEF1AE'>          else bs
</span>71 <span style=''></span><span style='background: #AEF1AE'>        }
</span>72 <span style=''></span><span style='background: #AEF1AE'>      }.toList</span><span style=''>
</span>73 <span style=''>
</span>74 <span style=''>  }
</span>75 <span style=''>
</span>76 <span style=''>  // default precision model
</span>77 <span style=''>  val maxRealisticGeoHashPrecision : Int = </span><span style='background: #AEF1AE'>45</span><span style=''>
</span>78 <span style=''>  val numDistinctGridPoints: Long = </span><span style='background: #AEF1AE'>1L &lt;&lt; ((maxRealisticGeoHashPrecision+1)/2).toLong</span><span style=''>
</span>79 <span style=''>  val defaultPrecisionModel = </span><span style='background: #AEF1AE'>new PrecisionModel(numDistinctGridPoints.toDouble)</span><span style=''>
</span>80 <span style=''>
</span>81 <span style=''>  // default factory for WGS84
</span>82 <span style=''>  val defaultGeometryFactory : GeometryFactory = </span><span style='background: #AEF1AE'>new GeometryFactory(defaultPrecisionModel, 4326)</span><span style=''>
</span>83 <span style=''>
</span>84 <span style=''>  /**
</span>85 <span style=''>   * Utility function that computes the minimum-bounding GeoHash that completely
</span>86 <span style=''>   * encloses the given (target) geometry.  This can be useful as a starting
</span>87 <span style=''>   * point for other calculations on the geometry.
</span>88 <span style=''>   *
</span>89 <span style=''>   * This is a bit of a short-cut, because what it *really* does is to start
</span>90 <span style=''>   * with the centroid of the target geometry, and step down through resolutions
</span>91 <span style=''>   * (in bits) for as long as a GeoHash constructed for that centroid continues
</span>92 <span style=''>   * to enclose the entire geometry.  This works, because any GeoHash that
</span>93 <span style=''>   * encloses the entire geometry must also include the centroid (as well as
</span>94 <span style=''>   * any other point).
</span>95 <span style=''>   *
</span>96 <span style=''>   * @param geom the target geometry that is to be enclosed
</span>97 <span style=''>   * @return the smallest GeoHash -- at an odd number of bits resolution -- that
</span>98 <span style=''>   *         completely encloses the target geometry
</span>99 <span style=''>   */
</span>100 <span style=''>  def getMinimumBoundingGeohash(geom:Geometry, resolutions:ResolutionRange) : GeoHash = {
</span>101 <span style=''>    // save yourself some effort by computing the geometry's centroid and envelope up front
</span>102 <span style=''>    val centroid = </span><span style='background: #AEF1AE'>getCentroid(geom)</span><span style=''>
</span>103 <span style=''>    val env = </span><span style='background: #AEF1AE'>defaultGeometryFactory.toGeometry(geom.getEnvelopeInternal)</span><span style=''>
</span>104 <span style=''>
</span>105 <span style=''>    // conduct the search through the various candidate resolutions
</span>106 <span style=''>    val </span><span style='background: #AEF1AE'>(_, ghOpt)</span><span style=''> = </span><span style='background: #AEF1AE'>resolutions.range.foldRight((resolutions.minBitsResolution, Option.empty[GeoHash])){
</span>107 <span style=''></span><span style='background: #AEF1AE'>      case (bits, orig@(res, _)) =&gt;
</span>108 <span style=''></span><span style='background: #AEF1AE'>        val gh = GeoHash(centroid.getX, centroid.getY, bits)
</span>109 <span style=''></span><span style='background: #AEF1AE'>        if (gh.contains(env) &amp;&amp; bits &gt;= res) (bits, Some(gh)) else orig
</span>110 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>111 <span style=''>
</span>112 <span style=''>    // validate that you found a usable result
</span>113 <span style=''>    val gh = </span><span style='background: #AEF1AE'>ghOpt.getOrElse(</span><span style='background: #F0ADAD'>GeoHash(centroid.getX, centroid.getY, resolutions.minBitsResolution)</span><span style='background: #AEF1AE'>)</span><span style=''>
</span>114 <span style=''>    if (</span><span style='background: #AEF1AE'>!gh.contains(env) &amp;&amp; </span><span style='background: #F0ADAD'>!gh.geom.equals(env)</span><span style=''>)
</span>115 <span style=''>      </span><span style='background: #F0ADAD'>throw new Exception(&quot;ERROR:  Could not find a suitable &quot; +
</span>116 <span style=''></span><span style='background: #F0ADAD'>        resolutions.minBitsResolution + &quot;-bit MBR for the target geometry:  &quot; +
</span>117 <span style=''></span><span style='background: #F0ADAD'>        geom)</span><span style=''>
</span>118 <span style=''>
</span>119 <span style=''>    gh
</span>120 <span style=''>  }
</span>121 <span style=''>
</span>122 <span style=''>  /**
</span>123 <span style=''>   * Computes the centroid of the given geometry as a WGS84 point.
</span>124 <span style=''>   *
</span>125 <span style=''>   * @param geom the target geometry whose centroid is sought
</span>126 <span style=''>   * @return the centroid of the given geometry
</span>127 <span style=''>   */
</span>128 <span style=''>  def getCentroid(geom:Geometry) : Point = {
</span>129 <span style=''>    val pt = </span><span style='background: #AEF1AE'>geom.safeCentroid()</span><span style=''>
</span>130 <span style=''>    </span><span style='background: #AEF1AE'>geom.getFactory.createPoint(new Coordinate(pt.getX, pt.getY))</span><span style=''>
</span>131 <span style=''>  }
</span>132 <span style=''>
</span>133 <span style=''>  // represents a degenerate (empty) geometry
</span>134 <span style=''>  lazy val emptyGeometry: Geometry = WKTUtils.read(&quot;POLYGON((0 0,0 0,0 0,0 0,0 0))&quot;)
</span>135 <span style=''>
</span>136 <span style=''>  /**
</span>137 <span style=''>   * Utility class for the geometry-decomposition routines.  This represents
</span>138 <span style=''>   * one GeoHash-cell candidate within a decomposition.
</span>139 <span style=''>   *
</span>140 <span style=''>   * @param gh the associated GeoHash cell
</span>141 <span style=''>   * @param targetGeom the geometry being decomposed
</span>142 <span style=''>   */
</span>143 <span style=''>  abstract class DecompositionCandidate(val gh:GeoHash,
</span>144 <span style=''>                                        val targetGeom:Geometry,
</span>145 <span style=''>                                        val targetArea:Double,
</span>146 <span style=''>                                        val resolutions:ResolutionRange) {
</span>147 <span style=''>
</span>148 <span style=''>    lazy val geomCatcher = catching(classOf[Exception])
</span>149 <span style=''>    lazy val area: Double = geomCatcher.opt{ gh.getArea }.getOrElse(0.0)
</span>150 <span style=''>    val areaOutside: Double
</span>151 <span style=''>    lazy val areaInside: Double = area - areaOutside
</span>152 <span style=''>    lazy val resolution: Int = gh.prec
</span>153 <span style=''>    lazy val isResolutionOk: Boolean =
</span>154 <span style=''>      resolution &gt;= resolutions.minBitsResolution &amp;&amp; resolution &lt;= resolutions.maxBitsResolution
</span>155 <span style=''>
</span>156 <span style=''>    lazy val intersectsTarget: Boolean =
</span>157 <span style=''>      geomCatcher.opt { gh.intersects(targetGeom) }.getOrElse(false)
</span>158 <span style=''>    lazy val intersection: Geometry =
</span>159 <span style=''>      geomCatcher.opt { gh.intersection(targetGeom) }.getOrElse(emptyGeometry)
</span>160 <span style=''>    lazy val intersectionArea: Double =
</span>161 <span style=''>      geomCatcher.opt { gh.intersection(targetGeom).getArea }.getOrElse(0.0)
</span>162 <span style=''>    def isLT(than:DecompositionCandidate): Boolean = {
</span>163 <span style=''>      if (</span><span style='background: #AEF1AE'>areaOutside &gt; than.areaOutside</span><span style=''>) </span><span style='background: #AEF1AE'>true</span><span style=''>
</span>164 <span style=''>      else {
</span>165 <span style=''>        </span><span style='background: #AEF1AE'>if (areaOutside == than.areaOutside) area &lt; than.area
</span>166 <span style=''></span><span style='background: #AEF1AE'>        else false</span><span style=''>
</span>167 <span style=''>      }
</span>168 <span style=''>    }
</span>169 <span style=''>  }
</span>170 <span style=''>
</span>171 <span style=''>  class PointDecompositionCandidate(gh:GeoHash,
</span>172 <span style=''>                                    targetGeom:Point,
</span>173 <span style=''>                                    targetArea:Double,
</span>174 <span style=''>                                    resolutions:ResolutionRange)
</span>175 <span style=''>    extends DecompositionCandidate(gh, targetGeom, targetArea, resolutions) {
</span>176 <span style=''>
</span>177 <span style=''>    /**
</span>178 <span style=''>     * If the GeoHash does not contain the point, then the entire cell's area is
</span>179 <span style=''>     * outside of the target.  If the GeoHash does contain the point, then be
</span>180 <span style=''>     * careful:  Only some fraction of the cell's area should count as overage
</span>181 <span style=''>     * (otherwise, we can't favor smaller GeoHash cells in the decomposer).
</span>182 <span style=''>     */
</span>183 <span style=''>    override lazy val areaOutside: Double = area * (if (intersectsTarget) 0.75 else 1.0)
</span>184 <span style=''>  }
</span>185 <span style=''>
</span>186 <span style=''>  class LineDecompositionCandidate(gh:GeoHash,
</span>187 <span style=''>                                   targetGeom:MultiLineString,
</span>188 <span style=''>                                   targetArea:Double,
</span>189 <span style=''>                                   resolutions:ResolutionRange)
</span>190 <span style=''>    extends DecompositionCandidate(gh, targetGeom, targetArea, resolutions) {
</span>191 <span style=''>
</span>192 <span style=''>    /**
</span>193 <span style=''>     * If the GeoHash intersects the target lines, then the overlap is the
</span>194 <span style=''>     * area of the GeoHash cell less the length of the intersection.  Otherwise,
</span>195 <span style=''>     * they are disjoint, and the overlap is the entire area of the GeoHash cell.
</span>196 <span style=''>     *
</span>197 <span style=''>     * Yes, this mixes units, but it observes two trends:
</span>198 <span style=''>     * 1.  the longer a segment intersects, the smaller the area outside will be;
</span>199 <span style=''>     * 2.  the smaller a GeoHash cell, the smaller the area outside will be
</span>200 <span style=''>     */
</span>201 <span style=''>    override lazy val areaOutside : Double =
</span>202 <span style=''>      if (intersectsTarget) area * (1.0 - intersection.getLength / targetArea)
</span>203 <span style=''>      else area
</span>204 <span style=''>  }
</span>205 <span style=''>
</span>206 <span style=''>  class PolygonDecompositionCandidate(gh:GeoHash,
</span>207 <span style=''>                                      targetGeom:MultiPolygon,
</span>208 <span style=''>                                      targetArea:Double,
</span>209 <span style=''>                                      resolutions:ResolutionRange)
</span>210 <span style=''>    extends DecompositionCandidate(gh, targetGeom, targetArea, resolutions) {
</span>211 <span style=''>
</span>212 <span style=''>    /**
</span>213 <span style=''>     * If the GeoHash intersects the target polygon, then the overlap is the
</span>214 <span style=''>     * area of the GeoHash cell less the area of the intersection.  Otherwise,
</span>215 <span style=''>     * they are disjoint, and the overlap is the entire area of the GeoHash cell.
</span>216 <span style=''>     */
</span>217 <span style=''>    override lazy val areaOutside : Double =
</span>218 <span style=''>      if (intersectsTarget) area - intersection.getArea
</span>219 <span style=''>      else area
</span>220 <span style=''>  }
</span>221 <span style=''>
</span>222 <span style=''>  def decompositionCandidateSorter(a:DecompositionCandidate,
</span>223 <span style=''>                                   b:DecompositionCandidate): Boolean = </span><span style='background: #AEF1AE'>a.isLT(b)</span><span style=''>
</span>224 <span style=''>
</span>225 <span style=''>  /**
</span>226 <span style=''>   * Decomposes the given polygon into a collection of disjoint GeoHash cells
</span>227 <span style=''>   * so that these constraints are satisfied:
</span>228 <span style=''>   * 1.  the total number of decomposed GeoHashes does not exceed the maximum
</span>229 <span style=''>   *     specified as an argument
</span>230 <span style=''>   * 2.  the resolution of the GeoHashes falls within the given range
</span>231 <span style=''>   * 3.  when replacing larger boxes with smaller boxes, always decompose first
</span>232 <span style=''>   *     the box that contains the most area outside the target polygon
</span>233 <span style=''>   *
</span>234 <span style=''>   * @param targetGeom the polygon to be decomposed
</span>235 <span style=''>   * @param maxSize the maximum number of GeoHash cells into which this polygon
</span>236 <span style=''>   *                should be decomposed
</span>237 <span style=''>   * @param resolutions the list of acceptable resolutions for the GeoHash cells
</span>238 <span style=''>   * @return the list of GeoHash cells into which this polygon was decomposed
</span>239 <span style=''>   *         under the given constraints
</span>240 <span style=''>   */
</span>241 <span style=''>  private def decomposeGeometry_(targetGeom: Geometry,
</span>242 <span style=''>                                 maxSize: Int = 100,
</span>243 <span style=''>                                 resolutions: ResolutionRange = new ResolutionRange(5,40,5)): List[GeoHash] = {
</span>244 <span style=''>    lazy val geomCatcher = catching(classOf[Exception])
</span>245 <span style=''>    val targetArea : Double = </span><span style='background: #AEF1AE'>geomCatcher.opt { targetGeom.getArea }.getOrElse(0.0)</span><span style=''>
</span>246 <span style=''>    val targetLength : Double = </span><span style='background: #AEF1AE'>geomCatcher.opt { targetGeom.getLength }.getOrElse(0.0)</span><span style=''>
</span>247 <span style=''>
</span>248 <span style=''>    // qua factory
</span>249 <span style=''>    def createDecompositionCandidate(gh: GeoHash): DecompositionCandidate = {
</span>250 <span style=''>      // simple switch based on the geometry type
</span>251 <span style=''>      targetGeom match {
</span>252 <span style=''>        case multipoly: MultiPolygon    =&gt;
</span>253 <span style=''>          </span><span style='background: #F0ADAD'>new PolygonDecompositionCandidate(gh, multipoly, targetArea, resolutions)</span><span style=''>
</span>254 <span style=''>        case polygon: Polygon           =&gt;
</span>255 <span style=''>          </span><span style='background: #AEF1AE'>new PolygonDecompositionCandidate(
</span>256 <span style=''></span><span style='background: #AEF1AE'>            gh, new MultiPolygon(Array(polygon), polygon.getFactory), targetArea, resolutions)</span><span style=''>
</span>257 <span style=''>        case line: LineString           =&gt;
</span>258 <span style=''>          </span><span style='background: #AEF1AE'>new LineDecompositionCandidate(  // promote to a multi-line string of one element
</span>259 <span style=''></span><span style='background: #AEF1AE'>            gh, new MultiLineString(Array(line), line.getFactory), targetLength, resolutions)</span><span style=''>
</span>260 <span style=''>        case multiLine: MultiLineString =&gt;
</span>261 <span style=''>          </span><span style='background: #F0ADAD'>new LineDecompositionCandidate(gh, multiLine, targetLength, resolutions)</span><span style=''>
</span>262 <span style=''>        case point: Point               =&gt;
</span>263 <span style=''>          </span><span style='background: #F0ADAD'>new PointDecompositionCandidate(gh, point, targetArea, resolutions)</span><span style=''>  // should never be called, but it works
</span>264 <span style=''>        case _                          =&gt;
</span>265 <span style=''>          </span><span style='background: #F0ADAD'>throw new Exception(s&quot;Unsupported Geometry type for decomposition:  ${targetGeom.getClass.getName}&quot;)</span><span style=''>
</span>266 <span style=''>      }
</span>267 <span style=''>    }
</span>268 <span style=''>
</span>269 <span style=''>    // recursive routine that will do the actual decomposition
</span>270 <span style=''>    def decomposeStep(candidates: List[DecompositionCandidate]): List[DecompositionCandidate] = {
</span>271 <span style=''>      // complain, if needed
</span>272 <span style=''>      if (</span><span style='background: #AEF1AE'>candidates.size &gt; maxSize</span><span style=''>) </span><span style='background: #F0ADAD'>throw new Exception(&quot;Too many candidates upon entry.&quot;)</span><span style=''>
</span>273 <span style=''>      else </span><span style='background: #AEF1AE'>{
</span>274 <span style=''></span><span style='background: #AEF1AE'>        // identify the partial to replace...
</span>275 <span style=''></span><span style='background: #AEF1AE'>        // which of the single candidates contains the least overlap (area outside the target geometry)?
</span>276 <span style=''></span><span style='background: #AEF1AE'>        // assume that these are always sorted so that they are in descending order of overlap-area
</span>277 <span style=''></span><span style='background: #AEF1AE'>        val candidate : DecompositionCandidate = candidates(0)
</span>278 <span style=''></span><span style='background: #AEF1AE'>        val childResolution : Int = candidate.gh.prec+resolutions.numBitsIncrement
</span>279 <span style=''></span><span style='background: #AEF1AE'>
</span>280 <span style=''></span><span style='background: #AEF1AE'>        // decompose this (worst) candidate into its four children
</span>281 <span style=''></span><span style='background: #AEF1AE'>        val candidateBitSet : BitSet = candidate.gh.bitset
</span>282 <span style=''></span><span style='background: #AEF1AE'>        val children:List[DecompositionCandidate] = resolutions.getNextChildren(candidateBitSet, candidate.gh.prec).map((childBitSet) =&gt; {
</span>283 <span style=''></span><span style='background: #AEF1AE'>          createDecompositionCandidate(GeoHash(childBitSet, childResolution))
</span>284 <span style=''></span><span style='background: #AEF1AE'>        }).filter(child =&gt; child.intersectsTarget)
</span>285 <span style=''></span><span style='background: #AEF1AE'>
</span>286 <span style=''></span><span style='background: #AEF1AE'>        // build the next iteration of candidates
</span>287 <span style=''></span><span style='background: #AEF1AE'>        val newCandidates : List[DecompositionCandidate] = (candidates.tail ++ children).sortWith(decompositionCandidateSorter)
</span>288 <span style=''></span><span style='background: #AEF1AE'>
</span>289 <span style=''></span><span style='background: #AEF1AE'>        // recurse, if appropriate
</span>290 <span style=''></span><span style='background: #AEF1AE'>        if ((newCandidates.size &lt;= maxSize) &amp;&amp; (childResolution &lt;= resolutions.maxBitsResolution)) {
</span>291 <span style=''></span><span style='background: #AEF1AE'>          decomposeStep(newCandidates)
</span>292 <span style=''></span><span style='background: #AEF1AE'>        } else candidates
</span>293 <span style=''></span><span style='background: #AEF1AE'>      }</span><span style=''>
</span>294 <span style=''>    }
</span>295 <span style=''>
</span>296 <span style=''>    // identify the smallest GeoHash that contains the entire polygon
</span>297 <span style=''>    val ghMBR = </span><span style='background: #AEF1AE'>getMinimumBoundingGeohash(targetGeom, resolutions)</span><span style=''>
</span>298 <span style=''>    val candidateMBR = </span><span style='background: #AEF1AE'>createDecompositionCandidate(ghMBR)</span><span style=''>
</span>299 <span style=''>
</span>300 <span style=''>    // recursively decompose worst choices
</span>301 <span style=''>    val (keepers:List[DecompositionCandidate]) = </span><span style='background: #AEF1AE'>decomposeStep(List(candidateMBR))</span><span style=''>
</span>302 <span style=''>
</span>303 <span style=''>    // return only the keepers
</span>304 <span style=''>    </span><span style='background: #AEF1AE'>(for (keeper:DecompositionCandidate &lt;- keepers) yield keeper.gh).toList</span><span style=''>
</span>305 <span style=''>  }
</span>306 <span style=''>
</span>307 <span style=''>  def getDecomposableGeometry(targetGeom: Geometry): Geometry = targetGeom match {
</span>308 <span style=''>    case g: Point                                            =&gt; </span><span style='background: #F0ADAD'>targetGeom</span><span style=''>
</span>309 <span style=''>    case g: Polygon                                          =&gt; </span><span style='background: #AEF1AE'>targetGeom</span><span style=''>
</span>310 <span style=''>    case g: LineString      if </span><span style='background: #AEF1AE'>targetGeom.getNumPoints &lt; 100</span><span style=''> =&gt; </span><span style='background: #AEF1AE'>targetGeom</span><span style=''>
</span>311 <span style=''>    case g: MultiLineString if </span><span style='background: #F0ADAD'>targetGeom.getNumPoints &lt; 100</span><span style=''> =&gt; </span><span style='background: #F0ADAD'>targetGeom</span><span style=''>
</span>312 <span style=''>    case _                                                   =&gt; </span><span style='background: #F0ADAD'>targetGeom.convexHull</span><span style=''>
</span>313 <span style=''>  }
</span>314 <span style=''>
</span>315 <span style=''>  /**
</span>316 <span style=''>   * Transforms a geometry with lon in (-inf, inf) and lat in [-90,90] to a geometry in whole earth BBOX
</span>317 <span style=''>   * 1) any coords of geometry outside lon [-180,180] are transformed to be within [-180,180]
</span>318 <span style=''>   *    (to avoid spatial4j validation errors)
</span>319 <span style=''>   * 2) use spatial4j to create a geometry with inferred International Date Line crossings
</span>320 <span style=''>   *    (if successive coordinates longitudinal difference is greater than 180)
</span>321 <span style=''>   * Parts of geometries with lat outside [-90,90] are ignored.
</span>322 <span style=''>   * To represent a geometry with successive coordinates having lon diff &gt; 180 and not wrapping
</span>323 <span style=''>   * the IDL, you must insert a waypoint such that the difference is less than 180
</span>324 <span style=''>   */
</span>325 <span style=''>  def getInternationalDateLineSafeGeometry(targetGeom: Geometry): Try[Geometry] = {
</span>326 <span style=''>
</span>327 <span style=''>    def degreesLonTranslation(lon: Double): Double = </span><span style='background: #AEF1AE'>(((lon + 180) / 360.0).floor * -360).toInt</span><span style=''>
</span>328 <span style=''>
</span>329 <span style=''>    def translateCoord(coord: Coordinate): Coordinate = {
</span>330 <span style=''>      </span><span style='background: #AEF1AE'>new Coordinate(coord.x + degreesLonTranslation(coord.x), coord.y)</span><span style=''>
</span>331 <span style=''>    }
</span>332 <span style=''>
</span>333 <span style=''>    def translatePolygon(geometry: Geometry): Geometry =
</span>334 <span style=''>      </span><span style='background: #AEF1AE'>defaultGeometryFactory.createPolygon(geometry.getCoordinates.map(c =&gt; translateCoord(c)))</span><span style=''>
</span>335 <span style=''>
</span>336 <span style=''>    def translateLineString(geometry: Geometry): Geometry =
</span>337 <span style=''>      </span><span style='background: #AEF1AE'>defaultGeometryFactory.createLineString(geometry.getCoordinates.map(c =&gt; translateCoord(c)))</span><span style=''>
</span>338 <span style=''>
</span>339 <span style=''>    def translateMultiLineString(geometry: Geometry): Geometry = {
</span>340 <span style=''>      val coords = </span><span style='background: #AEF1AE'>(0 until geometry.getNumGeometries).map { i =&gt; geometry.getGeometryN(i) }</span><span style=''>
</span>341 <span style=''>      val translated = </span><span style='background: #AEF1AE'>coords.map { c =&gt; translateLineString(c).asInstanceOf[LineString] }</span><span style=''>
</span>342 <span style=''>      </span><span style='background: #AEF1AE'>defaultGeometryFactory.createMultiLineString(translated.toArray)</span><span style=''>
</span>343 <span style=''>    }
</span>344 <span style=''>
</span>345 <span style=''>    def translateMultiPolygon(geometry: Geometry): Geometry = {
</span>346 <span style=''>      val coords = </span><span style='background: #AEF1AE'>(0 until geometry.getNumGeometries).map { i =&gt; geometry.getGeometryN(i) }</span><span style=''>
</span>347 <span style=''>      val translated = </span><span style='background: #AEF1AE'>coords.map { c =&gt; translatePolygon(c).asInstanceOf[Polygon] }</span><span style=''>
</span>348 <span style=''>      </span><span style='background: #AEF1AE'>defaultGeometryFactory.createMultiPolygon(translated.toArray)</span><span style=''>
</span>349 <span style=''>    }
</span>350 <span style=''>
</span>351 <span style=''>    def translateMultiPoint(geometry: Geometry): Geometry =
</span>352 <span style=''>      </span><span style='background: #AEF1AE'>defaultGeometryFactory.createMultiPoint(geometry.getCoordinates.map(c =&gt; translateCoord(c)))</span><span style=''>
</span>353 <span style=''>
</span>354 <span style=''>    def translatePoint(geometry: Geometry): Geometry = {
</span>355 <span style=''>      </span><span style='background: #AEF1AE'>defaultGeometryFactory.createPoint(translateCoord(geometry.getCoordinate))</span><span style=''>
</span>356 <span style=''>    }
</span>357 <span style=''>
</span>358 <span style=''>    def translateGeometry(geometry: Geometry): Geometry = {
</span>359 <span style=''>      geometry match {
</span>360 <span style=''>        case p: Polygon =&gt;          </span><span style='background: #AEF1AE'>translatePolygon(geometry)</span><span style=''>
</span>361 <span style=''>        case l: LineString =&gt;       </span><span style='background: #AEF1AE'>translateLineString(geometry)</span><span style=''>
</span>362 <span style=''>        case m: MultiLineString =&gt;  </span><span style='background: #AEF1AE'>translateMultiLineString(geometry)</span><span style=''>
</span>363 <span style=''>        case m: MultiPolygon =&gt;     </span><span style='background: #AEF1AE'>translateMultiPolygon(geometry)</span><span style=''>
</span>364 <span style=''>        case m: MultiPoint =&gt;       </span><span style='background: #AEF1AE'>translateMultiPoint(geometry)</span><span style=''>
</span>365 <span style=''>        case p: Point =&gt;            </span><span style='background: #AEF1AE'>translatePoint(geometry)</span><span style=''>
</span>366 <span style=''>      }
</span>367 <span style=''>    }
</span>368 <span style=''>
</span>369 <span style=''>    </span><span style='background: #AEF1AE'>Try {
</span>370 <span style=''></span><span style='background: #AEF1AE'>      // copy the geometry so that we don't modify the input - JTS mutates the geometry
</span>371 <span style=''></span><span style='background: #AEF1AE'>      // don't use the defaultGeometryFactory as it has limited precision
</span>372 <span style=''></span><span style='background: #AEF1AE'>      val copy = GeometryUtils.geoFactory.createGeometry(targetGeom)
</span>373 <span style=''></span><span style='background: #AEF1AE'>      val withinBoundsGeom =
</span>374 <span style=''></span><span style='background: #AEF1AE'>        if (targetGeom.getEnvelopeInternal.getMinX &lt; -180 || targetGeom.getEnvelopeInternal.getMaxX &gt; 180)
</span>375 <span style=''></span><span style='background: #AEF1AE'>          translateGeometry(copy)
</span>376 <span style=''></span><span style='background: #AEF1AE'>        else
</span>377 <span style=''></span><span style='background: #AEF1AE'>          copy
</span>378 <span style=''></span><span style='background: #AEF1AE'>
</span>379 <span style=''></span><span style='background: #AEF1AE'>      JtsSpatialContext.GEO.makeShape(withinBoundsGeom, true, true).getGeom
</span>380 <span style=''></span><span style='background: #AEF1AE'>    }</span><span style=''>
</span>381 <span style=''>  }
</span>382 <span style=''>
</span>383 <span style=''>  /**
</span>384 <span style=''>   * Quick-and-dirty sieve that ensures that we don't waste time decomposing
</span>385 <span style=''>   * single points.
</span>386 <span style=''>   */
</span>387 <span style=''>  def decomposeGeometry(targetGeom: Geometry,
</span>388 <span style=''>                        maxSize: Int = 100,
</span>389 <span style=''>                        resolutions: ResolutionRange = ResolutionRange(0, 40, 5),
</span>390 <span style=''>                        relaxFit: Boolean = true): List[GeoHash] = {
</span>391 <span style=''>  // quick hit to avoid wasting time for single points
</span>392 <span style=''>    targetGeom match {
</span>393 <span style=''>      case point: Point =&gt; </span><span style='background: #AEF1AE'>List(GeoHash(point.getX, point.getY, resolutions.maxBitsResolution))</span><span style=''>
</span>394 <span style=''>      case gc: GeometryCollection =&gt; </span><span style='background: #AEF1AE'>(0 until gc.getNumGeometries).toList.flatMap { i =&gt;
</span>395 <span style=''></span><span style='background: #AEF1AE'>        decomposeGeometry(gc.getGeometryN(i), maxSize, resolutions, relaxFit)
</span>396 <span style=''></span><span style='background: #AEF1AE'>      }.distinct</span><span style=''>
</span>397 <span style=''>      case _ </span><span style='background: #AEF1AE'>=&gt;
</span>398 <span style=''></span><span style='background: #AEF1AE'>        val safeGeom = getInternationalDateLineSafeGeometry(targetGeom).getOrElse(targetGeom)
</span>399 <span style=''></span><span style='background: #AEF1AE'>        decomposeGeometry_(
</span>400 <span style=''></span><span style='background: #AEF1AE'>          if (relaxFit) getDecomposableGeometry(safeGeom)
</span>401 <span style=''></span><span style='background: #AEF1AE'>          else </span><span style='background: #F0ADAD'>safeGeom</span><span style='background: #AEF1AE'>, maxSize, resolutions)</span><span style=''>
</span>402 <span style=''>    }
</span>403 <span style=''>  }
</span>404 <span style=''>
</span>405 <span style=''>  /**
</span>406 <span style=''>   * Given a collection of GeoHash hash sub-strings, this routine
</span>407 <span style=''>   * will build an iterator that generates all dotted variants.
</span>408 <span style=''>   * &quot;Dotted&quot; in this context means supporting the abstracted
</span>409 <span style=''>   * representation (in which higher-level hash-strings use periods
</span>410 <span style=''>   * for the base-32 characters they don't use).  For example,
</span>411 <span style=''>   * if the string is &quot;dqb&quot;, then the dotted variants include all
</span>412 <span style=''>   * of the following:
</span>413 <span style=''>   *
</span>414 <span style=''>   *   dqb
</span>415 <span style=''>   *   dq.
</span>416 <span style=''>   *   d..
</span>417 <span style=''>   *   ...
</span>418 <span style=''>   *
</span>419 <span style=''>   * @param set the collection of GeoHash hash substrings to dot
</span>420 <span style=''>   * @param maxSize the maximum allowable number of entries in the final
</span>421 <span style=''>   *                iterator
</span>422 <span style=''>   * @return an iterator over the dotted collection of hash substrings,
</span>423 <span style=''>   *         constrained to one more than the maximum allowable size
</span>424 <span style=''>   *         (to enable overflow-detection on the outside)
</span>425 <span style=''>   */
</span>426 <span style=''>  def getGeohashStringDottingIterator(set: Seq[String], maxSize: Int): Iterator[String] = {
</span>427 <span style=''>    val len = </span><span style='background: #AEF1AE'>set.headOption.map(_.length).getOrElse(0)</span><span style=''>
</span>428 <span style=''>    </span><span style='background: #AEF1AE'>(for {
</span>429 <span style=''></span><span style='background: #AEF1AE'>      i &lt;- (0 to len).iterator
</span>430 <span style=''></span><span style='background: #AEF1AE'>      hash &lt;- set.map(_.take(i)).distinct
</span>431 <span style=''></span><span style='background: #AEF1AE'>      newStr = hash.take(i) + &quot;&quot;.padTo(len - i, &quot;.&quot;).mkString
</span>432 <span style=''></span><span style='background: #AEF1AE'>    } yield newStr).take(maxSize + 1)</span><span style=''>
</span>433 <span style=''>  }
</span>434 <span style=''>
</span>435 <span style=''>  def promoteToRegion(geom: Geometry): Geometry = geom match {
</span>436 <span style=''>    case g: Point   =&gt;
</span>437 <span style=''>      </span><span style='background: #AEF1AE'>g.buffer(1e-6)</span><span style=''>
</span>438 <span style=''>    case g: Polygon =&gt;
</span>439 <span style=''>      </span><span style='background: #AEF1AE'>if (g.getArea &gt; 0.0) g
</span>440 <span style=''></span><span style='background: #AEF1AE'>      else </span><span style='background: #F0ADAD'>g.safeCentroid().buffer(1e-6)</span><span style=''>
</span>441 <span style=''>    case g          </span><span style='background: #AEF1AE'>=&gt;
</span>442 <span style=''></span><span style='background: #AEF1AE'>      val env = g.getEnvelope
</span>443 <span style=''></span><span style='background: #AEF1AE'>      if (env.getArea &gt; 0.0) </span><span style='background: #F0ADAD'>env</span><span style='background: #AEF1AE'>
</span>444 <span style=''></span><span style='background: #AEF1AE'>      else env.getCentroid.buffer(1e-6)</span><span style=''>
</span>445 <span style=''>  }
</span>446 <span style=''>
</span>447 <span style=''>  /**
</span>448 <span style=''>   * Given an index-schema format such as &quot;%1,3#gh&quot;, it becomes necessary to
</span>449 <span style=''>   * identify which unique 3-character GeoHash sub-strings intersect the
</span>450 <span style=''>   * query polygon.  This routine performs exactly such an identification.
</span>451 <span style=''>   *
</span>452 <span style=''>   * The full GeoHashes from which the sub-strings are extracted are computed
</span>453 <span style=''>   * at 35 bits.
</span>454 <span style=''>   *
</span>455 <span style=''>   * Computing all of the 35-bit GeoHashes that intersect with the target
</span>456 <span style=''>   * geometry can take too long.  Instead, we start with the minimum-bounding
</span>457 <span style=''>   * GeoHash (which might be 0 bits), and recursively dividing it in two
</span>458 <span style=''>   * while remembering those GeoHashes that are completely contained in the
</span>459 <span style=''>   * target geometry.  This has a few advantages:
</span>460 <span style=''>   *
</span>461 <span style=''>   * 1.  we can stop recursing into GeoHashes at the coarsest
</span>462 <span style=''>   *     level (largest geometry) possible when they stop intersecting
</span>463 <span style=''>   *     the target geometry;
</span>464 <span style=''>   * 2.  instead of enumerating all of the GeoHashes that intersect, we
</span>465 <span style=''>   *     can stop as soon as we know that all possible children are known
</span>466 <span style=''>   *     to be inside the target geometry; that is, if a 13-bit GeoHash
</span>467 <span style=''>   *     is covered by the target, then we know that all 15-bit GeoHashes
</span>468 <span style=''>   *     that are its children will also be covered by the target
</span>469 <span style=''>   * 3.  if we ever find a GeoHash that is entirely covered by the target
</span>470 <span style=''>   *     geometry whose precision is no more than 5 times the &quot;offset&quot;
</span>471 <span style=''>   *     parameter's number of bits, then we can stop, because all possible
</span>472 <span style=''>   *     combinations are known to be used
</span>473 <span style=''>   *
</span>474 <span style=''>   * As an example, consider trying to enumerate the (3, 2) sub-strings of
</span>475 <span style=''>   * GeoHashes in a polygon that is only slightly inset within the
</span>476 <span style=''>   * Southern hemisphere.  This implicates a large number of 25-bit
</span>477 <span style=''>   * GeoHashes, but as soon as one of the GeoHashes that has 15 or fewer
</span>478 <span style=''>   * bits is found that is covered by the target, the search can stop
</span>479 <span style=''>   * for unique prefixes, because all of its 25-bit children will be
</span>480 <span style=''>   * distinct and will also be covered by the target.
</span>481 <span style=''>   *
</span>482 <span style=''>   * This is easier to explain with pictures.
</span>483 <span style=''>   *
</span>484 <span style=''>   * @param geom the query-polygon that must intersect candidate GeoHashes
</span>485 <span style=''>   * @param offset how many of the left-most GeoHash characters to skip
</span>486 <span style=''>   * @param length how many of the (remaining) GeoHash characters to use
</span>487 <span style=''>   * @param MAX_KEYS_IN_LIST the maximum allowable number of unique GeoHash
</span>488 <span style=''>   *                         sub-strings; when exceeded, the function returns
</span>489 <span style=''>   *                         an empty list
</span>490 <span style=''>   *
</span>491 <span style=''>   * @return the list of unique GeoHash sub-strings from 35-bits precision that
</span>492 <span style=''>   *         intersect the target polygon; an empty list if there are too many
</span>493 <span style=''>   */
</span>494 <span style=''>  def getUniqueGeohashSubstringsInPolygon(geom: Geometry,
</span>495 <span style=''>                                          offset: Int,
</span>496 <span style=''>                                          length: Int,
</span>497 <span style=''>                                          MAX_KEYS_IN_LIST: Int = Int.MaxValue - 1,
</span>498 <span style=''>                                          includeDots: Boolean = true): Try[Seq[String]] = </span><span style='background: #AEF1AE'>Try {
</span>499 <span style=''></span><span style='background: #AEF1AE'>
</span>500 <span style=''></span><span style='background: #AEF1AE'>    val cover = promoteToRegion(geom)
</span>501 <span style=''></span><span style='background: #AEF1AE'>
</span>502 <span style=''></span><span style='background: #AEF1AE'>    //val cover: Geometry = geom.buffer(0)
</span>503 <span style=''></span><span style='background: #AEF1AE'>    val maxBits = (offset + length) * 5
</span>504 <span style=''></span><span style='background: #AEF1AE'>    val minBits = offset * 5
</span>505 <span style=''></span><span style='background: #AEF1AE'>    val usedBits = length * 5
</span>506 <span style=''></span><span style='background: #AEF1AE'>    val allResolutions = ResolutionRange(0, Math.min(35, maxBits), 1)
</span>507 <span style=''></span><span style='background: #AEF1AE'>    val maxKeys = Math.min(2 &lt;&lt; Math.min(usedBits, 29), MAX_KEYS_IN_LIST)
</span>508 <span style=''></span><span style='background: #AEF1AE'>    val polyCentroid = cover.safeCentroid()
</span>509 <span style=''></span><span style='background: #AEF1AE'>
</span>510 <span style=''></span><span style='background: #AEF1AE'>    // find the smallest GeoHash you can that covers the target geometry
</span>511 <span style=''></span><span style='background: #AEF1AE'>    val ghMBR = getMinimumBoundingGeohash(geom, allResolutions)
</span>512 <span style=''></span><span style='background: #AEF1AE'>
</span>513 <span style=''></span><span style='background: #AEF1AE'>    // this case-class closes over properties of the current search
</span>514 <span style=''></span><span style='background: #AEF1AE'>    case class BitPrefixes(prefixes: Seq[String]) {
</span>515 <span style=''></span><span style='background: #AEF1AE'>
</span>516 <span style=''></span><span style='background: #AEF1AE'>      val hasEverythingPrefix = prefixes.exists(prefix =&gt; prefix.length &lt;= minBits)
</span>517 <span style=''></span><span style='background: #AEF1AE'>
</span>518 <span style=''></span><span style='background: #AEF1AE'>      // how many GeoHashes are entailed by the list of prefixes
</span>519 <span style=''></span><span style='background: #AEF1AE'>      val entailedSize =
</span>520 <span style=''></span><span style='background: #AEF1AE'>        if (hasEverythingPrefix) </span><span style='background: #F0ADAD'>maxKeys</span><span style='background: #AEF1AE'>
</span>521 <span style=''></span><span style='background: #AEF1AE'>        else Math.min(
</span>522 <span style=''></span><span style='background: #AEF1AE'>          1 &lt;&lt; usedBits,
</span>523 <span style=''></span><span style='background: #AEF1AE'>          prefixes.foldLeft(0)((sumSoFar, prefix) =&gt; {
</span>524 <span style=''></span><span style='background: #AEF1AE'>            sumSoFar + (1 &lt;&lt; Math.min(usedBits, maxBits - prefix.length))
</span>525 <span style=''></span><span style='background: #AEF1AE'>          }))
</span>526 <span style=''></span><span style='background: #AEF1AE'>
</span>527 <span style=''></span><span style='background: #AEF1AE'>      // is there any prefix wholly contained within the target geometry
</span>528 <span style=''></span><span style='background: #AEF1AE'>      // that uses fewer than 5*offset bits?  if so, then all possible
</span>529 <span style=''></span><span style='background: #AEF1AE'>      // sub-strings are entailed
</span>530 <span style=''></span><span style='background: #AEF1AE'>      val usesAll = prefixes.exists(prefix =&gt; prefix.length &lt;= minBits) ||
</span>531 <span style=''></span><span style='background: #AEF1AE'>        entailedSize == maxKeys
</span>532 <span style=''></span><span style='background: #AEF1AE'>
</span>533 <span style=''></span><span style='background: #AEF1AE'>      // the loose inequality is so that we can detect overflow
</span>534 <span style=''></span><span style='background: #AEF1AE'>      def hasRoom = </span><span style='background: #F0ADAD'>entailedSize &lt;= maxKeys</span><span style='background: #AEF1AE'>
</span>535 <span style=''></span><span style='background: #AEF1AE'>
</span>536 <span style=''></span><span style='background: #AEF1AE'>      def notDone = </span><span style='background: #F0ADAD'>!usesAll &amp;&amp; hasRoom</span><span style='background: #AEF1AE'>
</span>537 <span style=''></span><span style='background: #AEF1AE'>
</span>538 <span style=''></span><span style='background: #AEF1AE'>      def overflowed =
</span>539 <span style=''></span><span style='background: #AEF1AE'>        if (usesAll) {
</span>540 <span style=''></span><span style='background: #AEF1AE'>          </span><span style='background: #F0ADAD'>(1 &lt;&lt; usedBits) &gt; maxKeys</span><span style='background: #AEF1AE'>
</span>541 <span style=''></span><span style='background: #AEF1AE'>        } else {
</span>542 <span style=''></span><span style='background: #AEF1AE'>          entailedSize &gt; maxKeys
</span>543 <span style=''></span><span style='background: #AEF1AE'>        }
</span>544 <span style=''></span><span style='background: #AEF1AE'>
</span>545 <span style=''></span><span style='background: #AEF1AE'>      // generate all combinations of GeoHash strings of
</span>546 <span style=''></span><span style='background: #AEF1AE'>      // the desired length
</span>547 <span style=''></span><span style='background: #AEF1AE'>      def generateAll(prefix: String): Seq[String] = {
</span>548 <span style=''></span><span style='background: #AEF1AE'>        val prefixHash = GeoHash.fromBinaryString(prefix).hash
</span>549 <span style=''></span><span style='background: #AEF1AE'>        if (prefixHash.length &lt; length) {
</span>550 <span style=''></span><span style='background: #AEF1AE'>          val charSeqs = Base32Padding(length - prefixHash.length)
</span>551 <span style=''></span><span style='background: #AEF1AE'>          CartesianProductIterable(charSeqs).toList.map(prefixHash + _.mkString)
</span>552 <span style=''></span><span style='background: #AEF1AE'>        } else Seq(prefixHash)
</span>553 <span style=''></span><span style='background: #AEF1AE'>      }
</span>554 <span style=''></span><span style='background: #AEF1AE'>
</span>555 <span style=''></span><span style='background: #AEF1AE'>      // generate all of the combinations entailed by the prefixes identified,
</span>556 <span style=''></span><span style='background: #AEF1AE'>      // all of which will have bits that overlap with the requested substring
</span>557 <span style=''></span><span style='background: #AEF1AE'>      // (that is, if we want (3,2), then all of the prefixes we identified have
</span>558 <span style=''></span><span style='background: #AEF1AE'>      // somewhere between 15 and 25 bits in them)
</span>559 <span style=''></span><span style='background: #AEF1AE'>      //
</span>560 <span style=''></span><span style='background: #AEF1AE'>      // each prefix, then, needs to be expanded to a list of all combinations
</span>561 <span style=''></span><span style='background: #AEF1AE'>      // of bits that reach the next 5-bit boundary, and then those prefixes
</span>562 <span style=''></span><span style='background: #AEF1AE'>      // can be expanded to use all combinations of base-32 characters that
</span>563 <span style=''></span><span style='background: #AEF1AE'>      // allow them to fill out the requisite range
</span>564 <span style=''></span><span style='background: #AEF1AE'>      def generateSome: Seq[String] = {
</span>565 <span style=''></span><span style='background: #AEF1AE'>        prefixes.foldLeft(HashSet[String]())((ghsSoFar, prefix) =&gt; {
</span>566 <span style=''></span><span style='background: #AEF1AE'>          // fill out this prefix to the next 5-bit boundary
</span>567 <span style=''></span><span style='background: #AEF1AE'>          val bitsToBoundary = (65 - prefix.length) % 5
</span>568 <span style=''></span><span style='background: #AEF1AE'>          val bases =
</span>569 <span style=''></span><span style='background: #AEF1AE'>            if (bitsToBoundary == 0) Seq(prefix)
</span>570 <span style=''></span><span style='background: #AEF1AE'>            else {
</span>571 <span style=''></span><span style='background: #AEF1AE'>              val fillers = BinaryPadding(bitsToBoundary)
</span>572 <span style=''></span><span style='background: #AEF1AE'>              val result = CartesianProductIterable(fillers).toList.map(prefix + _.mkString)
</span>573 <span style=''></span><span style='background: #AEF1AE'>              result
</span>574 <span style=''></span><span style='background: #AEF1AE'>            }
</span>575 <span style=''></span><span style='background: #AEF1AE'>          bases.foldLeft(ghsSoFar)((ghs, base) =&gt; {
</span>576 <span style=''></span><span style='background: #AEF1AE'>            val baseTrimmed = base.drop(minBits)
</span>577 <span style=''></span><span style='background: #AEF1AE'>            val newSubs = generateAll(baseTrimmed)
</span>578 <span style=''></span><span style='background: #AEF1AE'>            ghs ++ newSubs
</span>579 <span style=''></span><span style='background: #AEF1AE'>          })
</span>580 <span style=''></span><span style='background: #AEF1AE'>        }).toSeq
</span>581 <span style=''></span><span style='background: #AEF1AE'>      }
</span>582 <span style=''></span><span style='background: #AEF1AE'>
</span>583 <span style=''></span><span style='background: #AEF1AE'>      def toSeq: Seq[String] =
</span>584 <span style=''></span><span style='background: #AEF1AE'>        if (usesAll) </span><span style='background: #F0ADAD'>generateAll(&quot;&quot;)</span><span style='background: #AEF1AE'>
</span>585 <span style=''></span><span style='background: #AEF1AE'>        else generateSome
</span>586 <span style=''></span><span style='background: #AEF1AE'>    }
</span>587 <span style=''></span><span style='background: #AEF1AE'>
</span>588 <span style=''></span><span style='background: #AEF1AE'>    // assume that this method is never called on a GeoHash
</span>589 <span style=''></span><span style='background: #AEF1AE'>    // whose binary-string encoding is too long
</span>590 <span style=''></span><span style='background: #AEF1AE'>    def considerCandidate(candidate: GeoHash): Seq[String] = {
</span>591 <span style=''></span><span style='background: #AEF1AE'>      val bitString = candidate.toBinaryString
</span>592 <span style=''></span><span style='background: #AEF1AE'>
</span>593 <span style=''></span><span style='background: #AEF1AE'>      if (!geom.intersects(candidate.geom)) return Nil
</span>594 <span style=''></span><span style='background: #AEF1AE'>
</span>595 <span style=''></span><span style='background: #AEF1AE'>      if (cover.covers(candidate.geom) || (bitString.size == maxBits)) {
</span>596 <span style=''></span><span style='background: #AEF1AE'>        Seq(bitString)
</span>597 <span style=''></span><span style='background: #AEF1AE'>      } else {
</span>598 <span style=''></span><span style='background: #AEF1AE'>        if (bitString.size &lt; maxBits) {
</span>599 <span style=''></span><span style='background: #AEF1AE'>          // choose which direction to recurse into next by proximity
</span>600 <span style=''></span><span style='background: #AEF1AE'>          // of the two child GeoHashes to the polygon's centroid;
</span>601 <span style=''></span><span style='background: #AEF1AE'>          // for rectangles or polygons whose area is concentrated
</span>602 <span style=''></span><span style='background: #AEF1AE'>          // near the centroid, this provides for a a HUGE speed increase
</span>603 <span style=''></span><span style='background: #AEF1AE'>          val gh0 = GeoHash.fromBinaryString(bitString + &quot;0&quot;)
</span>604 <span style=''></span><span style='background: #AEF1AE'>          val gh1 = GeoHash.fromBinaryString(bitString + &quot;1&quot;)
</span>605 <span style=''></span><span style='background: #AEF1AE'>          val d0 = Math.hypot(gh0.getPoint.getX - polyCentroid.getX, gh0.getPoint.getY - polyCentroid.getY)
</span>606 <span style=''></span><span style='background: #AEF1AE'>          val d1 = Math.hypot(gh1.getPoint.getX - polyCentroid.getX, gh1.getPoint.getY - polyCentroid.getY)
</span>607 <span style=''></span><span style='background: #AEF1AE'>          val (firstChild, secondChild) =
</span>608 <span style=''></span><span style='background: #AEF1AE'>            if (d0 &lt;= d1) (gh0, gh1)
</span>609 <span style=''></span><span style='background: #AEF1AE'>            else (gh1, gh0)
</span>610 <span style=''></span><span style='background: #AEF1AE'>
</span>611 <span style=''></span><span style='background: #AEF1AE'>          val firstChildList = considerCandidate(firstChild)
</span>612 <span style=''></span><span style='background: #AEF1AE'>
</span>613 <span style=''></span><span style='background: #AEF1AE'>          // if you've found an entry that entails all sub-strings, stop searching
</span>614 <span style=''></span><span style='background: #AEF1AE'>          firstChildList ++ (firstChildList.headOption match {
</span>615 <span style=''></span><span style='background: #AEF1AE'>            case Some(bitStr) if bitStr.length &lt;= minBits =&gt; </span><span style='background: #F0ADAD'>Nil</span><span style='background: #AEF1AE'>
</span>616 <span style=''></span><span style='background: #AEF1AE'>            case _                                        =&gt;
</span>617 <span style=''></span><span style='background: #AEF1AE'>              considerCandidate(secondChild)
</span>618 <span style=''></span><span style='background: #AEF1AE'>          })
</span>619 <span style=''></span><span style='background: #AEF1AE'>        } else </span><span style='background: #F0ADAD'>Nil</span><span style='background: #AEF1AE'>
</span>620 <span style=''></span><span style='background: #AEF1AE'>      }
</span>621 <span style=''></span><span style='background: #AEF1AE'>    }
</span>622 <span style=''></span><span style='background: #AEF1AE'>
</span>623 <span style=''></span><span style='background: #AEF1AE'>    // compute the list of acceptable prefixes
</span>624 <span style=''></span><span style='background: #AEF1AE'>    val bitPrefixes = BitPrefixes(
</span>625 <span style=''></span><span style='background: #AEF1AE'>      if (ghMBR.prec &lt;= maxBits) considerCandidate(ghMBR)
</span>626 <span style=''></span><span style='background: #AEF1AE'>      else </span><span style='background: #F0ADAD'>Seq(ghMBR.toBinaryString.drop(minBits).take(usedBits))</span><span style='background: #AEF1AE'>)
</span>627 <span style=''></span><span style='background: #AEF1AE'>
</span>628 <span style=''></span><span style='background: #AEF1AE'>    // detect overflow
</span>629 <span style=''></span><span style='background: #AEF1AE'>    if (bitPrefixes.overflowed) </span><span style='background: #F0ADAD'>throw new IllegalStateException(&quot;Bit prefixes overflowed while calculating unique Geohash substrings in polygon using the following parameters: &quot; +
</span>630 <span style=''></span><span style='background: #F0ADAD'>      s&quot;\nGeometry: $geom \nOffset: $offset \nLength: $length \nMax Keys in List: $MAX_KEYS_IN_LIST&quot;)</span><span style='background: #AEF1AE'>
</span>631 <span style=''></span><span style='background: #AEF1AE'>
</span>632 <span style=''></span><span style='background: #AEF1AE'>    // not having overflowed, turn the collection of disjoint prefixes
</span>633 <span style=''></span><span style='background: #AEF1AE'>    // into a list of full geohash substrings
</span>634 <span style=''></span><span style='background: #AEF1AE'>    val unDotted = bitPrefixes.toSeq
</span>635 <span style=''></span><span style='background: #AEF1AE'>
</span>636 <span style=''></span><span style='background: #AEF1AE'>    // add dotted versions, if appropriate (to match decomposed GeoHashes that
</span>637 <span style=''></span><span style='background: #AEF1AE'>    // may be encoded at less than a full 35-bits precision)
</span>638 <span style=''></span><span style='background: #AEF1AE'>    if (includeDots) {
</span>639 <span style=''></span><span style='background: #AEF1AE'>      if (unDotted.size &lt; maxKeys) {
</span>640 <span style=''></span><span style='background: #AEF1AE'>        // STOP as soon as you've exceeded the maximum allowable entries
</span>641 <span style=''></span><span style='background: #AEF1AE'>        val keepers = getGeohashStringDottingIterator(
</span>642 <span style=''></span><span style='background: #AEF1AE'>          unDotted, MAX_KEYS_IN_LIST).take(MAX_KEYS_IN_LIST + 1).toList
</span>643 <span style=''></span><span style='background: #AEF1AE'>        if (keepers.size &lt;= MAX_KEYS_IN_LIST) keepers.toSeq else </span><span style='background: #F0ADAD'>Seq()</span><span style='background: #AEF1AE'>
</span>644 <span style=''></span><span style='background: #AEF1AE'>      } else </span><span style='background: #F0ADAD'>Seq()</span><span style='background: #AEF1AE'>
</span>645 <span style=''></span><span style='background: #AEF1AE'>    } else </span><span style='background: #F0ADAD'>unDotted</span><span style='background: #AEF1AE'>
</span>646 <span style=''></span><span style='background: #AEF1AE'>  }</span><span style=''>
</span>647 <span style=''>}
</span></pre>
          </div>
          <div class="tab-pane" id="statementlist">
            <table cellspacing="0" cellpadding="0" class="table statementlist">
      <tr>
        <th>Line</th>
        <th>Stmt Id</th>
        <th>Pos</th>
        <th>Tree</th>
        <th>Symbol</th>
        <th>Tests</th>
        <th>Code</th>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          3247
        </td>
        <td>
          1665
          -
          1666
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          3248
        </td>
        <td>
          1670
          -
          1671
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          7
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          3249
        </td>
        <td>
          1695
          -
          1709
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.base32
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeoHash.base32
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          3250
        </td>
        <td>
          1695
          -
          1715
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.toSeq
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(GeoHash.base32).toSeq
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          3251
        </td>
        <td>
          1682
          -
          1716
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenTraversableFactory.fill
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.List.fill[Seq[Char]](i)(scala.Predef.augmentString(GeoHash.base32).toSeq)
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          3252
        </td>
        <td>
          1676
          -
          1676
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[List[Seq[Char]]]
        </td>
      </tr><tr>
        <td>
          39
        </td>
        <td>
          3253
        </td>
        <td>
          1664
          -
          1717
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(0).to(7).map[List[Seq[Char]], scala.collection.immutable.IndexedSeq[List[Seq[Char]]]](((i: Int) =&gt; scala.collection.immutable.List.fill[Seq[Char]](i)(scala.Predef.augmentString(GeoHash.base32).toSeq)))(immutable.this.IndexedSeq.canBuildFrom[List[Seq[Char]]])
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          3254
        </td>
        <td>
          1741
          -
          1742
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          3255
        </td>
        <td>
          1746
          -
          1747
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          4
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          3256
        </td>
        <td>
          1771
          -
          1784
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[Char]('0', '1')
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          3257
        </td>
        <td>
          1758
          -
          1785
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenTraversableFactory.fill
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.List.fill[Seq[Char]](i)(scala.collection.Seq.apply[Char]('0', '1'))
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          3258
        </td>
        <td>
          1752
          -
          1752
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[List[Seq[Char]]]
        </td>
      </tr><tr>
        <td>
          40
        </td>
        <td>
          3259
        </td>
        <td>
          1740
          -
          1786
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(0).to(4).map[List[Seq[Char]], scala.collection.immutable.IndexedSeq[List[Seq[Char]]]](((i: Int) =&gt; scala.collection.immutable.List.fill[Seq[Char]](i)(scala.collection.Seq.apply[Char]('0', '1'))))(immutable.this.IndexedSeq.canBuildFrom[List[Seq[Char]]])
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          3260
        </td>
        <td>
          2336
          -
          2353
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.maxBitsResolution
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ResolutionRange.this.maxBitsResolution
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          3261
        </td>
        <td>
          2315
          -
          2353
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ResolutionRange.this.minBitsResolution.&gt;=(ResolutionRange.this.maxBitsResolution)
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          3264
        </td>
        <td>
          2311
          -
          2311
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          53
        </td>
        <td>
          3265
        </td>
        <td>
          2311
          -
          2311
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          54
        </td>
        <td>
          3262
        </td>
        <td>
          2361
          -
          2467
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(&quot;Minimum resolution must be strictly greater than maximum resolution.&quot;)
        </td>
      </tr><tr>
        <td>
          54
        </td>
        <td>
          3263
        </td>
        <td>
          2361
          -
          2467
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.IllegalArgumentException(&quot;Minimum resolution must be strictly greater than maximum resolution.&quot;)
        </td>
      </tr><tr>
        <td>
          57
        </td>
        <td>
          3266
        </td>
        <td>
          2605
          -
          2709
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.+
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          &quot;{&quot;.+(ResolutionRange.this.minBitsResolution.toString()).+(&quot;, +&quot;).+(ResolutionRange.this.numBitsIncrement).+(&quot;..., &quot;).+(ResolutionRange.this.maxBitsResolution.toString()).+(&quot;}&quot;)
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          3267
        </td>
        <td>
          2741
          -
          2742
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          3268
        </td>
        <td>
          2746
          -
          2762
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.numBitsIncrement
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ResolutionRange.this.numBitsIncrement
        </td>
      </tr><tr>
        <td>
          59
        </td>
        <td>
          3269
        </td>
        <td>
          2741
          -
          2762
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1.&lt;&lt;(ResolutionRange.this.numBitsIncrement)
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          3270
        </td>
        <td>
          2850
          -
          2851
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          3271
        </td>
        <td>
          2853
          -
          2867
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.getNumChildren
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ResolutionRange.this.getNumChildren
        </td>
      </tr><tr>
        <td>
          62
        </td>
        <td>
          3288
        </td>
        <td>
          2873
          -
          2873
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[scala.collection.BitSet]
        </td>
      </tr><tr>
        <td>
          65
        </td>
        <td>
          3272
        </td>
        <td>
          3026
          -
          3042
        </td>
        <td>
          Select
        </td>
        <td>
          scala.runtime.RichInt.toBinaryString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(i).toBinaryString
        </td>
      </tr><tr>
        <td>
          67
        </td>
        <td>
          3273
        </td>
        <td>
          3058
          -
          3059
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          67
        </td>
        <td>
          3274
        </td>
        <td>
          3061
          -
          3077
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.numBitsIncrement
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ResolutionRange.this.numBitsIncrement
        </td>
      </tr><tr>
        <td>
          67
        </td>
        <td>
          3286
        </td>
        <td>
          3111
          -
          3275
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val c: Char = if (j.&lt;(bitString.length()))
    bitString.charAt(j)
  else
    '0';
  if (c.==('1'))
    bs.+(oldPrecision.+(bitString.length()).-(1).-(j))
  else
    bs
}
        </td>
      </tr><tr>
        <td>
          67
        </td>
        <td>
          3287
        </td>
        <td>
          3052
          -
          3285
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Range.apply(0, ResolutionRange.this.numBitsIncrement).foldLeft[scala.collection.BitSet](parent)(((x0$1: scala.collection.BitSet, x1$1: Int) =&gt; scala.Tuple2.apply[scala.collection.BitSet, Int](x0$1, x1$1) match {
  case (_1: scala.collection.BitSet, _2: Int)(scala.collection.BitSet, Int)((bs @ _), (j @ _)) =&gt; {
    val c: Char = if (j.&lt;(bitString.length()))
      bitString.charAt(j)
    else
      '0';
    if (c.==('1'))
      bs.+(oldPrecision.+(bitString.length()).-(1).-(j))
    else
      bs
  }
}))
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          3275
        </td>
        <td>
          3140
          -
          3156
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitString.length()
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          3276
        </td>
        <td>
          3136
          -
          3156
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          j.&lt;(bitString.length())
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          3277
        </td>
        <td>
          3158
          -
          3177
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.charAt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitString.charAt(j)
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          3278
        </td>
        <td>
          3158
          -
          3177
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.String.charAt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitString.charAt(j)
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          3279
        </td>
        <td>
          3183
          -
          3186
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          '0'
        </td>
      </tr><tr>
        <td>
          68
        </td>
        <td>
          3280
        </td>
        <td>
          3183
          -
          3186
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          '0'
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          3281
        </td>
        <td>
          3201
          -
          3209
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Char.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          c.==('1')
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          3282
        </td>
        <td>
          3217
          -
          3256
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          oldPrecision.+(bitString.length()).-(1).-(j)
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          3283
        </td>
        <td>
          3211
          -
          3257
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SetLike.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bs.+(oldPrecision.+(bitString.length()).-(1).-(j))
        </td>
      </tr><tr>
        <td>
          69
        </td>
        <td>
          3284
        </td>
        <td>
          3211
          -
          3257
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.SetLike.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bs.+(oldPrecision.+(bitString.length()).-(1).-(j))
        </td>
      </tr><tr>
        <td>
          70
        </td>
        <td>
          3285
        </td>
        <td>
          3273
          -
          3275
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.bs
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bs
        </td>
      </tr><tr>
        <td>
          72
        </td>
        <td>
          3289
        </td>
        <td>
          2844
          -
          3300
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableOnce.toList
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.`package`.Range.apply(0, ResolutionRange.this.getNumChildren).map[scala.collection.BitSet, scala.collection.immutable.IndexedSeq[scala.collection.BitSet]](((i: Int) =&gt; {
  val bitString: String = scala.Predef.intWrapper(i).toBinaryString;
  scala.`package`.Range.apply(0, ResolutionRange.this.numBitsIncrement).foldLeft[scala.collection.BitSet](parent)(((x0$1: scala.collection.BitSet, x1$1: Int) =&gt; scala.Tuple2.apply[scala.collection.BitSet, Int](x0$1, x1$1) match {
    case (_1: scala.collection.BitSet, _2: Int)(scala.collection.BitSet, Int)((bs @ _), (j @ _)) =&gt; {
      val c: Char = if (j.&lt;(bitString.length()))
        bitString.charAt(j)
      else
        '0';
      if (c.==('1'))
        bs.+(oldPrecision.+(bitString.length()).-(1).-(j))
      else
        bs
    }
  }))
}))(immutable.this.IndexedSeq.canBuildFrom[scala.collection.BitSet]).toList
        </td>
      </tr><tr>
        <td>
          77
        </td>
        <td>
          3290
        </td>
        <td>
          3379
          -
          3381
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          45
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          3291
        </td>
        <td>
          3418
          -
          3420
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          3292
        </td>
        <td>
          3455
          -
          3456
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          3293
        </td>
        <td>
          3458
          -
          3459
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          2
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          3294
        </td>
        <td>
          3424
          -
          3467
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toLong
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.maxRealisticGeoHashPrecision.+(1)./(2).toLong
        </td>
      </tr><tr>
        <td>
          78
        </td>
        <td>
          3295
        </td>
        <td>
          3418
          -
          3467
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Long.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1L.&lt;&lt;(GeohashUtils.this.maxRealisticGeoHashPrecision.+(1)./(2).toLong)
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          3296
        </td>
        <td>
          3517
          -
          3547
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Long.toDouble
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.numDistinctGridPoints.toDouble
        </td>
      </tr><tr>
        <td>
          79
        </td>
        <td>
          3297
        </td>
        <td>
          3498
          -
          3548
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.PrecisionModel.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.jts.geom.PrecisionModel(GeohashUtils.this.numDistinctGridPoints.toDouble)
        </td>
      </tr><tr>
        <td>
          82
        </td>
        <td>
          3298
        </td>
        <td>
          3650
          -
          3671
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.defaultPrecisionModel
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultPrecisionModel
        </td>
      </tr><tr>
        <td>
          82
        </td>
        <td>
          3299
        </td>
        <td>
          3673
          -
          3677
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          4326
        </td>
      </tr><tr>
        <td>
          82
        </td>
        <td>
          3300
        </td>
        <td>
          3630
          -
          3678
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.jts.geom.GeometryFactory(GeohashUtils.this.defaultPrecisionModel, 4326)
        </td>
      </tr><tr>
        <td>
          102
        </td>
        <td>
          3301
        </td>
        <td>
          4719
          -
          4736
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.getCentroid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.getCentroid(geom)
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          3302
        </td>
        <td>
          4785
          -
          4809
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getEnvelopeInternal
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geom.getEnvelopeInternal()
        </td>
      </tr><tr>
        <td>
          103
        </td>
        <td>
          3303
        </td>
        <td>
          4751
          -
          4810
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.toGeometry
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultGeometryFactory.toGeometry(geom.getEnvelopeInternal())
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          3304
        </td>
        <td>
          4930
          -
          4959
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.minBitsResolution
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          resolutions.minBitsResolution
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          3305
        </td>
        <td>
          4961
          -
          4982
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Option.empty
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Option.empty[org.locationtech.geomesa.utils.geohash.GeoHash]
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          3306
        </td>
        <td>
          4929
          -
          4983
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash]](resolutions.minBitsResolution, scala.Option.empty[org.locationtech.geomesa.utils.geohash.GeoHash])
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          3317
        </td>
        <td>
          4901
          -
          5160
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.foldRight
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          resolutions.range.foldRight[(Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash])](scala.Tuple2.apply[Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash]](resolutions.minBitsResolution, scala.Option.empty[org.locationtech.geomesa.utils.geohash.GeoHash]))(((x0$1: Int, x1$1: (Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash])) =&gt; scala.Tuple2.apply[Int, (Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash])](x0$1, x1$1) match {
  case (_1: Int, _2: (Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash]))(Int, (Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash]))((bits @ _), (orig @ (_1: Int, _2: Option[org.locationtech.geomesa.utils.geohash.GeoHash])(Int, Option[org.locationtech.geomesa.utils.geohash.GeoHash])((res @ _), _))) =&gt; {
    val gh: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.apply(centroid.getX(), centroid.getY(), bits);
    if (geohash.this.GeoHash.toGeometry(gh).contains(env).&amp;&amp;(bits.&gt;=(res)))
      scala.Tuple2.apply[Int, Some[org.locationtech.geomesa.utils.geohash.GeoHash]](bits, scala.Some.apply[org.locationtech.geomesa.utils.geohash.GeoHash](gh))
    else
      orig
  }
}))
        </td>
      </tr><tr>
        <td>
          106
        </td>
        <td>
          3318
        </td>
        <td>
          4888
          -
          4898
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ghOpt
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ghOpt
        </td>
      </tr><tr>
        <td>
          107
        </td>
        <td>
          3316
        </td>
        <td>
          5019
          -
          5154
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val gh: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.apply(centroid.getX(), centroid.getY(), bits);
  if (geohash.this.GeoHash.toGeometry(gh).contains(env).&amp;&amp;(bits.&gt;=(res)))
    scala.Tuple2.apply[Int, Some[org.locationtech.geomesa.utils.geohash.GeoHash]](bits, scala.Some.apply[org.locationtech.geomesa.utils.geohash.GeoHash](gh))
  else
    orig
}
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          3307
        </td>
        <td>
          5047
          -
          5060
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getX
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          centroid.getX()
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          3308
        </td>
        <td>
          5062
          -
          5075
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getY
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          centroid.getY()
        </td>
      </tr><tr>
        <td>
          108
        </td>
        <td>
          3309
        </td>
        <td>
          5039
          -
          5082
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeoHash.apply(centroid.getX(), centroid.getY(), bits)
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          3310
        </td>
        <td>
          5115
          -
          5126
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bits.&gt;=(res)
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          3311
        </td>
        <td>
          5095
          -
          5126
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geohash.this.GeoHash.toGeometry(gh).contains(env).&amp;&amp;(bits.&gt;=(res))
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          3312
        </td>
        <td>
          5135
          -
          5143
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Some.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Some.apply[org.locationtech.geomesa.utils.geohash.GeoHash](gh)
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          3313
        </td>
        <td>
          5128
          -
          5144
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, Some[org.locationtech.geomesa.utils.geohash.GeoHash]](bits, scala.Some.apply[org.locationtech.geomesa.utils.geohash.GeoHash](gh))
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          3314
        </td>
        <td>
          5128
          -
          5144
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[Int, Some[org.locationtech.geomesa.utils.geohash.GeoHash]](bits, scala.Some.apply[org.locationtech.geomesa.utils.geohash.GeoHash](gh))
        </td>
      </tr><tr>
        <td>
          109
        </td>
        <td>
          3315
        </td>
        <td>
          5150
          -
          5154
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.orig
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          orig
        </td>
      </tr><tr>
        <td>
          113
        </td>
        <td>
          3319
        </td>
        <td>
          5246
          -
          5259
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getX
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          centroid.getX()
        </td>
      </tr><tr>
        <td>
          113
        </td>
        <td>
          3320
        </td>
        <td>
          5261
          -
          5274
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getY
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          centroid.getY()
        </td>
      </tr><tr>
        <td>
          113
        </td>
        <td>
          3321
        </td>
        <td>
          5276
          -
          5305
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.minBitsResolution
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          resolutions.minBitsResolution
        </td>
      </tr><tr>
        <td>
          113
        </td>
        <td>
          3322
        </td>
        <td>
          5238
          -
          5306
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          GeoHash.apply(centroid.getX(), centroid.getY(), resolutions.minBitsResolution)
        </td>
      </tr><tr>
        <td>
          113
        </td>
        <td>
          3323
        </td>
        <td>
          5222
          -
          5307
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ghOpt.getOrElse[org.locationtech.geomesa.utils.geohash.GeoHash](GeoHash.apply(centroid.getX(), centroid.getY(), resolutions.minBitsResolution))
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          3324
        </td>
        <td>
          5337
          -
          5357
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          gh.geom.equals(env).unary_!
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          3325
        </td>
        <td>
          5316
          -
          5357
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geohash.this.GeoHash.toGeometry(gh).contains(env).unary_!.&amp;&amp;(gh.geom.equals(env).unary_!)
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          3328
        </td>
        <td>
          5312
          -
          5312
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          114
        </td>
        <td>
          3329
        </td>
        <td>
          5312
          -
          5312
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          3326
        </td>
        <td>
          5365
          -
          5517
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.Exception(&quot;ERROR:  Could not find a suitable &quot;.+(resolutions.minBitsResolution).+(&quot;-bit MBR for the target geometry:  &quot;).+(geom))
        </td>
      </tr><tr>
        <td>
          115
        </td>
        <td>
          3327
        </td>
        <td>
          5365
          -
          5517
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.Exception(&quot;ERROR:  Could not find a suitable &quot;.+(resolutions.minBitsResolution).+(&quot;-bit MBR for the target geometry:  &quot;).+(geom))
        </td>
      </tr><tr>
        <td>
          129
        </td>
        <td>
          3330
        </td>
        <td>
          5783
          -
          5802
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry.safeCentroid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(geom).safeCentroid()
        </td>
      </tr><tr>
        <td>
          130
        </td>
        <td>
          3331
        </td>
        <td>
          5850
          -
          5857
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getX
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          pt.getX()
        </td>
      </tr><tr>
        <td>
          130
        </td>
        <td>
          3332
        </td>
        <td>
          5859
          -
          5866
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getY
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          pt.getY()
        </td>
      </tr><tr>
        <td>
          130
        </td>
        <td>
          3333
        </td>
        <td>
          5835
          -
          5867
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Coordinate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.jts.geom.Coordinate(pt.getX(), pt.getY())
        </td>
      </tr><tr>
        <td>
          130
        </td>
        <td>
          3334
        </td>
        <td>
          5807
          -
          5868
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createPoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geom.getFactory().createPoint(new org.locationtech.jts.geom.Coordinate(pt.getX(), pt.getY()))
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          3335
        </td>
        <td>
          7321
          -
          7337
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate.areaOutside
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          than.areaOutside
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          3336
        </td>
        <td>
          7307
          -
          7337
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          DecompositionCandidate.this.areaOutside.&gt;(than.areaOutside)
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          3337
        </td>
        <td>
          7339
          -
          7343
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          163
        </td>
        <td>
          3338
        </td>
        <td>
          7339
          -
          7343
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          true
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          3339
        </td>
        <td>
          7384
          -
          7400
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate.areaOutside
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          than.areaOutside
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          3340
        </td>
        <td>
          7369
          -
          7400
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          DecompositionCandidate.this.areaOutside.==(than.areaOutside)
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          3341
        </td>
        <td>
          7402
          -
          7418
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          DecompositionCandidate.this.area.&lt;(than.area)
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          3342
        </td>
        <td>
          7402
          -
          7418
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Double.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          DecompositionCandidate.this.area.&lt;(than.area)
        </td>
      </tr><tr>
        <td>
          165
        </td>
        <td>
          3345
        </td>
        <td>
          7365
          -
          7437
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (DecompositionCandidate.this.areaOutside.==(than.areaOutside))
  DecompositionCandidate.this.area.&lt;(than.area)
else
  false
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          3343
        </td>
        <td>
          7432
          -
          7437
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          166
        </td>
        <td>
          3344
        </td>
        <td>
          7432
          -
          7437
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          false
        </td>
      </tr><tr>
        <td>
          223
        </td>
        <td>
          3346
        </td>
        <td>
          9936
          -
          9945
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate.isLT
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          a.isLT(b)
        </td>
      </tr><tr>
        <td>
          245
        </td>
        <td>
          3347
        </td>
        <td>
          11101
          -
          11154
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geomCatcher.opt[Double](targetGeom.getArea()).getOrElse[Double](0.0)
        </td>
      </tr><tr>
        <td>
          246
        </td>
        <td>
          3348
        </td>
        <td>
          11187
          -
          11242
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geomCatcher.opt[Double](targetGeom.getLength()).getOrElse[Double](0.0)
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          3349
        </td>
        <td>
          11469
          -
          11542
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.PolygonDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          new GeohashUtils.this.PolygonDecompositionCandidate(gh, multipoly, targetArea, resolutions)
        </td>
      </tr><tr>
        <td>
          253
        </td>
        <td>
          3350
        </td>
        <td>
          11469
          -
          11542
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.PolygonDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          new GeohashUtils.this.PolygonDecompositionCandidate(gh, multipoly, targetArea, resolutions)
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          3354
        </td>
        <td>
          11596
          -
          11725
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.PolygonDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new GeohashUtils.this.PolygonDecompositionCandidate(gh, new org.locationtech.jts.geom.MultiPolygon(scala.Array.apply[org.locationtech.jts.geom.Polygon](polygon)((ClassTag.apply[org.locationtech.jts.geom.Polygon](classOf[org.locationtech.jts.geom.Polygon]): scala.reflect.ClassTag[org.locationtech.jts.geom.Polygon])), polygon.getFactory()), targetArea, resolutions)
        </td>
      </tr><tr>
        <td>
          255
        </td>
        <td>
          3355
        </td>
        <td>
          11596
          -
          11725
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.PolygonDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new GeohashUtils.this.PolygonDecompositionCandidate(gh, new org.locationtech.jts.geom.MultiPolygon(scala.Array.apply[org.locationtech.jts.geom.Polygon](polygon)((ClassTag.apply[org.locationtech.jts.geom.Polygon](classOf[org.locationtech.jts.geom.Polygon]): scala.reflect.ClassTag[org.locationtech.jts.geom.Polygon])), polygon.getFactory()), targetArea, resolutions)
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          3351
        </td>
        <td>
          11664
          -
          11678
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Array.apply[org.locationtech.jts.geom.Polygon](polygon)((ClassTag.apply[org.locationtech.jts.geom.Polygon](classOf[org.locationtech.jts.geom.Polygon]): scala.reflect.ClassTag[org.locationtech.jts.geom.Polygon]))
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          3352
        </td>
        <td>
          11680
          -
          11698
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getFactory
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          polygon.getFactory()
        </td>
      </tr><tr>
        <td>
          256
        </td>
        <td>
          3353
        </td>
        <td>
          11647
          -
          11699
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.MultiPolygon.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.jts.geom.MultiPolygon(scala.Array.apply[org.locationtech.jts.geom.Polygon](polygon)((ClassTag.apply[org.locationtech.jts.geom.Polygon](classOf[org.locationtech.jts.geom.Polygon]): scala.reflect.ClassTag[org.locationtech.jts.geom.Polygon])), polygon.getFactory())
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          3359
        </td>
        <td>
          11779
          -
          11954
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.LineDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new GeohashUtils.this.LineDecompositionCandidate(gh, new org.locationtech.jts.geom.MultiLineString(scala.Array.apply[org.locationtech.jts.geom.LineString](line)((ClassTag.apply[org.locationtech.jts.geom.LineString](classOf[org.locationtech.jts.geom.LineString]): scala.reflect.ClassTag[org.locationtech.jts.geom.LineString])), line.getFactory()), targetLength, resolutions)
        </td>
      </tr><tr>
        <td>
          258
        </td>
        <td>
          3360
        </td>
        <td>
          11779
          -
          11954
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.LineDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new GeohashUtils.this.LineDecompositionCandidate(gh, new org.locationtech.jts.geom.MultiLineString(scala.Array.apply[org.locationtech.jts.geom.LineString](line)((ClassTag.apply[org.locationtech.jts.geom.LineString](classOf[org.locationtech.jts.geom.LineString]): scala.reflect.ClassTag[org.locationtech.jts.geom.LineString])), line.getFactory()), targetLength, resolutions)
        </td>
      </tr><tr>
        <td>
          259
        </td>
        <td>
          3356
        </td>
        <td>
          11897
          -
          11908
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Array.apply[org.locationtech.jts.geom.LineString](line)((ClassTag.apply[org.locationtech.jts.geom.LineString](classOf[org.locationtech.jts.geom.LineString]): scala.reflect.ClassTag[org.locationtech.jts.geom.LineString]))
        </td>
      </tr><tr>
        <td>
          259
        </td>
        <td>
          3357
        </td>
        <td>
          11910
          -
          11925
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getFactory
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          line.getFactory()
        </td>
      </tr><tr>
        <td>
          259
        </td>
        <td>
          3358
        </td>
        <td>
          11877
          -
          11926
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.MultiLineString.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.jts.geom.MultiLineString(scala.Array.apply[org.locationtech.jts.geom.LineString](line)((ClassTag.apply[org.locationtech.jts.geom.LineString](classOf[org.locationtech.jts.geom.LineString]): scala.reflect.ClassTag[org.locationtech.jts.geom.LineString])), line.getFactory())
        </td>
      </tr><tr>
        <td>
          261
        </td>
        <td>
          3361
        </td>
        <td>
          12008
          -
          12080
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.LineDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          new GeohashUtils.this.LineDecompositionCandidate(gh, multiLine, targetLength, resolutions)
        </td>
      </tr><tr>
        <td>
          261
        </td>
        <td>
          3362
        </td>
        <td>
          12008
          -
          12080
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.LineDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          new GeohashUtils.this.LineDecompositionCandidate(gh, multiLine, targetLength, resolutions)
        </td>
      </tr><tr>
        <td>
          263
        </td>
        <td>
          3363
        </td>
        <td>
          12134
          -
          12201
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.PointDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          new GeohashUtils.this.PointDecompositionCandidate(gh, point, targetArea, resolutions)
        </td>
      </tr><tr>
        <td>
          263
        </td>
        <td>
          3364
        </td>
        <td>
          12134
          -
          12201
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.PointDecompositionCandidate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          new GeohashUtils.this.PointDecompositionCandidate(gh, point, targetArea, resolutions)
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          3365
        </td>
        <td>
          12296
          -
          12396
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.Exception(scala.StringContext.apply(&quot;Unsupported Geometry type for decomposition:  &quot;, &quot;&quot;).s(targetGeom.getClass().getName()))
        </td>
      </tr><tr>
        <td>
          265
        </td>
        <td>
          3366
        </td>
        <td>
          12296
          -
          12396
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.Exception(scala.StringContext.apply(&quot;Unsupported Geometry type for decomposition:  &quot;, &quot;&quot;).s(targetGeom.getClass().getName()))
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          3367
        </td>
        <td>
          12612
          -
          12637
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidates.size.&gt;(maxSize)
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          3368
        </td>
        <td>
          12639
          -
          12693
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.Exception(&quot;Too many candidates upon entry.&quot;)
        </td>
      </tr><tr>
        <td>
          272
        </td>
        <td>
          3369
        </td>
        <td>
          12639
          -
          12693
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new scala.`package`.Exception(&quot;Too many candidates upon entry.&quot;)
        </td>
      </tr><tr>
        <td>
          273
        </td>
        <td>
          3388
        </td>
        <td>
          12705
          -
          13887
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val candidate: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate = candidates.apply(0);
  val childResolution: Int = candidate.gh.prec.+(resolutions.numBitsIncrement);
  val candidateBitSet: scala.collection.BitSet = candidate.gh.bitset;
  val children: List[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate] = resolutions.getNextChildren(candidateBitSet, candidate.gh.prec).map[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate, List[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]](((childBitSet: scala.collection.BitSet) =&gt; createDecompositionCandidate(GeoHash.apply(childBitSet, childResolution))))(immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]).filter(((child: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate) =&gt; child.intersectsTarget));
  val newCandidates: List[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate] = candidates.tail.++[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate, List[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]](children)(immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]).sortWith({
    ((a: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate, b: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate) =&gt; GeohashUtils.this.decompositionCandidateSorter(a, b))
  });
  if (newCandidates.size.&lt;=(maxSize).&amp;&amp;(childResolution.&lt;=(resolutions.maxBitsResolution)))
    decomposeStep(newCandidates)
  else
    candidates
}
        </td>
      </tr><tr>
        <td>
          277
        </td>
        <td>
          3370
        </td>
        <td>
          13007
          -
          13020
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.LinearSeqOptimized.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidates.apply(0)
        </td>
      </tr><tr>
        <td>
          278
        </td>
        <td>
          3371
        </td>
        <td>
          13075
          -
          13103
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.numBitsIncrement
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          resolutions.numBitsIncrement
        </td>
      </tr><tr>
        <td>
          278
        </td>
        <td>
          3372
        </td>
        <td>
          13057
          -
          13103
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidate.gh.prec.+(resolutions.numBitsIncrement)
        </td>
      </tr><tr>
        <td>
          281
        </td>
        <td>
          3373
        </td>
        <td>
          13211
          -
          13230
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.bitset
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidate.gh.bitset
        </td>
      </tr><tr>
        <td>
          282
        </td>
        <td>
          3374
        </td>
        <td>
          13328
          -
          13345
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.prec
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidate.gh.prec
        </td>
      </tr><tr>
        <td>
          282
        </td>
        <td>
          3377
        </td>
        <td>
          13350
          -
          13350
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.List.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]
        </td>
      </tr><tr>
        <td>
          283
        </td>
        <td>
          3375
        </td>
        <td>
          13409
          -
          13446
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeoHash.apply(childBitSet, childResolution)
        </td>
      </tr><tr>
        <td>
          283
        </td>
        <td>
          3376
        </td>
        <td>
          13380
          -
          13447
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.createDecompositionCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          createDecompositionCandidate(GeoHash.apply(childBitSet, childResolution))
        </td>
      </tr><tr>
        <td>
          284
        </td>
        <td>
          3378
        </td>
        <td>
          13283
          -
          13498
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableLike.filter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          resolutions.getNextChildren(candidateBitSet, candidate.gh.prec).map[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate, List[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]](((childBitSet: scala.collection.BitSet) =&gt; createDecompositionCandidate(GeoHash.apply(childBitSet, childResolution))))(immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]).filter(((child: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate) =&gt; child.intersectsTarget))
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          3379
        </td>
        <td>
          13626
          -
          13626
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.List.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          3380
        </td>
        <td>
          13648
          -
          13676
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.decompositionCandidateSorter
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.decompositionCandidateSorter(a, b)
        </td>
      </tr><tr>
        <td>
          287
        </td>
        <td>
          3381
        </td>
        <td>
          13609
          -
          13677
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SeqLike.sortWith
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidates.tail.++[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate, List[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]](children)(immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate]).sortWith({
  ((a: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate, b: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate) =&gt; GeohashUtils.this.decompositionCandidateSorter(a, b))
})
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          3382
        </td>
        <td>
          13781
          -
          13810
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.maxBitsResolution
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          resolutions.maxBitsResolution
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          3383
        </td>
        <td>
          13762
          -
          13810
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          childResolution.&lt;=(resolutions.maxBitsResolution)
        </td>
      </tr><tr>
        <td>
          290
        </td>
        <td>
          3384
        </td>
        <td>
          13726
          -
          13811
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          newCandidates.size.&lt;=(maxSize).&amp;&amp;(childResolution.&lt;=(resolutions.maxBitsResolution))
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          3385
        </td>
        <td>
          13825
          -
          13853
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.decomposeStep
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          decomposeStep(newCandidates)
        </td>
      </tr><tr>
        <td>
          291
        </td>
        <td>
          3386
        </td>
        <td>
          13825
          -
          13853
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.decomposeStep
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          decomposeStep(newCandidates)
        </td>
      </tr><tr>
        <td>
          292
        </td>
        <td>
          3387
        </td>
        <td>
          13869
          -
          13879
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.candidates
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidates
        </td>
      </tr><tr>
        <td>
          297
        </td>
        <td>
          3389
        </td>
        <td>
          13981
          -
          14031
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.getMinimumBoundingGeohash
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.getMinimumBoundingGeohash(targetGeom, resolutions)
        </td>
      </tr><tr>
        <td>
          298
        </td>
        <td>
          3390
        </td>
        <td>
          14055
          -
          14090
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.createDecompositionCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          createDecompositionCandidate(ghMBR)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          3391
        </td>
        <td>
          14198
          -
          14216
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.List.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.List.apply[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate](candidateMBR)
        </td>
      </tr><tr>
        <td>
          301
        </td>
        <td>
          3392
        </td>
        <td>
          14184
          -
          14217
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.decomposeStep
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          decomposeStep(scala.collection.immutable.List.apply[org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate](candidateMBR))
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          3393
        </td>
        <td>
          14308
          -
          14317
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate.gh
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          keeper.gh
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          3394
        </td>
        <td>
          14290
          -
          14290
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.List.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeoHash]
        </td>
      </tr><tr>
        <td>
          304
        </td>
        <td>
          3395
        </td>
        <td>
          14254
          -
          14325
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.immutable.List.toList
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          keepers.withFilter(((check$ifrefutable$1: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate) =&gt; (check$ifrefutable$1: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate @unchecked) match {
  case (keeper @ (_: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate)) =&gt; true
  case _ =&gt; false
})).map[org.locationtech.geomesa.utils.geohash.GeoHash, List[org.locationtech.geomesa.utils.geohash.GeoHash]](((keeper: org.locationtech.geomesa.utils.geohash.GeohashUtils.DecompositionCandidate) =&gt; keeper.gh))(immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeoHash]).toList
        </td>
      </tr><tr>
        <td>
          308
        </td>
        <td>
          3396
        </td>
        <td>
          14478
          -
          14488
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.targetGeom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          targetGeom
        </td>
      </tr><tr>
        <td>
          309
        </td>
        <td>
          3397
        </td>
        <td>
          14553
          -
          14563
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.targetGeom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          targetGeom
        </td>
      </tr><tr>
        <td>
          310
        </td>
        <td>
          3398
        </td>
        <td>
          14595
          -
          14624
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          targetGeom.getNumPoints().&lt;(100)
        </td>
      </tr><tr>
        <td>
          310
        </td>
        <td>
          3399
        </td>
        <td>
          14628
          -
          14638
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.targetGeom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          targetGeom
        </td>
      </tr><tr>
        <td>
          311
        </td>
        <td>
          3400
        </td>
        <td>
          14670
          -
          14699
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          targetGeom.getNumPoints().&lt;(100)
        </td>
      </tr><tr>
        <td>
          311
        </td>
        <td>
          3401
        </td>
        <td>
          14703
          -
          14713
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.targetGeom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          targetGeom
        </td>
      </tr><tr>
        <td>
          312
        </td>
        <td>
          3402
        </td>
        <td>
          14778
          -
          14799
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.convexHull
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          targetGeom.convexHull()
        </td>
      </tr><tr>
        <td>
          312
        </td>
        <td>
          3403
        </td>
        <td>
          14778
          -
          14799
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.convexHull
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          targetGeom.convexHull()
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          3404
        </td>
        <td>
          15617
          -
          15636
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double./
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          lon.+(180)./(360.0)
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          3405
        </td>
        <td>
          15646
          -
          15650
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          -360
        </td>
      </tr><tr>
        <td>
          327
        </td>
        <td>
          3406
        </td>
        <td>
          15615
          -
          15657
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Int.toDouble
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.doubleWrapper(lon.+(180)./(360.0)).floor.*(-360).toInt.toDouble
        </td>
      </tr><tr>
        <td>
          330
        </td>
        <td>
          3407
        </td>
        <td>
          15770
          -
          15777
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.jts.geom.Coordinate.x
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          coord.x
        </td>
      </tr><tr>
        <td>
          330
        </td>
        <td>
          3408
        </td>
        <td>
          15748
          -
          15778
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.degreesLonTranslation
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          degreesLonTranslation(coord.x)
        </td>
      </tr><tr>
        <td>
          330
        </td>
        <td>
          3409
        </td>
        <td>
          15738
          -
          15778
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          coord.x.+(degreesLonTranslation(coord.x))
        </td>
      </tr><tr>
        <td>
          330
        </td>
        <td>
          3410
        </td>
        <td>
          15780
          -
          15787
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.jts.geom.Coordinate.y
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          coord.y
        </td>
      </tr><tr>
        <td>
          330
        </td>
        <td>
          3411
        </td>
        <td>
          15723
          -
          15788
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Coordinate.&lt;init&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          new org.locationtech.jts.geom.Coordinate(coord.x.+(degreesLonTranslation(coord.x)), coord.y)
        </td>
      </tr><tr>
        <td>
          334
        </td>
        <td>
          3412
        </td>
        <td>
          15896
          -
          15919
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getCoordinates
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getCoordinates()
        </td>
      </tr><tr>
        <td>
          334
        </td>
        <td>
          3413
        </td>
        <td>
          15929
          -
          15946
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateCoord
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateCoord(c)
        </td>
      </tr><tr>
        <td>
          334
        </td>
        <td>
          3414
        </td>
        <td>
          15923
          -
          15923
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate]))
        </td>
      </tr><tr>
        <td>
          334
        </td>
        <td>
          3415
        </td>
        <td>
          15896
          -
          15947
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.refArrayOps[org.locationtech.jts.geom.Coordinate](geometry.getCoordinates()).map[org.locationtech.jts.geom.Coordinate, Array[org.locationtech.jts.geom.Coordinate]](((c: org.locationtech.jts.geom.Coordinate) =&gt; translateCoord(c)))(scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate])))
        </td>
      </tr><tr>
        <td>
          334
        </td>
        <td>
          3416
        </td>
        <td>
          15859
          -
          15948
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createPolygon
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultGeometryFactory.createPolygon(scala.Predef.refArrayOps[org.locationtech.jts.geom.Coordinate](geometry.getCoordinates()).map[org.locationtech.jts.geom.Coordinate, Array[org.locationtech.jts.geom.Coordinate]](((c: org.locationtech.jts.geom.Coordinate) =&gt; translateCoord(c)))(scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate]))))
        </td>
      </tr><tr>
        <td>
          337
        </td>
        <td>
          3417
        </td>
        <td>
          16056
          -
          16079
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getCoordinates
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getCoordinates()
        </td>
      </tr><tr>
        <td>
          337
        </td>
        <td>
          3418
        </td>
        <td>
          16089
          -
          16106
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateCoord
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateCoord(c)
        </td>
      </tr><tr>
        <td>
          337
        </td>
        <td>
          3419
        </td>
        <td>
          16083
          -
          16083
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate]))
        </td>
      </tr><tr>
        <td>
          337
        </td>
        <td>
          3420
        </td>
        <td>
          16056
          -
          16107
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.refArrayOps[org.locationtech.jts.geom.Coordinate](geometry.getCoordinates()).map[org.locationtech.jts.geom.Coordinate, Array[org.locationtech.jts.geom.Coordinate]](((c: org.locationtech.jts.geom.Coordinate) =&gt; translateCoord(c)))(scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate])))
        </td>
      </tr><tr>
        <td>
          337
        </td>
        <td>
          3421
        </td>
        <td>
          16016
          -
          16108
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createLineString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultGeometryFactory.createLineString(scala.Predef.refArrayOps[org.locationtech.jts.geom.Coordinate](geometry.getCoordinates()).map[org.locationtech.jts.geom.Coordinate, Array[org.locationtech.jts.geom.Coordinate]](((c: org.locationtech.jts.geom.Coordinate) =&gt; translateCoord(c)))(scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate]))))
        </td>
      </tr><tr>
        <td>
          340
        </td>
        <td>
          3422
        </td>
        <td>
          16197
          -
          16198
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          340
        </td>
        <td>
          3423
        </td>
        <td>
          16205
          -
          16230
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getNumGeometries
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getNumGeometries()
        </td>
      </tr><tr>
        <td>
          340
        </td>
        <td>
          3424
        </td>
        <td>
          16243
          -
          16267
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getGeometryN
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getGeometryN(i)
        </td>
      </tr><tr>
        <td>
          340
        </td>
        <td>
          3425
        </td>
        <td>
          16236
          -
          16236
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          340
        </td>
        <td>
          3426
        </td>
        <td>
          16196
          -
          16269
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(0).until(geometry.getNumGeometries()).map[org.locationtech.jts.geom.Geometry, scala.collection.immutable.IndexedSeq[org.locationtech.jts.geom.Geometry]](((i: Int) =&gt; geometry.getGeometryN(i)))(immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.Geometry])
        </td>
      </tr><tr>
        <td>
          341
        </td>
        <td>
          3427
        </td>
        <td>
          16311
          -
          16358
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateLineString(c).asInstanceOf[org.locationtech.jts.geom.LineString]
        </td>
      </tr><tr>
        <td>
          341
        </td>
        <td>
          3428
        </td>
        <td>
          16304
          -
          16304
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.LineString]
        </td>
      </tr><tr>
        <td>
          341
        </td>
        <td>
          3429
        </td>
        <td>
          16293
          -
          16360
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          coords.map[org.locationtech.jts.geom.LineString, scala.collection.immutable.IndexedSeq[org.locationtech.jts.geom.LineString]](((c: org.locationtech.jts.geom.Geometry) =&gt; translateLineString(c).asInstanceOf[org.locationtech.jts.geom.LineString]))(immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.LineString])
        </td>
      </tr><tr>
        <td>
          342
        </td>
        <td>
          3430
        </td>
        <td>
          16412
          -
          16430
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.toArray
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translated.toArray[org.locationtech.jts.geom.LineString]((ClassTag.apply[org.locationtech.jts.geom.LineString](classOf[org.locationtech.jts.geom.LineString]): scala.reflect.ClassTag[org.locationtech.jts.geom.LineString]))
        </td>
      </tr><tr>
        <td>
          342
        </td>
        <td>
          3431
        </td>
        <td>
          16367
          -
          16431
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createMultiLineString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultGeometryFactory.createMultiLineString(translated.toArray[org.locationtech.jts.geom.LineString]((ClassTag.apply[org.locationtech.jts.geom.LineString](classOf[org.locationtech.jts.geom.LineString]): scala.reflect.ClassTag[org.locationtech.jts.geom.LineString])))
        </td>
      </tr><tr>
        <td>
          346
        </td>
        <td>
          3432
        </td>
        <td>
          16523
          -
          16524
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          346
        </td>
        <td>
          3433
        </td>
        <td>
          16531
          -
          16556
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getNumGeometries
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getNumGeometries()
        </td>
      </tr><tr>
        <td>
          346
        </td>
        <td>
          3434
        </td>
        <td>
          16569
          -
          16593
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getGeometryN
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getGeometryN(i)
        </td>
      </tr><tr>
        <td>
          346
        </td>
        <td>
          3435
        </td>
        <td>
          16562
          -
          16562
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.Geometry]
        </td>
      </tr><tr>
        <td>
          346
        </td>
        <td>
          3436
        </td>
        <td>
          16522
          -
          16595
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(0).until(geometry.getNumGeometries()).map[org.locationtech.jts.geom.Geometry, scala.collection.immutable.IndexedSeq[org.locationtech.jts.geom.Geometry]](((i: Int) =&gt; geometry.getGeometryN(i)))(immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.Geometry])
        </td>
      </tr><tr>
        <td>
          347
        </td>
        <td>
          3437
        </td>
        <td>
          16637
          -
          16678
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.Any.asInstanceOf
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translatePolygon(c).asInstanceOf[org.locationtech.jts.geom.Polygon]
        </td>
      </tr><tr>
        <td>
          347
        </td>
        <td>
          3438
        </td>
        <td>
          16630
          -
          16630
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.IndexedSeq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.Polygon]
        </td>
      </tr><tr>
        <td>
          347
        </td>
        <td>
          3439
        </td>
        <td>
          16619
          -
          16680
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          coords.map[org.locationtech.jts.geom.Polygon, scala.collection.immutable.IndexedSeq[org.locationtech.jts.geom.Polygon]](((c: org.locationtech.jts.geom.Geometry) =&gt; translatePolygon(c).asInstanceOf[org.locationtech.jts.geom.Polygon]))(immutable.this.IndexedSeq.canBuildFrom[org.locationtech.jts.geom.Polygon])
        </td>
      </tr><tr>
        <td>
          348
        </td>
        <td>
          3440
        </td>
        <td>
          16729
          -
          16747
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableOnce.toArray
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translated.toArray[org.locationtech.jts.geom.Polygon]((ClassTag.apply[org.locationtech.jts.geom.Polygon](classOf[org.locationtech.jts.geom.Polygon]): scala.reflect.ClassTag[org.locationtech.jts.geom.Polygon]))
        </td>
      </tr><tr>
        <td>
          348
        </td>
        <td>
          3441
        </td>
        <td>
          16687
          -
          16748
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createMultiPolygon
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultGeometryFactory.createMultiPolygon(translated.toArray[org.locationtech.jts.geom.Polygon]((ClassTag.apply[org.locationtech.jts.geom.Polygon](classOf[org.locationtech.jts.geom.Polygon]): scala.reflect.ClassTag[org.locationtech.jts.geom.Polygon])))
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          3442
        </td>
        <td>
          16862
          -
          16885
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getCoordinates
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getCoordinates()
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          3443
        </td>
        <td>
          16895
          -
          16912
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateCoord
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateCoord(c)
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          3444
        </td>
        <td>
          16889
          -
          16889
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.Array.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate]))
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          3445
        </td>
        <td>
          16862
          -
          16913
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.refArrayOps[org.locationtech.jts.geom.Coordinate](geometry.getCoordinates()).map[org.locationtech.jts.geom.Coordinate, Array[org.locationtech.jts.geom.Coordinate]](((c: org.locationtech.jts.geom.Coordinate) =&gt; translateCoord(c)))(scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate])))
        </td>
      </tr><tr>
        <td>
          352
        </td>
        <td>
          3446
        </td>
        <td>
          16822
          -
          16914
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createMultiPoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultGeometryFactory.createMultiPoint(scala.Predef.refArrayOps[org.locationtech.jts.geom.Coordinate](geometry.getCoordinates()).map[org.locationtech.jts.geom.Coordinate, Array[org.locationtech.jts.geom.Coordinate]](((c: org.locationtech.jts.geom.Coordinate) =&gt; translateCoord(c)))(scala.this.Array.canBuildFrom[org.locationtech.jts.geom.Coordinate]((ClassTag.apply[org.locationtech.jts.geom.Coordinate](classOf[org.locationtech.jts.geom.Coordinate]): scala.reflect.ClassTag[org.locationtech.jts.geom.Coordinate]))))
        </td>
      </tr><tr>
        <td>
          355
        </td>
        <td>
          3447
        </td>
        <td>
          17029
          -
          17051
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getCoordinate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geometry.getCoordinate()
        </td>
      </tr><tr>
        <td>
          355
        </td>
        <td>
          3448
        </td>
        <td>
          17014
          -
          17052
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateCoord
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateCoord(geometry.getCoordinate())
        </td>
      </tr><tr>
        <td>
          355
        </td>
        <td>
          3449
        </td>
        <td>
          16979
          -
          17053
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createPoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.defaultGeometryFactory.createPoint(translateCoord(geometry.getCoordinate()))
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          3450
        </td>
        <td>
          17180
          -
          17206
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translatePolygon
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translatePolygon(geometry)
        </td>
      </tr><tr>
        <td>
          360
        </td>
        <td>
          3451
        </td>
        <td>
          17180
          -
          17206
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translatePolygon
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translatePolygon(geometry)
        </td>
      </tr><tr>
        <td>
          361
        </td>
        <td>
          3452
        </td>
        <td>
          17243
          -
          17272
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateLineString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateLineString(geometry)
        </td>
      </tr><tr>
        <td>
          361
        </td>
        <td>
          3453
        </td>
        <td>
          17243
          -
          17272
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateLineString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateLineString(geometry)
        </td>
      </tr><tr>
        <td>
          362
        </td>
        <td>
          3454
        </td>
        <td>
          17309
          -
          17343
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateMultiLineString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateMultiLineString(geometry)
        </td>
      </tr><tr>
        <td>
          362
        </td>
        <td>
          3455
        </td>
        <td>
          17309
          -
          17343
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateMultiLineString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateMultiLineString(geometry)
        </td>
      </tr><tr>
        <td>
          363
        </td>
        <td>
          3456
        </td>
        <td>
          17380
          -
          17411
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateMultiPolygon
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateMultiPolygon(geometry)
        </td>
      </tr><tr>
        <td>
          363
        </td>
        <td>
          3457
        </td>
        <td>
          17380
          -
          17411
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateMultiPolygon
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateMultiPolygon(geometry)
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          3458
        </td>
        <td>
          17448
          -
          17477
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateMultiPoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateMultiPoint(geometry)
        </td>
      </tr><tr>
        <td>
          364
        </td>
        <td>
          3459
        </td>
        <td>
          17448
          -
          17477
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateMultiPoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateMultiPoint(geometry)
        </td>
      </tr><tr>
        <td>
          365
        </td>
        <td>
          3460
        </td>
        <td>
          17514
          -
          17538
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translatePoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translatePoint(geometry)
        </td>
      </tr><tr>
        <td>
          365
        </td>
        <td>
          3461
        </td>
        <td>
          17514
          -
          17538
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translatePoint
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translatePoint(geometry)
        </td>
      </tr><tr>
        <td>
          369
        </td>
        <td>
          3470
        </td>
        <td>
          17558
          -
          18075
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.util.Try.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.util.Try.apply[org.locationtech.jts.geom.Geometry]({
  val copy: org.locationtech.jts.geom.Geometry = org.locationtech.geomesa.utils.geotools.GeometryUtils.geoFactory.createGeometry(targetGeom);
  val withinBoundsGeom: org.locationtech.jts.geom.Geometry = if (targetGeom.getEnvelopeInternal().getMinX().&lt;(-180).||(targetGeom.getEnvelopeInternal().getMaxX().&gt;(180)))
    translateGeometry(copy)
  else
    copy;
  org.locationtech.spatial4j.context.jts.JtsSpatialContext.GEO.makeShape(withinBoundsGeom, true, true).getGeom()
})
        </td>
      </tr><tr>
        <td>
          372
        </td>
        <td>
          3462
        </td>
        <td>
          17743
          -
          17794
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryFactory.createGeometry
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.GeometryUtils.geoFactory.createGeometry(targetGeom)
        </td>
      </tr><tr>
        <td>
          374
        </td>
        <td>
          3463
        </td>
        <td>
          17877
          -
          17881
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          -180
        </td>
      </tr><tr>
        <td>
          374
        </td>
        <td>
          3464
        </td>
        <td>
          17885
          -
          17929
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          targetGeom.getEnvelopeInternal().getMaxX().&gt;(180)
        </td>
      </tr><tr>
        <td>
          374
        </td>
        <td>
          3465
        </td>
        <td>
          17836
          -
          17929
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          targetGeom.getEnvelopeInternal().getMinX().&lt;(-180).||(targetGeom.getEnvelopeInternal().getMaxX().&gt;(180))
        </td>
      </tr><tr>
        <td>
          375
        </td>
        <td>
          3466
        </td>
        <td>
          17941
          -
          17964
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateGeometry
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateGeometry(copy)
        </td>
      </tr><tr>
        <td>
          375
        </td>
        <td>
          3467
        </td>
        <td>
          17941
          -
          17964
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.translateGeometry
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          translateGeometry(copy)
        </td>
      </tr><tr>
        <td>
          377
        </td>
        <td>
          3468
        </td>
        <td>
          17988
          -
          17992
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.copy
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          copy
        </td>
      </tr><tr>
        <td>
          379
        </td>
        <td>
          3469
        </td>
        <td>
          18000
          -
          18069
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.spatial4j.shape.jts.JtsGeometry.getGeom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.spatial4j.context.jts.JtsSpatialContext.GEO.makeShape(withinBoundsGeom, true, true).getGeom()
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          3471
        </td>
        <td>
          18549
          -
          18559
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getX
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          point.getX()
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          3472
        </td>
        <td>
          18561
          -
          18571
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getY
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          point.getY()
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          3473
        </td>
        <td>
          18573
          -
          18602
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.maxBitsResolution
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          resolutions.maxBitsResolution
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          3474
        </td>
        <td>
          18541
          -
          18603
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeoHash.apply(point.getX(), point.getY(), resolutions.maxBitsResolution)
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          3475
        </td>
        <td>
          18536
          -
          18604
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.immutable.List.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.List.apply[org.locationtech.geomesa.utils.geohash.GeoHash](GeoHash.apply(point.getX(), point.getY(), resolutions.maxBitsResolution))
        </td>
      </tr><tr>
        <td>
          393
        </td>
        <td>
          3476
        </td>
        <td>
          18536
          -
          18604
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.immutable.List.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.List.apply[org.locationtech.geomesa.utils.geohash.GeoHash](GeoHash.apply(point.getX(), point.getY(), resolutions.maxBitsResolution))
        </td>
      </tr><tr>
        <td>
          394
        </td>
        <td>
          3477
        </td>
        <td>
          18643
          -
          18644
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          394
        </td>
        <td>
          3478
        </td>
        <td>
          18651
          -
          18670
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryCollection.getNumGeometries
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          gc.getNumGeometries()
        </td>
      </tr><tr>
        <td>
          394
        </td>
        <td>
          3481
        </td>
        <td>
          18687
          -
          18687
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.List.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeoHash]
        </td>
      </tr><tr>
        <td>
          395
        </td>
        <td>
          3479
        </td>
        <td>
          18720
          -
          18738
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.GeometryCollection.getGeometryN
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          gc.getGeometryN(i)
        </td>
      </tr><tr>
        <td>
          395
        </td>
        <td>
          3480
        </td>
        <td>
          18702
          -
          18771
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.decomposeGeometry
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.decomposeGeometry(gc.getGeometryN(i), maxSize, resolutions, relaxFit)
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          3482
        </td>
        <td>
          18642
          -
          18788
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SeqLike.distinct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(0).until(gc.getNumGeometries()).toList.flatMap[org.locationtech.geomesa.utils.geohash.GeoHash, List[org.locationtech.geomesa.utils.geohash.GeoHash]](((i: Int) =&gt; GeohashUtils.this.decomposeGeometry(gc.getGeometryN(i), maxSize, resolutions, relaxFit)))(immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeoHash]).distinct
        </td>
      </tr><tr>
        <td>
          396
        </td>
        <td>
          3483
        </td>
        <td>
          18642
          -
          18788
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.SeqLike.distinct
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(0).until(gc.getNumGeometries()).toList.flatMap[org.locationtech.geomesa.utils.geohash.GeoHash, List[org.locationtech.geomesa.utils.geohash.GeoHash]](((i: Int) =&gt; GeohashUtils.this.decomposeGeometry(gc.getGeometryN(i), maxSize, resolutions, relaxFit)))(immutable.this.List.canBuildFrom[org.locationtech.geomesa.utils.geohash.GeoHash]).distinct
        </td>
      </tr><tr>
        <td>
          397
        </td>
        <td>
          3489
        </td>
        <td>
          18802
          -
          19031
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val safeGeom: org.locationtech.jts.geom.Geometry = GeohashUtils.this.getInternationalDateLineSafeGeometry(targetGeom).getOrElse[org.locationtech.jts.geom.Geometry](targetGeom);
  GeohashUtils.this.decomposeGeometry_(if (relaxFit)
    GeohashUtils.this.getDecomposableGeometry(safeGeom)
  else
    safeGeom, maxSize, resolutions)
}
        </td>
      </tr><tr>
        <td>
          398
        </td>
        <td>
          3484
        </td>
        <td>
          18828
          -
          18898
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.util.Try.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.getInternationalDateLineSafeGeometry(targetGeom).getOrElse[org.locationtech.jts.geom.Geometry](targetGeom)
        </td>
      </tr><tr>
        <td>
          399
        </td>
        <td>
          3488
        </td>
        <td>
          18907
          -
          19031
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.decomposeGeometry_
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.decomposeGeometry_(if (relaxFit)
  GeohashUtils.this.getDecomposableGeometry(safeGeom)
else
  safeGeom, maxSize, resolutions)
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          3485
        </td>
        <td>
          18951
          -
          18984
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.getDecomposableGeometry
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.getDecomposableGeometry(safeGeom)
        </td>
      </tr><tr>
        <td>
          400
        </td>
        <td>
          3486
        </td>
        <td>
          18951
          -
          18984
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.getDecomposableGeometry
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.getDecomposableGeometry(safeGeom)
        </td>
      </tr><tr>
        <td>
          401
        </td>
        <td>
          3487
        </td>
        <td>
          19000
          -
          19008
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.safeGeom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          safeGeom
        </td>
      </tr><tr>
        <td>
          427
        </td>
        <td>
          3490
        </td>
        <td>
          19994
          -
          20035
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Option.getOrElse
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          set.headOption.map[Int](((x$1: String) =&gt; x$1.length())).getOrElse[Int](0)
        </td>
      </tr><tr>
        <td>
          429
        </td>
        <td>
          3491
        </td>
        <td>
          20059
          -
          20060
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          430
        </td>
        <td>
          3492
        </td>
        <td>
          20100
          -
          20109
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IndexedSeqOptimized.take
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(x$2).take(i)
        </td>
      </tr><tr>
        <td>
          430
        </td>
        <td>
          3493
        </td>
        <td>
          20099
          -
          20099
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[String]
        </td>
      </tr><tr>
        <td>
          430
        </td>
        <td>
          3500
        </td>
        <td>
          20084
          -
          20084
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Tuple2.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Tuple2.apply[String, String](hash, newStr)
        </td>
      </tr><tr>
        <td>
          430
        </td>
        <td>
          3501
        </td>
        <td>
          20089
          -
          20089
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[(String, String)]
        </td>
      </tr><tr>
        <td>
          430
        </td>
        <td>
          3503
        </td>
        <td>
          20089
          -
          20089
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[String]
        </td>
      </tr><tr>
        <td>
          430
        </td>
        <td>
          3504
        </td>
        <td>
          20084
          -
          20200
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          set.map[String, Seq[String]](((x$2: String) =&gt; scala.Predef.augmentString(x$2).take(i)))(collection.this.Seq.canBuildFrom[String]).distinct.map[(String, String), Seq[(String, String)]](((hash: String) =&gt; {
  val newStr: String = scala.Predef.augmentString(hash).take(i).+(scala.Predef.augmentString(&quot;&quot;).padTo[Any, scala.collection.immutable.IndexedSeq[Any]](len.-(i), &quot;.&quot;)(scala.Predef.fallbackStringCanBuildFrom[Any]).mkString);
  scala.Tuple2.apply[String, String](hash, newStr)
}))(collection.this.Seq.canBuildFrom[(String, String)]).map[String, Seq[String]](((x$3: (String, String)) =&gt; (x$3: (String, String) @unchecked) match {
  case (_1: String, _2: String)(String, String)((hash @ _), (newStr @ _)) =&gt; newStr
}))(collection.this.Seq.canBuildFrom[String])
        </td>
      </tr><tr>
        <td>
          431
        </td>
        <td>
          3494
        </td>
        <td>
          20150
          -
          20152
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;&quot;
        </td>
      </tr><tr>
        <td>
          431
        </td>
        <td>
          3495
        </td>
        <td>
          20159
          -
          20166
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          len.-(i)
        </td>
      </tr><tr>
        <td>
          431
        </td>
        <td>
          3496
        </td>
        <td>
          20168
          -
          20171
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          &quot;.&quot;
        </td>
      </tr><tr>
        <td>
          431
        </td>
        <td>
          3497
        </td>
        <td>
          20158
          -
          20158
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.LowPriorityImplicits.fallbackStringCanBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.fallbackStringCanBuildFrom[Any]
        </td>
      </tr><tr>
        <td>
          431
        </td>
        <td>
          3498
        </td>
        <td>
          20150
          -
          20181
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableOnce.mkString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(&quot;&quot;).padTo[Any, scala.collection.immutable.IndexedSeq[Any]](len.-(i), &quot;.&quot;)(scala.Predef.fallbackStringCanBuildFrom[Any]).mkString
        </td>
      </tr><tr>
        <td>
          431
        </td>
        <td>
          3499
        </td>
        <td>
          20135
          -
          20181
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(hash).take(i).+(scala.Predef.augmentString(&quot;&quot;).padTo[Any, scala.collection.immutable.IndexedSeq[Any]](len.-(i), &quot;.&quot;)(scala.Predef.fallbackStringCanBuildFrom[Any]).mkString)
        </td>
      </tr><tr>
        <td>
          432
        </td>
        <td>
          3502
        </td>
        <td>
          20194
          -
          20200
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.newStr
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          newStr
        </td>
      </tr><tr>
        <td>
          432
        </td>
        <td>
          3505
        </td>
        <td>
          20207
          -
          20218
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          maxSize.+(1)
        </td>
      </tr><tr>
        <td>
          432
        </td>
        <td>
          3506
        </td>
        <td>
          20040
          -
          20219
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.Iterator.take
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.intWrapper(0).to(len).iterator.flatMap[String](((i: Int) =&gt; set.map[String, Seq[String]](((x$2: String) =&gt; scala.Predef.augmentString(x$2).take(i)))(collection.this.Seq.canBuildFrom[String]).distinct.map[(String, String), Seq[(String, String)]](((hash: String) =&gt; {
  val newStr: String = scala.Predef.augmentString(hash).take(i).+(scala.Predef.augmentString(&quot;&quot;).padTo[Any, scala.collection.immutable.IndexedSeq[Any]](len.-(i), &quot;.&quot;)(scala.Predef.fallbackStringCanBuildFrom[Any]).mkString);
  scala.Tuple2.apply[String, String](hash, newStr)
}))(collection.this.Seq.canBuildFrom[(String, String)]).map[String, Seq[String]](((x$3: (String, String)) =&gt; (x$3: (String, String) @unchecked) match {
  case (_1: String, _2: String)(String, String)((hash @ _), (newStr @ _)) =&gt; newStr
}))(collection.this.Seq.canBuildFrom[String]))).take(maxSize.+(1))
        </td>
      </tr><tr>
        <td>
          437
        </td>
        <td>
          3507
        </td>
        <td>
          20317
          -
          20331
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.buffer
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          g.buffer(1.0E-6)
        </td>
      </tr><tr>
        <td>
          437
        </td>
        <td>
          3508
        </td>
        <td>
          20317
          -
          20331
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.buffer
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          g.buffer(1.0E-6)
        </td>
      </tr><tr>
        <td>
          439
        </td>
        <td>
          3509
        </td>
        <td>
          20365
          -
          20380
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          g.getArea().&gt;(0.0)
        </td>
      </tr><tr>
        <td>
          439
        </td>
        <td>
          3510
        </td>
        <td>
          20382
          -
          20383
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.g
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          g
        </td>
      </tr><tr>
        <td>
          439
        </td>
        <td>
          3513
        </td>
        <td>
          20361
          -
          20424
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (g.getArea().&gt;(0.0))
  g
else
  org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(g).safeCentroid().buffer(1.0E-6)
        </td>
      </tr><tr>
        <td>
          440
        </td>
        <td>
          3511
        </td>
        <td>
          20395
          -
          20424
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.buffer
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(g).safeCentroid().buffer(1.0E-6)
        </td>
      </tr><tr>
        <td>
          440
        </td>
        <td>
          3512
        </td>
        <td>
          20395
          -
          20424
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.buffer
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(g).safeCentroid().buffer(1.0E-6)
        </td>
      </tr><tr>
        <td>
          441
        </td>
        <td>
          3519
        </td>
        <td>
          20445
          -
          20550
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val env: org.locationtech.jts.geom.Geometry = g.getEnvelope();
  if (env.getArea().&gt;(0.0))
    env
  else
    env.getCentroid().buffer(1.0E-6)
}
        </td>
      </tr><tr>
        <td>
          442
        </td>
        <td>
          3514
        </td>
        <td>
          20464
          -
          20477
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.getEnvelope
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          g.getEnvelope()
        </td>
      </tr><tr>
        <td>
          443
        </td>
        <td>
          3515
        </td>
        <td>
          20488
          -
          20505
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          env.getArea().&gt;(0.0)
        </td>
      </tr><tr>
        <td>
          443
        </td>
        <td>
          3516
        </td>
        <td>
          20507
          -
          20510
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.env
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          env
        </td>
      </tr><tr>
        <td>
          444
        </td>
        <td>
          3517
        </td>
        <td>
          20522
          -
          20550
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.buffer
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          env.getCentroid().buffer(1.0E-6)
        </td>
      </tr><tr>
        <td>
          444
        </td>
        <td>
          3518
        </td>
        <td>
          20522
          -
          20550
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.jts.geom.Geometry.buffer
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          env.getCentroid().buffer(1.0E-6)
        </td>
      </tr><tr>
        <td>
          498
        </td>
        <td>
          3658
        </td>
        <td>
          23500
          -
          29720
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.util.Try.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.util.Try.apply[Seq[String]]({
  val cover: org.locationtech.jts.geom.Geometry = GeohashUtils.this.promoteToRegion(geom);
  val maxBits: Int = offset.+(length).*(5);
  val minBits: Int = offset.*(5);
  val usedBits: Int = length.*(5);
  val allResolutions: org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange = GeohashUtils.this.ResolutionRange.apply(0, java.lang.Math.min(35, maxBits), 1);
  val maxKeys: Int = java.lang.Math.min(2.&lt;&lt;(java.lang.Math.min(usedBits, 29)), MAX_KEYS_IN_LIST);
  val polyCentroid: org.locationtech.jts.geom.Point = org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(cover).safeCentroid();
  val ghMBR: org.locationtech.geomesa.utils.geohash.GeoHash = GeohashUtils.this.getMinimumBoundingGeohash(geom, allResolutions);
  case class BitPrefixes extends AnyRef with Product with Serializable {
    &lt;caseaccessor&gt; &lt;paramaccessor&gt; private[this] val prefixes: Seq[String] = _;
    &lt;stable&gt; &lt;caseaccessor&gt; &lt;accessor&gt; &lt;paramaccessor&gt; def prefixes: Seq[String] = BitPrefixes.this.prefixes;
    def &lt;init&gt;(prefixes: Seq[String]): BitPrefixes = {
      BitPrefixes.super.&lt;init&gt;();
      ()
    };
    private[this] val hasEverythingPrefix: Boolean = BitPrefixes.this.prefixes.exists(((prefix: String) =&gt; prefix.length().&lt;=(minBits)));
    &lt;stable&gt; &lt;accessor&gt; def hasEverythingPrefix: Boolean = BitPrefixes.this.hasEverythingPrefix;
    private[this] val entailedSize: Int = if (BitPrefixes.this.hasEverythingPrefix)
      maxKeys
    else
      java.lang.Math.min(1.&lt;&lt;(usedBits), BitPrefixes.this.prefixes.foldLeft[Int](0)(((sumSoFar: Int, prefix: String) =&gt; sumSoFar.+(1.&lt;&lt;(java.lang.Math.min(usedBits, maxBits.-(prefix.length())))))));
    &lt;stable&gt; &lt;accessor&gt; def entailedSize: Int = BitPrefixes.this.entailedSize;
    private[this] val usesAll: Boolean = BitPrefixes.this.prefixes.exists(((prefix: String) =&gt; prefix.length().&lt;=(minBits))).||(BitPrefixes.this.entailedSize.==(maxKeys));
    &lt;stable&gt; &lt;accessor&gt; def usesAll: Boolean = BitPrefixes.this.usesAll;
    def hasRoom: Boolean = BitPrefixes.this.entailedSize.&lt;=(maxKeys);
    def notDone: Boolean = BitPrefixes.this.usesAll.unary_!.&amp;&amp;(BitPrefixes.this.hasRoom);
    def overflowed: Boolean = if (BitPrefixes.this.usesAll)
      1.&lt;&lt;(usedBits).&gt;(maxKeys)
    else
      BitPrefixes.this.entailedSize.&gt;(maxKeys);
    def generateAll(prefix: String): Seq[String] = {
      val prefixHash: String = GeoHash.fromBinaryString(prefix).hash;
      if (prefixHash.length().&lt;(length))
        {
          val charSeqs: List[Seq[Char]] = GeohashUtils.this.Base32Padding.apply(length.-(prefixHash.length()));
          org.locationtech.geomesa.utils.iterators.CartesianProductIterable.apply(charSeqs).toList.map[String, Seq[String]](((x$4: Seq[_]) =&gt; prefixHash.+(x$4.mkString)))(immutable.this.List.canBuildFrom[String])
        }
      else
        scala.collection.Seq.apply[String](prefixHash)
    };
    def generateSome: Seq[String] = BitPrefixes.this.prefixes.foldLeft[scala.collection.immutable.HashSet[String]](scala.collection.immutable.HashSet.apply[String]())(((ghsSoFar: scala.collection.immutable.HashSet[String], prefix: String) =&gt; {
  val bitsToBoundary: Int = 65.-(prefix.length()).%(5);
  val bases: Seq[String] = if (bitsToBoundary.==(0))
    scala.collection.Seq.apply[String](prefix)
  else
    {
      val fillers: List[Seq[Char]] = GeohashUtils.this.BinaryPadding.apply(bitsToBoundary);
      val result: List[String] = org.locationtech.geomesa.utils.iterators.CartesianProductIterable.apply(fillers).toList.map[String, List[String]](((x$5: Seq[_]) =&gt; prefix.+(x$5.mkString)))(immutable.this.List.canBuildFrom[String]);
      result
    };
  bases.foldLeft[scala.collection.immutable.HashSet[String]](ghsSoFar)(((ghs: scala.collection.immutable.HashSet[String], base: String) =&gt; {
    val baseTrimmed: String = scala.Predef.augmentString(base).drop(minBits);
    val newSubs: Seq[String] = BitPrefixes.this.generateAll(baseTrimmed);
    ghs.++(newSubs)
  }))
})).toSeq;
    def toSeq: Seq[String] = if (BitPrefixes.this.usesAll)
      BitPrefixes.this.generateAll(&quot;&quot;)
    else
      BitPrefixes.this.generateSome;
    &lt;synthetic&gt; def copy(prefixes: Seq[String] = prefixes): BitPrefixes = new BitPrefixes(prefixes);
    &lt;synthetic&gt; def copy$default$1: Seq[String] = BitPrefixes.this.prefixes;
    override &lt;synthetic&gt; def productPrefix: String = &quot;BitPrefixes&quot;;
    &lt;synthetic&gt; def productArity: Int = 1;
    &lt;synthetic&gt; def productElement(x$1: Int): Any = x$1 match {
      case 0 =&gt; BitPrefixes.this.prefixes
      case _ =&gt; throw new IndexOutOfBoundsException(x$1.toString())
    };
    override &lt;synthetic&gt; def productIterator: Iterator[Any] = scala.runtime.ScalaRunTime.typedProductIterator[Any](BitPrefixes.this);
    &lt;synthetic&gt; def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[BitPrefixes]();
    override &lt;synthetic&gt; def hashCode(): Int = scala.runtime.ScalaRunTime._hashCode(BitPrefixes.this);
    override &lt;synthetic&gt; def toString(): String = scala.runtime.ScalaRunTime._toString(BitPrefixes.this);
    override &lt;synthetic&gt; def equals(x$1: Any): Boolean = BitPrefixes.this.eq(x$1.asInstanceOf[Object]).||(x$1 match {
  case (_: BitPrefixes) =&gt; true
  case _ =&gt; false
}.&amp;&amp;({
      &lt;synthetic&gt; val BitPrefixes$1: BitPrefixes = x$1.asInstanceOf[BitPrefixes];
      BitPrefixes.this.prefixes.==(BitPrefixes$1.prefixes).&amp;&amp;(BitPrefixes$1.canEqual(BitPrefixes.this))
    }))
  };
  &lt;synthetic&gt; object BitPrefixes extends scala.runtime.AbstractFunction1[Seq[String],BitPrefixes] with Serializable {
    def &lt;init&gt;(): BitPrefixes.type = {
      BitPrefixes.super.&lt;init&gt;();
      ()
    };
    final override &lt;synthetic&gt; def toString(): String = &quot;BitPrefixes&quot;;
    case &lt;synthetic&gt; def apply(prefixes: Seq[String]): BitPrefixes = new BitPrefixes(prefixes);
    case &lt;synthetic&gt; def unapply(x$0: BitPrefixes): Option[Seq[String]] = if (x$0.==(null))
      scala.None
    else
      Some.apply[Seq[String]](x$0.prefixes)
  };
  def considerCandidate(candidate: org.locationtech.geomesa.utils.geohash.GeoHash): Seq[String] = {
    val bitString: String = candidate.toBinaryString;
    if (geom.intersects(candidate.geom).unary_!)
      return scala.collection.immutable.Nil
    else
      ();
    if (cover.covers(candidate.geom).||(scala.Predef.augmentString(bitString).size.==(maxBits)))
      scala.collection.Seq.apply[String](bitString)
    else
      if (scala.Predef.augmentString(bitString).size.&lt;(maxBits))
        {
          val gh0: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.fromBinaryString(bitString.+(&quot;0&quot;));
          val gh1: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.fromBinaryString(bitString.+(&quot;1&quot;));
          val d0: Double = java.lang.Math.hypot(gh0.getPoint.getX().-(polyCentroid.getX()), gh0.getPoint.getY().-(polyCentroid.getY()));
          val d1: Double = java.lang.Math.hypot(gh1.getPoint.getX().-(polyCentroid.getX()), gh1.getPoint.getY().-(polyCentroid.getY()));
          &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash) = (if (d0.&lt;=(d1))
            scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](gh0, gh1)
          else
            scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](gh1, gh0): (org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash) @unchecked) match {
            case (_1: org.locationtech.geomesa.utils.geohash.GeoHash, _2: org.locationtech.geomesa.utils.geohash.GeoHash)(org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash)((firstChild @ _), (secondChild @ _)) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](firstChild, secondChild)
          };
          val firstChild: org.locationtech.geomesa.utils.geohash.GeoHash = x$6._1;
          val secondChild: org.locationtech.geomesa.utils.geohash.GeoHash = x$6._2;
          val firstChildList: Seq[String] = considerCandidate(firstChild);
          firstChildList.++[String, Seq[String]](firstChildList.headOption match {
            case (value: String)Some[String]((bitStr @ _)) if bitStr.length().&lt;=(minBits) =&gt; scala.collection.immutable.Nil
            case _ =&gt; considerCandidate(secondChild)
          })(collection.this.Seq.canBuildFrom[String])
        }
      else
        scala.collection.immutable.Nil
  };
  val bitPrefixes: BitPrefixes = BitPrefixes.apply(if (ghMBR.prec.&lt;=(maxBits))
    considerCandidate(ghMBR)
  else
    scala.collection.Seq.apply[String](scala.Predef.augmentString(scala.Predef.augmentString(ghMBR.toBinaryString).drop(minBits)).take(usedBits)));
  if (bitPrefixes.overflowed)
    throw new java.lang.IllegalStateException(&quot;Bit prefixes overflowed while calculating unique Geohash substrings in polygon using the following parameters: &quot;.+(scala.StringContext.apply(&quot;\\nGeometry: &quot;, &quot; \\nOffset: &quot;, &quot; \\nLength: &quot;, &quot; \\nMax Keys in List: &quot;, &quot;&quot;).s(geom, offset, length, MAX_KEYS_IN_LIST)))
  else
    ();
  val unDotted: Seq[String] = bitPrefixes.toSeq;
  if (includeDots)
    if (unDotted.size.&lt;(maxKeys))
      {
        val keepers: List[String] = GeohashUtils.this.getGeohashStringDottingIterator(unDotted, MAX_KEYS_IN_LIST).take(MAX_KEYS_IN_LIST.+(1)).toList;
        if (keepers.size.&lt;=(MAX_KEYS_IN_LIST))
          keepers.toSeq
        else
          scala.collection.Seq.apply[Nothing]()
      }
    else
      scala.collection.Seq.apply[Nothing]()
  else
    unDotted
})
        </td>
      </tr><tr>
        <td>
          500
        </td>
        <td>
          3520
        </td>
        <td>
          23523
          -
          23544
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.promoteToRegion
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.promoteToRegion(geom)
        </td>
      </tr><tr>
        <td>
          503
        </td>
        <td>
          3521
        </td>
        <td>
          23607
          -
          23628
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          offset.+(length).*(5)
        </td>
      </tr><tr>
        <td>
          504
        </td>
        <td>
          3522
        </td>
        <td>
          23647
          -
          23657
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          offset.*(5)
        </td>
      </tr><tr>
        <td>
          505
        </td>
        <td>
          3523
        </td>
        <td>
          23677
          -
          23687
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.*
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          length.*(5)
        </td>
      </tr><tr>
        <td>
          506
        </td>
        <td>
          3524
        </td>
        <td>
          23729
          -
          23730
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          506
        </td>
        <td>
          3525
        </td>
        <td>
          23732
          -
          23753
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.min(35, maxBits)
        </td>
      </tr><tr>
        <td>
          506
        </td>
        <td>
          3526
        </td>
        <td>
          23755
          -
          23756
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1
        </td>
      </tr><tr>
        <td>
          506
        </td>
        <td>
          3527
        </td>
        <td>
          23713
          -
          23757
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.ResolutionRange.apply(0, java.lang.Math.min(35, maxBits), 1)
        </td>
      </tr><tr>
        <td>
          507
        </td>
        <td>
          3528
        </td>
        <td>
          23785
          -
          23786
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          2
        </td>
      </tr><tr>
        <td>
          507
        </td>
        <td>
          3529
        </td>
        <td>
          23790
          -
          23812
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.min(usedBits, 29)
        </td>
      </tr><tr>
        <td>
          507
        </td>
        <td>
          3530
        </td>
        <td>
          23785
          -
          23812
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          2.&lt;&lt;(java.lang.Math.min(usedBits, 29))
        </td>
      </tr><tr>
        <td>
          507
        </td>
        <td>
          3531
        </td>
        <td>
          23776
          -
          23831
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.min(2.&lt;&lt;(java.lang.Math.min(usedBits, 29)), MAX_KEYS_IN_LIST)
        </td>
      </tr><tr>
        <td>
          508
        </td>
        <td>
          3532
        </td>
        <td>
          23855
          -
          23875
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry.safeCentroid
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry(cover).safeCentroid()
        </td>
      </tr><tr>
        <td>
          511
        </td>
        <td>
          3533
        </td>
        <td>
          23966
          -
          24013
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.getMinimumBoundingGeohash
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.getMinimumBoundingGeohash(geom, allResolutions)
        </td>
      </tr><tr>
        <td>
          516
        </td>
        <td>
          3534
        </td>
        <td>
          24194
          -
          24218
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          prefix.length().&lt;=(minBits)
        </td>
      </tr><tr>
        <td>
          516
        </td>
        <td>
          3535
        </td>
        <td>
          24168
          -
          24219
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IterableLike.exists
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.prefixes.exists(((prefix: String) =&gt; prefix.length().&lt;=(minBits)))
        </td>
      </tr><tr>
        <td>
          520
        </td>
        <td>
          3536
        </td>
        <td>
          24323
          -
          24342
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.hasEverythingPrefix
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.hasEverythingPrefix
        </td>
      </tr><tr>
        <td>
          520
        </td>
        <td>
          3537
        </td>
        <td>
          24344
          -
          24351
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.maxKeys
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          maxKeys
        </td>
      </tr><tr>
        <td>
          521
        </td>
        <td>
          3547
        </td>
        <td>
          24365
          -
          24542
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.min(1.&lt;&lt;(usedBits), BitPrefixes.this.prefixes.foldLeft[Int](0)(((sumSoFar: Int, prefix: String) =&gt; sumSoFar.+(1.&lt;&lt;(java.lang.Math.min(usedBits, maxBits.-(prefix.length())))))))
        </td>
      </tr><tr>
        <td>
          521
        </td>
        <td>
          3548
        </td>
        <td>
          24365
          -
          24542
        </td>
        <td>
          Block
        </td>
        <td>
          java.lang.Math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.min(1.&lt;&lt;(usedBits), BitPrefixes.this.prefixes.foldLeft[Int](0)(((sumSoFar: Int, prefix: String) =&gt; sumSoFar.+(1.&lt;&lt;(java.lang.Math.min(usedBits, maxBits.-(prefix.length())))))))
        </td>
      </tr><tr>
        <td>
          522
        </td>
        <td>
          3538
        </td>
        <td>
          24385
          -
          24398
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1.&lt;&lt;(usedBits)
        </td>
      </tr><tr>
        <td>
          523
        </td>
        <td>
          3539
        </td>
        <td>
          24428
          -
          24429
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          0
        </td>
      </tr><tr>
        <td>
          523
        </td>
        <td>
          3546
        </td>
        <td>
          24410
          -
          24541
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.prefixes.foldLeft[Int](0)(((sumSoFar: Int, prefix: String) =&gt; sumSoFar.+(1.&lt;&lt;(java.lang.Math.min(usedBits, maxBits.-(prefix.length()))))))
        </td>
      </tr><tr>
        <td>
          524
        </td>
        <td>
          3540
        </td>
        <td>
          24479
          -
          24480
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1
        </td>
      </tr><tr>
        <td>
          524
        </td>
        <td>
          3541
        </td>
        <td>
          24513
          -
          24526
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          prefix.length()
        </td>
      </tr><tr>
        <td>
          524
        </td>
        <td>
          3542
        </td>
        <td>
          24503
          -
          24526
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          maxBits.-(prefix.length())
        </td>
      </tr><tr>
        <td>
          524
        </td>
        <td>
          3543
        </td>
        <td>
          24484
          -
          24527
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Math.min
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.min(usedBits, maxBits.-(prefix.length()))
        </td>
      </tr><tr>
        <td>
          524
        </td>
        <td>
          3544
        </td>
        <td>
          24479
          -
          24527
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          1.&lt;&lt;(java.lang.Math.min(usedBits, maxBits.-(prefix.length())))
        </td>
      </tr><tr>
        <td>
          524
        </td>
        <td>
          3545
        </td>
        <td>
          24467
          -
          24528
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          sumSoFar.+(1.&lt;&lt;(java.lang.Math.min(usedBits, maxBits.-(prefix.length()))))
        </td>
      </tr><tr>
        <td>
          530
        </td>
        <td>
          3549
        </td>
        <td>
          24768
          -
          24792
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          prefix.length().&lt;=(minBits)
        </td>
      </tr><tr>
        <td>
          530
        </td>
        <td>
          3551
        </td>
        <td>
          24742
          -
          24828
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.prefixes.exists(((prefix: String) =&gt; prefix.length().&lt;=(minBits))).||(BitPrefixes.this.entailedSize.==(maxKeys))
        </td>
      </tr><tr>
        <td>
          531
        </td>
        <td>
          3550
        </td>
        <td>
          24805
          -
          24828
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.entailedSize.==(maxKeys)
        </td>
      </tr><tr>
        <td>
          534
        </td>
        <td>
          3552
        </td>
        <td>
          24914
          -
          24937
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          BitPrefixes.this.entailedSize.&lt;=(maxKeys)
        </td>
      </tr><tr>
        <td>
          536
        </td>
        <td>
          3553
        </td>
        <td>
          24971
          -
          24978
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.hasRoom
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          BitPrefixes.this.hasRoom
        </td>
      </tr><tr>
        <td>
          536
        </td>
        <td>
          3554
        </td>
        <td>
          24959
          -
          24978
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.&amp;&amp;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          BitPrefixes.this.usesAll.unary_!.&amp;&amp;(BitPrefixes.this.hasRoom)
        </td>
      </tr><tr>
        <td>
          539
        </td>
        <td>
          3555
        </td>
        <td>
          25015
          -
          25022
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.usesAll
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.usesAll
        </td>
      </tr><tr>
        <td>
          540
        </td>
        <td>
          3556
        </td>
        <td>
          25036
          -
          25061
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          1.&lt;&lt;(usedBits).&gt;(maxKeys)
        </td>
      </tr><tr>
        <td>
          540
        </td>
        <td>
          3557
        </td>
        <td>
          25036
          -
          25061
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          1.&lt;&lt;(usedBits).&gt;(maxKeys)
        </td>
      </tr><tr>
        <td>
          542
        </td>
        <td>
          3558
        </td>
        <td>
          25089
          -
          25111
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.entailedSize.&gt;(maxKeys)
        </td>
      </tr><tr>
        <td>
          542
        </td>
        <td>
          3559
        </td>
        <td>
          25089
          -
          25111
        </td>
        <td>
          Block
        </td>
        <td>
          scala.Int.&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.entailedSize.&gt;(maxKeys)
        </td>
      </tr><tr>
        <td>
          549
        </td>
        <td>
          3560
        </td>
        <td>
          25338
          -
          25364
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          prefixHash.length().&lt;(length)
        </td>
      </tr><tr>
        <td>
          549
        </td>
        <td>
          3568
        </td>
        <td>
          25366
          -
          25525
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val charSeqs: List[Seq[Char]] = GeohashUtils.this.Base32Padding.apply(length.-(prefixHash.length()));
  org.locationtech.geomesa.utils.iterators.CartesianProductIterable.apply(charSeqs).toList.map[String, Seq[String]](((x$4: Seq[_]) =&gt; prefixHash.+(x$4.mkString)))(immutable.this.List.canBuildFrom[String])
}
        </td>
      </tr><tr>
        <td>
          550
        </td>
        <td>
          3561
        </td>
        <td>
          25416
          -
          25433
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.length
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          prefixHash.length()
        </td>
      </tr><tr>
        <td>
          550
        </td>
        <td>
          3562
        </td>
        <td>
          25407
          -
          25433
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          length.-(prefixHash.length())
        </td>
      </tr><tr>
        <td>
          550
        </td>
        <td>
          3563
        </td>
        <td>
          25393
          -
          25434
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SeqLike.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.Base32Padding.apply(length.-(prefixHash.length()))
        </td>
      </tr><tr>
        <td>
          551
        </td>
        <td>
          3564
        </td>
        <td>
          25504
          -
          25514
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableOnce.mkString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$4.mkString
        </td>
      </tr><tr>
        <td>
          551
        </td>
        <td>
          3565
        </td>
        <td>
          25491
          -
          25514
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          prefixHash.+(x$4.mkString)
        </td>
      </tr><tr>
        <td>
          551
        </td>
        <td>
          3566
        </td>
        <td>
          25490
          -
          25490
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.List.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.List.canBuildFrom[String]
        </td>
      </tr><tr>
        <td>
          551
        </td>
        <td>
          3567
        </td>
        <td>
          25445
          -
          25515
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.immutable.List.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.iterators.CartesianProductIterable.apply(charSeqs).toList.map[String, Seq[String]](((x$4: Seq[_]) =&gt; prefixHash.+(x$4.mkString)))(immutable.this.List.canBuildFrom[String])
        </td>
      </tr><tr>
        <td>
          552
        </td>
        <td>
          3569
        </td>
        <td>
          25531
          -
          25546
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[String](prefixHash)
        </td>
      </tr><tr>
        <td>
          552
        </td>
        <td>
          3570
        </td>
        <td>
          25531
          -
          25546
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[String](prefixHash)
        </td>
      </tr><tr>
        <td>
          565
        </td>
        <td>
          3571
        </td>
        <td>
          26205
          -
          26222
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.HashSet.apply[String]()
        </td>
      </tr><tr>
        <td>
          567
        </td>
        <td>
          3572
        </td>
        <td>
          26340
          -
          26364
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.%
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          65.-(prefix.length()).%(5)
        </td>
      </tr><tr>
        <td>
          569
        </td>
        <td>
          3573
        </td>
        <td>
          26403
          -
          26422
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitsToBoundary.==(0)
        </td>
      </tr><tr>
        <td>
          569
        </td>
        <td>
          3574
        </td>
        <td>
          26424
          -
          26435
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[String](prefix)
        </td>
      </tr><tr>
        <td>
          569
        </td>
        <td>
          3575
        </td>
        <td>
          26424
          -
          26435
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[String](prefix)
        </td>
      </tr><tr>
        <td>
          570
        </td>
        <td>
          3581
        </td>
        <td>
          26453
          -
          26640
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val fillers: List[Seq[Char]] = GeohashUtils.this.BinaryPadding.apply(bitsToBoundary);
  val result: List[String] = org.locationtech.geomesa.utils.iterators.CartesianProductIterable.apply(fillers).toList.map[String, List[String]](((x$5: Seq[_]) =&gt; prefix.+(x$5.mkString)))(immutable.this.List.canBuildFrom[String]);
  result
}
        </td>
      </tr><tr>
        <td>
          571
        </td>
        <td>
          3576
        </td>
        <td>
          26483
          -
          26512
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SeqLike.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.BinaryPadding.apply(bitsToBoundary)
        </td>
      </tr><tr>
        <td>
          572
        </td>
        <td>
          3577
        </td>
        <td>
          26594
          -
          26604
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableOnce.mkString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$5.mkString
        </td>
      </tr><tr>
        <td>
          572
        </td>
        <td>
          3578
        </td>
        <td>
          26585
          -
          26604
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          prefix.+(x$5.mkString)
        </td>
      </tr><tr>
        <td>
          572
        </td>
        <td>
          3579
        </td>
        <td>
          26584
          -
          26584
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.immutable.List.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          immutable.this.List.canBuildFrom[String]
        </td>
      </tr><tr>
        <td>
          572
        </td>
        <td>
          3580
        </td>
        <td>
          26540
          -
          26605
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.immutable.List.map
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          org.locationtech.geomesa.utils.iterators.CartesianProductIterable.apply(fillers).toList.map[String, List[String]](((x$5: Seq[_]) =&gt; prefix.+(x$5.mkString)))(immutable.this.List.canBuildFrom[String])
        </td>
      </tr><tr>
        <td>
          575
        </td>
        <td>
          3585
        </td>
        <td>
          26651
          -
          26832
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.TraversableOnce.foldLeft
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bases.foldLeft[scala.collection.immutable.HashSet[String]](ghsSoFar)(((ghs: scala.collection.immutable.HashSet[String], base: String) =&gt; {
  val baseTrimmed: String = scala.Predef.augmentString(base).drop(minBits);
  val newSubs: Seq[String] = BitPrefixes.this.generateAll(baseTrimmed);
  ghs.++(newSubs)
}))
        </td>
      </tr><tr>
        <td>
          576
        </td>
        <td>
          3582
        </td>
        <td>
          26723
          -
          26741
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IndexedSeqOptimized.drop
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(base).drop(minBits)
        </td>
      </tr><tr>
        <td>
          577
        </td>
        <td>
          3583
        </td>
        <td>
          26768
          -
          26792
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.generateAll
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.generateAll(baseTrimmed)
        </td>
      </tr><tr>
        <td>
          578
        </td>
        <td>
          3584
        </td>
        <td>
          26805
          -
          26819
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.SetLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ghs.++(newSubs)
        </td>
      </tr><tr>
        <td>
          580
        </td>
        <td>
          3586
        </td>
        <td>
          26187
          -
          26849
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.SetLike.toSeq
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.prefixes.foldLeft[scala.collection.immutable.HashSet[String]](scala.collection.immutable.HashSet.apply[String]())(((ghsSoFar: scala.collection.immutable.HashSet[String], prefix: String) =&gt; {
  val bitsToBoundary: Int = 65.-(prefix.length()).%(5);
  val bases: Seq[String] = if (bitsToBoundary.==(0))
    scala.collection.Seq.apply[String](prefix)
  else
    {
      val fillers: List[Seq[Char]] = GeohashUtils.this.BinaryPadding.apply(bitsToBoundary);
      val result: List[String] = org.locationtech.geomesa.utils.iterators.CartesianProductIterable.apply(fillers).toList.map[String, List[String]](((x$5: Seq[_]) =&gt; prefix.+(x$5.mkString)))(immutable.this.List.canBuildFrom[String]);
      result
    };
  bases.foldLeft[scala.collection.immutable.HashSet[String]](ghsSoFar)(((ghs: scala.collection.immutable.HashSet[String], base: String) =&gt; {
    val baseTrimmed: String = scala.Predef.augmentString(base).drop(minBits);
    val newSubs: Seq[String] = BitPrefixes.this.generateAll(baseTrimmed);
    ghs.++(newSubs)
  }))
})).toSeq
        </td>
      </tr><tr>
        <td>
          584
        </td>
        <td>
          3587
        </td>
        <td>
          26902
          -
          26909
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.usesAll
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.usesAll
        </td>
      </tr><tr>
        <td>
          584
        </td>
        <td>
          3588
        </td>
        <td>
          26911
          -
          26926
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.generateAll
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          BitPrefixes.this.generateAll(&quot;&quot;)
        </td>
      </tr><tr>
        <td>
          584
        </td>
        <td>
          3589
        </td>
        <td>
          26911
          -
          26926
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.generateAll
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          BitPrefixes.this.generateAll(&quot;&quot;)
        </td>
      </tr><tr>
        <td>
          585
        </td>
        <td>
          3590
        </td>
        <td>
          26940
          -
          26952
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.generateSome
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.generateSome
        </td>
      </tr><tr>
        <td>
          585
        </td>
        <td>
          3591
        </td>
        <td>
          26940
          -
          26952
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.generateSome
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.this.generateSome
        </td>
      </tr><tr>
        <td>
          591
        </td>
        <td>
          3592
        </td>
        <td>
          27153
          -
          27177
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.toBinaryString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          candidate.toBinaryString
        </td>
      </tr><tr>
        <td>
          593
        </td>
        <td>
          3593
        </td>
        <td>
          27189
          -
          27221
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Boolean.unary_!
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          geom.intersects(candidate.geom).unary_!
        </td>
      </tr><tr>
        <td>
          593
        </td>
        <td>
          3594
        </td>
        <td>
          27230
          -
          27233
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.immutable.Nil
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.immutable.Nil
        </td>
      </tr><tr>
        <td>
          593
        </td>
        <td>
          3595
        </td>
        <td>
          27223
          -
          27233
        </td>
        <td>
          Return
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.considerCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          return scala.collection.immutable.Nil
        </td>
      </tr><tr>
        <td>
          593
        </td>
        <td>
          3596
        </td>
        <td>
          27185
          -
          27185
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          593
        </td>
        <td>
          3597
        </td>
        <td>
          27185
          -
          27185
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          595
        </td>
        <td>
          3598
        </td>
        <td>
          27278
          -
          27303
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.==
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(bitString).size.==(maxBits)
        </td>
      </tr><tr>
        <td>
          595
        </td>
        <td>
          3599
        </td>
        <td>
          27245
          -
          27304
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Boolean.||
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          cover.covers(candidate.geom).||(scala.Predef.augmentString(bitString).size.==(maxBits))
        </td>
      </tr><tr>
        <td>
          596
        </td>
        <td>
          3600
        </td>
        <td>
          27316
          -
          27330
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[String](bitString)
        </td>
      </tr><tr>
        <td>
          596
        </td>
        <td>
          3601
        </td>
        <td>
          27316
          -
          27330
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.collection.Seq.apply[String](bitString)
        </td>
      </tr><tr>
        <td>
          598
        </td>
        <td>
          3602
        </td>
        <td>
          27358
          -
          27382
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          scala.Predef.augmentString(bitString).size.&lt;(maxBits)
        </td>
      </tr><tr>
        <td>
          598
        </td>
        <td>
          3628
        </td>
        <td>
          27384
          -
          28513
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val gh0: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.fromBinaryString(bitString.+(&quot;0&quot;));
  val gh1: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.fromBinaryString(bitString.+(&quot;1&quot;));
  val d0: Double = java.lang.Math.hypot(gh0.getPoint.getX().-(polyCentroid.getX()), gh0.getPoint.getY().-(polyCentroid.getY()));
  val d1: Double = java.lang.Math.hypot(gh1.getPoint.getX().-(polyCentroid.getX()), gh1.getPoint.getY().-(polyCentroid.getY()));
  &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash) = (if (d0.&lt;=(d1))
    scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](gh0, gh1)
  else
    scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](gh1, gh0): (org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash) @unchecked) match {
    case (_1: org.locationtech.geomesa.utils.geohash.GeoHash, _2: org.locationtech.geomesa.utils.geohash.GeoHash)(org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash)((firstChild @ _), (secondChild @ _)) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](firstChild, secondChild)
  };
  val firstChild: org.locationtech.geomesa.utils.geohash.GeoHash = x$6._1;
  val secondChild: org.locationtech.geomesa.utils.geohash.GeoHash = x$6._2;
  val firstChildList: Seq[String] = considerCandidate(firstChild);
  firstChildList.++[String, Seq[String]](firstChildList.headOption match {
    case (value: String)Some[String]((bitStr @ _)) if bitStr.length().&lt;=(minBits) =&gt; scala.collection.immutable.Nil
    case _ =&gt; considerCandidate(secondChild)
  })(collection.this.Seq.canBuildFrom[String])
}
        </td>
      </tr><tr>
        <td>
          598
        </td>
        <td>
          3631
        </td>
        <td>
          27354
          -
          28522
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (scala.Predef.augmentString(bitString).size.&lt;(maxBits))
  {
    val gh0: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.fromBinaryString(bitString.+(&quot;0&quot;));
    val gh1: org.locationtech.geomesa.utils.geohash.GeoHash = GeoHash.fromBinaryString(bitString.+(&quot;1&quot;));
    val d0: Double = java.lang.Math.hypot(gh0.getPoint.getX().-(polyCentroid.getX()), gh0.getPoint.getY().-(polyCentroid.getY()));
    val d1: Double = java.lang.Math.hypot(gh1.getPoint.getX().-(polyCentroid.getX()), gh1.getPoint.getY().-(polyCentroid.getY()));
    &lt;synthetic&gt; &lt;artifact&gt; private[this] val x$6: (org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash) = (if (d0.&lt;=(d1))
      scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](gh0, gh1)
    else
      scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](gh1, gh0): (org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash) @unchecked) match {
      case (_1: org.locationtech.geomesa.utils.geohash.GeoHash, _2: org.locationtech.geomesa.utils.geohash.GeoHash)(org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash)((firstChild @ _), (secondChild @ _)) =&gt; scala.Tuple2.apply[org.locationtech.geomesa.utils.geohash.GeoHash, org.locationtech.geomesa.utils.geohash.GeoHash](firstChild, secondChild)
    };
    val firstChild: org.locationtech.geomesa.utils.geohash.GeoHash = x$6._1;
    val secondChild: org.locationtech.geomesa.utils.geohash.GeoHash = x$6._2;
    val firstChildList: Seq[String] = considerCandidate(firstChild);
    firstChildList.++[String, Seq[String]](firstChildList.headOption match {
      case (value: String)Some[String]((bitStr @ _)) if bitStr.length().&lt;=(minBits) =&gt; scala.collection.immutable.Nil
      case _ =&gt; considerCandidate(secondChild)
    })(collection.this.Seq.canBuildFrom[String])
  }
else
  scala.collection.immutable.Nil
        </td>
      </tr><tr>
        <td>
          603
        </td>
        <td>
          3603
        </td>
        <td>
          27709
          -
          27724
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitString.+(&quot;0&quot;)
        </td>
      </tr><tr>
        <td>
          603
        </td>
        <td>
          3604
        </td>
        <td>
          27684
          -
          27725
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.fromBinaryString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeoHash.fromBinaryString(bitString.+(&quot;0&quot;))
        </td>
      </tr><tr>
        <td>
          604
        </td>
        <td>
          3605
        </td>
        <td>
          27771
          -
          27786
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.String.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitString.+(&quot;1&quot;)
        </td>
      </tr><tr>
        <td>
          604
        </td>
        <td>
          3606
        </td>
        <td>
          27746
          -
          27787
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeoHash.fromBinaryString
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeoHash.fromBinaryString(bitString.+(&quot;1&quot;))
        </td>
      </tr><tr>
        <td>
          605
        </td>
        <td>
          3607
        </td>
        <td>
          27838
          -
          27855
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getX
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          polyCentroid.getX()
        </td>
      </tr><tr>
        <td>
          605
        </td>
        <td>
          3608
        </td>
        <td>
          27818
          -
          27855
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          gh0.getPoint.getX().-(polyCentroid.getX())
        </td>
      </tr><tr>
        <td>
          605
        </td>
        <td>
          3609
        </td>
        <td>
          27877
          -
          27894
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getY
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          polyCentroid.getY()
        </td>
      </tr><tr>
        <td>
          605
        </td>
        <td>
          3610
        </td>
        <td>
          27857
          -
          27894
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          gh0.getPoint.getY().-(polyCentroid.getY())
        </td>
      </tr><tr>
        <td>
          605
        </td>
        <td>
          3611
        </td>
        <td>
          27807
          -
          27895
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Math.hypot
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.hypot(gh0.getPoint.getX().-(polyCentroid.getX()), gh0.getPoint.getY().-(polyCentroid.getY()))
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          3612
        </td>
        <td>
          27946
          -
          27963
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getX
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          polyCentroid.getX()
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          3613
        </td>
        <td>
          27926
          -
          27963
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          gh1.getPoint.getX().-(polyCentroid.getX())
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          3614
        </td>
        <td>
          27985
          -
          28002
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.jts.geom.Point.getY
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          polyCentroid.getY()
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          3615
        </td>
        <td>
          27965
          -
          28002
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Double.-
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          gh1.getPoint.getY().-(polyCentroid.getY())
        </td>
      </tr><tr>
        <td>
          606
        </td>
        <td>
          3616
        </td>
        <td>
          27915
          -
          28003
        </td>
        <td>
          Apply
        </td>
        <td>
          java.lang.Math.hypot
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          java.lang.Math.hypot(gh1.getPoint.getX().-(polyCentroid.getX()), gh1.getPoint.getY().-(polyCentroid.getY()))
        </td>
      </tr><tr>
        <td>
          607
        </td>
        <td>
          3617
        </td>
        <td>
          28019
          -
          28019
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._1
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$6._1
        </td>
      </tr><tr>
        <td>
          607
        </td>
        <td>
          3618
        </td>
        <td>
          28031
          -
          28031
        </td>
        <td>
          Select
        </td>
        <td>
          scala.Tuple2._2
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          x$6._2
        </td>
      </tr><tr>
        <td>
          611
        </td>
        <td>
          3619
        </td>
        <td>
          28143
          -
          28172
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.considerCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          considerCandidate(firstChild)
        </td>
      </tr><tr>
        <td>
          614
        </td>
        <td>
          3620
        </td>
        <td>
          28286
          -
          28311
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableLike.headOption
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          firstChildList.headOption
        </td>
      </tr><tr>
        <td>
          614
        </td>
        <td>
          3626
        </td>
        <td>
          28282
          -
          28282
        </td>
        <td>
          TypeApply
        </td>
        <td>
          scala.collection.Seq.canBuildFrom
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          collection.this.Seq.canBuildFrom[String]
        </td>
      </tr><tr>
        <td>
          614
        </td>
        <td>
          3627
        </td>
        <td>
          28267
          -
          28503
        </td>
        <td>
          ApplyToImplicitArgs
        </td>
        <td>
          scala.collection.TraversableLike.++
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          firstChildList.++[String, Seq[String]](firstChildList.headOption match {
  case (value: String)Some[String]((bitStr @ _)) if bitStr.length().&lt;=(minBits) =&gt; scala.collection.immutable.Nil
  case _ =&gt; considerCandidate(secondChild)
})(collection.this.Seq.canBuildFrom[String])
        </td>
      </tr><tr>
        <td>
          615
        </td>
        <td>
          3621
        </td>
        <td>
          28353
          -
          28377
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitStr.length().&lt;=(minBits)
        </td>
      </tr><tr>
        <td>
          615
        </td>
        <td>
          3622
        </td>
        <td>
          28381
          -
          28384
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.immutable.Nil
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.immutable.Nil
        </td>
      </tr><tr>
        <td>
          615
        </td>
        <td>
          3623
        </td>
        <td>
          28381
          -
          28384
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.immutable.Nil
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.immutable.Nil
        </td>
      </tr><tr>
        <td>
          617
        </td>
        <td>
          3624
        </td>
        <td>
          28460
          -
          28490
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.considerCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          considerCandidate(secondChild)
        </td>
      </tr><tr>
        <td>
          617
        </td>
        <td>
          3625
        </td>
        <td>
          28460
          -
          28490
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.considerCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          considerCandidate(secondChild)
        </td>
      </tr><tr>
        <td>
          619
        </td>
        <td>
          3629
        </td>
        <td>
          28519
          -
          28522
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.immutable.Nil
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.immutable.Nil
        </td>
      </tr><tr>
        <td>
          619
        </td>
        <td>
          3630
        </td>
        <td>
          28519
          -
          28522
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.immutable.Nil
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.immutable.Nil
        </td>
      </tr><tr>
        <td>
          624
        </td>
        <td>
          3638
        </td>
        <td>
          28607
          -
          28744
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.apply
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          BitPrefixes.apply(if (ghMBR.prec.&lt;=(maxBits))
  considerCandidate(ghMBR)
else
  scala.collection.Seq.apply[String](scala.Predef.augmentString(scala.Predef.augmentString(ghMBR.toBinaryString).drop(minBits)).take(usedBits)))
        </td>
      </tr><tr>
        <td>
          625
        </td>
        <td>
          3632
        </td>
        <td>
          28630
          -
          28651
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ghMBR.prec.&lt;=(maxBits)
        </td>
      </tr><tr>
        <td>
          625
        </td>
        <td>
          3633
        </td>
        <td>
          28653
          -
          28677
        </td>
        <td>
          Apply
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.considerCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          considerCandidate(ghMBR)
        </td>
      </tr><tr>
        <td>
          625
        </td>
        <td>
          3634
        </td>
        <td>
          28653
          -
          28677
        </td>
        <td>
          Block
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.considerCandidate
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          considerCandidate(ghMBR)
        </td>
      </tr><tr>
        <td>
          626
        </td>
        <td>
          3635
        </td>
        <td>
          28693
          -
          28742
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.IndexedSeqOptimized.take
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.Predef.augmentString(scala.Predef.augmentString(ghMBR.toBinaryString).drop(minBits)).take(usedBits)
        </td>
      </tr><tr>
        <td>
          626
        </td>
        <td>
          3636
        </td>
        <td>
          28689
          -
          28743
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.Seq.apply[String](scala.Predef.augmentString(scala.Predef.augmentString(ghMBR.toBinaryString).drop(minBits)).take(usedBits))
        </td>
      </tr><tr>
        <td>
          626
        </td>
        <td>
          3637
        </td>
        <td>
          28689
          -
          28743
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.Seq.apply[String](scala.Predef.augmentString(scala.Predef.augmentString(ghMBR.toBinaryString).drop(minBits)).take(usedBits))
        </td>
      </tr><tr>
        <td>
          629
        </td>
        <td>
          3639
        </td>
        <td>
          28777
          -
          28799
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.overflowed
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitPrefixes.overflowed
        </td>
      </tr><tr>
        <td>
          629
        </td>
        <td>
          3640
        </td>
        <td>
          28801
          -
          29050
        </td>
        <td>
          Throw
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new java.lang.IllegalStateException(&quot;Bit prefixes overflowed while calculating unique Geohash substrings in polygon using the following parameters: &quot;.+(scala.StringContext.apply(&quot;\\nGeometry: &quot;, &quot; \\nOffset: &quot;, &quot; \\nLength: &quot;, &quot; \\nMax Keys in List: &quot;, &quot;&quot;).s(geom, offset, length, MAX_KEYS_IN_LIST)))
        </td>
      </tr><tr>
        <td>
          629
        </td>
        <td>
          3641
        </td>
        <td>
          28801
          -
          29050
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          throw new java.lang.IllegalStateException(&quot;Bit prefixes overflowed while calculating unique Geohash substrings in polygon using the following parameters: &quot;.+(scala.StringContext.apply(&quot;\\nGeometry: &quot;, &quot; \\nOffset: &quot;, &quot; \\nLength: &quot;, &quot; \\nMax Keys in List: &quot;, &quot;&quot;).s(geom, offset, length, MAX_KEYS_IN_LIST)))
        </td>
      </tr><tr>
        <td>
          629
        </td>
        <td>
          3642
        </td>
        <td>
          28773
          -
          28773
        </td>
        <td>
          Literal
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          629
        </td>
        <td>
          3643
        </td>
        <td>
          28773
          -
          28773
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          ()
        </td>
      </tr><tr>
        <td>
          634
        </td>
        <td>
          3644
        </td>
        <td>
          29188
          -
          29205
        </td>
        <td>
          Select
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.BitPrefixes.toSeq
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          bitPrefixes.toSeq
        </td>
      </tr><tr>
        <td>
          639
        </td>
        <td>
          3645
        </td>
        <td>
          29380
          -
          29403
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          unDotted.size.&lt;(maxKeys)
        </td>
      </tr><tr>
        <td>
          639
        </td>
        <td>
          3653
        </td>
        <td>
          29405
          -
          29685
        </td>
        <td>
          Block
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          {
  val keepers: List[String] = GeohashUtils.this.getGeohashStringDottingIterator(unDotted, MAX_KEYS_IN_LIST).take(MAX_KEYS_IN_LIST.+(1)).toList;
  if (keepers.size.&lt;=(MAX_KEYS_IN_LIST))
    keepers.toSeq
  else
    scala.collection.Seq.apply[Nothing]()
}
        </td>
      </tr><tr>
        <td>
          639
        </td>
        <td>
          3656
        </td>
        <td>
          29376
          -
          29696
        </td>
        <td>
          If
        </td>
        <td>
          &lt;nosymbol&gt;
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          if (unDotted.size.&lt;(maxKeys))
  {
    val keepers: List[String] = GeohashUtils.this.getGeohashStringDottingIterator(unDotted, MAX_KEYS_IN_LIST).take(MAX_KEYS_IN_LIST.+(1)).toList;
    if (keepers.size.&lt;=(MAX_KEYS_IN_LIST))
      keepers.toSeq
    else
      scala.collection.Seq.apply[Nothing]()
  }
else
  scala.collection.Seq.apply[Nothing]()
        </td>
      </tr><tr>
        <td>
          642
        </td>
        <td>
          3646
        </td>
        <td>
          29578
          -
          29598
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.+
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          MAX_KEYS_IN_LIST.+(1)
        </td>
      </tr><tr>
        <td>
          642
        </td>
        <td>
          3647
        </td>
        <td>
          29502
          -
          29606
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.TraversableOnce.toList
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          GeohashUtils.this.getGeohashStringDottingIterator(unDotted, MAX_KEYS_IN_LIST).take(MAX_KEYS_IN_LIST.+(1)).toList
        </td>
      </tr><tr>
        <td>
          643
        </td>
        <td>
          3648
        </td>
        <td>
          29619
          -
          29651
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.Int.&lt;=
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          keepers.size.&lt;=(MAX_KEYS_IN_LIST)
        </td>
      </tr><tr>
        <td>
          643
        </td>
        <td>
          3649
        </td>
        <td>
          29653
          -
          29666
        </td>
        <td>
          Select
        </td>
        <td>
          scala.collection.immutable.Seq.toSeq
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          keepers.toSeq
        </td>
      </tr><tr>
        <td>
          643
        </td>
        <td>
          3650
        </td>
        <td>
          29653
          -
          29666
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.immutable.Seq.toSeq
        </td>
        <td>
          
        </td>
        <td style="background: #AEF1AE">
          keepers.toSeq
        </td>
      </tr><tr>
        <td>
          643
        </td>
        <td>
          3651
        </td>
        <td>
          29672
          -
          29677
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.Seq.apply[Nothing]()
        </td>
      </tr><tr>
        <td>
          643
        </td>
        <td>
          3652
        </td>
        <td>
          29672
          -
          29677
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.Seq.apply[Nothing]()
        </td>
      </tr><tr>
        <td>
          644
        </td>
        <td>
          3654
        </td>
        <td>
          29691
          -
          29696
        </td>
        <td>
          Apply
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.Seq.apply[Nothing]()
        </td>
      </tr><tr>
        <td>
          644
        </td>
        <td>
          3655
        </td>
        <td>
          29691
          -
          29696
        </td>
        <td>
          Block
        </td>
        <td>
          scala.collection.generic.GenericCompanion.apply
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          scala.collection.Seq.apply[Nothing]()
        </td>
      </tr><tr>
        <td>
          645
        </td>
        <td>
          3657
        </td>
        <td>
          29708
          -
          29716
        </td>
        <td>
          Ident
        </td>
        <td>
          org.locationtech.geomesa.utils.geohash.GeohashUtils.unDotted
        </td>
        <td>
          
        </td>
        <td style="background: #F0ADAD">
          unDotted
        </td>
      </tr>
    </table>
          </div>
        </div>
      </body>
    </html>