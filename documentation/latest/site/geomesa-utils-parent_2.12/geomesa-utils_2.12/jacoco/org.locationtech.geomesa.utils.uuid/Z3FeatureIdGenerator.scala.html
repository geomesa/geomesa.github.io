<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Z3FeatureIdGenerator.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.uuid</a> &gt; <span class="el_source">Z3FeatureIdGenerator.scala</span></div><h1>Z3FeatureIdGenerator.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.uuid

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.curve.{BinnedTime, Z3SFC}
import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.jts.geom.{Geometry, Point}

import java.util.{Date, UUID}
import scala.util.hashing.MurmurHash3

/**
 * Creates feature id based on the z3 index.
 */
<span class="nc" id="L25">class Z3FeatureIdGenerator extends FeatureIdGenerator {</span>
  override def createId(sft: SimpleFeatureType, sf: SimpleFeature): String = {
<span class="nc bnc" id="L27" title="All 2 branches missed.">    if (sft.getGeometryDescriptor == null) {</span>
      // no geometry in this feature type - just use a random UUID
<span class="nc" id="L29">      UUID.randomUUID().toString</span>
    } else {
<span class="nc" id="L31">      Z3UuidGenerator.createUuid(sft, sf).toString</span>
    }
  }
}

/**
 * UUID generator that creates UUIDs that sort by z3 index.
 * UUIDs will be prefixed with a shard number, which will ensure some distribution of values as well
 * as allow pre-splitting of tables based on hex values.
 *
 * Uses variant 2 (IETF) and version 4 (for random UUIDs, although it's not totally random).
 * See https://en.wikipedia.org/wiki/Universally_unique_identifier#Variants_and_versions
 *
 * Format is:
 *
 *   4 bits for a shard - enough for a single hex digit
 *   44 bits of the z3 index value
 *   4 bits for the UUID version
 *   12 more bits of the z3 index value
 *   2 bits for the UUID variant
 *   62 bits of randomness
 */
<span class="nc bnc" id="L53" title="All 4 branches missed.">object Z3UuidGenerator extends RandomLsbUuidGenerator with LazyLogging {</span>

  import org.locationtech.geomesa.utils.geotools.Conversions.RichGeometry

<span class="nc" id="L57">  private val NullGeom = &quot;Cannot meaningfully index a feature with a NULL geometry&quot;</span>

  /**
    * Creates a UUID where the first 8 bytes are based on the z3 index of the feature and
    * the second 8 bytes are based on a random number.
    *
    * This provides uniqueness along with locality.
    *
    * @param sft simple feature type
    * @param sf feature
    * @return
    */
  def createUuid(sft: SimpleFeatureType, sf: SimpleFeature): UUID = {
<span class="nc bnc" id="L70" title="All 2 branches missed.">    val (x, y) = sf.getAttribute(sft.getGeomIndex) match {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">      case null =&gt; throw new IllegalArgumentException(NullGeom)</span>
<span class="nc bnc" id="L72" title="All 4 branches missed.">      case g: Geometry if g.isEmpty =&gt; (0d, 0d)</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">      case p: Point =&gt; (p.getX, p.getY)</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">      case g: Geometry =&gt; val p = g.safeCentroid(); (p.getX, p.getY)</span>
    }
    val time =
<span class="nc" id="L77">      sft.getDtgIndex</span>
<span class="nc" id="L78">          .flatMap(i =&gt; Option(sf.getAttribute(i)))</span>
<span class="nc" id="L79">          .map(_.asInstanceOf[Date].getTime)</span>
<span class="nc" id="L80">          .getOrElse(System.currentTimeMillis())</span>

<span class="nc" id="L82">    createUuid(x, y, time, sft.getZ3Interval)</span>
  }

  /**
    * Create a UUID based on the raw values that make up the z3
    *
    * @param geom geometry
    * @param time millis since java epoch
    * @param period z3 time period
    * @return
    */
  def createUuid(geom: Geometry, time: Long, period: TimePeriod): UUID = {
<span class="nc bnc" id="L94" title="All 2 branches missed.">    if (geom == null) {</span>
<span class="nc" id="L95">      throw new IllegalArgumentException(NullGeom)</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">    } else if (geom.isEmpty) {</span>
<span class="nc" id="L97">      createUuid(0, 0, time, period)</span>
    } else {
<span class="nc" id="L99">      val pt = geom.safeCentroid()</span>
<span class="nc" id="L100">      createUuid(pt.getX, pt.getY, time, period)</span>
    }
  }


  /**
   * Create a UUID based on the raw values that make up the z3, optimized for point geometries
   *
   * @param pt point
   * @param time millis since java epoch
   * @param period z3 time period
   * @return
   */
  def createUuid(pt: Point, time: Long, period: TimePeriod): UUID = {
<span class="nc bnc" id="L114" title="All 2 branches missed.">    if (pt == null) {</span>
<span class="nc" id="L115">      throw new IllegalArgumentException(NullGeom)</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">    } else if (pt.isEmpty) {</span>
<span class="nc" id="L117">      createUuid(0, 0, time, period)</span>
    } else {
<span class="nc" id="L119">      createUuid(pt.getX, pt.getY, time, period)</span>
    }
  }

  /**
   * Create a UUID based on the raw values that make up the z3, optimized for point geometries
   *
   * @param x x coord
   * @param y y coord
   * @param time millis since java epoch
   * @param period z3 time period
   * @return
   */
  def createUuid(x: Double, y: Double, time: Long, period: TimePeriod): UUID = {
    // create the random part
    // this uses the same temp array we use later, so be careful with the order this gets called
<span class="nc" id="L135">    val leastSigBits = createRandomLsb()</span>

    val z3 = {
<span class="nc bnc" id="L138" title="All 2 branches missed.">      val BinnedTime(b, t) = BinnedTime.timeToBinnedTime(period)(time)</span>
<span class="nc" id="L139">      val z = Z3SFC(period).index(x, y, t)</span>
<span class="nc" id="L140">      ByteArrays.toBytes(b, z)</span>
    }

    // shard is first 4 bits of our uuid (e.g. 1 hex char) - this allows nice pre-splitting
<span class="nc" id="L144">    val shard = math.abs(MurmurHash3.bytesHash(z3, MurmurHash3.arraySeed) % 16).toByte</span>

<span class="nc" id="L146">    val msb = getTempByteArray</span>
    // set the shard bits, then the z3 bits
<span class="nc" id="L148">    msb(0) = lohi(shard, z3(0))</span>
<span class="nc" id="L149">    msb(1) = lohi(z3(0), z3(1))</span>
<span class="nc" id="L150">    msb(2) = lohi(z3(1), z3(2))</span>
<span class="nc" id="L151">    msb(3) = lohi(z3(2), z3(3))</span>
<span class="nc" id="L152">    msb(4) = lohi(z3(3), z3(4))</span>
<span class="nc" id="L153">    msb(5) = lohi(z3(4), z3(5))</span>
<span class="nc" id="L154">    msb(6) = lohi(0, (z3(5) &lt;&lt; 4).asInstanceOf[Byte]) // leave 4 bits for the version</span>
<span class="nc" id="L155">    msb(7) = z3(6)</span>
    // we drop the last 4 bytes of the z3 to ensure some randomness
    // that leaves us 62 bits of randomness, and still gives us ~10 bits per dimension for locality

    // set the UUID version - we skipped those bits when writing
<span class="nc" id="L160">    setVersion(msb)</span>
    // create the long
<span class="nc" id="L162">    val mostSigBits = ByteArrays.readLong(msb)</span>

<span class="nc" id="L164">    new UUID(mostSigBits, leastSigBits)</span>
  }

  /**
    * Gets the z3 time period bin based on a z3 uuid
    *
    * @param uuid uuid, as bytes
    * @return
    */
<span class="nc" id="L173">  def timeBin(uuid: Array[Byte], offset: Int = 0): Short = timeBin(uuid(offset), uuid(offset + 1), uuid(offset + 2))</span>

  /**
    * Gets the z3 time period bin based on a z3 uuid
    *
    * @param b0 first byte of the uuid
    * @param b1 second byte of the uuid
    * @param b2 third byte of the uuid
    * @return
    */
  def timeBin(b0: Byte, b1: Byte, b2: Byte): Short = {
    // undo the lo-hi byte merging to get the two bytes for the time period
<span class="nc" id="L185">    ByteArrays.readShort(Array(lohi(b0, b1), lohi(b1, b2)))</span>
  }

  // takes 4 low bits from b1 as the new hi bits, and 4 high bits of b2 as the new low bits, of a new byte
  private def lohi(b1: Byte, b2: Byte): Byte =
<span class="nc" id="L190">    ((java.lang.Byte.toUnsignedInt(b1) &lt;&lt; 4) | (java.lang.Byte.toUnsignedInt(b2) &gt;&gt;&gt; 4)).asInstanceOf[Byte]</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>