<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteArrays.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.index</a> &gt; <span class="el_source">ByteArrays.scala</span></div><h1>ByteArrays.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

/**
  * Portions
  * Copyright 2011-2016 The Apache Software Foundation
  */

package org.locationtech.geomesa.utils.index

<span class="nc" id="L16">object ByteArrays {</span>

<span class="nc" id="L18">  val ZeroByte: Byte = 0x00.toByte</span>
<span class="nc" id="L19">  val OneByte: Byte  = 0x01.toByte</span>
<span class="nc" id="L20">  val MaxByte: Byte =  0xff.toByte</span>

<span class="nc" id="L22">  val ZeroByteArray: Array[Byte] = Array(ByteArrays.ZeroByte)</span>
<span class="nc" id="L23">  val OneByteArray : Array[Byte] = Array(ByteArrays.OneByte)</span>

<span class="nc" id="L25">  implicit val UnsignedByteOrdering: Ordering[Byte] = new Ordering[Byte] {</span>
<span class="nc" id="L26">    override def compare(x: Byte, y: Byte): Int = (x &amp; 0xff) - (y &amp; 0xff)</span>
  }

<span class="nc" id="L29">  implicit val ByteOrdering: Ordering[Array[Byte]] = new Ordering[Array[Byte]] {</span>
    override def compare(x: Array[Byte], y: Array[Byte]): Int = {
<span class="nc" id="L31">      var i = 0</span>
<span class="nc" id="L32">      val minLength = Math.min(x.length, y.length)</span>
<span class="nc bnc" id="L33" title="All 2 branches missed.">      while (i &lt; minLength) {</span>
<span class="nc" id="L34">        val res = UnsignedByteOrdering.compare(x(i), y(i))</span>
<span class="nc bnc" id="L35" title="All 2 branches missed.">        if (res != 0) {</span>
<span class="nc" id="L36">          return res</span>
        }
<span class="nc" id="L38">        i +=1</span>
      }
<span class="nc" id="L40">      x.length - y.length</span>
    }
  }

  /**
    * Writes the short as 2 bytes in the provided array, starting at offset
    *
    * @param short short to write
    * @param bytes byte array to write to, must have length at least `offset` + 2
    * @param offset offset to start writing
    */
<span class="nc" id="L51">  def writeShort(short: Short, bytes: Array[Byte], offset: Int = 0): Unit = {</span>
<span class="nc" id="L52">    bytes(offset) = (short &gt;&gt; 8).asInstanceOf[Byte]</span>
<span class="nc" id="L53">    bytes(offset + 1) = short.asInstanceOf[Byte]</span>
  }

  /**
    * Writes the short as 2 bytes in the provided array, starting at offset,
    * and preserving sort order for negative values
    *
    * @param short short to write
    * @param bytes bytes array to write to, must have length at least `offset` + 2
    * @param offset offset to start writing
    */
<span class="nc" id="L64">  def writeOrderedShort(short: Short, bytes: Array[Byte], offset: Int = 0): Unit = {</span>
<span class="nc" id="L65">    bytes(offset) = (((short &gt;&gt; 8) &amp; 0xff) ^ 0x80).asInstanceOf[Byte]</span>
<span class="nc" id="L66">    bytes(offset + 1) = (short &amp; 0xff).asInstanceOf[Byte]</span>
  }

  /**
    * Writes the int as 4 bytes in the provided array, starting at offset
    *
    * @param int int to write
    * @param bytes byte array to write to, must have length at least `offset` + 8
    * @param offset offset to start writing
    */
<span class="nc" id="L76">  def writeInt(int: Int, bytes: Array[Byte], offset: Int = 0): Unit = {</span>
<span class="nc" id="L77">    bytes(offset    ) = ((int &gt;&gt; 24) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L78">    bytes(offset + 1) = ((int &gt;&gt; 16) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L79">    bytes(offset + 2) = ((int &gt;&gt; 8)  &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L80">    bytes(offset + 3) =  (int        &amp; 0xff).asInstanceOf[Byte]</span>
  }

  /**
    * Writes the long as 8 bytes in the provided array, starting at offset
    *
    * @param long long to write
    * @param bytes byte array to write to, must have length at least `offset` + 8
    * @param offset offset to start writing
    */
<span class="nc" id="L90">  def writeLong(long: Long, bytes: Array[Byte], offset: Int = 0): Unit = {</span>
<span class="nc" id="L91">    bytes(offset    ) = ((long &gt;&gt; 56) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L92">    bytes(offset + 1) = ((long &gt;&gt; 48) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L93">    bytes(offset + 2) = ((long &gt;&gt; 40) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L94">    bytes(offset + 3) = ((long &gt;&gt; 32) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L95">    bytes(offset + 4) = ((long &gt;&gt; 24) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L96">    bytes(offset + 5) = ((long &gt;&gt; 16) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L97">    bytes(offset + 6) = ((long &gt;&gt; 8)  &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L98">    bytes(offset + 7) =  (long        &amp; 0xff).asInstanceOf[Byte]</span>
  }

  /**
    * Writes the long as 8 bytes in the provided array, starting at offset,
    * and preserving sort order for negative values
    *
    * @param long long to write
    * @param bytes bytes array to write to, must have length at least `offset` + 8
    * @param offset offset to start writing
    */
<span class="nc" id="L109">  def writeOrderedLong(long: Long, bytes: Array[Byte], offset: Int = 0): Unit = {</span>
<span class="nc" id="L110">    bytes(offset    ) = (((long &gt;&gt; 56) &amp; 0xff) ^ 0x80).asInstanceOf[Byte]</span>
<span class="nc" id="L111">    bytes(offset + 1) = ((long &gt;&gt; 48) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L112">    bytes(offset + 2) = ((long &gt;&gt; 40) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L113">    bytes(offset + 3) = ((long &gt;&gt; 32) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L114">    bytes(offset + 4) = ((long &gt;&gt; 24) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L115">    bytes(offset + 5) = ((long &gt;&gt; 16) &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L116">    bytes(offset + 6) = ((long &gt;&gt; 8)  &amp; 0xff).asInstanceOf[Byte]</span>
<span class="nc" id="L117">    bytes(offset + 7) =  (long        &amp; 0xff).asInstanceOf[Byte]</span>
  }

  /**
    * Reads 2 bytes from the provided array as a short, starting at offset
    *
    * @param bytes array to read from
    * @param offset offset to start reading
    * @return
    */
<span class="nc" id="L127">  def readShort(bytes: Array[Byte], offset: Int = 0): Short =</span>
<span class="nc" id="L128">    (((bytes(offset) &amp; 0xff) &lt;&lt; 8) | (bytes(offset + 1) &amp; 0xff)).toShort</span>

  /**
    * Reads 2 bytes from the provided array as a short, starting at offset
    *
    * @param bytes array to read from
    * @param offset offset to start reading
    * @return
    */
<span class="nc" id="L137">  def readOrderedShort(bytes: Array[Byte], offset: Int = 0): Short =</span>
<span class="nc" id="L138">    ((((bytes(offset) ^ 0x80) &amp; 0xff) &lt;&lt; 8) | (bytes(offset + 1) &amp; 0xff)).toShort</span>

  /**
    * Reads 4 bytes from the provided array as an int, starting at offset
    *
    * @param bytes array to read from
    * @param offset offset to start reading
    * @return
    */
<span class="nc" id="L147">  def readInt(bytes: Array[Byte], offset: Int = 0): Int = {</span>
<span class="nc" id="L148">    ((bytes(offset    ) &amp; 0xff) &lt;&lt; 24) |</span>
<span class="nc" id="L149">    ((bytes(offset + 1) &amp; 0xff) &lt;&lt; 16) |</span>
<span class="nc" id="L150">    ((bytes(offset + 2) &amp; 0xff) &lt;&lt;  8) |</span>
<span class="nc" id="L151">     (bytes(offset + 3) &amp; 0xff)</span>
  }

  /**
    * Reads 8 bytes from the provided array as a long, starting at offset
    *
    * @param bytes array to read from
    * @param offset offset to start reading
    * @return
    */
<span class="nc" id="L161">  def readLong(bytes: Array[Byte], offset: Int = 0): Long = {</span>
<span class="nc" id="L162">    ((bytes(offset    ) &amp; 0xffL) &lt;&lt; 56) |</span>
<span class="nc" id="L163">    ((bytes(offset + 1) &amp; 0xffL) &lt;&lt; 48) |</span>
<span class="nc" id="L164">    ((bytes(offset + 2) &amp; 0xffL) &lt;&lt; 40) |</span>
<span class="nc" id="L165">    ((bytes(offset + 3) &amp; 0xffL) &lt;&lt; 32) |</span>
<span class="nc" id="L166">    ((bytes(offset + 4) &amp; 0xffL) &lt;&lt; 24) |</span>
<span class="nc" id="L167">    ((bytes(offset + 5) &amp; 0xffL) &lt;&lt; 16) |</span>
<span class="nc" id="L168">    ((bytes(offset + 6) &amp; 0xffL) &lt;&lt;  8) |</span>
<span class="nc" id="L169">     (bytes(offset + 7) &amp; 0xffL)</span>
  }

  /**
    * Reads 8 bytes from the provided array as a long, starting at offset
    *
    * @param bytes array to read from
    * @param offset offset to start reading
    * @return
    */
<span class="nc" id="L179">  def readOrderedLong(bytes: Array[Byte], offset: Int = 0): Long = {</span>
<span class="nc" id="L180">    (((bytes(offset) ^ 0x80) &amp; 0xffL) &lt;&lt; 56) |</span>
<span class="nc" id="L181">    ((bytes(offset + 1) &amp; 0xffL) &lt;&lt; 48) |</span>
<span class="nc" id="L182">    ((bytes(offset + 2) &amp; 0xffL) &lt;&lt; 40) |</span>
<span class="nc" id="L183">    ((bytes(offset + 3) &amp; 0xffL) &lt;&lt; 32) |</span>
<span class="nc" id="L184">    ((bytes(offset + 4) &amp; 0xffL) &lt;&lt; 24) |</span>
<span class="nc" id="L185">    ((bytes(offset + 5) &amp; 0xffL) &lt;&lt; 16) |</span>
<span class="nc" id="L186">    ((bytes(offset + 6) &amp; 0xffL) &lt;&lt;  8) |</span>
<span class="nc" id="L187">     (bytes(offset + 7) &amp; 0xffL)</span>
  }

  /**
    * Allocates a new array of length two and writes the short to it
    *
    * @param short value to encode
    * @return
    */
  def toBytes(short: Short): Array[Byte] = {
<span class="nc" id="L197">    val result = Array.ofDim[Byte](2)</span>
<span class="nc" id="L198">    writeShort(short, result)</span>
<span class="nc" id="L199">    result</span>
  }

  /**
    * Allocates a new array of length two and writes the short to it, preserving sort order for negative values
    *
    * @param short value to encode
    * @return
    */
  def toOrderedBytes(short: Short): Array[Byte] = {
<span class="nc" id="L209">    val result = Array.ofDim[Byte](2)</span>
<span class="nc" id="L210">    writeOrderedShort(short, result)</span>
<span class="nc" id="L211">    result</span>
  }

  /**
    * Allocates a new array of length four and writes the int to it
    *
    * @param int value to encode
    * @return
    */
  def toBytes(int: Int): Array[Byte] = {
<span class="nc" id="L221">    val result = Array.ofDim[Byte](4)</span>
<span class="nc" id="L222">    writeInt(int, result)</span>
<span class="nc" id="L223">    result</span>
  }

  /**
    * Allocates a new array of length eight and writes the long to it
    *
    * @param long value to encode
    * @return
    */
  def toBytes(long: Long): Array[Byte] = {
<span class="nc" id="L233">    val result = Array.ofDim[Byte](8)</span>
<span class="nc" id="L234">    writeLong(long, result)</span>
<span class="nc" id="L235">    result</span>
  }

  /**
    * Allocates a new array of length eight and writes the long to it, preserving sort order for negative values
    *
    * @param long value to encode
    * @return
    */
  def toOrderedBytes(long: Long): Array[Byte] = {
<span class="nc" id="L245">    val result = Array.ofDim[Byte](8)</span>
<span class="nc" id="L246">    writeOrderedLong(long, result)</span>
<span class="nc" id="L247">    result</span>
  }

  /**
    * Creates a byte array with a short and a long.
    *
    * Code based on the following methods, but avoids allocating extra byte arrays:
    *
    *   com.google.common.primitives.Shorts#toByteArray(short)
    *   com.google.common.primitives.Longs#toByteArray(long)
    *
    * @param bin time bin
    * @param z z value
    * @return
    */
  def toBytes(bin: Short, z: Long): Array[Byte] = {
<span class="nc" id="L263">    val result = Array.ofDim[Byte](10)</span>
<span class="nc" id="L264">    writeShort(bin, result, 0)</span>
<span class="nc" id="L265">    writeLong(z, result, 2)</span>
<span class="nc" id="L266">    result</span>
  }

  /**
   * Creates a byte array with a short and a long and an int
   *
   * @param bin bin
   * @param s s value
   * @param time time offset
   * @return
   */
  def toBytes(bin: Short, s: Long, time: Int): Array[Byte] = {
<span class="nc" id="L278">    val result = Array.ofDim[Byte](14)</span>
<span class="nc" id="L279">    writeShort(bin, result)</span>
<span class="nc" id="L280">    writeLong(s, result, 2)</span>
<span class="nc" id="L281">    writeInt(time, result, 10)</span>
<span class="nc" id="L282">    result</span>
  }

  /**
   * Creates a byte array with a short and a long and an int
   *
   * @param bin bin
   * @param s s value
   * @param time time offset
   * @return
   */
<span class="nc" id="L293">  def toBytesFollowingPrefix(bin: Short, s: Long, time: Int): Array[Byte] = incrementInPlace(toBytes(bin, s, time))</span>

  /**
    * Creates a byte array with a short and a long, preserving the sort order of the short for negative values
    *
    * @param bin time bin
    * @param z z value
    * @return
    */
  def toOrderedBytes(bin: Short, z: Long): Array[Byte] = {
<span class="nc" id="L303">    val result = Array.ofDim[Byte](10)</span>
<span class="nc" id="L304">    writeOrderedShort(bin, result, 0)</span>
<span class="nc" id="L305">    writeLong(z, result, 2)</span>
<span class="nc" id="L306">    result</span>
  }

  /**
    * Creates a byte array with a short and a long.
    *
    * Code based on the following methods, but avoids allocating extra byte arrays:
    *
    *   com.google.common.primitives.Shorts#toByteArray(short)
    *   com.google.common.primitives.Longs#toByteArray(long)
    *
    * @param bin time bin, already converted to 2 bytes
    * @param z z value
    * @return
    */
  def toBytes(bin: Array[Byte], z: Long): Array[Byte] = {
<span class="nc" id="L322">    val result = Array.ofDim[Byte](10)</span>

<span class="nc" id="L324">    result(0) = bin(0)</span>
<span class="nc" id="L325">    result(1) = bin(1)</span>

<span class="nc" id="L327">    writeLong(z, result, 2)</span>

<span class="nc" id="L329">    result</span>
  }

  /**
    * Converts a UUID into a byte array.
    *
    * Code based on the following method, but avoids allocating extra byte arrays:
    *
    *   com.google.common.primitives.Longs#toByteArray(long)
    *
    * @param msb most significant bits
    * @param lsb least significant bits
    * @return
    */
  def uuidToBytes(msb: Long, lsb: Long): Array[Byte] = {
<span class="nc" id="L344">    val result = Array.ofDim[Byte](16)</span>
<span class="nc" id="L345">    writeLong(msb, result, 0)</span>
<span class="nc" id="L346">    writeLong(lsb, result, 8)</span>
<span class="nc" id="L347">    result</span>
  }

  /**
    * Converts a byte array into a UUID.
    *
    * Code based on the following method:
    *
    *   com.google.common.primitives.Longs#fromByteArray(bytes)
    *
    * @param bytes bytes
    * @return (most significant bits, least significant bits)
    */
<span class="nc" id="L360">  def uuidFromBytes(bytes: Array[Byte], offset: Int = 0): (Long, Long) = {</span>
<span class="nc" id="L361">    val msb = readLong(bytes, offset)</span>
<span class="nc" id="L362">    val lsb = readLong(bytes, offset + 8)</span>
<span class="nc" id="L363">    (msb, lsb)</span>
  }

  /**
    * Creates a byte array that sorts directly after the z-value (as converted into a byte array).
    *
    * Code based on the following methods, but avoids allocating extra byte arrays:
    *
    *   org.apache.accumulo.core.data.Range#followingPrefix(org.apache.hadoop.io.Text)
    *   com.google.common.primitives.Longs#toByteArray(long)
    *
    *
    * @param z z value
    * @return
    */
<span class="nc" id="L378">  def toBytesFollowingPrefix(z: Long): Array[Byte] = incrementInPlace(toBytes(z))</span>

  /**
    * Creates a byte array that sorts directly after the z-value (as converted into a byte array).
    *
    * Code based on the following methods, but avoids allocating extra byte arrays:
    *
    *   org.apache.accumulo.core.data.Range#followingPrefix(org.apache.hadoop.io.Text)
    *   com.google.common.primitives.Shorts#toByteArray(short)
    *   com.google.common.primitives.Longs#toByteArray(long)
    *
    * @param bin epoch bin
    * @param z z value
    * @return
    */
<span class="nc" id="L393">  def toBytesFollowingPrefix(bin: Short, z: Long): Array[Byte] = incrementInPlace(toBytes(bin, z))</span>

  /**
    * Creates a byte array that sorts directly after the z-value (as converted into a byte array).
    *
    * @param bin epoch bin
    * @param z z value
    * @return
    */
<span class="nc" id="L402">  def toOrderedBytesFollowingPrefix(bin: Short, z: Long): Array[Byte] = incrementInPlace(toOrderedBytes(bin, z))</span>

  def toBytesFollowingRow(long: Long): Array[Byte] = {
<span class="nc" id="L405">    val result = Array.ofDim[Byte](9)</span>
<span class="nc" id="L406">    writeLong(long, result)</span>
<span class="nc" id="L407">    result(8) = ZeroByte</span>
<span class="nc" id="L408">    result</span>
  }

  def toBytesFollowingRow(bin: Short, z: Long): Array[Byte] = {
<span class="nc" id="L412">    val result = Array.ofDim[Byte](11)</span>
<span class="nc" id="L413">    writeShort(bin, result, 0)</span>
<span class="nc" id="L414">    writeLong(z, result, 2)</span>
<span class="nc" id="L415">    result(10) = ZeroByte</span>
<span class="nc" id="L416">    result</span>
  }

  def toOrderedBytesFollowingRow(bin: Short, z: Long): Array[Byte] = {
<span class="nc" id="L420">    val result = Array.ofDim[Byte](11)</span>
<span class="nc" id="L421">    writeOrderedShort(bin, result, 0)</span>
<span class="nc" id="L422">    writeLong(z, result, 2)</span>
<span class="nc" id="L423">    result(10) = ZeroByte</span>
<span class="nc" id="L424">    result</span>
  }

  /**
    * Returns a row that sorts just after all rows beginning with a prefix. Copied from Accumulo Range
    *
    * @param prefix to follow
    * @return prefix that immediately follows the given prefix when sorted, or an empty array if no prefix can follow
    *         (i.e., the string is all 0xff bytes)
    */
  def rowFollowingPrefix(prefix: Array[Byte]): Array[Byte] = {
    // find the last byte in the array that is not 0xff
<span class="nc" id="L436">    var changeIndex = prefix.length - 1</span>
<span class="nc bnc" id="L437" title="All 4 branches missed.">    while (changeIndex &gt;= 0 &amp;&amp; prefix(changeIndex) == MaxByte) {</span>
<span class="nc" id="L438">      changeIndex -= 1</span>
    }
<span class="nc bnc" id="L440" title="All 2 branches missed.">    if (changeIndex &lt; 0) { Array.empty } else {</span>
      // copy prefix bytes into new array
<span class="nc" id="L442">      val following = Array.ofDim[Byte](changeIndex + 1)</span>
<span class="nc" id="L443">      System.arraycopy(prefix, 0, following, 0, changeIndex + 1)</span>
      // increment the selected byte
<span class="nc" id="L445">      following(changeIndex) = (following(changeIndex) + 1).toByte</span>
<span class="nc" id="L446">      following</span>
    }
  }

  /**
    * Returns a row that immediately follows the row. Useful for inclusive endpoints.
    *
    * @param row row
    * @return
    */
  def rowFollowingRow(row: Array[Byte]): Array[Byte] = {
<span class="nc" id="L457">    val following = Array.ofDim[Byte](row.length + 1)</span>
<span class="nc" id="L458">    System.arraycopy(row, 0, following, 0, row.length)</span>
<span class="nc" id="L459">    following(row.length) = ZeroByte</span>
<span class="nc" id="L460">    following</span>
  }

  /**
    * Returns a row that immediately follows the row. Useful for inclusive endpoints.
    *
    * @param bytes row
    * @return
    */
  def rowFollowingRow(bytes: Array[Byte]*): Array[Byte] = {
<span class="nc" id="L470">    var length = 1</span>
<span class="nc" id="L471">    bytes.foreach(b =&gt; length += b.length)</span>
<span class="nc" id="L472">    val result = Array.ofDim[Byte](length)</span>
<span class="nc" id="L473">    var i = 0</span>
<span class="nc" id="L474">    bytes.foreach { b =&gt;</span>
<span class="nc" id="L475">      System.arraycopy(b, 0, result, i, b.length)</span>
<span class="nc" id="L476">      i += b.length</span>
    }
<span class="nc" id="L478">    result(i) = ZeroByte</span>
<span class="nc" id="L479">    result</span>
  }

  /**
    * Concatenate byte arrays
    *
    * @param first first array
    * @param second second array
    * @return
    */
  def concat(first: Array[Byte], second: Array[Byte]): Array[Byte] = {
<span class="nc" id="L490">    val result = Array.ofDim[Byte](first.length + second.length)</span>
<span class="nc" id="L491">    System.arraycopy(first, 0, result, 0, first.length)</span>
<span class="nc" id="L492">    System.arraycopy(second, 0, result, first.length, second.length)</span>
<span class="nc" id="L493">    result</span>
  }

  /**
    * Concatenate byte arrays
    *
    * @param bytes arrays
    * @return
    */
  def concat(bytes: Array[Byte]*): Array[Byte] = {
<span class="nc" id="L503">    var length = 0</span>
<span class="nc" id="L504">    bytes.foreach(b =&gt; length += b.length)</span>
<span class="nc" id="L505">    val result = Array.ofDim[Byte](length)</span>
<span class="nc" id="L506">    var i = 0</span>
<span class="nc" id="L507">    bytes.foreach { b =&gt;</span>
<span class="nc" id="L508">      System.arraycopy(b, 0, result, i, b.length)</span>
<span class="nc" id="L509">      i += b.length</span>
    }
<span class="nc" id="L511">    result</span>
  }

  /**
    * Converts an unsigned byte into a hex string
    *
    * @param b unsigned byte
    * @return
    */
<span class="nc" id="L520">  def toHex(b: Byte): String = f&quot;${(b &amp; 0xff) &gt;&gt;&gt; 4}%01x${b &amp; 0x0f}%01x&quot;</span>

  /**
    * Converts an unsigned byte array into a hex string
    *
    * @param bytes unsigned byte array
    * @return
    */
<span class="nc" id="L528">  def toHex(bytes: Array[Byte]): String = toHex(bytes, 0, bytes.length)</span>

  /**
    * Converts an unsigned byte array into a hex string
    *
    * @param bytes unsigned byte array
    * @return
    */
  def toHex(bytes: Array[Byte], offset: Int, length: Int): String = {
<span class="nc" id="L537">    val sb = new StringBuilder(length * 2)</span>
<span class="nc" id="L538">    var i = 0</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L540">      sb.append(toHex(bytes(i + offset)))</span>
<span class="nc" id="L541">      i += 1</span>
    }
<span class="nc" id="L543">    sb.toString</span>
  }


  /**
   * Convert a byte to a printable string. Based on Accumulo's byte representation
   *
   * @param b byte
   * @return
   */
  def printable(b: Byte): String = {
<span class="nc" id="L554">    val c = 0xff &amp; b</span>
<span class="nc bnc" id="L555" title="All 4 branches missed.">    if (c &gt;= 32 &amp;&amp; c &lt;= 126) { c.toChar.toString } else { f&quot;%%$c%02x;&quot; }</span>
  }

  /**
   * Convert each byte in the array to a printable string
   *
   * @param bytes bytes
   * @return
   */
  def printable(bytes: Array[Byte]): String = {
<span class="nc bnc" id="L565" title="All 2 branches missed.">    if (bytes == null) { &quot;null&quot; } else {</span>
<span class="nc" id="L566">      bytes.map(printable).mkString(&quot;&quot;)</span>
    }
  }

  /**
    * Increment the last byte in the array, if it's not equal to MaxByte. Otherwise,
    * walk backwards until we find a byte we can increment, and create a new sub-array
    *
    * @param bytes bytes
    * @return
    */
  private def incrementInPlace(bytes: Array[Byte]): Array[Byte] = {
<span class="nc" id="L578">    var i = bytes.length - 1</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">    if (bytes(i) != MaxByte) {</span>
      // normal case - we can just update the original byte array
<span class="nc" id="L581">      bytes(i) = (bytes(i) + 1).toByte</span>
<span class="nc" id="L582">      bytes</span>
    } else {
      // walk backwards to find the first byte we can increment, then take the sub-array to that point
<span class="nc bnc" id="L585" title="All 4 branches missed.">      while ({{ i -= 1 }; i &gt;= 0 &amp;&amp; bytes(i) == MaxByte })()</span>

<span class="nc bnc" id="L587" title="All 2 branches missed.">      if (i == -1) { Array.empty } else {</span>
<span class="nc" id="L588">        val result = Array.ofDim[Byte](i + 1)</span>
<span class="nc" id="L589">        System.arraycopy(bytes, 0, result, 0, result.length)</span>
<span class="nc" id="L590">        result(i) = (result(i) + 1).toByte</span>
<span class="nc" id="L591">        result</span>
      }
    }
  }
<span class="nc" id="L595">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>