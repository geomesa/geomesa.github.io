<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleFeatureTypes.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools</a> &gt; <span class="el_source">SimpleFeatureTypes.scala</span></div><h1>SimpleFeatureTypes.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools

import com.typesafe.config.Config
import org.apache.commons.text.StringEscapeUtils
import org.geotools.api.feature.`type`.{AttributeDescriptor, FeatureTypeFactory, GeometryDescriptor}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.feature.AttributeTypeBuilder
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.locationtech.geomesa.utils.geotools.NameableFeatureTypeFactory.NameableSimpleFeatureType
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.Configs.{DefaultDtgField, IndexIgnoreDtg}
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec.GeomAttributeSpec
import org.locationtech.geomesa.utils.geotools.sft._
import org.locationtech.geomesa.utils.text.StringSerialization
import org.parboiled.errors.ParsingException

import java.util.Date
import java.util.concurrent.ConcurrentHashMap

<span class="nc" id="L27">object SimpleFeatureTypes {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

<span class="nc" id="L33">  object Configs {</span>

    // note: configs that don't start with 'geomesa' won't be persisted

<span class="nc" id="L37">    val DefaultDtgField       = &quot;geomesa.index.dtg&quot;</span>
<span class="nc" id="L38">    val EnabledIndices        = &quot;geomesa.indices.enabled&quot;</span>
<span class="nc" id="L39">    val FeatureExpiration     = &quot;geomesa.feature.expiry&quot;</span>
<span class="nc" id="L40">    val FidsAreUuids          = &quot;geomesa.fid.uuid&quot;</span>
<span class="nc" id="L41">    val FidsAreUuidEncoded    = &quot;geomesa.fid.uuid-encoded&quot;</span>
<span class="nc" id="L42">    val IndexAttributeShards  = &quot;geomesa.attr.splits&quot;</span>
<span class="nc" id="L43">    val IndexIdShards         = &quot;geomesa.id.splits&quot;</span>
<span class="nc" id="L44">    val IndexIgnoreDtg        = &quot;geomesa.ignore.dtg&quot;</span>
<span class="nc" id="L45">    val IndexTablePrefix      = &quot;index.table.prefix&quot;</span>
<span class="nc" id="L46">    val IndexVisibilityLevel  = &quot;geomesa.visibility.level&quot;</span>
<span class="nc" id="L47">    val IndexXzPrecision      = &quot;geomesa.xz.precision&quot;</span>
<span class="nc" id="L48">    val IndexZ3Interval       = &quot;geomesa.z3.interval&quot;</span>
<span class="nc" id="L49">    val IndexS3Interval       = &quot;geomesa.s3.interval&quot;</span>
<span class="nc" id="L50">    val Keywords              = &quot;geomesa.keywords&quot;</span>
<span class="nc" id="L51">    val MixedGeometries       = &quot;geomesa.mixed.geometries&quot;</span>
<span class="nc" id="L52">    val OverrideDtgJoin       = &quot;override.index.dtg.join&quot;</span>
<span class="nc" id="L53">    val OverrideReservedWords = &quot;override.reserved.words&quot;</span>
<span class="nc" id="L54">    val QueryInterceptors     = &quot;geomesa.query.interceptors&quot;</span>
<span class="nc" id="L55">    val RequireVisibility     = &quot;geomesa.vis.required&quot;</span>
<span class="nc" id="L56">    val StatsEnabled          = &quot;geomesa.stats.enable&quot;</span>
<span class="nc" id="L57">    val TableCompressionType  = &quot;geomesa.table.compression.type&quot; // valid: gz(default), snappy, lzo, bzip2, lz4, zstd</span>
<span class="nc" id="L58">    val TableLogicalTime      = &quot;geomesa.logical.time&quot;</span>
<span class="nc" id="L59">    val TablePartitioning     = &quot;geomesa.table.partition&quot;</span>
<span class="nc" id="L60">    val TableSharing          = &quot;geomesa.table.sharing&quot;</span>
<span class="nc" id="L61">    val TableSplitterClass    = &quot;table.splitter.class&quot;</span>
<span class="nc" id="L62">    val TableSplitterOpts     = &quot;table.splitter.options&quot;</span>
<span class="nc" id="L63">    val TableCacheEnabled     = &quot;table.cache.enabled&quot;</span>
<span class="nc" id="L64">    val TableProps            = &quot;index.table.props&quot;</span>
<span class="nc" id="L65">    val TemporalPriority      = &quot;geomesa.temporal.priority&quot;</span>
<span class="nc" id="L66">    val UpdateBackupMetadata  = &quot;schema.update.backup.metadata&quot;</span>
<span class="nc" id="L67">    val UpdateRenameTables    = &quot;schema.update.rename.tables&quot;</span>

<span class="nc" id="L69">    val IndexZShards  = &quot;geomesa.z.splits&quot;</span>
<span class="nc" id="L70">    val IndexZ2Shards = &quot;geomesa.z2.splits&quot;</span>
<span class="nc" id="L71">    val IndexZ3Shards = &quot;geomesa.z3.splits&quot;</span>

    // keep around old values for back compatibility
    @deprecated(&quot;EnabledIndices&quot;)
<span class="nc" id="L75">    val ENABLED_INDEX_OPTS: Seq[String] = Seq(EnabledIndices, &quot;geomesa.indexes.enabled&quot;, &quot;table.indexes.enabled&quot;)</span>
  }

<span class="nc" id="L78">  private[geomesa] object InternalConfigs {</span>
<span class="nc" id="L79">    val GeomesaPrefix          = &quot;geomesa.&quot;</span>
<span class="nc" id="L80">    val TableSharingPrefix     = &quot;geomesa.table.sharing.prefix&quot;</span>
<span class="nc" id="L81">    val UserDataPrefix         = &quot;geomesa.user-data.prefix&quot;</span>
<span class="nc" id="L82">    val IndexVersions          = &quot;geomesa.indices&quot;</span>
<span class="nc" id="L83">    val PartitionSplitterClass = &quot;geomesa.splitter.class&quot;</span>
<span class="nc" id="L84">    val PartitionSplitterOpts  = &quot;geomesa.splitter.opts&quot;</span>
<span class="nc" id="L85">    val PartitionTablePrefix   = &quot;geomesa.table.prefix&quot;</span>
<span class="nc" id="L86">    val RemoteVersion          = &quot;gm.remote.version&quot; // note: doesn't start with geomesa so we don't persist it</span>
<span class="nc" id="L87">    val PartitionTableCache    = &quot;geomesa.table.cache&quot;</span>
<span class="nc" id="L88">    val PartitionTableProps    = &quot;geomesa.table.props&quot;</span>
<span class="nc" id="L89">    val KeywordsDelimiter      = &quot;\u0000&quot;</span>

    // configs that are not normally persisted, but that we want to persist for creating partitioned tables down the line
<span class="nc" id="L92">    val PartitionConfigMappings: Map[String, String] = Map(</span>
<span class="nc" id="L93">      Configs.TableCacheEnabled  -&gt; PartitionTableCache,</span>
<span class="nc" id="L94">      Configs.TableSplitterClass -&gt; PartitionSplitterClass,</span>
<span class="nc" id="L95">      Configs.TableSplitterOpts  -&gt; PartitionSplitterOpts,</span>
    )
<span class="nc" id="L97">    val PartitionConfigPrefixMappings: Map[String, String] = Map(</span>
<span class="nc" id="L98">      Configs.IndexTablePrefix -&gt; PartitionTablePrefix,</span>
<span class="nc" id="L99">      Configs.TableProps       -&gt; PartitionTableProps,</span>
    )

    // deprecated configs that we want to re-map for back-compatibility
<span class="nc" id="L103">    val DeprecatedConfigMappings: Map[String, String] = Map(</span>
<span class="nc" id="L104">      &quot;geomesa.indexes.enabled&quot; -&gt; Configs.EnabledIndices,</span>
<span class="nc" id="L105">      &quot;table.indexes.enabled&quot;   -&gt; Configs.EnabledIndices,</span>
    )
  }

<span class="nc" id="L109">  object AttributeOptions {</span>
<span class="nc" id="L110">    val OptCardinality  = &quot;cardinality&quot;</span>
<span class="nc" id="L111">    val OptColumnGroups = &quot;column-groups&quot;</span>
<span class="nc" id="L112">    val OptCqIndex      = &quot;cq-index&quot;</span>
<span class="nc" id="L113">    val OptDefault      = &quot;default&quot;</span>
<span class="nc" id="L114">    val OptIndex        = &quot;index&quot;</span>
<span class="nc" id="L115">    val OptIndexValue   = &quot;index-value&quot;</span>
<span class="nc" id="L116">    val OptJson         = &quot;json&quot;</span>
<span class="nc" id="L117">    val OptPrecision    = &quot;precision&quot;</span>
<span class="nc" id="L118">    val OptSrid         = &quot;srid&quot;</span>
<span class="nc" id="L119">    val OptStats        = &quot;keep-stats&quot;</span>
  }

<span class="nc" id="L122">  private[geomesa] object AttributeConfigs {</span>
<span class="nc" id="L123">    val UserDataListType     = &quot;subtype&quot;</span>
<span class="nc" id="L124">    val UserDataMapKeyType   = &quot;keyclass&quot;</span>
<span class="nc" id="L125">    val UserDataMapValueType = &quot;valueclass&quot;</span>
  }

<span class="nc" id="L128">  private val IndexChecks: Seq[SimpleFeatureType =&gt; Any] =</span>
<span class="nc" id="L129">    Seq(</span>
<span class="nc" id="L130">      _.getIndices,</span>
<span class="nc" id="L131">      _.getDtgField,</span>
<span class="nc" id="L132">      _.isUuidEncoded,</span>
<span class="nc" id="L133">      _.getAttributeShards,</span>
<span class="nc" id="L134">      _.getIdShards,</span>
<span class="nc" id="L135">      _.getZ3Shards,</span>
<span class="nc" id="L136">      _.getZ2Shards,</span>
<span class="nc" id="L137">      _.getVisibilityLevel,</span>
<span class="nc" id="L138">      _.getXZPrecision,</span>
<span class="nc" id="L139">      _.getZ3Interval,</span>
<span class="nc" id="L140">      _.getS3Interval,</span>
<span class="nc" id="L141">      _.getCompression,</span>
<span class="nc" id="L142">      _.isPartitioned,</span>
<span class="nc" id="L143">      _.getTableSharingPrefix,</span>
    )

<span class="nc" id="L146">  private val AttributeChecks: Seq[AttributeDescriptor =&gt; Any] =</span>
<span class="nc" id="L147">    Seq(</span>
<span class="nc" id="L148">      _.getUserData.get(AttributeOptions.OptIndexValue),</span>
<span class="nc" id="L149">      _.getUserData.get(AttributeOptions.OptJson),</span>
<span class="nc" id="L150">      _.getUserData.get(AttributeOptions.OptPrecision),</span>
<span class="nc" id="L151">      _.getUserData.get(AttributeOptions.OptColumnGroups),</span>
    )

<span class="nc" id="L154">  private val cache = new ConcurrentHashMap[(String, String), ImmutableSimpleFeatureType]()</span>

  /**
    * Create a simple feature type from a specification. Extends DataUtilities.createType with
    * GeoMesa-specific functionality like list/map attributes, indexing options, etc.
    *
    * @param typeName type name - may include namespace
    * @param spec specification
    * @return
    */
  def createType(typeName: String, spec: String): SimpleFeatureType = {
<span class="nc bnc" id="L165" title="All 2 branches missed.">    val (namespace, name) = parseTypeName(typeName)</span>
<span class="nc" id="L166">    createType(namespace, name, spec)</span>
  }

  /**
    * Create a simple feature type from a specification. Extends DataUtilities.createType with
    * GeoMesa-specific functionality like list/map attributes, indexing options, etc.
    *
    * @param namespace namespace
    * @param name name
    * @param spec specification
    * @return
    */
  def createType(namespace: String, name: String, spec: String): SimpleFeatureType = {
<span class="nc" id="L179">    val parsed = try { SimpleFeatureSpecParser.parse(spec) } catch {</span>
<span class="nc" id="L180">      case e: ParsingException =&gt; throw new IllegalArgumentException(e.getMessage, e)</span>
    }
<span class="nc" id="L182">    createFeatureType(namespace, name, parsed)</span>
  }

  /**
    * Create a simple feature type from a specification. Extends DataUtilities.createType with
    * GeoMesa-specific functionality like list/map attributes, indexing options, etc.
    *
    * This method can be more efficient that `createType`, as it will return a cached, immutable instance
    *
    * Note that immutable types will never be `equals` to a mutable type, due to specific class checking
    * in the geotools implementation
    *
    * @param typeName type name - may include namespace
    * @param spec specification
    * @return
    */
  def createImmutableType(typeName: String, spec: String): SimpleFeatureType = {
<span class="nc" id="L199">    var sft = cache.get((typeName, spec))</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">    if (sft == null) {</span>
<span class="nc" id="L201">      sft = immutable(createType(typeName, spec)).asInstanceOf[ImmutableSimpleFeatureType]</span>
<span class="nc" id="L202">      cache.put((typeName, spec), sft)</span>
    }
<span class="nc" id="L204">    sft</span>
  }

  /**
    * Create a simple feature type from a specification. Extends DataUtilities.createType with
    * GeoMesa-specific functionality like list/map attributes, indexing options, etc.
    *
    * This method can be more efficient that `createType`, as it will return a cached, immutable instance
    *
    * Note that immutable types will never be `equals` to a mutable type, due to specific class checking
    * in the geotools implementation
    *
    * @param namespace namespace
    * @param name name
    * @param spec specification
    * @return
    */
  def createImmutableType(namespace: String, name: String, spec: String): SimpleFeatureType =
<span class="nc bnc" id="L222" title="All 2 branches missed.">    createImmutableType(if (namespace == null) { name } else { s&quot;$namespace:$name&quot; }, spec)</span>

  /**
    * Parse a SimpleFeatureType spec from a typesafe Config
    *
    * @param conf config
    * @param typeName optional typename to use for the sft. will be overridden if the config contains a type-name key
    * @param path optional config path to parse. defaults to 'sft'
    * @return
    */
  def createType(conf: Config,
<span class="nc" id="L233">                 typeName: Option[String] = None,</span>
<span class="nc" id="L234">                 path: Option[String] = Some(&quot;sft&quot;)): SimpleFeatureType = {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">    val (nameFromConf, spec) = SimpleFeatureSpecConfig.parse(conf, path)</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">    val (namespace, name) = parseTypeName(nameFromConf.orElse(typeName).getOrElse {</span>
<span class="nc" id="L237">      throw new IllegalArgumentException(&quot;Unable to parse type name from provided argument or config&quot;)</span>
    })
<span class="nc" id="L239">    createFeatureType(namespace, name, spec)</span>
  }

  /**
    * Creates a type that can be renamed
    *
    * @param spec spec
    * @return
    */
  def createNameableType(spec: String): NameableSimpleFeatureType = {
<span class="nc" id="L249">    val parsed = try { SimpleFeatureSpecParser.parse(spec) } catch {</span>
<span class="nc" id="L250">      case e: ParsingException =&gt; throw new IllegalArgumentException(e.getMessage, e)</span>
    }
<span class="nc" id="L252">    createFeatureType(null, &quot;&quot;, parsed, Some(new NameableFeatureTypeFactory())).asInstanceOf[NameableSimpleFeatureType]</span>
  }

  /**
    * Create a single attribute descriptor
    *
    * @param spec attribute spec, e.g. 'foo:String'
    * @return
    */
  def createDescriptor(spec: String): AttributeDescriptor = {
<span class="nc" id="L262">    try { SimpleFeatureSpecParser.parseAttribute(spec).toDescriptor } catch {</span>
<span class="nc" id="L263">      case e: ParsingException =&gt; throw new IllegalArgumentException(e.getMessage, e)</span>
    }
  }

  /**
    * Encode a SimpleFeatureType as a comma-separated String
    *
    * @param sft - SimpleFeatureType to encode
    * @return a string representing a serialization of the sft
    */
  def encodeType(sft: SimpleFeatureType): String =
<span class="nc" id="L274">    sft.getAttributeDescriptors.asScala.map(encodeDescriptor(sft, _)).mkString(&quot;,&quot;)</span>

  /**
    * Encode a SimpleFeatureType as a comma-separated String
    *
    * @param sft - SimpleFeatureType to encode
    * @param includeUserData - defaults to false
    * @return a string representing a serialization of the sft
    */
  def encodeType(sft: SimpleFeatureType, includeUserData: Boolean): String =
<span class="nc bnc" id="L284" title="All 2 branches missed.">    if (includeUserData) { s&quot;${encodeType(sft)}${encodeUserData(sft)}&quot; } else { encodeType(sft) }</span>

  def encodeDescriptor(sft: SimpleFeatureType, descriptor: AttributeDescriptor): String =
<span class="nc" id="L287">    SimpleFeatureSpec.attribute(sft, descriptor).toSpec</span>

  def encodeUserData(sft: SimpleFeatureType): String = {
<span class="nc" id="L290">    val prefixes = sft.getUserDataPrefixes</span>
<span class="nc bnc" id="L291" title="All 4 branches missed.">    val toEncode = sft.getUserData.asScala.collect {</span>
<span class="nc bnc" id="L292" title="All 8 branches missed.">      case (k, v) if v != null &amp;&amp; prefixes.exists(k.toString.startsWith) =&gt; encodeUserData(k, v)</span>
    }
<span class="nc bnc" id="L294" title="All 2 branches missed.">    if (toEncode.isEmpty) { &quot;&quot; } else {</span>
<span class="nc" id="L295">      toEncode.toSeq.sorted.mkString(&quot;;&quot;, &quot;,&quot;, &quot;&quot;)</span>
    }
  }

  def encodeUserData(data: java.util.Map[_ &lt;: AnyRef, _ &lt;: AnyRef]): String = {
<span class="nc bnc" id="L300" title="All 2 branches missed.">    if (data.isEmpty) { &quot;&quot; } else {</span>
<span class="nc" id="L301">      val result = new StringBuilder(&quot;;&quot;)</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">      data.asScala.foreach { case (k, v) =&gt;</span>
<span class="nc" id="L303">        result.append(encodeUserData(k, v)).append(&quot;,&quot;)</span>
      }
<span class="nc" id="L305">      result.substring(0, result.length - 1)</span>
    }
  }

<span class="nc" id="L309">  def encodeUserData(key: AnyRef, value: AnyRef): String = s&quot;$key='${StringEscapeUtils.escapeJava(value.toString)}'&quot;</span>

<span class="nc" id="L311">  def toConfig(sft: SimpleFeatureType, includeUserData: Boolean = true, includePrefix: Boolean = true): Config =</span>
<span class="nc" id="L312">    SimpleFeatureSpecConfig.toConfig(sft, includeUserData, includePrefix)</span>

  def toConfigString(sft: SimpleFeatureType,
<span class="nc" id="L315">                     includeUserData: Boolean = true,</span>
<span class="nc" id="L316">                     concise: Boolean = false,</span>
<span class="nc" id="L317">                     includePrefix: Boolean = true,</span>
<span class="nc" id="L318">                     json: Boolean = false): String =</span>
<span class="nc" id="L319">    SimpleFeatureSpecConfig.toConfigString(sft, includeUserData, concise, includePrefix, json)</span>

  /**
    * Serializes a feature type to a single string
    *
    * @param sft feature type
    * @return
    */
  def serialize(sft: SimpleFeatureType): String =
<span class="nc" id="L328">    StringSerialization.encodeSeq(Seq(sft.getTypeName, encodeType(sft, includeUserData = true)))</span>

  /**
    * Deserializes a serialized feature type string
    *
    * @param sft serialized feature type
    * @return
    */
  def deserialize(sft: String): SimpleFeatureType = {
<span class="nc bnc" id="L337" title="All 6 branches missed.">    val Seq(name, spec) = StringSerialization.decodeSeq(sft)</span>
<span class="nc" id="L338">    SimpleFeatureTypes.createType(name, spec)</span>
  }

  /**
    * Creates an immutable copy of the simple feature type
    *
    * Note that immutable types will never be `equals` to a mutable type, due to specific class checking
    * in the geotools implementation
    *
    * Note that some parts of the feature type may still be mutable - in particular AttributeType,
    * GeometryType and SuperType are not used by geomesa so we don't bother with them. In addition,
    * user data keys and values may be mutable objects, so while the user data map will not change,
    * the values inside may
    *
    * @param sft simple feature type
    * @param extraData additional user data to add to the simple feature type
    * @return immutable copy of the simple feature type
    */
  def immutable(
      sft: SimpleFeatureType,
<span class="nc" id="L358">      extraData: java.util.Map[_ &lt;: AnyRef, _ &lt;: AnyRef] = null): SimpleFeatureType = {</span>
<span class="nc" id="L359">    sft match {</span>
<span class="nc bnc" id="L360" title="All 6 branches missed.">      case immutable: ImmutableSimpleFeatureType if extraData == null || extraData.isEmpty =&gt; immutable</span>
      case _ =&gt;
<span class="nc" id="L362">        val schema = new java.util.ArrayList[AttributeDescriptor](sft.getAttributeCount)</span>
<span class="nc" id="L363">        var geom: GeometryDescriptor = null</span>
<span class="nc" id="L364">        var i = 0</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        while (i &lt; sft.getAttributeCount) {</span>
<span class="nc" id="L366">          val descriptor = sft.getDescriptor(i)</span>
<span class="nc" id="L367">          val im = immutable(descriptor)</span>
<span class="nc bnc" id="L368" title="All 6 branches missed.">          if (descriptor == sft.getGeometryDescriptor) {</span>
<span class="nc" id="L369">            geom = im.asInstanceOf[GeometryDescriptor]</span>
          }
<span class="nc" id="L371">          schema.add(im)</span>
<span class="nc" id="L372">          i += 1</span>
        }
<span class="nc" id="L374">        val userData = Option(extraData).filterNot(_.isEmpty).map { data =&gt;</span>
<span class="nc" id="L375">          val map = new java.util.HashMap[AnyRef, AnyRef](data.size() + sft.getUserData.size)</span>
<span class="nc" id="L376">          map.putAll(sft.getUserData)</span>
<span class="nc" id="L377">          map.putAll(data)</span>
<span class="nc" id="L378">          map</span>
        }

<span class="nc" id="L381">        new ImmutableSimpleFeatureType(sft.getName, schema, geom, sft.isAbstract, sft.getRestrictions, sft.getSuper,</span>
<span class="nc" id="L382">          sft.getDescription, userData.getOrElse(sft.getUserData))</span>
    }
  }

  def immutable(descriptor: AttributeDescriptor): AttributeDescriptor = {
<span class="nc" id="L387">    descriptor match {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">      case d: ImmutableAttributeDescriptor =&gt; d</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">      case d: ImmutableGeometryDescriptor =&gt; d</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">      case d: GeometryDescriptor =&gt;</span>
<span class="nc" id="L391">        new ImmutableGeometryDescriptor(</span>
<span class="nc" id="L392">          d.getType, d.getName, d.getMinOccurs, d.getMaxOccurs, d.isNillable, d.getDefaultValue, d.getUserData)</span>
      case d =&gt;
<span class="nc" id="L394">        new ImmutableAttributeDescriptor(</span>
<span class="nc" id="L395">          d.getType, d.getName, d.getMinOccurs, d.getMaxOccurs, d.isNillable, d.getDefaultValue, d.getUserData)</span>
      case null =&gt; throw new NullPointerException(&quot;Descriptor is null&quot;)
    }
  }

  /**
    * Creates a mutable copy of a simple feature type. If the feature type is already mutable,
    * it is returned as is
    *
    * @param sft simple feature type
    * @return
    */
  def mutable(sft: SimpleFeatureType): SimpleFeatureType = {
<span class="nc bnc" id="L408" title="All 4 branches missed.">    if (sft.isInstanceOf[ImmutableSimpleFeatureType] || sft.getAttributeDescriptors.asScala.exists(isImmutable)) {</span>
<span class="nc" id="L409">      copy(sft)</span>
    } else {
<span class="nc" id="L411">      sft</span>
    }
  }

  /**
   * Copy a simple feature type, returning a mutable implementation
   *
   * @param sft simple feature type
   * @return
   */
  def copy(sft: SimpleFeatureType): SimpleFeatureType = {
    // note: SimpleFeatureTypeBuilder copies attribute user data but not feature user data
<span class="nc" id="L423">    val copy = SimpleFeatureTypeBuilder.copy(sft)</span>
<span class="nc" id="L424">    copy.getUserData.putAll(sft.getUserData)</span>
<span class="nc" id="L425">    copy</span>
  }

  private def isImmutable(d: AttributeDescriptor): Boolean =
<span class="nc bnc" id="L429" title="All 4 branches missed.">    d.isInstanceOf[ImmutableAttributeDescriptor] || d.isInstanceOf[ImmutableGeometryDescriptor]</span>

  /**
    * Renames a simple feature type. Preserves user data
    *
    * @param sft simple feature type
    * @param newName new name
    * @return
    */
  def renameSft(sft: SimpleFeatureType, newName: String): SimpleFeatureType = {
<span class="nc" id="L439">    val builder = new SimpleFeatureTypeBuilder()</span>
<span class="nc" id="L440">    builder.init(sft)</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">    newName.indexOf(':') match {</span>
<span class="nc" id="L442">      case -1 =&gt; builder.setName(newName)</span>
<span class="nc" id="L443">      case i  =&gt; builder.setNamespaceURI(newName.substring(0, i)); builder.setName(newName.substring(i + 1))</span>
    }
<span class="nc" id="L445">    val renamed = builder.buildFeatureType()</span>
<span class="nc" id="L446">    renamed.getUserData.putAll(sft.getUserData)</span>
<span class="nc" id="L447">    renamed</span>
  }

  /**
   * Rename an attribute descriptor
   *
   * @param descriptor descriptor
   * @param newName new name
   * @return
   */
  def renameDescriptor(descriptor: AttributeDescriptor, newName: String): AttributeDescriptor = {
<span class="nc" id="L458">    val builder = new AttributeTypeBuilder()</span>
<span class="nc" id="L459">    builder.init(descriptor)</span>
<span class="nc" id="L460">    builder.buildDescriptor(newName)</span>
  }

  /**
    * Compare two feature types. This method compares the the schemas of each feature type, i.e. the
    * names and type bindings of the attributes. The result will be:
    *
    * &lt;ul&gt;
    *   &lt;li&gt;a positive int if type A is a sub type or reorder of type B&lt;/li&gt;
    *   &lt;li&gt;zero if type A has the same schema as type B&lt;/li&gt;
    *   &lt;li&gt;a negative int if none of the above&lt;/li&gt;
    * &lt;/ul&gt;
    *
    * Note that this shouldn't be used for sorting.
    *
    * Note: GeoTools DataUtilities has a similar method that does not work correctly
    *
    * @param a schema A
    * @param b schema B
    * @return comparison
    */
  def compare(a: SimpleFeatureType, b: SimpleFeatureType): Int = {
<span class="nc bnc" id="L482" title="All 2 branches missed.">    if (a.getAttributeCount &gt; b.getAttributeCount) {</span>
<span class="nc" id="L483">      return -1 // not equals, subtype or reorder</span>
    }

<span class="nc bnc" id="L486" title="All 2 branches missed.">    var exact = a.getAttributeCount == b.getAttributeCount</span>

<span class="nc" id="L488">    var i = 0</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">    while (i &lt; a.getAttributeCount) {</span>
<span class="nc" id="L490">      val ad = a.getDescriptor(i)</span>
<span class="nc" id="L491">      val bd = b.getDescriptor(i)</span>
<span class="nc bnc" id="L492" title="All 6 branches missed.">      if (ad.getLocalName == bd.getLocalName) {</span>
<span class="nc bnc" id="L493" title="All 6 branches missed.">        if (ad.getType.getBinding != bd.getType.getBinding) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">          if (bd.getType.getBinding.isAssignableFrom(ad.getType.getBinding)) {</span>
<span class="nc" id="L495">            exact = false // we've seen a subtyping</span>
          } else {
<span class="nc" id="L497">            return -1 // not a subtype/reorder</span>
          }
        }
      } else {
<span class="nc" id="L501">        val reorder = b.getDescriptor(ad.getLocalName)</span>
<span class="nc bnc" id="L502" title="All 4 branches missed.">        if (reorder == null || !reorder.getType.getBinding.isAssignableFrom(ad.getType.getBinding)) {</span>
<span class="nc" id="L503">          return -1 // not a subtype/reorder</span>
        } else {
<span class="nc" id="L505">          exact = false // we've seen a reordering</span>
        }
      }
<span class="nc" id="L508">      i += 1</span>
    }

<span class="nc bnc" id="L511" title="All 2 branches missed.">    if (exact) { 0 } else {</span>
<span class="nc" id="L512">      1  // we haven't hit an absolute inequality, but we've found a reordering or subtype</span>
    }
  }

  /**
   * Compares that index tables are the same format (key and value) between the two feature types
   *
   * @param a first type
   * @param b second type
   * @return 0 if indices are the same, non-zero otherwise
   */
  def compareIndexConfigs(a: SimpleFeatureType, b: SimpleFeatureType): Int = {
    def compareAttributes(i: Int): Boolean = {
<span class="nc bnc" id="L525" title="All 2 branches missed.">      val (ad, bd) = (a.getDescriptor(i), b.getDescriptor(i))</span>
<span class="nc bnc" id="L526" title="All 10 branches missed.">      ad.getType.getBinding == bd.getType.getBinding &amp;&amp; AttributeChecks.forall(c =&gt; c(ad) == c(bd))</span>
    }
<span class="nc bnc" id="L528" title="All 2 branches missed.">    if (a.getAttributeCount == b.getAttributeCount &amp;&amp;</span>
<span class="nc bnc" id="L529" title="All 4 branches missed.">        IndexChecks.forall(c =&gt; c(a) == c(b)) &amp;&amp;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        Range(0, a.getAttributeCount).forall(compareAttributes)) {</span>
<span class="nc" id="L531">      0</span>
    } else {
<span class="nc" id="L533">      1</span>
    }
  }

  private def createFeatureType(namespace: String,
                                name: String,
                                spec: SimpleFeatureSpec,
<span class="nc" id="L540">                                factory: Option[FeatureTypeFactory] = None): SimpleFeatureType = {</span>
    import AttributeOptions.OptDefault

    val defaultGeom = {
<span class="nc bnc" id="L544" title="All 4 branches missed.">      val geomAttributes = spec.attributes.collect { case g: GeomAttributeSpec =&gt; g }</span>
<span class="nc" id="L545">      geomAttributes.find(_.options.get(OptDefault).exists(_.toBoolean))</span>
<span class="nc" id="L546">          .orElse(geomAttributes.headOption)</span>
<span class="nc" id="L547">          .map(_.name)</span>
    }
<span class="nc bnc" id="L549" title="All 2 branches missed.">    val defaultDate = if (spec.options.get(IndexIgnoreDtg).exists(toBoolean)) { None } else {</span>
<span class="nc" id="L550">      val dateAttributes = spec.attributes.filter(a =&gt; classOf[Date].isAssignableFrom(a.clazz))</span>
<span class="nc bnc" id="L551" title="All 6 branches missed.">      spec.options.get(DefaultDtgField).flatMap(dtg =&gt; dateAttributes.find(_.name == dtg))</span>
<span class="nc" id="L552">          .orElse(dateAttributes.find(_.options.get(OptDefault).exists(_.toBoolean)))</span>
<span class="nc" id="L553">          .orElse(dateAttributes.headOption)</span>
<span class="nc" id="L554">          .map(_.name)</span>
    }

<span class="nc" id="L557">    val b = factory.map(new SimpleFeatureTypeBuilder(_)).getOrElse(new SimpleFeatureTypeBuilder())</span>
<span class="nc" id="L558">    b.setNamespaceURI(namespace)</span>
<span class="nc" id="L559">    b.setName(name)</span>
<span class="nc" id="L560">    b.addAll(spec.attributes.map(_.toDescriptor).asJava)</span>
<span class="nc" id="L561">    defaultGeom.foreach(b.setDefaultGeometry)</span>

<span class="nc" id="L563">    val sft = b.buildFeatureType()</span>
<span class="nc" id="L564">    sft.getUserData.putAll(spec.options.asJava)</span>
<span class="nc" id="L565">    defaultDate.foreach(sft.setDtgField)</span>
<span class="nc" id="L566">    sft</span>
  }

  private def parseTypeName(name: String): (String, String) = {
<span class="nc" id="L570">    val nsIndex = name.lastIndexOf(':')</span>
<span class="nc bnc" id="L571" title="All 6 branches missed.">    val (namespace, local) = if (nsIndex == -1 || nsIndex == name.length - 1) {</span>
<span class="nc" id="L572">      (null, name)</span>
    } else {
<span class="nc" id="L574">      (name.substring(0, nsIndex), name.substring(nsIndex + 1))</span>
    }
<span class="nc" id="L576">    (namespace, local)</span>
  }

<span class="nc" id="L579">  private [utils] def toBoolean(value: AnyRef): Boolean = value match {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">    case null =&gt; false</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">    case bool: java.lang.Boolean =&gt; bool.booleanValue</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">    case bool: String =&gt; java.lang.Boolean.valueOf(bool).booleanValue</span>
<span class="nc" id="L583">    case bool =&gt; java.lang.Boolean.valueOf(bool.toString).booleanValue</span>
  }
<span class="nc" id="L585">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>