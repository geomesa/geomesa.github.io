<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Transform.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools</a> &gt; <span class="el_source">Transform.scala</span></div><h1>Transform.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools

import org.geotools.api.feature.`type`.{AttributeDescriptor, GeometryDescriptor}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.expression.{Expression, Function, PropertyName}
import org.geotools.feature.{AttributeTypeBuilder, NameImpl}
import org.geotools.filter.MathExpressionImpl
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.utils.geotools.sft.{ImmutableAttributeDescriptor, ImmutableGeometryDescriptor, ImmutableSimpleFeatureType}
import org.locationtech.jts.geom.Geometry

import java.util.Collections
import scala.util.control.NonFatal

/**
 * An attribute transformation or projection
 */
sealed trait Transform {

  /**
   * The name of the attribute
   *
   * @return
   */
  def name: String

  /**
   * The type of the attribute
   *
   * @return
   */
  def binding: Class[_]

  /**
   * Evaluate the transform against a full feature
   *
   * @param feature simple feature, of the original, untransformed feature type
   * @return
   */
  def evaluate(feature: SimpleFeature): AnyRef
}

/**
  * Convenience methods for working with relational query projections (aka transforms)
  */
<span class="nc" id="L54">object Transform {</span>

<span class="nc" id="L56">  val DefinitionDelimiter = &quot;;&quot;</span>

  /**
   * A simple relational projection (selection)
   *
   * @param name name
   * @param binding binding
   * @param i index of the original attribute being projected
   */
<span class="nc bnc" id="L65" title="All 28 branches missed.">  case class PropertyTransform(name: String, binding: Class[_], i: Int) extends Transform {</span>
<span class="nc" id="L66">    override def evaluate(feature: SimpleFeature): AnyRef = feature.getAttribute(i)</span>
  }

  /**
   * A simple relational projection, but also renamed
   *
   * @param name name
   * @param binding binding
   * @param original name of the original attribute being projected
   * @param i index of the original attribute being projected
   */
<span class="nc bnc" id="L77" title="All 35 branches missed.">  case class RenameTransform(name: String, binding: Class[_], original: String, i: Int) extends Transform {</span>
<span class="nc" id="L78">    override def evaluate(feature: SimpleFeature): AnyRef = feature.getAttribute(i)</span>
  }

  /**
   * An attribute comprised of an expression (function, math transform, json-path, etc)
   *
   * @param name name
   * @param binding binding
   * @param expression expression
   */
<span class="nc bnc" id="L88" title="All 32 branches missed.">  case class ExpressionTransform(name: String, binding: Class[_], expression: Expression) extends Transform {</span>
<span class="nc" id="L89">    override def evaluate(feature: SimpleFeature): AnyRef = expression.evaluate(feature)</span>
  }

<span class="nc" id="L92">  object Transforms {</span>

    /**
     * Create transform definitions for a delimited expression string
     *
     * @param sft original simple feature type
     * @param transforms semi-colon delimited transform expressions
     * @return
     */
    def apply(sft: SimpleFeatureType, transforms: String): Seq[Transform] =
<span class="nc bnc" id="L102" title="All 2 branches missed.">      if (transforms.isEmpty) { Seq.empty } else { apply(sft, transforms.split(DefinitionDelimiter)) }</span>

    /**
     * Create transform definitions for a sequence of expression strings
     *
     * @param sft original simple feature type
     * @param transforms transform expressions
     * @return
     */
    def apply(sft: SimpleFeatureType, transforms: Seq[String]): Seq[Transform] =
<span class="nc" id="L112">      transforms.map(definition(sft, _))</span>

    /**
     * Create a transform definition from an expression
     *
     * @param sft simple feature type
     * @param transform transform expression
     * @return
     */
    private def definition(sft: SimpleFeatureType, transform: String): Transform = {
<span class="nc" id="L122">      val equals = transform.indexOf('=')</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">      if (equals == -1) {</span>
<span class="nc" id="L124">        val name = transform.trim()</span>
<span class="nc" id="L125">        val i = sft.indexOf(name)</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (i == -1) {</span>
<span class="nc" id="L127">          attributeExpression(sft, name, name)</span>
        } else {
<span class="nc" id="L129">          PropertyTransform(name, sft.getDescriptor(i).getType.getBinding, i)</span>
        }
      } else {
<span class="nc" id="L132">        val name = transform.substring(0, equals).trim()</span>
<span class="nc" id="L133">        val exp = transform.substring(equals + 1).trim()</span>
<span class="nc" id="L134">        val expression = try { ECQL.toExpression(exp) } catch {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">          case NonFatal(e) =&gt; throw new IllegalArgumentException(s&quot;Unable to parse expression $transform:&quot;, e)</span>
        }
<span class="nc" id="L137">        expression match {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">          case f: Function =&gt;</span>
<span class="nc" id="L139">            ExpressionTransform(name, f.getFunctionName.getReturn.getType, f)</span>

<span class="nc bnc" id="L141" title="All 2 branches missed.">          case f: MathExpressionImpl =&gt;</span>
<span class="nc" id="L142">            ExpressionTransform(name, classOf[java.lang.Double], f) // math ops always return doubles?</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">          case p: PropertyName =&gt;</span>
<span class="nc" id="L145">            val orig = p.getPropertyName</span>
<span class="nc" id="L146">            val i = sft.indexOf(orig)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (i == -1) {</span>
<span class="nc" id="L148">              attributeExpression(sft, name, p)</span>
<span class="nc bnc" id="L149" title="All 6 branches missed.">            } else if (name == orig) {</span>
<span class="nc" id="L150">              PropertyTransform(name, sft.getDescriptor(i).getType.getBinding, i)</span>
            } else {
<span class="nc" id="L152">              RenameTransform(name, sft.getDescriptor(i).getType.getBinding, orig, i)</span>
            }

          // TODO: Add support for LiteralExpressionImpl and/or ClassificationFunction?
          case _ =&gt;
<span class="nc" id="L157">            throw new IllegalArgumentException(s&quot;Unable to handle transform expression: $expression&quot;)</span>
        }
      }
    }

    /**
     * This handles custom attribute accessors (e.g. json-path) and transforms that don't correspond
     * to any attribute (e.g. in AttributeKeyPlusValueIterator)
     *
     * @param sft simple feature type
     * @param name transform name
     * @param e expression
     * @return
     */
    private def attributeExpression(sft: SimpleFeatureType, name: String, e: String): ExpressionTransform = {
<span class="nc" id="L172">      val expression = try { ECQL.toExpression(e) } catch {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new IllegalArgumentException(s&quot;Unable to parse expression '$e':&quot;, e)</span>
      }
<span class="nc" id="L175">      attributeExpression(sft, name, expression)</span>
    }

    /**
     * This handles custom attribute accessors (e.g. json-path) and transforms that don't correspond
     * to any attribute (e.g. in AttributeKeyPlusValueIterator)
     *
     * @param sft simple feature type
     * @param name transform name
     * @param expression expression
     * @return
     */
    private def attributeExpression(
        sft: SimpleFeatureType,
        name: String,
        expression: Expression): ExpressionTransform = {
<span class="nc" id="L191">      val descriptor = expression.evaluate(sft).asInstanceOf[AttributeDescriptor]</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">      val binding = if (descriptor == null) { classOf[String] } else { descriptor.getType.getBinding }</span>
<span class="nc" id="L193">      ExpressionTransform(name, binding, expression)</span>
    }

    /**
     * Create the feature type corresponding a transform
     *
     * @param sft original simple feature type
     * @param transforms transforms
     * @return
     */
    def schema(sft: SimpleFeatureType, transforms: Seq[Transform]): SimpleFeatureType = {
<span class="nc" id="L204">      val schema = new java.util.ArrayList[AttributeDescriptor]()</span>
<span class="nc" id="L205">      var geom: GeometryDescriptor = null</span>

<span class="nc bnc" id="L207" title="All 2 branches missed.">      lazy val typeBuilder = new AttributeTypeBuilder()</span>

<span class="nc" id="L209">      transforms.foreach { t =&gt;</span>
<span class="nc" id="L210">        val descriptor = t match {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">          case t: PropertyTransform =&gt;</span>
<span class="nc" id="L212">            val d = sft.getDescriptor(t.i)</span>
<span class="nc" id="L213">            val im = SimpleFeatureTypes.immutable(d)</span>
<span class="nc bnc" id="L214" title="All 6 branches missed.">            if (d == sft.getGeometryDescriptor) {</span>
<span class="nc" id="L215">              geom = im.asInstanceOf[GeometryDescriptor]</span>
            }
<span class="nc" id="L217">            im</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">          case t: RenameTransform =&gt;</span>
<span class="nc" id="L220">            sft.getDescriptor(t.i) match {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">              case d: GeometryDescriptor =&gt;</span>
<span class="nc" id="L222">                val im = new ImmutableGeometryDescriptor(d.getType, new NameImpl(t.name), d.getMinOccurs,</span>
<span class="nc" id="L223">                  d.getMaxOccurs, d.isNillable, d.getDefaultValue, d.getUserData)</span>
<span class="nc bnc" id="L224" title="All 6 branches missed.">                if (d == sft.getGeometryDescriptor) {</span>
<span class="nc" id="L225">                  geom = im</span>
                }
<span class="nc" id="L227">                im</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">              case d: AttributeDescriptor =&gt;</span>
<span class="nc" id="L229">                new ImmutableAttributeDescriptor(d.getType, new NameImpl(t.name), d.getMinOccurs, d.getMaxOccurs,</span>
<span class="nc" id="L230">                  d.isNillable, d.getDefaultValue, d.getUserData)</span>
            }

<span class="nc bnc" id="L233" title="All 2 branches missed.">          case t: ExpressionTransform =&gt;</span>
<span class="nc" id="L234">            typeBuilder.setBinding(t.binding)</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (classOf[Geometry].isAssignableFrom(t.binding)) {</span>
<span class="nc" id="L236">              typeBuilder.crs(CRS_EPSG_4326)</span>
<span class="nc" id="L237">              val typ = typeBuilder.buildGeometryType()</span>
<span class="nc" id="L238">              new ImmutableGeometryDescriptor(typ, new NameImpl(t.name), 0, 1, true, null, Collections.emptyMap())</span>
            } else {
<span class="nc" id="L240">              val typ = typeBuilder.buildType()</span>
<span class="nc" id="L241">              new ImmutableAttributeDescriptor(typ, new NameImpl(t.name), 0, 1, true, null, Collections.emptyMap())</span>
            }
        }

<span class="nc" id="L245">        schema.add(descriptor)</span>
      }

<span class="nc" id="L248">      var i = 0</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">      while (geom == null &amp;&amp; i &lt; schema.size) {</span>
<span class="nc" id="L250">        schema.get(i) match {</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">          case d: ImmutableGeometryDescriptor =&gt; geom = d</span>
<span class="nc" id="L252">          case _ =&gt; // no-op</span>
        }
<span class="nc" id="L254">        i += 1</span>
      }

      // TODO reconsider default field user data?
<span class="nc" id="L258">      new ImmutableSimpleFeatureType(sft.getName, schema, geom, sft.isAbstract, sft.getRestrictions, sft.getSuper,</span>
<span class="nc" id="L259">        sft.getDescription, sft.getUserData)</span>
    }
  }
<span class="nc" id="L262">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>