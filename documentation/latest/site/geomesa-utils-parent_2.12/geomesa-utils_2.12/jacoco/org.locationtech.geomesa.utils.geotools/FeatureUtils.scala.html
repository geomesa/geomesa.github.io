<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FeatureUtils.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools</a> &gt; <span class="el_source">FeatureUtils.scala</span></div><h1>FeatureUtils.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools

import org.geotools.api.data.FeatureWriter
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.data.DataUtilities
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.geotools.filter.identity.FeatureIdImpl
import org.geotools.util.factory.Hints

import java.lang.{Boolean =&gt; jBoolean}
import java.util.Locale
import scala.collection.JavaConverters._
import scala.collection.immutable.HashSet

/** Utilities for re-typing and re-building [[SimpleFeatureType]]s and [[SimpleFeature]]s while
  * preserving user data which the standard Geo Tools utilities do not do.
  */
<span class="nc" id="L26">object FeatureUtils {</span>

  // sourced from the following:
  //   https://github.com/geotools/geotools/blob/master/modules/library/cql/src/main/jjtree/ECQLGrammar.jjt
  //   https://docs.geotools.org/latest/userguide/library/cql/internal.html
<span class="nc" id="L31">  val ReservedWords: Set[String] = HashSet(</span>
<span class="nc" id="L32">    &quot;AFTER&quot;,</span>
<span class="nc" id="L33">    &quot;AND&quot;,</span>
<span class="nc" id="L34">    &quot;BEFORE&quot;,</span>
<span class="nc" id="L35">    &quot;BEYOND&quot;,</span>
<span class="nc" id="L36">    &quot;CONTAINS&quot;,</span>
<span class="nc" id="L37">    &quot;CROSSES&quot;,</span>
<span class="nc" id="L38">    &quot;DISJOINT&quot;,</span>
<span class="nc" id="L39">    &quot;DOES-NOT-EXIST&quot;,</span>
<span class="nc" id="L40">    &quot;DURING&quot;,</span>
<span class="nc" id="L41">    &quot;DWITHIN&quot;,</span>
<span class="nc" id="L42">    &quot;EQUALS&quot;,</span>
<span class="nc" id="L43">    &quot;EXCLUDE&quot;,</span>
<span class="nc" id="L44">    &quot;EXISTS&quot;,</span>
<span class="nc" id="L45">    &quot;FALSE&quot;,</span>
<span class="nc" id="L46">    &quot;GEOMETRYCOLLECTION&quot;,</span>
<span class="nc" id="L47">    &quot;ID&quot;,</span>
<span class="nc" id="L48">    &quot;INCLUDE&quot;,</span>
<span class="nc" id="L49">    &quot;INTERSECTS&quot;,</span>
<span class="nc" id="L50">    &quot;IS&quot;,</span>
<span class="nc" id="L51">    &quot;LIKE&quot;,</span>
<span class="nc" id="L52">    &quot;LINESTRING&quot;,</span>
<span class="nc" id="L53">    &quot;MULTILINESTRING&quot;,</span>
<span class="nc" id="L54">    &quot;MULTIPOINT&quot;,</span>
<span class="nc" id="L55">    &quot;MULTIPOLYGON&quot;,</span>
<span class="nc" id="L56">    &quot;NOT&quot;,</span>
<span class="nc" id="L57">    &quot;NULL&quot;,</span>
<span class="nc" id="L58">    &quot;OR&quot;,</span>
<span class="nc" id="L59">    &quot;OVERLAPS&quot;,</span>
<span class="nc" id="L60">    &quot;POINT&quot;,</span>
<span class="nc" id="L61">    &quot;POLYGON&quot;,</span>
<span class="nc" id="L62">    &quot;RELATE&quot;,</span>
<span class="nc" id="L63">    &quot;TOUCHES&quot;,</span>
<span class="nc" id="L64">    &quot;TRUE&quot;,</span>
<span class="nc" id="L65">    &quot;WITHIN&quot;</span>
  )

  /** Retypes a [[SimpleFeatureType]], preserving the user data.
   *
   * @param orig the original
   * @param propertyNames the property names for the new type
   * @return the new [[SimpleFeatureType]]
   */
  def retype(orig: SimpleFeatureType, propertyNames: Array[String]): SimpleFeatureType = {
<span class="nc" id="L75">    val mod = SimpleFeatureTypeBuilder.retype(orig, propertyNames: _*)</span>
<span class="nc" id="L76">    mod.getUserData.putAll(orig.getUserData)</span>
<span class="nc" id="L77">    mod</span>
  }

  /** Retypes a [[SimpleFeature]], preserving the user data.
    *
    * @param orig the source feature
    * @param targetType the target type
    * @return the new [[SimpleFeature]]
    */
  def retype(orig: SimpleFeature, targetType: SimpleFeatureType): SimpleFeature = {
<span class="nc" id="L87">    val mod = DataUtilities.reType(targetType, orig, false)</span>
<span class="nc" id="L88">    mod.getUserData.putAll(orig.getUserData)</span>
<span class="nc" id="L89">    mod</span>
  }

  /** A new [[SimpleFeatureType]] builder initialized with ``orig`` which, when ``buildFeatureType`` is
    * called will, as a last step, add all user data from ``orig`` to the newly built [[SimpleFeatureType]].
    *
    * @param orig the source feature
    * @return a new [[SimpleFeatureTypeBuilder]]
    */
<span class="nc" id="L98">  def builder(orig: SimpleFeatureType): SimpleFeatureTypeBuilder = {</span>
<span class="nc" id="L99">    val builder = new SimpleFeatureTypeBuilder() {</span>

      override def buildFeatureType(): SimpleFeatureType = {
<span class="nc" id="L102">        val result = super.buildFeatureType()</span>
<span class="nc" id="L103">        result.getUserData.putAll(orig.getUserData)</span>
<span class="nc" id="L104">        result</span>
      }
    }

<span class="nc" id="L108">    builder.init(orig)</span>
<span class="nc" id="L109">    builder</span>
  }

  /**
   * Copy a feature to the feature returned by a feature writer
   *
   * @param toWrite feature writer feature
   * @param sf feature containing the data we want to write
   * @param useProvidedFid use the feature id from the feature, or generate a new one
   * @return
   */
<span class="nc" id="L120">  def copyToFeature(toWrite: SimpleFeature, sf: SimpleFeature, useProvidedFid: Boolean = false): SimpleFeature = {</span>
<span class="nc" id="L121">    var i = 0</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">    while (i &lt; sf.getAttributeCount) {</span>
<span class="nc" id="L123">      toWrite.setAttribute(i, sf.getAttribute(i))</span>
<span class="nc" id="L124">      i += 1</span>
    }
<span class="nc" id="L126">    toWrite.getUserData.putAll(sf.getUserData)</span>
<span class="nc bnc" id="L127" title="All 8 branches missed.">    if (useProvidedFid || jBoolean.TRUE == sf.getUserData.get(Hints.USE_PROVIDED_FID).asInstanceOf[jBoolean]) {</span>
<span class="nc" id="L128">      toWrite.getIdentifier match {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        case id: FeatureIdImpl =&gt; id.setID(sf.getID)</span>
<span class="nc" id="L130">        case _ =&gt; toWrite.getUserData.put(Hints.PROVIDED_FID, sf.getID)</span>
      }
<span class="nc" id="L132">      toWrite.getUserData.put(Hints.USE_PROVIDED_FID, java.lang.Boolean.TRUE)</span>
    }
<span class="nc" id="L134">    toWrite</span>
  }

  /**
    * Write a feature to a feature writer
    *
    * @param writer feature writer
    * @param sf feature to write
    * @param useProvidedFid use provided fid
    */
  def write(
      writer: FeatureWriter[SimpleFeatureType, SimpleFeature],
      sf: SimpleFeature,
<span class="nc" id="L147">      useProvidedFid: Boolean = false): SimpleFeature = {</span>
<span class="nc" id="L148">    val written = writer.next()</span>
<span class="nc" id="L149">    copyToFeature(written, sf, useProvidedFid)</span>
<span class="nc" id="L150">    writer.write()</span>
<span class="nc" id="L151">    written</span>
  }

  /**
    *
    * @param sft simple feature type
    * @return
    */
  def sftReservedWords(sft: SimpleFeatureType): Seq[String] =
<span class="nc" id="L160">    sft.getDescriptors.asScala.map(_.getName.getLocalPart.toUpperCase(Locale.US)).filter(ReservedWords.contains).toList</span>
<span class="nc" id="L161">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>