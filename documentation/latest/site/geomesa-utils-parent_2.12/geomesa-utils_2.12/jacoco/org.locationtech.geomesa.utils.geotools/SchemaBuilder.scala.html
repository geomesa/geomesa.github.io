<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SchemaBuilder.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools</a> &gt; <span class="el_source">SchemaBuilder.scala</span></div><h1>SchemaBuilder.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools

import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.utils.geotools.SchemaBuilder.{AbstractSchemaBuilder, AttributeBuilder, UserDataBuilder}
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec.{ListAttributeSpec, MapAttributeSpec}
import org.locationtech.geomesa.utils.index.Cardinality.Cardinality

import scala.reflect.{ClassTag, classTag}

/**
  * Builder class for creating simple feature types
  *
  * Adding an attribute returns an AttributeBuilder class with additional options for that attribute.
  * There is an implicit conversion back to SchemaBuilder to allow for operation chaining.
  *
  * Example usage:
  *
  *   SchemaBuilder.builder().addString(&quot;foo&quot;).withIndex().addInt(&quot;bar&quot;).build(&quot;baz&quot;)
  *
  */
<span class="nc" id="L32">class SchemaBuilder extends AbstractSchemaBuilder[AttributeBuilder, UserDataBuilder] {</span>
  override protected def createAttributeBuilder(spec: StringBuilder): AttributeBuilder =
<span class="nc" id="L34">    new AttributeBuilder(this, spec)</span>
  override protected def createUserDataBuilder(userData: StringBuilder): UserDataBuilder =
<span class="nc" id="L36">    new UserDataBuilder(this, userData)</span>
}

<span class="nc" id="L39">object SchemaBuilder {</span>

<span class="nc" id="L41">  def builder(): SchemaBuilder = new SchemaBuilder</span>

  /**
    * Implicit function to return from an attribute builder to a schema builder for chaining calls
    *
    * @param b attribute builder
    * @return schema builder
    */
  // noinspection LanguageFeature
<span class="nc" id="L50">  implicit def toSchemaBuilder(b: AttributeBuilder): SchemaBuilder = b.end()</span>

  /**
    * Implicit function to return from a user data builder to a schema builder for chaining calls
    *
    * @param b user data builder
    * @return schema builder
    */
  // noinspection LanguageFeature
<span class="nc" id="L59">  implicit def toSchemaBuilder(b: UserDataBuilder): SchemaBuilder = b.end()</span>

<span class="nc" id="L61">  class AttributeBuilder(parent: SchemaBuilder, spec: StringBuilder) extends</span>
<span class="nc" id="L62">      AbstractAttributeBuilder[AttributeBuilder](parent, spec)</span>

<span class="nc" id="L64">  class UserDataBuilder(parent: SchemaBuilder, spec: StringBuilder) extends</span>
<span class="nc" id="L65">      AbstractUserDataBuilder[UserDataBuilder](parent, spec)</span>

  /**
    * Base parameterized schema builder trait to allow subclassing with correct return type chaining
    */
<span class="nc" id="L70">  trait AbstractSchemaBuilder[A &lt;: AbstractAttributeBuilder[A], U &lt;: AbstractUserDataBuilder[U]] {</span>

<span class="nc" id="L72">    private val specString = new StringBuilder()</span>
<span class="nc" id="L73">    private val userDataString = new StringBuilder(&quot;;&quot;)</span>

<span class="nc" id="L75">    private val attributeBuilder = createAttributeBuilder(specString)</span>
<span class="nc" id="L76">    private val userDataBuilder = createUserDataBuilder(userDataString)</span>

    /**
      * Add a string-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L84">    def addString(name: String): A = add(s&quot;$name:String&quot;)</span>

    /**
      * Add an integer-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L92">    def addInt(name: String): A = add(s&quot;$name:Int&quot;)</span>

    /**
      * Add a long-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L100">    def addLong(name: String): A = add(s&quot;$name:Long&quot;)</span>

    /**
      * Add a float-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L108">    def addFloat(name: String): A = add(s&quot;$name:Float&quot;)</span>

    /**
      * Add a double-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L116">    def addDouble(name: String): A = add(s&quot;$name:Double&quot;)</span>

    /**
      * Add a boolean-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L124">    def addBoolean(name: String): A = add(s&quot;$name:Boolean&quot;)</span>

    /**
      * Add a UUID-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L132">    def addUuid(name: String): A = add(s&quot;$name:UUID&quot;)</span>

    /**
      * Add a binary-type (byte array) attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L140">    def addBytes(name: String): A = add(s&quot;$name:Bytes&quot;)</span>

    /**
      * Add a json-formatted string-type attribute
      *
      * @param name name of the attribute to add
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L148">    def addJson(name: String): A = add(s&quot;$name:String:json=true&quot;)</span>

    /**
      * Add a date-type attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default (primary) date field, which will be automatically indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L157">    def addDate(name: String, default: Boolean = false): A = {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      if (default) {</span>
<span class="nc" id="L159">        userData(SimpleFeatureTypes.Configs.DefaultDtgField, name)</span>
      }
<span class="nc" id="L161">      add(s&quot;$name:Date&quot;)</span>
    }

    /**
      * Add a list-type attribute
      *
      * @param name name of the attribute to add
      * @tparam V value type for the list - this must be one of the normal supported types (string, int, etc)
      * @return attribute builder forchaining additional options
      */
    def addList[V: ClassTag](name: String): A =
<span class="nc" id="L172">      add(s&quot;$name:${ListAttributeSpec(&quot;&quot;, classy[V], Map.empty).getClassSpec}&quot;)</span>

    /**
      * Add a map-type attribute
      *
      * @param name name of the attribute to add
      * @tparam K key type of the map - this must be one of the normal supported types (string, int, etc)
      * @tparam V value type of the map - this must be one of the normal supported types (string, int, etc)
      * @return attribute builder forchaining additional options
      */
    def addMap[K: ClassTag, V: ClassTag](name: String): A =
<span class="nc" id="L183">      add(s&quot;$name:${MapAttributeSpec(&quot;&quot;, classy[K], classy[V], Map.empty).getClassSpec}&quot;)</span>

    /**
      * Add a point-type geometry attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L192">    def addPoint(name: String, default: Boolean = false): A =</span>
<span class="nc" id="L193">      add(geom(name, &quot;Point&quot;, default))</span>

    /**
      * Add a linestring-type geometry attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L202">    def addLineString(name: String, default: Boolean = false): A =</span>
<span class="nc" id="L203">      add(geom(name, &quot;LineString&quot;, default))</span>

    /**
      * Add a polygon-type geometry attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L212">    def addPolygon(name: String, default: Boolean = false): A =</span>
<span class="nc" id="L213">      add(geom(name, &quot;Polygon&quot;, default))</span>

    /**
      * Add a multi-point-type geometry attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L222">    def addMultiPoint(name: String, default: Boolean = false): A =</span>
<span class="nc" id="L223">      add(geom(name, &quot;MultiPoint&quot;, default))</span>

    /**
      * Add a multi-linestring-type geometry attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L232">    def addMultiLineString(name: String, default: Boolean = false): A =</span>
<span class="nc" id="L233">      add(geom(name, &quot;MultiLineString&quot;, default))</span>

    /**
      * Add a multi-polygon-type geometry attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L242">    def addMultiPolygon(name: String, default: Boolean = false): A =</span>
<span class="nc" id="L243">      add(geom(name, &quot;MultiPolygon&quot;, default))</span>

    /**
      * Add a geometry-collection-type geometry attribute
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L252">    def addGeometryCollection(name: String, default: Boolean = false): A =</span>
<span class="nc" id="L253">      add(geom(name, &quot;GeometryCollection&quot;, default))</span>

    /**
      * Add a mixed-geometry-type geometry attribute. This should be used if you want multiple types of geometries
      * in the same attribute - otherwise prefer one of the explicit geometry types
      *
      * @param name name of the attribute to add
      * @param default if this is the default geometry, which will automatically be indexed
      * @return attribute builder forchaining additional options
      */
<span class="nc" id="L263">    def addMixedGeometry(name: String, default: Boolean = false): A = {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">      if (default) {</span>
<span class="nc" id="L265">        userData(SimpleFeatureTypes.Configs.MixedGeometries, &quot;true&quot;)</span>
      }
<span class="nc" id="L267">      add(geom(name, &quot;Geometry&quot;, default))</span>
    }

    /**
      * Add an attribute based on an attribute descriptor
      *
      * @param ad attribute descriptor
      * @return schema builder for chaining additional calls
      */
<span class="nc" id="L276">    def addAttribute(ad: AttributeDescriptor): A = add(SimpleFeatureSpec.attribute(null, ad).toSpec)</span>

    /**
      * Add feature-level user data
      *
      * @param key user data key
      * @param value user data value
      * @return schema builder for chaining additional calls
      */
<span class="nc" id="L285">    def userData(key: String, value: String): U = userDataBuilder.userData(key, value)</span>

    /**
      * Get a user data builder for additional user data operations
      *
      * @return user data builder for chaining additional calls
      */
<span class="nc" id="L292">    def userData: U = userDataBuilder</span>

    /**
      * Get the current simple feature type specification string
      *
      * @return spec
      */
<span class="nc" id="L299">    def spec: String = specString.toString + userDataString.substring(0, userDataString.length - 1)</span>

    /**
      * Create a new simple feature type using the current attributes
      *
      * @param name simple feature type name
      * @return simple feature type
      */
<span class="nc" id="L307">    def build(name: String): SimpleFeatureType = SimpleFeatureTypes.createType(name, spec)</span>

    /**
      * Create a new simple feature type using the current attributes
      *
      * @param namespace simple feature type namespace
      * @param name simple feature type name
      * @return simple feature type
      */
    def build(namespace: String, name: String): SimpleFeatureType =
<span class="nc" id="L317">      SimpleFeatureTypes.createType(namespace, name, spec)</span>

    protected def add(spec: String): A = {
<span class="nc bnc" id="L320" title="All 2 branches missed.">      if (specString.nonEmpty) {</span>
<span class="nc" id="L321">        specString.append(&quot;,&quot;)</span>
      }
<span class="nc" id="L323">      specString.append(spec)</span>
<span class="nc" id="L324">      attributeBuilder</span>
    }

    protected def createAttributeBuilder(spec: StringBuilder): A
    protected def createUserDataBuilder(userData: StringBuilder): U

    private def classy[T: ClassTag]: Class[_] = {
<span class="nc" id="L331">      classTag[T].runtimeClass match {</span>
<span class="nc bnc" id="L332" title="All 6 branches missed.">        case java.lang.Byte.TYPE      =&gt; classOf[java.lang.Byte]</span>
<span class="nc bnc" id="L333" title="All 6 branches missed.">        case java.lang.Short.TYPE     =&gt; classOf[java.lang.Short]</span>
<span class="nc bnc" id="L334" title="All 6 branches missed.">        case java.lang.Character.TYPE =&gt; classOf[java.lang.Character]</span>
<span class="nc bnc" id="L335" title="All 6 branches missed.">        case java.lang.Integer.TYPE   =&gt; classOf[java.lang.Integer]</span>
<span class="nc bnc" id="L336" title="All 6 branches missed.">        case java.lang.Long.TYPE      =&gt; classOf[java.lang.Long]</span>
<span class="nc bnc" id="L337" title="All 6 branches missed.">        case java.lang.Float.TYPE     =&gt; classOf[java.lang.Float]</span>
<span class="nc bnc" id="L338" title="All 6 branches missed.">        case java.lang.Double.TYPE    =&gt; classOf[java.lang.Double]</span>
<span class="nc bnc" id="L339" title="All 6 branches missed.">        case java.lang.Boolean.TYPE   =&gt; classOf[java.lang.Boolean]</span>
<span class="nc bnc" id="L340" title="All 6 branches missed.">        case java.lang.Void.TYPE      =&gt; classOf[java.lang.Void]</span>
<span class="nc" id="L341">        case c                        =&gt; c</span>
      }
    }

    private def geom(name: String, binding: String, default: Boolean): String =
<span class="nc bnc" id="L346" title="All 2 branches missed.">      if (default) { s&quot;*$name:$binding:srid=4326&quot; } else { s&quot;$name:$binding:srid=4326&quot; }</span>
  }

  /**
    * Builder class for configuring per-attribute options
    */
<span class="nc" id="L352">  class AbstractAttributeBuilder[A &lt;: AbstractAttributeBuilder[A]](parent: AbstractSchemaBuilder[_, _],</span>
<span class="nc" id="L353">                                                                   specification: StringBuilder) {</span>

    this: A =&gt;

    import SimpleFeatureTypes.AttributeOptions

    /**
      * Add an index on the current attribute, to facilitate  querying on that attribute
      *
      * @return attribute builder for chaining calls
      */
<span class="nc" id="L364">    def withIndex(): A = withOption(AttributeOptions.OptIndex, &quot;true&quot;)</span>

    /**
      * Add an index on the current attribute, to facilitate querying on that attribute
      *
      * @param cardinality a cardinality hint for the attribute - will be considered when picking an index
      *                    during query planning
      * @return attribute builder for chaining calls
      */
    def withIndex(cardinality: Cardinality): A =
<span class="nc" id="L374">      withOptions(AttributeOptions.OptIndex -&gt; &quot;true&quot;, AttributeOptions.OptCardinality -&gt; cardinality.toString)</span>

    /**
      * Specify column groups for a particular attribute, to speed up querying for subsets of attributes
      *
      * @param groups column groups - preferably short strings (one character is best), case sensitive
      * @return
      */
<span class="nc" id="L382">    def withColumnGroups(groups: String*): A = withOptions(AttributeOptions.OptColumnGroups -&gt; groups.mkString(&quot;,&quot;))</span>

    /**
      * Add any attribute-level option
      *
      * @param key option key
      * @param value option value
      * @return attribute builder for chaining calls
      */
    def withOption(key: String, value: String): A = {
<span class="nc" id="L392">      specification.append(SimpleFeatureSpec.encodeAttributeOption(key, value)); this</span>
    }

    /**
      * Add multiple attribute-level options at once
      *
      * @param options key/value attribute-level options
      * @return attribute builder for chaining calls
      */
    def withOptions(options: (String, String)*): A = {
<span class="nc bnc" id="L402" title="All 2 branches missed.">      options.foreach { case (k, v) =&gt; withOption(k, v) }</span>
<span class="nc" id="L403">      this</span>
    }

    /**
      * End the current attribute and return to the schema builder. Useful for chaining calls. Note that
      * there is an implicit conversion back to SchemaBuilder, so this method does not normally need to be invoked
      *
      * @return schema builder for chaining calls
      */
<span class="nc" id="L412">    def end[B &lt;: AbstractSchemaBuilder[A, _ &lt;: AbstractUserDataBuilder[_]]](): B = parent.asInstanceOf[B]</span>
  }

  /**
    * Builder class for configuring schema-level user data
    */
<span class="nc" id="L418">  class AbstractUserDataBuilder[U &lt;: AbstractUserDataBuilder[U]](parent: AbstractSchemaBuilder[_, _],</span>
<span class="nc" id="L419">                                                                 userData: StringBuilder) {</span>

    this: U =&gt;

    import SimpleFeatureTypes.Configs

    /**
      * Configure the enabled indices for a schema
      *
      * @param names names of the indices to enable (e.g. &quot;z3&quot;, &quot;id&quot;, etc)
      * @return user data builder for chaining calls
      */
<span class="nc" id="L431">    def indices(names: List[String]): U = userData(Configs.EnabledIndices, names.mkString(&quot;,&quot;))</span>

    /**
      * Disable indexing on the default date field. If the default date field has not been specified,
      * this will override the default behavior of using the first date-type attribute
      *
      * @return user data builder for chaining calls
      */
<span class="nc" id="L439">    def disableDefaultDate(): U = userData(Configs.IndexIgnoreDtg, &quot;true&quot;)</span>

    /**
      * Configure table splits for a schema
      *
      * @param options table splitter options
      * @return user data builder for chaining calls
      */
    def splits(options: Map[String,String]): U =
<span class="nc bnc" id="L448" title="All 2 branches missed.">      userData(Configs.TableSplitterOpts, options.map { case (k, v) =&gt; s&quot;$k:$v&quot; }.mkString(&quot;,&quot;))</span>

    /**
      * Specify the number of shards to use for the Z indices. Shards can provide distribution
      * across nodes in a cluster, but also require more nodes to be scanned when querying.
      *
      * Default value is 4
      *
      * @param shards number of shards
      * @return user data builder for chaining calls
      */
<span class="nc" id="L459">    def zShards(shards: Int): U = userData(Configs.IndexZShards, shards.toString)</span>

    /**
     * Specify the number of shards to use for the Z2 indices. Shards can provide distribution
     * across nodes in a cluster, but also require more nodes to be scanned when querying.
     *
     * Default value is 4
     *
     * @param shards number of shards
     * @return user data builder for chaining calls
     */
<span class="nc" id="L470">    def z2Shards(shards: Int): U = userData(Configs.IndexZ2Shards, shards.toString)</span>

    /**
     * Specify the number of shards to use for the Z3 indices. Shards can provide distribution
     * across nodes in a cluster, but also require more nodes to be scanned when querying.
     *
     * Default value is 4
     *
     * @param shards number of shards
     * @return user data builder for chaining calls
     */
<span class="nc" id="L481">    def z3Shards(shards: Int): U = userData(Configs.IndexZ2Shards, shards.toString)</span>

    /**
      * Specify the number of shards to use for the attribute index. Shards can provide distribution
      * across nodes in a cluster, but also require more nodes to be scanned when querying.
      *
      * Default value is 4
      *
      * @param shards number of shards
      * @return user data builder for chaining calls
      */
<span class="nc" id="L492">    def attributeShards(shards: Int): U = userData(Configs.IndexAttributeShards, shards.toString)</span>

    /**
      * Specifies that feature IDs are UUIDs. This can save space on disk, as a UUID can be serialized more
      * efficiently than its string representation. Note that if enabled, all feature IDs **must** be
      * valid UUIDs, in the format '28a12c18-e5ae-4c04-ae7b-bf7cdbfaf234'
      *
      * @return user data builder for chaining calls
      */
<span class="nc" id="L501">    def uuidFeatureIds(): U = userData(Configs.FidsAreUuids, &quot;true&quot;)</span>

    /**
      * Sets the time interval used for binning dates in the Z3 and XZ3 indices
      *
      * @param interval time interval to use
      * @return user data builder for chaining calls
      */
<span class="nc" id="L509">    def z3Interval(interval: TimePeriod): U = userData(Configs.IndexZ3Interval, interval.toString)</span>

    /**
      * Set the precision of the XZ index (if used).
      *
      * Default value is 12
      *
      * @param precision precision
      * @return user data builder for chaining calls
      */
<span class="nc" id="L519">    def xzPrecision(precision: Int): U = userData(Configs.IndexXzPrecision, precision.toString)</span>

    /**
      * Enable date-based table partitioning
      *
      * @return user data builder for chainging calls
      */
<span class="nc" id="L526">    def partitioned(): U = userData(Configs.TablePartitioning, &quot;time&quot;)</span>

    /**
      * Add arbitrary user data values to the schema
      *
      * @param key user data key
      * @param value user data value
      * @return user data builder for chaining calls
      */
    def userData(key: String, value: String): U = {
<span class="nc" id="L536">      userData.append(SimpleFeatureTypes.encodeUserData(key, value)).append(&quot;,&quot;)</span>
<span class="nc" id="L537">      this</span>
    }

    /**
      * Add multiple user data values to the schema
      *
      * @param data user data key values
      * @return
      */
    def userData(data: Map[String, String]): U = {
<span class="nc bnc" id="L547" title="All 2 branches missed.">      data.foreach { case (k, v) =&gt; userData(k, v) }</span>
<span class="nc" id="L548">      this</span>
    }

    /**
      * End the current user data and return to the schema builder. Useful for chaining calls. Note that
      * this method does not normally need to be invoked explicitly, as there is an implicit conversion back
      * to SchemaBuilder
      *
      * @return schema builder for chaining calls
      */
<span class="nc" id="L558">    def end[B &lt;: AbstractSchemaBuilder[_ &lt;: AbstractAttributeBuilder[_], U]](): B = parent.asInstanceOf[B]</span>
  }
<span class="nc" id="L560">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>