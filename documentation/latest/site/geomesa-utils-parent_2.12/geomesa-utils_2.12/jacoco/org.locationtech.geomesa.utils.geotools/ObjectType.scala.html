<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObjectType.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools</a> &gt; <span class="el_source">ObjectType.scala</span></div><h1>ObjectType.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools

import org.geotools.api.feature.`type`.AttributeDescriptor
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeConfigs.{UserDataListType, UserDataMapKeyType, UserDataMapValueType}
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeOptions._
import org.locationtech.jts.geom._

import java.util.{Collections, UUID, List =&gt; jList, Map =&gt; jMap}

<span class="nc" id="L18">object ObjectType extends Enumeration {</span>

  type ObjectType = Value

<span class="nc" id="L22">  val STRING, INT, LONG, FLOAT, DOUBLE, BOOLEAN, DATE, UUID, GEOMETRY, LIST, MAP, BYTES = Value</span>

  // geometry sub-types
<span class="nc" id="L25">  val POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRY_COLLECTION = Value</span>

  // string sub-types
<span class="nc" id="L28">  val JSON: Value = Value</span>

<span class="nc" id="L30">  val GeometrySubtypes: Seq[Value] =</span>
<span class="nc" id="L31">    Seq(POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRY_COLLECTION, GEOMETRY)</span>

  /**
   * Turns a SimpleFeatureType attribute class binding into an enumeration.
   *
   * The first element in the result will be the primary binding. For geometries, lists and maps,
   * the result will also contain secondary types.
   *
   * Lists will contain the type of the list elements.
   * Maps will contain the type of the map keys, then the type of the map values.
   * Geometries will contain the specific geometry type.
   *
   * Note: geometries will always return GEOMETRY as the primary type to allow for generic matching.
   *
   * @param descriptor attribute descriptor
   * @return binding
   */
  def selectType(descriptor: AttributeDescriptor): Seq[ObjectType] =
<span class="nc" id="L49">    selectType(descriptor.getType.getBinding, descriptor.getUserData, Option(descriptor.getLocalName))</span>

  /**
   * Used if there is no descriptor available. Note that this will throw an error for list or map-type attributes.
   *
   * @see selectType(descriptor: AttributeDescriptor)
   *
   * @param clazz class, must be valid for a SimpleFeatureType attribute
   * @return binding
   */
<span class="nc" id="L59">  def selectType(clazz: Class[_]): Seq[ObjectType] = selectType(clazz, Collections.emptyMap(), None)</span>

  /**
   * Get the type enumeration
   *
   * @param clazz class, must be valid for a SimpleFeatureType attribute
   * @param metadata attribute metadata (user data)
   * @param fieldName name of the field
   * @return binding
   */
  private def selectType(clazz: Class[_], metadata: jMap[_, _], fieldName: Option[String]): Seq[ObjectType] = {
<span class="nc" id="L70">    clazz match {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">      case c if classOf[java.lang.String].isAssignableFrom(c) =&gt;</span>
<span class="nc bnc" id="L72" title="All 6 branches missed.">        if (metadata.get(OptJson) == &quot;true&quot;) { Seq(STRING, JSON) } else { Seq(STRING) }</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">      case c if classOf[java.lang.Integer].isAssignableFrom(c) =&gt; Seq(INT)</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">      case c if classOf[java.lang.Long].isAssignableFrom(c) =&gt; Seq(LONG)</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">      case c if classOf[java.lang.Float].isAssignableFrom(c) =&gt; Seq(FLOAT)</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      case c if classOf[java.lang.Double].isAssignableFrom(c) =&gt; Seq(DOUBLE)</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      case c if classOf[java.lang.Boolean].isAssignableFrom(c) =&gt; Seq(BOOLEAN)</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      case c if classOf[java.util.Date].isAssignableFrom(c) =&gt; Seq(DATE)</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">      case c if classOf[UUID].isAssignableFrom(c) =&gt; Seq(UUID)</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">      case c if classOf[Geometry].isAssignableFrom(c) =&gt; geometryType(c.asInstanceOf[Class[_ &lt;: Geometry]])</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      case c if classOf[Array[Byte]].isAssignableFrom(c) =&gt; Seq(BYTES)</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">      case c if classOf[jList[_]].isAssignableFrom(c) =&gt; listType(metadata, fieldName)</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      case c if classOf[jMap[_, _]].isAssignableFrom(c) =&gt; mapType(metadata, fieldName)</span>

      case _ =&gt;
<span class="nc" id="L86">        throw new IllegalArgumentException(s&quot;${fieldName.fold(&quot;Type&quot;)(f =&gt; s&quot;Field $f of type&quot;)} $clazz can't be serialized&quot;)</span>
    }
  }

  private def geometryType(clazz: Class[_ &lt;: Geometry]): Seq[ObjectType] = {
<span class="nc" id="L91">    val subtype = clazz match {</span>
<span class="nc bnc" id="L92" title="All 6 branches missed.">      case c if c == classOf[Point]              =&gt; POINT</span>
<span class="nc bnc" id="L93" title="All 6 branches missed.">      case c if c == classOf[LineString]         =&gt; LINESTRING</span>
<span class="nc bnc" id="L94" title="All 6 branches missed.">      case c if c == classOf[Polygon]            =&gt; POLYGON</span>
<span class="nc bnc" id="L95" title="All 6 branches missed.">      case c if c == classOf[MultiLineString]    =&gt; MULTILINESTRING</span>
<span class="nc bnc" id="L96" title="All 6 branches missed.">      case c if c == classOf[MultiPolygon]       =&gt; MULTIPOLYGON</span>
<span class="nc bnc" id="L97" title="All 6 branches missed.">      case c if c == classOf[MultiPoint]         =&gt; MULTIPOINT</span>
<span class="nc bnc" id="L98" title="All 6 branches missed.">      case c if c == classOf[GeometryCollection] =&gt; GEOMETRY_COLLECTION</span>
<span class="nc" id="L99">      case _                                     =&gt; GEOMETRY</span>
    }
<span class="nc" id="L101">    Seq(GEOMETRY, subtype)</span>
  }

  private def listType(metadata: jMap[_, _], fieldName: Option[String]): Seq[ObjectType] = {
<span class="nc" id="L105">    val elementType = getSubType(metadata, UserDataListType, fieldName)</span>
<span class="nc" id="L106">    Seq(LIST, elementType)</span>
  }

  private def mapType(metadata: jMap[_, _], fieldName: Option[String]): Seq[ObjectType] = {
<span class="nc" id="L110">    val keyType = getSubType(metadata, UserDataMapKeyType, fieldName)</span>
<span class="nc" id="L111">    val valueType = getSubType(metadata, UserDataMapValueType, fieldName)</span>
<span class="nc" id="L112">    Seq(MAP, keyType, valueType)</span>
  }

  private def getSubType(metadata: jMap[_, _], typeKey: String, fieldName: Option[String]): ObjectType = {
<span class="nc" id="L116">    def fieldError: String = s&quot;for collection-type field${fieldName.fold(&quot;&quot;)(f =&gt; s&quot; '$f'&quot;)}&quot;</span>
<span class="nc" id="L117">    metadata.get(typeKey) match {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">      case s: String =&gt;</span>
<span class="nc" id="L119">        val clazz = Class.forName(s)</span>
<span class="nc" id="L120">        selectType(clazz) match {</span>
<span class="nc bnc" id="L121" title="All 6 branches missed.">          case Seq(binding) =&gt; binding</span>
<span class="nc" id="L122">          case _ =&gt; throw new IllegalArgumentException(s&quot;Can't serialize sub-type of ${clazz.getName} $fieldError&quot;)</span>
        }

<span class="nc bnc" id="L125" title="All 2 branches missed.">      case null =&gt; throw new IllegalArgumentException(s&quot;Missing user data key '$typeKey' $fieldError&quot;)</span>
<span class="nc" id="L126">      case t =&gt; throw new IllegalArgumentException(s&quot;Unexpected user data '$typeKey' $fieldError: $t&quot;)</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>