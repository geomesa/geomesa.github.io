<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Conversions.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools</a> &gt; <span class="el_source">Conversions.scala</span></div><h1>Conversions.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools

import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.feature.AttributeTypeBuilder
import org.locationtech.geomesa.curve.TimePeriod.TimePeriod
import org.locationtech.geomesa.curve.{TimePeriod, XZSFC}
import org.locationtech.geomesa.utils.conf.{FeatureExpiration, IndexId}
import org.locationtech.geomesa.utils.geometry.GeometryPrecision
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.{Configs, InternalConfigs}
import org.locationtech.geomesa.utils.index.Cardinality._
import org.locationtech.geomesa.utils.index.VisibilityLevel.VisibilityLevel
import org.locationtech.geomesa.utils.index.{Cardinality, VisibilityLevel}
import org.locationtech.jts.geom._

import java.nio.charset.StandardCharsets
import java.util.{Date, UUID}
import scala.util.Try

<span class="nc" id="L28">object Conversions {</span>

<span class="nc bnc" id="L30" title="All 12 branches missed.">  implicit class RichGeometry(val geom: Geometry) extends AnyVal {</span>
<span class="nc" id="L31">    def bufferMeters(meters: Double): Geometry = geom.buffer(distanceDegrees(meters))</span>
<span class="nc" id="L32">    def distanceDegrees(meters: Double): Double = GeometryUtils.distanceDegrees(geom, meters)._2</span>
<span class="nc" id="L33">    def safeCentroid(): Point = {</span>
<span class="nc" id="L34">      val centroid = geom.getCentroid</span>
<span class="nc bnc" id="L35" title="All 4 branches missed.">      if (java.lang.Double.isNaN(centroid.getCoordinate.x) || java.lang.Double.isNaN(centroid.getCoordinate.y)) {</span>
<span class="nc" id="L36">        geom.getEnvelope.getCentroid</span>
      } else {
<span class="nc" id="L38">        centroid</span>
      }
    }
  }

<span class="nc bnc" id="L43" title="All 12 branches missed.">  implicit class RichSimpleFeature(val sf: SimpleFeature) extends AnyVal {</span>

    /**
      * Gets the feature ID as a parsed UUID consisting of (msb, lsb). Caches the bits
      * in the user data for retrieval.
      *
      * Note: this method assumes that the feature ID is a UUID - should first check this
      * with `sft.isUuid`
      *
      * @return (most significant bits, least significant bits)
      */
<span class="nc" id="L54">    def getUuid: (Long, Long) = {</span>
<span class="nc" id="L55">      var bits: (Long, Long) = sf.getUserData.get(&quot;uuid&quot;).asInstanceOf[(Long, Long)]</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">      if (bits == null) {</span>
<span class="nc" id="L57">        val uuid = UUID.fromString(sf.getID)</span>
<span class="nc" id="L58">        bits = (uuid.getMostSignificantBits, uuid.getLeastSignificantBits)</span>
<span class="nc" id="L59">        sf.getUserData.put(&quot;uuid&quot;, bits)</span>
      }
<span class="nc" id="L61">      bits</span>
    }

    /**
      * Cache a parsed uuid for later lookup with `getUuid`
      *
      * @param uuid (most significant bits, least significant bits)
      */
<span class="nc" id="L69">    def cacheUuid(uuid: (Long, Long)): Unit = sf.getUserData.put(&quot;uuid&quot;, uuid)</span>
  }
}

<span class="nc" id="L73">object PrimitiveConversions {</span>

  trait Conversion[T] {
    def convert(value: AnyRef): T
  }

<span class="nc" id="L79">  implicit object ConvertToBoolean extends ConvertToBoolean</span>

<span class="nc" id="L81">  trait ConvertToBoolean extends Conversion[Boolean] {</span>
<span class="nc" id="L82">    override def convert(value: AnyRef): Boolean = value match {</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      case v: String =&gt; v.equalsIgnoreCase(&quot;true&quot;)</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      case v: java.lang.Boolean =&gt; v.booleanValue</span>
<span class="nc" id="L85">      case _ =&gt; throw new IllegalArgumentException(s&quot;Input $value is not a Boolean type&quot;)</span>
    }
  }

<span class="nc" id="L89">  implicit object ConvertToDouble extends ConvertToDouble</span>

<span class="nc" id="L91">  trait ConvertToDouble extends Conversion[Double] {</span>
<span class="nc" id="L92">    override def convert(value: AnyRef): Double = value match {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">      case v: String =&gt; v.toDouble</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      case v: Number =&gt; v.doubleValue()</span>
<span class="nc" id="L95">      case _         =&gt; throw new IllegalArgumentException(s&quot;Input $value is not a numeric type&quot;)</span>
    }
  }

<span class="nc" id="L99">  implicit object ConvertToInt extends ConvertToInt</span>

<span class="nc" id="L101">  trait ConvertToInt extends Conversion[Int] {</span>
<span class="nc" id="L102">    override def convert(value: AnyRef): Int = value match {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">      case v: String =&gt; v.toInt</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">      case v: Number =&gt; v.intValue()</span>
<span class="nc" id="L105">      case _         =&gt; throw new IllegalArgumentException(s&quot;Input $value is not a numeric type&quot;)</span>
    }
  }

<span class="nc" id="L109">  implicit object ConvertToShort extends ConvertToShort</span>

<span class="nc" id="L111">  trait ConvertToShort extends Conversion[Short] {</span>
<span class="nc" id="L112">    override def convert(value: AnyRef): Short = value match {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      case v: String =&gt; v.toShort</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">      case v: Number =&gt; v.shortValue()</span>
<span class="nc" id="L115">      case _         =&gt; throw new IllegalArgumentException(s&quot;Input $value is not a numeric type&quot;)</span>
    }
  }

<span class="nc" id="L119">  implicit object ConvertToString extends ConvertToString</span>

<span class="nc" id="L121">  trait ConvertToString extends Conversion[String] {</span>
<span class="nc" id="L122">    override def convert(value: AnyRef): String = value match {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">      case v: String =&gt; v</span>
<span class="nc" id="L124">      case v         =&gt; v.toString</span>
    }
  }
}

<span class="nc" id="L129">trait Conversions {</span>

  import PrimitiveConversions._

<span class="nc" id="L133">  protected def boolean(value: AnyRef, default: Boolean = false): Boolean =</span>
<span class="nc" id="L134">    Try(ConvertToBoolean.convert(value)).getOrElse(default)</span>

<span class="nc" id="L136">  protected def double(value: AnyRef): Double = ConvertToDouble.convert(value)</span>

<span class="nc" id="L138">  protected def int(value: AnyRef): Int = ConvertToInt.convert(value)</span>

<span class="nc" id="L140">  protected def short(value: AnyRef): Short = ConvertToShort.convert(value)</span>
}

/**
 * Contains GeoMesa specific attribute descriptor information
 */
<span class="nc" id="L146">object RichAttributeDescriptors extends Conversions {</span>

  import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeConfigs._
  import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeOptions._

  // noinspection AccessorLikeMethodIsEmptyParen
<span class="nc bnc" id="L152" title="All 12 branches missed.">  implicit class RichAttributeDescriptor(val ad: AttributeDescriptor) extends AnyVal {</span>

<span class="nc" id="L154">    def isKeepStats(): Boolean = boolean(ad.getUserData.get(OptStats))</span>

<span class="nc" id="L156">    def isIndexValue(): Boolean = boolean(ad.getUserData.get(OptIndexValue))</span>

    def getColumnGroups(): Set[String] =
<span class="nc" id="L159">      Option(ad.getUserData.get(OptColumnGroups).asInstanceOf[String]).map(_.split(&quot;,&quot;).toSet).getOrElse(Set.empty)</span>

    def getCardinality(): Cardinality =
<span class="nc" id="L162">      Option(ad.getUserData.get(OptCardinality).asInstanceOf[String])</span>
<span class="nc" id="L163">          .flatMap(c =&gt; Try(Cardinality.withName(c)).toOption).getOrElse(Cardinality.UNKNOWN)</span>

<span class="nc" id="L165">    def isJson(): Boolean = boolean(ad.getUserData.get(OptJson))</span>

<span class="nc" id="L167">    def getListType(): Class[_] = tryClass(ad.getUserData.get(UserDataListType).asInstanceOf[String])</span>

    def getMapTypes(): (Class[_], Class[_]) =
<span class="nc" id="L170">      (tryClass(ad.getUserData.get(UserDataMapKeyType)), tryClass(ad.getUserData.get(UserDataMapValueType)))</span>

<span class="nc" id="L172">    private def tryClass(value: AnyRef): Class[_] = Try(Class.forName(value.asInstanceOf[String])).getOrElse(null)</span>

<span class="nc" id="L174">    def isList: Boolean = classOf[java.util.List[_]].isAssignableFrom(ad.getType.getBinding)</span>
<span class="nc" id="L175">    def isMap: Boolean = classOf[java.util.Map[_, _]].isAssignableFrom(ad.getType.getBinding)</span>
<span class="nc bnc" id="L176" title="All 4 branches missed.">    def isMultiValued: Boolean = isList || isMap</span>

    def getPrecision: GeometryPrecision = {
<span class="nc" id="L179">      Option(ad.getUserData.get(OptPrecision).asInstanceOf[String]).map(_.split(',')) match {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        case None =&gt; GeometryPrecision.FullPrecision</span>
<span class="nc bnc" id="L181" title="All 8 branches missed.">        case Some(Array(xy)) =&gt; GeometryPrecision.TwkbPrecision(xy.toByte)</span>
<span class="nc bnc" id="L182" title="All 8 branches missed.">        case Some(Array(xy, z)) =&gt; GeometryPrecision.TwkbPrecision(xy.toByte, z.toByte)</span>
<span class="nc bnc" id="L183" title="All 8 branches missed.">        case Some(Array(xy, z, m)) =&gt; GeometryPrecision.TwkbPrecision(xy.toByte, z.toByte, m.toByte)</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        case Some(p) =&gt; throw new IllegalArgumentException(s&quot;Invalid geometry precision: ${p.mkString(&quot;,&quot;)}&quot;)</span>
      }
    }
  }

<span class="nc bnc" id="L189" title="All 12 branches missed.">  implicit class RichAttributeTypeBuilder(val builder: AttributeTypeBuilder) extends AnyVal {</span>

<span class="nc" id="L191">    def indexValue(indexValue: Boolean): AttributeTypeBuilder = builder.userData(OptIndexValue, indexValue)</span>

    def cardinality(cardinality: Cardinality): AttributeTypeBuilder =
<span class="nc" id="L194">      builder.userData(OptCardinality, cardinality.toString)</span>

<span class="nc" id="L196">    def collectionType(typ: Class[_]): AttributeTypeBuilder = builder.userData(UserDataListType, typ)</span>
  }
}

<span class="nc" id="L200">object RichSimpleFeatureType extends Conversions {</span>

  // in general we store everything as strings so that it's easy to pass to accumulo iterators
<span class="nc bnc" id="L203" title="All 12 branches missed.">  implicit class RichSimpleFeatureType(val sft: SimpleFeatureType) extends AnyVal {</span>

    import SimpleFeatureTypes.Configs._
    import SimpleFeatureTypes.InternalConfigs._

    import scala.collection.JavaConverters._

<span class="nc" id="L210">    def getGeomField: String = {</span>
<span class="nc" id="L211">      val gd = sft.getGeometryDescriptor</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      if (gd == null) { null } else { gd.getLocalName }</span>
    }
<span class="nc" id="L214">    def getGeomIndex: Int = Option(getGeomField).map(sft.indexOf).getOrElse(-1)</span>

<span class="nc" id="L216">    def getDtgField: Option[String] = userData[String](DefaultDtgField)</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">    def getDtgIndex: Option[Int] = getDtgField.map(sft.indexOf).filter(_ != -1)</span>
<span class="nc" id="L218">    def clearDtgField(): Unit = sft.getUserData.remove(DefaultDtgField)</span>
<span class="nc" id="L219">    def setDtgField(dtg: String): Unit = {</span>
<span class="nc" id="L220">      val descriptor = sft.getDescriptor(dtg)</span>
<span class="nc bnc" id="L221" title="All 4 branches missed.">      require(descriptor != null &amp;&amp; classOf[Date].isAssignableFrom(descriptor.getType.getBinding),</span>
<span class="nc" id="L222">        s&quot;Invalid date field '$dtg' for schema $sft&quot;)</span>
<span class="nc" id="L223">      sft.getUserData.put(DefaultDtgField, dtg)</span>
    }

<span class="nc" id="L226">    def statsEnabled: Boolean = boolean(sft.getUserData.get(StatsEnabled), default = true)</span>
<span class="nc" id="L227">    def setStatsEnabled(enabled: Boolean): Unit = sft.getUserData.put(StatsEnabled, enabled.toString)</span>

<span class="nc" id="L229">    def isLogicalTime: Boolean = boolean(sft.getUserData.get(TableLogicalTime), default = true)</span>

<span class="nc" id="L231">    def isPoints: Boolean = {</span>
<span class="nc" id="L232">      val gd = sft.getGeometryDescriptor</span>
<span class="nc bnc" id="L233" title="All 8 branches missed.">      gd != null &amp;&amp; gd.getType.getBinding == classOf[Point]</span>
    }
<span class="nc" id="L235">    def nonPoints: Boolean = {</span>
<span class="nc" id="L236">      val gd = sft.getGeometryDescriptor</span>
<span class="nc bnc" id="L237" title="All 8 branches missed.">      gd != null &amp;&amp; gd.getType.getBinding != classOf[Point]</span>
    }
<span class="nc" id="L239">    def isLines: Boolean = {</span>
<span class="nc" id="L240">      val gd = sft.getGeometryDescriptor</span>
<span class="nc bnc" id="L241" title="All 8 branches missed.">      gd != null &amp;&amp; gd.getType.getBinding == classOf[LineString]</span>
    }

<span class="nc" id="L244">    def getVisibilityLevel: VisibilityLevel = userData[String](IndexVisibilityLevel) match {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">      case None        =&gt; VisibilityLevel.Feature</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">      case Some(level) =&gt; VisibilityLevel.withName(level.toLowerCase)</span>
    }

<span class="nc" id="L249">    def isVisibilityRequired: Boolean = boolean(sft.getUserData.get(RequireVisibility), default = false)</span>

<span class="nc" id="L251">    def getZ3Interval: TimePeriod = userData[String](IndexZ3Interval) match {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">      case None    =&gt; TimePeriod.Week</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">      case Some(i) =&gt; TimePeriod.withName(i.toLowerCase)</span>
    }

<span class="nc" id="L256">    def getS3Interval: TimePeriod = userData[String](IndexS3Interval) match {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      case None    =&gt; TimePeriod.Week</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">      case Some(i) =&gt; TimePeriod.withName(i.toLowerCase)</span>
    }

<span class="nc" id="L261">    def getXZPrecision: Short = userData(IndexXzPrecision).map(short).getOrElse(XZSFC.DefaultPrecision)</span>

    // note: defaults to false now
    @deprecated(&quot;table sharing no longer supported&quot;)
<span class="nc" id="L265">    def isTableSharing: Boolean = userData[String](TableSharing).exists(_.toBoolean)</span>
    @deprecated(&quot;table sharing no longer supported&quot;)
<span class="nc" id="L267">    def getTableSharingPrefix: String = userData[String](TableSharingPrefix).getOrElse(&quot;&quot;)</span>

    // noinspection ScalaDeprecation
    @deprecated(&quot;table sharing no longer supported&quot;)
<span class="nc bnc" id="L271" title="All 2 branches missed.">    def getTableSharingBytes: Array[Byte] = if (sft.isTableSharing) {</span>
<span class="nc" id="L272">      sft.getTableSharingPrefix.getBytes(StandardCharsets.UTF_8)</span>
    } else {
<span class="nc" id="L274">      Array.empty[Byte]</span>
    }

<span class="nc" id="L277">    def setCompression(c: String): Unit = sft.getUserData.put(TableCompressionType, c)</span>
    def getCompression: Option[String] = {
<span class="nc" id="L279">      userData[String](TableCompressionType).orElse {</span>
        // check deprecated 'enabled' config, which defaults to 'gz'
<span class="nc bnc" id="L281" title="All 4 branches missed.">        userData[String](&quot;geomesa.table.compression.enabled&quot;).collect { case e if e.toBoolean =&gt; &quot;gz&quot; }</span>
      }
    }

    // gets indices configured for this sft
    def getIndices: Seq[IndexId] =
<span class="nc" id="L287">      userData[String](IndexVersions).map(_.split(&quot;,&quot;).map(IndexId.apply).toSeq).getOrElse(Seq.empty)</span>
    def setIndices(indices: Seq[IndexId]): Unit =
<span class="nc" id="L289">      sft.getUserData.put(IndexVersions, indices.map(_.encoded).mkString(&quot;,&quot;))</span>

<span class="nc" id="L291">    def setUserDataPrefixes(prefixes: Seq[String]): Unit = sft.getUserData.put(UserDataPrefix, prefixes.mkString(&quot;,&quot;))</span>
    def getUserDataPrefixes: Seq[String] =
<span class="nc" id="L293">      (Seq(GeomesaPrefix) ++ userData[String](UserDataPrefix).map(_.split(&quot;,&quot;)).getOrElse(Array.empty)).toSeq</span>

<span class="nc" id="L295">    def setZ2Shards(splits: Int): Unit = sft.getUserData.put(IndexZ2Shards, splits.toString)</span>
    def getZ2Shards: Int =
<span class="nc" id="L297">      userData(IndexZ2Shards).map(int).getOrElse(userData(IndexZShards).map(int).getOrElse(4))</span>

<span class="nc" id="L299">    def setZ3Shards(splits: Int): Unit = sft.getUserData.put(IndexZ3Shards, splits.toString)</span>
    def getZ3Shards: Int =
<span class="nc" id="L301">      userData(IndexZ3Shards).map(int).getOrElse(userData(IndexZShards).map(int).getOrElse(4))</span>

<span class="nc" id="L303">    def setAttributeShards(splits: Int): Unit = sft.getUserData.put(IndexAttributeShards, splits.toString)</span>
<span class="nc" id="L304">    def getAttributeShards: Int = userData(IndexAttributeShards).map(int).getOrElse(4)</span>

<span class="nc" id="L306">    def setIdShards(splits: Int): Unit = sft.getUserData.put(IndexIdShards, splits.toString)</span>
<span class="nc" id="L307">    def getIdShards: Int = userData(IndexIdShards).map(int).getOrElse(4)</span>

<span class="nc" id="L309">    def isUuid: Boolean = boolean(sft.getUserData.get(FidsAreUuids))</span>
<span class="nc bnc" id="L310" title="All 4 branches missed.">    def isUuidEncoded: Boolean = isUuid &amp;&amp; boolean(sft.getUserData.get(FidsAreUuidEncoded), default = true)</span>

<span class="nc" id="L312">    def setFeatureExpiration(expiration: FeatureExpiration): Unit = {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">      val org.locationtech.geomesa.utils.conf.FeatureExpiration(string) = expiration</span>
<span class="nc" id="L314">      sft.getUserData.put(Configs.FeatureExpiration, string)</span>
    }
    def getFeatureExpiration: Option[FeatureExpiration] =
<span class="nc" id="L317">      userData[String](Configs.FeatureExpiration).map(org.locationtech.geomesa.utils.conf.FeatureExpiration.apply(sft, _))</span>
<span class="nc" id="L318">    def isFeatureExpirationEnabled: Boolean = sft.getUserData.containsKey(Configs.FeatureExpiration)</span>

<span class="nc" id="L320">    def isTemporalPriority: Boolean = boolean(sft.getUserData.get(TemporalPriority))</span>

<span class="nc" id="L322">    def isPartitioned: Boolean = sft.getUserData.containsKey(Configs.TablePartitioning)</span>

<span class="nc" id="L324">    def getTableProps: Map[String, String] = {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">      val key = (if (sft.isPartitioned) { InternalConfigs.PartitionTableProps } else { Configs.TableProps }) + &quot;.&quot;</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">      val  props = sft.getUserData.asScala.collect {</span>
<span class="nc bnc" id="L327" title="All 12 branches missed.">        case (k: String, v: String) if k.startsWith(key) =&gt; k.substring(key.length) -&gt; v</span>
      }
<span class="nc" id="L329">      props.toMap</span>
    }

<span class="nc" id="L332">    def getTablePrefix(indexName: String): Option[String] = {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">      val key = if (isPartitioned) { InternalConfigs.PartitionTablePrefix } else { Configs.IndexTablePrefix }</span>
<span class="nc" id="L334">      userData[String](s&quot;$key.$indexName&quot;).orElse(userData[String](key))</span>
    }

<span class="nc" id="L337">    def getQueryInterceptors: Seq[String] = userData[String](QueryInterceptors).toSeq.flatMap(_.split(&quot;,&quot;))</span>

    def getKeywords: Set[String] =
<span class="nc" id="L340">      userData[String](Keywords).map(_.split(KeywordsDelimiter).toSet).getOrElse(Set.empty)</span>

    def addKeywords(keywords: Set[String]): Unit =
<span class="nc" id="L343">      sft.getUserData.put(Keywords, getKeywords.union(keywords).mkString(KeywordsDelimiter))</span>

    def removeKeywords(keywords: Set[String]): Unit =
<span class="nc" id="L346">      sft.getUserData.put(Keywords, getKeywords.diff(keywords).mkString(KeywordsDelimiter))</span>

<span class="nc" id="L348">    def userData[T](key: AnyRef): Option[T] = Option(sft.getUserData.get(key).asInstanceOf[T])</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>