<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeometryUtils.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools</a> &gt; <span class="el_source">GeometryUtils.scala</span></div><h1>GeometryUtils.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools

import com.typesafe.scalalogging.LazyLogging
import org.geotools.geometry.jts.{JTSFactoryFinder, ReferencedEnvelope}
import org.geotools.referencing.GeodeticCalculator
import org.locationtech.geomesa.utils.geohash.GeohashUtils
import org.locationtech.geomesa.utils.geohash.GeohashUtils.ResolutionRange
import org.locationtech.jts.geom._

import scala.util.control.NonFatal

/**
 * The object provides convenience methods for common operations on geometries.
 */
<span class="nc bnc" id="L23" title="All 4 branches missed.">object GeometryUtils extends LazyLogging {</span>

<span class="nc" id="L25">  val geoFactory: GeometryFactory = JTSFactoryFinder.getGeometryFactory</span>

<span class="nc" id="L27">  val zeroPoint: Point = geoFactory.createPoint(new Coordinate(0,0))</span>

  /**
    * Convert meters to decimal degrees, based on the latitude of the geometry.
    *
    * Returns two values, ones based on latitude and one based on longitude. The first value
    * will always be &amp;lt;= the second value
    *
    * For non-point geometries, distances are measured from the corners of the geometry envelope
    *
    * @param geom geometry to buffer
    * @param meters meters
    * @return (min degrees, max degrees)
    */
  def distanceDegrees(geom: Geometry, meters: Double): (Double, Double) = {
<span class="nc" id="L42">    geom match {</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">      case p: Point =&gt; distanceDegrees(p, meters, new GeodeticCalculator())</span>
<span class="nc" id="L44">      case _        =&gt; distanceDegrees(geom.getEnvelopeInternal, meters)</span>
    }
  }

  /**
    * Convert meters to decimal degrees, based on the latitude of the geometry.
    *
    * Returns two values, ones based on latitude and one based on longitude. The first value
    * will always be &amp;lt;= the second value
    *
    * @param point geometry to buffer
    * @param meters meters
    * @param calc geodetic calculator instance
    * @return (min degrees, max degrees)
    */
  def distanceDegrees(point: Point, meters: Double, calc: GeodeticCalculator): (Double, Double) = {
<span class="nc bnc" id="L60" title="All 2 branches missed.">    val (east, north) = directionalDegrees(point, meters, calc)</span>
    // normally east would be the largest in degrees, but sometimes it can be smaller
    // due to variances in the ellipsoid
<span class="nc bnc" id="L63" title="All 2 branches missed.">    if (east &gt; north) { (north, east) } else { (east, north) }</span>
  }

  /**
    * Convert meters to decimal degrees, based on the latitude of the geometry.
    *
    * Returns two values, ones based on latitude and one based on longitude. The first value
    * will always be &amp;lt;= the second value
    *
    * Distances are measured from the corners of the geometry envelope
    *
    * @param env envelope to buffer
    * @param meters meters
    * @return (min degrees, max degrees)
    */
  def distanceDegrees(env: Envelope, meters: Double): (Double, Double) = {
<span class="nc" id="L79">    val distances = Seq(</span>
<span class="nc" id="L80">      distanceDegrees(geoFactory.createPoint(new Coordinate(env.getMaxX, env.getMaxY)), meters),</span>
<span class="nc" id="L81">      distanceDegrees(geoFactory.createPoint(new Coordinate(env.getMaxX, env.getMinY)), meters),</span>
<span class="nc" id="L82">      distanceDegrees(geoFactory.createPoint(new Coordinate(env.getMinX, env.getMinY)), meters),</span>
<span class="nc" id="L83">      distanceDegrees(geoFactory.createPoint(new Coordinate(env.getMinX, env.getMaxY)), meters)</span>
    )
<span class="nc" id="L85">    (distances.minBy(_._1)._1, distances.maxBy(_._2)._2)</span>
  }

  /**
    * Calculate distance from a point, in degrees.
    *
    * Note: normally east/west would be the largest in degrees, but sometimes it can be smaller
    * due to variances in the ellipsoid
    *
    * @param point point to buffer
    * @param meters distance to buffer, in meters
    * @param calc calculator, for re-use
    * @return (east/west, north/south) distance in degrees
    */
  def directionalDegrees(point: Point, meters: Double, calc: GeodeticCalculator): (Double, Double) = {
<span class="nc" id="L100">    calc.setStartingGeographicPoint(point.getX, point.getY)</span>
    def degrees(azimuth: Double): Double = {
<span class="nc" id="L102">      calc.setDirection(azimuth, meters)</span>
<span class="nc" id="L103">      val dest = calc.getDestinationGeographicPoint</span>
<span class="nc" id="L104">      point.distance(geoFactory.createPoint(new Coordinate(dest.getX, dest.getY)))</span>
    }
    // take min distance to account for crossing the AM/poles
<span class="nc" id="L107">    (math.min(degrees(90), degrees(-90)), math.min(degrees(0), degrees(180)))</span>
  }

  /** Adds way points to Seq[Coordinates] so that they remain valid with Spatial4j, useful for BBOX */
  def addWayPoints(coords: Seq[Coordinate]): List[Coordinate] = {
<span class="nc" id="L112">    unfoldRight(coords) {</span>
<span class="nc bnc" id="L113" title="All 6 branches missed.">      case Seq() =&gt; None</span>
<span class="nc bnc" id="L114" title="All 6 branches missed.">      case Seq(pt) =&gt; Some((pt, Seq()))</span>
<span class="nc bnc" id="L115" title="All 6 branches missed.">      case Seq(first, second, rest @ _*) =&gt; second.x - first.x match {</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        case dx if dx &gt; 120 =&gt;</span>
<span class="nc" id="L117">          Some((first, new Coordinate(first.x + 120, first.y) +: second +: rest))</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        case dx if dx &lt; -120 =&gt;</span>
<span class="nc" id="L119">          Some((first, new Coordinate(first.x - 120, first.y) +: second +: rest))</span>
<span class="nc" id="L120">        case _ =&gt; Some((first, second +: rest))</span>
      }
    }
  }

<span class="nc" id="L125">  private def unfoldRight[A, B](seed: B)(f: B =&gt; Option[(A, B)]): List[A] = f(seed) match {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">    case None =&gt; Nil</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">    case Some((a, b)) =&gt; a :: unfoldRight(b)(f)</span>
  }

  /**
    * Returns the rough bounds of a geometry
    *
    * @param geometry geometry
    * @return (xmin, ymin, xmax, ymax)
    */
  def bounds(geometry: Geometry): (Double, Double, Double, Double) = {
<span class="nc" id="L137">    val env = geometry.getEnvelopeInternal</span>
<span class="nc" id="L138">    (env.getMinX, env.getMinY, env.getMaxX, env.getMaxY)</span>
  }

  /**
    * Returns the rough bounds of a geometry, decomposing the geometry to provide better accuracy
    *
    * @param geometry geometry
    * @param maxBounds maximum number of bounds that will be returned
    * @param maxBitResolution maximum bit resolution to decompose to
    *                         must be between 1-63, inclusive
    * @return seq of (xmin, ymin, xmax, ymax)
    */
  def bounds(geometry: Geometry, maxBounds: Int, maxBitResolution: Int): Seq[(Double, Double, Double, Double)] = {
<span class="nc bnc" id="L151" title="All 4 branches missed.">    if (maxBounds &lt; 2 || GeometryUtils.isRectangular(geometry)) {</span>
<span class="nc" id="L152">      return Seq(bounds(geometry))</span>
    }

<span class="nc" id="L155">    try {</span>
      // use `maxBitResolution | 1` to ensure oddness, which is required by GeohashUtils
<span class="nc" id="L157">      val resolution = ResolutionRange(0, maxBitResolution | 1, 5)</span>
<span class="nc" id="L158">      GeohashUtils.decomposeGeometry(geometry, maxBounds, resolution)</span>
    } catch {
<span class="nc bnc" id="L160" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        logger.error(&quot;Error decomposing geometry, falling back to envelope bounds:&quot;, e)</span>
<span class="nc" id="L162">        Seq(bounds(geometry))</span>
    }
  }

  /**
    * Evaluates the complexity of a geometry. Will return true if the geometry is a point or
    * a rectangular polygon without interior holes.
    *
    * @param geometry geometry
    * @return
    */
<span class="nc" id="L173">  def isRectangular(geometry: Geometry): Boolean = geometry match {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    case _: Point   =&gt; true</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">    case p: Polygon =&gt; isRectangular(p)</span>
<span class="nc" id="L176">    case _ =&gt; false</span>
  }

  /**
    * Checks that a polygon is rectangular and has no interior holes
    *
    * @param p polygon
    * @return
    */
  def isRectangular(p: Polygon): Boolean = {
<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (p.isEmpty) {</span>
<span class="nc" id="L187">      true</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">    } else if (p.getNumInteriorRing != 0) {</span>
      // checks that there are no interior holes
<span class="nc" id="L190">      false</span>
    } else {
<span class="nc" id="L192">      val env = p.getEnvelopeInternal</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">      val (xmin, ymin, xmax, ymax) = (env.getMinX, env.getMinY, env.getMaxX, env.getMaxY)</span>

      // checks that all points are on the exterior envelope of the polygon
<span class="nc bnc" id="L196" title="All 8 branches missed.">      def cutout(c: Coordinate): Boolean = c.x != xmin &amp;&amp; c.x != xmax &amp;&amp; c.y != ymin &amp;&amp; c.y != ymax</span>

<span class="nc" id="L198">      val coords = p.getCoordinates // note: getCoordinates constructs an array so just call once</span>
<span class="nc" id="L199">      var i = 1</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      while (i &lt; coords.length) {</span>
<span class="nc" id="L201">        val c = coords(i)</span>
        // checks that there aren't any cutouts or angled lines
<span class="nc bnc" id="L203" title="All 6 branches missed.">        if (cutout(c) || (c.x != coords(i - 1).x &amp;&amp; c.y != coords(i - 1).y)) {</span>
<span class="nc" id="L204">          return false</span>
        }
<span class="nc" id="L206">        i += 1</span>
      }
      // check final coord cutout
<span class="nc bnc" id="L209" title="All 2 branches missed.">      !cutout(coords(0))</span>
    }
  }

  /**
    * This function checks if a segment crosses the IDL.
    * @param point1 The first point in the segment
    * @param point2 The second point in the segment
    * @return boolean true if the segment crosses the IDL, otherwise false
    */
  def crossesIDL(point1:Coordinate, point2:Coordinate): Boolean = {
<span class="nc bnc" id="L220" title="All 2 branches missed.">    Math.abs(point1.x - point2.x) &gt;= 180</span>
  }

  /**
    * Calculate the latitude at which the segment intercepts the IDL.
    * This function assumes that the provided points do actually cross the IDL.
    * @param point1 The first point in the segment
    * @param point2 The second point in the segment
    * @return a double representing the intercept latitude
    */
  def calcIDLIntercept(point1: Coordinate, point2: Coordinate): Double = {
<span class="nc bnc" id="L231" title="All 2 branches missed.">    if (point1.x &lt; 0) {</span>
<span class="nc" id="L232">      calcCrossLat(point1, new Coordinate(point2.x - 360, point2.y), -180)</span>
    } else {
<span class="nc" id="L234">      calcCrossLat(point1, new Coordinate(point2.x + 360, point2.y), 180)</span>
    }
  }

  /**
    * Calculate the latitude at which a segment intercepts a given latitude.
    * @param point1 The first point in the segment
    * @param point2 The second point in the segment
    * @param crossLon The longitude of intercept
    * @return a double representing the intercept latitude
    */
  def calcCrossLat(point1: Coordinate, point2: Coordinate, crossLon: Double): Double = {
<span class="nc" id="L246">    val slope = (point1.y - point2.y) / (point1.x - point2.x)</span>
<span class="nc" id="L247">    val intercept = point1.y - (slope * point1.x)</span>
<span class="nc" id="L248">    (slope * crossLon) + intercept</span>
  }

  /**
    * Split a bounding box envelope, which may extend outside [-180,180], into one or more envelopes
    * that are contained within [-180,180]
    *
    * @param envelope envelope of a bounding box
    * @return
    */
  def splitBoundingBox(envelope: ReferencedEnvelope): Seq[ReferencedEnvelope] = {
<span class="nc" id="L259">    try {</span>
<span class="nc" id="L260">      val crs = envelope.getCoordinateReferenceSystem</span>

      // if the bbox is completely outside world bounds, translate to bring it back in
<span class="nc bnc" id="L263" title="All 2 branches missed.">      val translated = if (envelope.getMinX &gt;= 180d) {</span>
<span class="nc" id="L264">        val multiplier = math.ceil((envelope.getMinX - 180d) / 360d)</span>
<span class="nc" id="L265">        val left = envelope.getMinX - 360d * multiplier</span>
<span class="nc" id="L266">        val right = envelope.getMaxX - 360d * multiplier</span>
<span class="nc" id="L267">        new ReferencedEnvelope(left, right, envelope.getMinY, envelope.getMaxY, crs)</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      } else if (envelope.getMaxX &lt;= -180d) {</span>
<span class="nc" id="L269">        val multiplier = math.ceil((envelope.getMaxX + 180d) / -360d)</span>
<span class="nc" id="L270">        val left = envelope.getMinX + 360d * multiplier</span>
<span class="nc" id="L271">        val right = envelope.getMaxX + 360d * multiplier</span>
<span class="nc" id="L272">        new ReferencedEnvelope(left, right, envelope.getMinY, envelope.getMaxY, crs)</span>
      } else {
<span class="nc" id="L274">        envelope</span>
      }

      // if the bbox extends past world bounds, split and wrap it
<span class="nc bnc" id="L278" title="All 4 branches missed.">      if (translated.getMinX &lt; -180d &amp;&amp; translated.getMaxX &lt; 180d) {</span>
<span class="nc" id="L279">        val trimmed = new ReferencedEnvelope(-180d , translated.getMaxX, envelope.getMinY, envelope.getMaxY, crs)</span>
<span class="nc" id="L280">        val wrapped = new ReferencedEnvelope(translated.getMinX + 360d , 180d, envelope.getMinY, envelope.getMaxY, crs)</span>
<span class="nc" id="L281">        Seq(trimmed, wrapped)</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">      } else if (translated.getMaxX &gt; 180d &amp;&amp; translated.getMinX &gt; -180d) {</span>
<span class="nc" id="L283">        val trimmed = new ReferencedEnvelope(translated.getMinX, 180d, envelope.getMinY, envelope.getMaxY, crs)</span>
<span class="nc" id="L284">        val wrapped = new ReferencedEnvelope(-180d, translated.getMaxX - 360d, envelope.getMinY, envelope.getMaxY, crs)</span>
<span class="nc" id="L285">        Seq(trimmed, wrapped)</span>
      } else {
<span class="nc" id="L287">        Seq(translated)</span>
      }
    } catch {
<span class="nc bnc" id="L290" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.warn(s&quot;Error splitting bounding box envelope '$envelope':&quot;, e); Seq(envelope)</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>