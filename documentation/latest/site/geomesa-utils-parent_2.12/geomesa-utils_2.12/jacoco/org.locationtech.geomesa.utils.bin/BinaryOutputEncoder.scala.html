<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BinaryOutputEncoder.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.bin</a> &gt; <span class="el_source">BinaryOutputEncoder.scala</span></div><h1>BinaryOutputEncoder.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.bin

import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.utils.bin.BinaryEncodeCallback.{ByteArrayCallback, ByteStreamCallback}
import org.locationtech.geomesa.utils.bin.BinaryOutputEncoder.ToValues
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec.ListAttributeSpec
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpecParser
import org.locationtech.jts.geom.{Geometry, LineString, Point}

import java.io.{ByteArrayOutputStream, OutputStream}
import java.nio.charset.StandardCharsets
import java.nio.{ByteBuffer, ByteOrder}
import java.util.Date
import scala.collection.JavaConverters._

<span class="nc" id="L27">class BinaryOutputEncoder private (toValues: ToValues) {</span>

  def encode(f: SimpleFeature): Array[Byte] = {
<span class="nc" id="L30">    toValues(f, ByteArrayCallback)</span>
<span class="nc" id="L31">    ByteArrayCallback.result</span>
  }

<span class="nc" id="L34">  def encode(f: SimpleFeature, callback: BinaryOutputCallback): Unit = toValues(f, callback)</span>

  def encode(f: Iterator[SimpleFeature], os: OutputStream): Long =
<span class="nc" id="L37">    encode(f, os, sort = false)</span>

  def encode(f: Iterator[SimpleFeature], os: OutputStream, sort: Boolean): Long = {
<span class="nc bnc" id="L40" title="All 2 branches missed.">    if (sort) {</span>
<span class="nc" id="L41">      val byteStream = new ByteArrayOutputStream</span>
<span class="nc" id="L42">      val callback = new ByteStreamCallback(byteStream)</span>
<span class="nc" id="L43">      f.foreach(toValues(_, callback))</span>
<span class="nc" id="L44">      val count = callback.result</span>
<span class="nc" id="L45">      val bytes = byteStream.toByteArray</span>
<span class="nc" id="L46">      val size = (bytes.length / count).toInt</span>
<span class="nc" id="L47">      bytes.grouped(size).toSeq.sorted(BinaryOutputEncoder.DateOrdering).foreach(os.write)</span>
<span class="nc" id="L48">      count</span>
    } else {
<span class="nc" id="L50">      val callback = new ByteStreamCallback(os)</span>
<span class="nc" id="L51">      f.foreach(toValues(_, callback))</span>
<span class="nc" id="L52">      callback.result</span>
    }
  }
}

<span class="nc bnc" id="L57" title="All 4 branches missed.">object BinaryOutputEncoder extends LazyLogging {</span>

  import AxisOrder._
  import org.locationtech.geomesa.utils.geotools.Conversions._
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L63">  val BinEncodedSft: SimpleFeatureType = SimpleFeatureTypes.createType(&quot;bin&quot;, &quot;bin:Bytes,*geom:Point:srid=4326&quot;)</span>
<span class="nc" id="L64">  val BIN_ATTRIBUTE_INDEX = 0 // index of 'bin' attribute in BinEncodedSft</span>

  // compares the 4 bytes representing the date in a bin array
<span class="nc" id="L67">  private val DateOrdering = new Ordering[Array[Byte]] {</span>
    override def compare(x: Array[Byte], y: Array[Byte]): Int = {
<span class="nc" id="L69">      val compare1 = Ordering.Byte.compare(x(4), y(4))</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">      if (compare1 != 0) { return compare1 }</span>
<span class="nc" id="L71">      val compare2 = Ordering.Byte.compare(x(5), y(5))</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">      if (compare2 != 0) { return compare2 }</span>
<span class="nc" id="L73">      val compare3 = Ordering.Byte.compare(x(6), y(6))</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">      if (compare3 != 0) { return compare3 }</span>
<span class="nc" id="L75">      Ordering.Byte.compare(x(7), y(7))</span>
    }
  }

<span class="nc bnc" id="L79" title="All 46 branches missed.">  case class EncodingOptions(geomField: Option[Int],</span>
<span class="nc" id="L80">                             dtgField: Option[Int],</span>
<span class="nc" id="L81">                             trackIdField: Option[Int],</span>
<span class="nc" id="L82">                             labelField: Option[Int] = None,</span>
<span class="nc" id="L83">                             axisOrder: Option[AxisOrder] = None)</span>

<span class="nc bnc" id="L85" title="All 26 branches missed.">  case class EncodedValues(trackId: Int, lat: Float, lon: Float, dtg: Long, label: Long)</span>

  /**
    * BIN queries pack multiple records into each feature. To count the records, we have to count
    * the total bytes coming back, instead of the number of features
    *
    * @param iter aggregated bin iter
    * @param maxFeatures max features
    * @param hasLabel bin results have labels (extended format) or not
    */
<span class="nc" id="L95">  class FeatureLimitingIterator(iter: CloseableIterator[SimpleFeature], maxFeatures: Int, hasLabel: Boolean)</span>
<span class="nc" id="L96">      extends CloseableIterator[SimpleFeature] {</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">    private val bytesPerHit = if (hasLabel) { 24 } else { 16 }</span>
<span class="nc" id="L99">    private var seen = 0L</span>

<span class="nc bnc" id="L101" title="All 4 branches missed.">    override def hasNext: Boolean = seen &lt; maxFeatures &amp;&amp; iter.hasNext</span>

    override def next(): SimpleFeature = {
<span class="nc bnc" id="L104" title="All 2 branches missed.">      if (hasNext) {</span>
<span class="nc" id="L105">        val sf = iter.next()</span>
<span class="nc" id="L106">        val bytes = sf.getAttribute(0).asInstanceOf[Array[Byte]]</span>
<span class="nc" id="L107">        val count = bytes.length / bytesPerHit</span>
<span class="nc" id="L108">        seen += count</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (seen &gt; maxFeatures) {</span>
          // remove the extra aggregated features so that we hit our exact feature limit
<span class="nc" id="L111">          val trimmed = Array.ofDim[Byte]((count - (seen - maxFeatures).toInt) * bytesPerHit)</span>
<span class="nc" id="L112">          System.arraycopy(bytes, 0, trimmed, 0, trimmed.length)</span>
<span class="nc" id="L113">          sf.setAttribute(0, trimmed)</span>
        }
<span class="nc" id="L115">        sf</span>
      } else {
<span class="nc" id="L117">        Iterator.empty.next()</span>
      }
    }

<span class="nc" id="L121">    override def close(): Unit = iter.close()</span>
  }

  def apply(sft: SimpleFeatureType, options: EncodingOptions): BinaryOutputEncoder =
<span class="nc" id="L125">    new BinaryOutputEncoder(toValues(sft, options))</span>

<span class="nc" id="L127">  def convertToTrack(f: SimpleFeature, i: Int): Int = convertToTrack(f.getAttribute(i))</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">  def convertToTrack(track: AnyRef): Int = if (track == null) { 0 } else { track.hashCode }</span>

  // TODO could use `.getDateAsLong` if we know we have a KryoBufferSimpleFeature
<span class="nc" id="L131">  def convertToDate(f: SimpleFeature, i: Int): Long = convertToDate(f.getAttribute(i).asInstanceOf[Date])</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">  def convertToDate(date: Date): Long = if (date == null) { 0L } else { date.getTime }</span>

<span class="nc" id="L134">  def convertToLabel(f: SimpleFeature, i: Int): Long = convertToLabel(f.getAttribute(i))</span>
<span class="nc" id="L135">  def convertToLabel(label: AnyRef): Long = label match {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    case null =&gt; 0L</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">    case n: Number =&gt; n.longValue()</span>
    case _ =&gt;
<span class="nc" id="L139">      var sum = 0L</span>
<span class="nc" id="L140">      var i = 0</span>
<span class="nc" id="L141">      label.toString.getBytes(StandardCharsets.UTF_8).iterator.take(8).foreach { b =&gt;</span>
<span class="nc" id="L142">        sum += (b &amp; 0xffL) &lt;&lt; (8 * i)</span>
<span class="nc" id="L143">        i += 1</span>
      }
<span class="nc" id="L145">      sum</span>
  }

  /**
    * Decodes a byte array
    *
    * @param encoded encoded byte array
    * @param callback callback for results
    */
  def decode(encoded: Array[Byte], callback: BinaryOutputCallback): Unit = {
<span class="nc" id="L155">    val buf = ByteBuffer.wrap(encoded).order(ByteOrder.LITTLE_ENDIAN)</span>
<span class="nc" id="L156">    val trackId = buf.getInt</span>
<span class="nc" id="L157">    val time = buf.getInt * 1000L</span>
<span class="nc" id="L158">    val lat = buf.getFloat</span>
<span class="nc" id="L159">    val lon = buf.getFloat</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">    if (encoded.length &gt; 16) {</span>
<span class="nc" id="L161">      val label = buf.getLong</span>
<span class="nc" id="L162">      callback(trackId, lat, lon, time, label)</span>
    } else {
<span class="nc" id="L164">      callback(trackId, lat, lon, time)</span>
    }
  }

  def decode(encoded: Array[Byte]): EncodedValues = {
<span class="nc" id="L169">    var values: EncodedValues = null</span>
<span class="nc" id="L170">    decode(encoded, new BinaryOutputCallback() {</span>
      override def apply(trackId: Int, lat: Float, lon: Float, dtg: Long): Unit =
<span class="nc" id="L172">        values = EncodedValues(trackId, lat, lon, dtg, -1L)</span>
      override def apply(trackId: Int, lat: Float, lon: Float, dtg: Long, label: Long): Unit =
<span class="nc" id="L174">        values = EncodedValues(trackId, lat, lon, dtg, label)</span>
    })
<span class="nc" id="L176">    values</span>
  }

  /**
    * Creates the function to map a simple feature to a bin-encoded buffer
    *
    * @param sft simple feature type
    * @param options encoding options
    * @return
    */
  private def toValues(sft: SimpleFeatureType, options: EncodingOptions): ToValues = {

<span class="nc" id="L188">    val geomIndex = options.geomField.getOrElse(sft.getGeomIndex)</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">    if (geomIndex == -1) {</span>
<span class="nc" id="L190">      throw new IllegalArgumentException(s&quot;Invalid geometry field requested for feature type ${sft.getTypeName}&quot;)</span>
    }
<span class="nc" id="L192">    val dtgIndex = options.dtgField.orElse(sft.getDtgIndex).getOrElse(-1)</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">    if (dtgIndex == -1) {</span>
<span class="nc" id="L194">      throw new RuntimeException(s&quot;Invalid date field requested for feature type ${sft.getTypeName}&quot;)</span>
    }
<span class="nc" id="L196">    val isSingleDate = classOf[Date].isAssignableFrom(sft.getDescriptor(dtgIndex).getType.getBinding)</span>
<span class="nc" id="L197">    val axisOrder = options.axisOrder.getOrElse(AxisOrder.LonLat)</span>

<span class="nc bnc" id="L199" title="All 2 branches missed.">    val (isPoint, isLineString) = {</span>
<span class="nc" id="L200">      val binding = sft.getDescriptor(geomIndex).getType.getBinding</span>
<span class="nc bnc" id="L201" title="All 12 branches missed.">      (binding == classOf[Point], binding == classOf[LineString])</span>
    }

    // noinspection ExistsEquals
<span class="nc bnc" id="L205" title="All 4 branches missed.">    if (options.trackIdField.exists(_ == -1)) {</span>
<span class="nc" id="L206">      throw new IllegalArgumentException(s&quot;Invalid track field requested for feature type ${sft.getTypeName}&quot;)</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">    } else if (options.labelField.exists(_ == -1)) {</span>
<span class="nc" id="L208">      throw new IllegalArgumentException(s&quot;Invalid label field requested for feature type ${sft.getTypeName}&quot;)</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">    } else if (!isSingleDate) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">      if (isLineString) {</span>
<span class="nc" id="L211">        val dtgField = sft.getDescriptor(dtgIndex).getLocalName</span>
<span class="nc" id="L212">        val sftAttributes = SimpleFeatureSpecParser.parse(SimpleFeatureTypes.encodeType(sft)).attributes</span>
<span class="nc bnc" id="L213" title="All 6 branches missed.">        sftAttributes.find(_.name == dtgField).foreach { spec =&gt;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">          if (!spec.isInstanceOf[ListAttributeSpec] ||</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                !classOf[Date].isAssignableFrom(spec.asInstanceOf[ListAttributeSpec].subClass)) {</span>
<span class="nc" id="L216">            throw new RuntimeException(s&quot;Invalid date field requested for feature type ${sft.getTypeName}&quot;)</span>
          }
        }
      } else {
<span class="nc" id="L220">        throw new RuntimeException(s&quot;Invalid date field requested for feature type ${sft.getTypeName}&quot;)</span>
      }
    }

    // gets the track id from a feature
<span class="nc" id="L225">    val getTrackId: (SimpleFeature) =&gt; Int = options.trackIdField match {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">      case None =&gt; (f) =&gt; f.getID.hashCode</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">      case Some(trackId) =&gt; convertToTrack(_, trackId)</span>
    }

    // gets the label from a feature
<span class="nc" id="L231">    val getLabelOption: Option[(SimpleFeature) =&gt; Long] = options.labelField.map { labelIndex =&gt;</span>
<span class="nc" id="L232">      convertToLabel(_, labelIndex)</span>
    }

<span class="nc bnc" id="L235" title="All 2 branches missed.">    if (isLineString) {</span>
      // for linestrings, we return each point - use an array so we get constant-time lookup
      // depending on srs requested and wfs versions, axis order can be flipped
<span class="nc" id="L238">      val getLineLatLon: (SimpleFeature) =&gt; Array[(Float, Float)] = axisOrder match {</span>
<span class="nc bnc" id="L239" title="All 6 branches missed.">        case LatLon =&gt; lineToXY(_, geomIndex)</span>
<span class="nc bnc" id="L240" title="All 6 branches missed.">        case LonLat =&gt; lineToYX(_, geomIndex)</span>
      }

<span class="nc bnc" id="L243" title="All 2 branches missed.">      if (isSingleDate) {</span>
<span class="nc" id="L244">        getLabelOption match {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">          case None =&gt; new ToValuesLines(getTrackId, getLineLatLon, dtgIndex)</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">          case Some(getLabel) =&gt; new ToValuesLinesLabels(getTrackId, getLineLatLon, getLabel, dtgIndex)</span>
        }
      } else {
        // for line strings, we need an array of dates corresponding to the points in the line
<span class="nc" id="L250">        val getLineDtg: (SimpleFeature) =&gt; Array[Long] = dateArray(_, dtgIndex)</span>
<span class="nc" id="L251">        getLabelOption match {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">          case None =&gt; new ToValuesLinesDates(getTrackId, getLineLatLon, getLineDtg)</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">          case Some(getLabel) =&gt; new ToValuesLinesDatesLabels(getTrackId, getLineLatLon, getLineDtg, getLabel)</span>
        }
      }
    } else {
      // get lat/lon as floats
      // depending on srs requested and wfs versions, axis order can be flipped
<span class="nc bnc" id="L259" title="All 8 branches missed.">      val getLatLon: (SimpleFeature) =&gt; (Float, Float) = (isPoint, axisOrder) match {</span>
<span class="nc bnc" id="L260" title="All 8 branches missed.">        case (true,  LatLon) =&gt; pointToXY(_, geomIndex)</span>
<span class="nc bnc" id="L261" title="All 8 branches missed.">        case (true,  LonLat) =&gt; pointToYX(_, geomIndex)</span>
<span class="nc bnc" id="L262" title="All 8 branches missed.">        case (false, LatLon) =&gt; geomToXY(_, geomIndex)</span>
<span class="nc bnc" id="L263" title="All 8 branches missed.">        case (false, LonLat) =&gt; geomToYX(_, geomIndex)</span>
      }

<span class="nc" id="L266">      getLabelOption match {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        case None =&gt; new ToValuesPoints(getTrackId, getLatLon, dtgIndex)</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        case Some(getLabel) =&gt; new ToValuesPointsLabels(getTrackId, getLatLon, getLabel, dtgIndex)</span>
      }
    }
  }

<span class="nc" id="L273">  private def pointToXY(p: Point): (Float, Float) = (p.getX.toFloat, p.getY.toFloat)</span>
<span class="nc" id="L274">  private def pointToYX(p: Point): (Float, Float) = (p.getY.toFloat, p.getX.toFloat)</span>

  private def pointToXY(f: SimpleFeature, i: Int): (Float, Float) =
<span class="nc" id="L277">    pointToXY(f.getAttribute(i).asInstanceOf[Point])</span>
  private def pointToYX(f: SimpleFeature, i: Int): (Float, Float) =
<span class="nc" id="L279">    pointToYX(f.getAttribute(i).asInstanceOf[Point])</span>

  private def geomToXY(f: SimpleFeature, i: Int): (Float, Float) =
<span class="nc" id="L282">    pointToXY(f.getAttribute(i).asInstanceOf[Geometry].safeCentroid())</span>
  private def geomToYX(f: SimpleFeature, i: Int): (Float, Float) =
<span class="nc" id="L284">    pointToYX(f.getAttribute(i).asInstanceOf[Geometry].safeCentroid())</span>

  private def lineToXY(f: SimpleFeature, i: Int): Array[(Float, Float)] = {
<span class="nc" id="L287">    val line = f.getAttribute(i).asInstanceOf[LineString]</span>
<span class="nc" id="L288">    Array.tabulate(line.getNumPoints)(i =&gt; pointToXY(line.getPointN(i)))</span>
  }
  private def lineToYX(f: SimpleFeature, i: Int): Array[(Float, Float)] = {
<span class="nc" id="L291">    val line = f.getAttribute(i).asInstanceOf[LineString]</span>
<span class="nc" id="L292">    Array.tabulate(line.getNumPoints)(i =&gt; pointToYX(line.getPointN(i)))</span>
  }

  private def dateArray(f: SimpleFeature, i: Int): Array[Long] = {
<span class="nc" id="L296">    val dates = f.getAttribute(i).asInstanceOf[java.util.List[Date]]</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">    if (dates == null) { Array.empty } else { dates.asScala.map(_.getTime).toArray }</span>
  }

  private trait ToValues {
    def apply(f: SimpleFeature, callback: BinaryOutputCallback): Unit
  }

<span class="nc" id="L304">  private class ToValuesPoints(getTrackId: (SimpleFeature) =&gt; Int,</span>
<span class="nc" id="L305">                               getLatLon: (SimpleFeature) =&gt; (Float, Float),</span>
<span class="nc" id="L306">                               dtgIndex: Int) extends ToValues {</span>
    override def apply(f: SimpleFeature, callback: BinaryOutputCallback): Unit = {
<span class="nc bnc" id="L308" title="All 2 branches missed.">      val (lat, lon) = getLatLon(f)</span>
<span class="nc" id="L309">      callback(getTrackId(f), lat, lon, convertToDate(f, dtgIndex))</span>
    }
  }

<span class="nc" id="L313">  private class ToValuesPointsLabels(getTrackId: (SimpleFeature) =&gt; Int,</span>
<span class="nc" id="L314">                                     getLatLon: (SimpleFeature) =&gt; (Float, Float),</span>
<span class="nc" id="L315">                                     getLabel: (SimpleFeature) =&gt; Long,</span>
<span class="nc" id="L316">                                     dtgIndex: Int) extends ToValues {</span>
    override def apply(f: SimpleFeature, callback: BinaryOutputCallback): Unit = {
<span class="nc bnc" id="L318" title="All 2 branches missed.">      val (lat, lon) = getLatLon(f)</span>
<span class="nc" id="L319">      callback(getTrackId(f), lat, lon, convertToDate(f, dtgIndex), getLabel(f))</span>
    }
  }

<span class="nc" id="L323">  private class ToValuesLines(getTrackId: (SimpleFeature) =&gt; Int,</span>
<span class="nc" id="L324">                              getLatLon: (SimpleFeature) =&gt; Array[(Float, Float)],</span>
<span class="nc" id="L325">                              dtgIndex: Int) extends ToValues {</span>
    override def apply(f: SimpleFeature, callback: BinaryOutputCallback): Unit = {
<span class="nc" id="L327">      val trackId = getTrackId(f)</span>
<span class="nc" id="L328">      val points = getLatLon(f)</span>
<span class="nc" id="L329">      val date = convertToDate(f, dtgIndex)</span>
<span class="nc" id="L330">      var i = 0</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">      while (i &lt; points.length) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        val (lat, lon) = points(i)</span>
<span class="nc" id="L333">        callback(trackId, lat, lon, date)</span>
<span class="nc" id="L334">        i += 1</span>
      }
    }
  }

<span class="nc" id="L339">  private class ToValuesLinesLabels(getTrackId: (SimpleFeature) =&gt; Int,</span>
<span class="nc" id="L340">                                    getLatLon: (SimpleFeature) =&gt; Array[(Float, Float)],</span>
<span class="nc" id="L341">                                    getLabel: (SimpleFeature) =&gt; Long,</span>
<span class="nc" id="L342">                                    dtgIndex: Int) extends ToValues {</span>
    override def apply(f: SimpleFeature, callback: BinaryOutputCallback): Unit = {
<span class="nc" id="L344">      val trackId = getTrackId(f)</span>
<span class="nc" id="L345">      val points = getLatLon(f)</span>
<span class="nc" id="L346">      val date = convertToDate(f, dtgIndex)</span>
<span class="nc" id="L347">      val label = getLabel(f)</span>
<span class="nc" id="L348">      var i = 0</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">      while (i &lt; points.length) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        val (lat, lon) = points(i)</span>
<span class="nc" id="L351">        callback(trackId, lat, lon, date, label)</span>
<span class="nc" id="L352">        i += 1</span>
      }
    }
  }

<span class="nc" id="L357">  private class ToValuesLinesDates(getTrackId: (SimpleFeature) =&gt; Int,</span>
<span class="nc" id="L358">                                   getLatLon: (SimpleFeature) =&gt; Array[(Float, Float)],</span>
<span class="nc" id="L359">                                   getLineDtg: (SimpleFeature) =&gt; Array[Long]) extends ToValues {</span>
    override def apply(f: SimpleFeature, callback: BinaryOutputCallback): Unit = {
<span class="nc" id="L361">      val trackId = getTrackId(f)</span>
<span class="nc" id="L362">      val points = getLatLon(f)</span>
<span class="nc" id="L363">      val dates = getLineDtg(f)</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">      val size = if (points.length == dates.length) { points.length } else {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        logger.warn(s&quot;Mismatched geometries and dates for simple feature $f: ${points.toList} ${dates.toList}&quot;)</span>
<span class="nc" id="L366">        math.min(points.length, dates.length)</span>
      }
<span class="nc" id="L368">      var i = 0</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">      while (i &lt; size) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        val (lat, lon) = points(i)</span>
<span class="nc" id="L371">        callback(trackId, lat, lon, dates(i))</span>
<span class="nc" id="L372">        i += 1</span>
      }
    }
  }

<span class="nc" id="L377">  private class ToValuesLinesDatesLabels(getTrackId: (SimpleFeature) =&gt; Int,</span>
<span class="nc" id="L378">                                         getLatLon: (SimpleFeature) =&gt; Array[(Float, Float)],</span>
<span class="nc" id="L379">                                         getLineDtg: (SimpleFeature) =&gt; Array[Long],</span>
<span class="nc" id="L380">                                         getLabel: (SimpleFeature) =&gt; Long) extends ToValues {</span>
    override def apply(f: SimpleFeature, callback: BinaryOutputCallback): Unit = {
<span class="nc" id="L382">      val trackId = getTrackId(f)</span>
<span class="nc" id="L383">      val points = getLatLon(f)</span>
<span class="nc" id="L384">      val dates = getLineDtg(f)</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">      val size = if (points.length == dates.length) { points.length } else {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        logger.warn(s&quot;Mismatched geometries and dates for simple feature $f: ${points.toList} ${dates.toList}&quot;)</span>
<span class="nc" id="L387">        math.min(points.length, dates.length)</span>
      }
<span class="nc" id="L389">      val label = getLabel(f)</span>
<span class="nc" id="L390">      var i = 0</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">      while (i &lt; size) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        val (lat, lon) = points(i)</span>
<span class="nc" id="L393">        callback(trackId, lat, lon, dates(i), label)</span>
<span class="nc" id="L394">        i += 1</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>