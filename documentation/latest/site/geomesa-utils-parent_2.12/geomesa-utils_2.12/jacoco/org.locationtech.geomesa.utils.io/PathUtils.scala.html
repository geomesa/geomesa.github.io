<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PathUtils.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.io</a> &gt; <span class="el_source">PathUtils.scala</span></div><h1>PathUtils.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.io

import com.typesafe.scalalogging.LazyLogging
import org.apache.commons.io.FilenameUtils
import org.locationtech.geomesa.utils.io.fs.FileSystemDelegate.FileHandle
import org.locationtech.geomesa.utils.io.fs.{FileSystemDelegate, LocalDelegate}

import java.io._
import java.net.URL
import java.nio.file._
import java.nio.file.attribute.BasicFileAttributes
import java.util.regex.Pattern
import scala.util.Try

<span class="nc bnc" id="L23" title="All 4 branches missed.">object PathUtils extends FileSystemDelegate with LazyLogging {</span>

<span class="nc" id="L25">  private val uriRegex = Pattern.compile(&quot;&quot;&quot;\w+://.*&quot;&quot;&quot;)</span>

<span class="nc" id="L27">  private val localDelegate = new LocalDelegate()</span>

  // delegate allows us to avoid a runtime dependency on hadoop
<span class="nc" id="L30">  private val hadoopDelegate: FileSystemDelegate =</span>
<span class="nc" id="L31">    try {</span>
      Class.forName(&quot;org.locationtech.geomesa.utils.hadoop.HadoopDelegate&quot;)
        .getDeclaredConstructor().newInstance().asInstanceOf[FileSystemDelegate]
    } catch {
      case _: Throwable =&gt; null
    }

<span class="nc" id="L38">  override def interpretPath(path: String): Seq[FileHandle] = chooseDelegate(path).interpretPath(path)</span>

<span class="nc" id="L40">  override def getHandle(path: String): FileHandle = chooseDelegate(path).getHandle(path)</span>

<span class="nc" id="L42">  override def getUrl(path: String): URL = chooseDelegate(path).getUrl(path)</span>

  /**
    * Checks to see if the path uses a URL pattern and then if it is *not* file://
    *
    * @param path Input resource path
    * @return     Whether or not the resource is remote.
    */
  def isRemote(path: String): Boolean =
<span class="nc bnc" id="L51" title="All 4 branches missed.">    uriRegex.matcher(path).matches() &amp;&amp; !path.toLowerCase.startsWith(&quot;file://&quot;)</span>

  /**
    * Returns the file extension, minus any compression that may be present
    *
    * @param path file path
    * @return
    */
  def getUncompressedExtension(path: String): String =
<span class="nc" id="L60">    FilenameUtils.getExtension(CompressionUtils.getUncompressedFilename(path))</span>

  /**
    * Gets the base file name and the extension. Useful for adding unique ids to a common file name,
    * while preserving the extension
    *
    * @param path path
    * @param includeDot if true, the '.' will be preserved in the extension, otherwise it will be dropped
    * @return (base name including path prefix, extension)
    */
<span class="nc" id="L70">  def getBaseNameAndExtension(path: String, includeDot: Boolean = true): (String, String) = {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">    def dotIndex(base: Int): Int = if (includeDot) { base } else { base + 1}</span>
<span class="nc" id="L72">    val split = FilenameUtils.indexOfExtension(path)</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">    if (split == -1) { (path, &quot;&quot;) } else {</span>
<span class="nc" id="L74">      val withoutExtension = path.substring(0, split)</span>
      // look for file names like 'foo.tar.gz'
<span class="nc" id="L76">      val secondSplit = FilenameUtils.indexOfExtension(withoutExtension)</span>
<span class="nc bnc" id="L77" title="All 4 branches missed.">      if (secondSplit != -1 &amp;&amp; CompressionUtils.isCompressedFilename(path)) {</span>
<span class="nc" id="L78">        (path.substring(0, secondSplit), path.substring(dotIndex(secondSplit)))</span>
      } else {
<span class="nc" id="L80">        (withoutExtension, path.substring(dotIndex(split)))</span>
      }
    }
  }

  /**
    * Wrap the input stream in a decompressor, if the file is compressed
    *
    * @param is input stream
    * @param filename filename (used to determine compression)
    * @return
    */
  def handleCompression(is: InputStream, filename: String): InputStream = {
<span class="nc" id="L93">    val buffered = new BufferedInputStream(is)</span>
<span class="nc" id="L94">    CompressionUtils.Utils.find(_.isCompressedFilename(filename)) match {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">      case None =&gt; buffered</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">      case Some(utils) =&gt; utils.decompress(buffered)</span>
    }
  }

  /**
    * Delete a path, including all children
    *
    * @param path path
    */
<span class="nc" id="L105">  def deleteRecursively(path: Path): Unit = Files.walkFileTree(path, new DeleteFileVisitor)</span>

  private def chooseDelegate(path: String): FileSystemDelegate =
<span class="nc bnc" id="L108" title="All 4 branches missed.">    if (hadoopDelegate != null &amp;&amp; uriRegex.matcher(path).matches()) { hadoopDelegate } else { localDelegate }</span>

  /**
    * File visitor to delete nested paths
    */
<span class="nc" id="L113">  class DeleteFileVisitor extends FileVisitor[Path] {</span>

<span class="nc" id="L115">    override def visitFileFailed(file: Path, exc: IOException): FileVisitResult = FileVisitResult.CONTINUE</span>

    override def visitFile(file: Path, attrs: BasicFileAttributes): FileVisitResult = {
<span class="nc bnc" id="L118" title="All 2 branches missed.">      if (!attrs.isDirectory) {</span>
<span class="nc" id="L119">        Files.delete(file)</span>
      }
<span class="nc" id="L121">      FileVisitResult.CONTINUE</span>
    }

<span class="nc" id="L124">    override def preVisitDirectory(dir: Path, attrs: BasicFileAttributes): FileVisitResult = FileVisitResult.CONTINUE</span>

    override def postVisitDirectory(dir: Path, exc: IOException): FileVisitResult = {
<span class="nc" id="L127">      Files.delete(dir)</span>
<span class="nc" id="L128">      FileVisitResult.CONTINUE</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>