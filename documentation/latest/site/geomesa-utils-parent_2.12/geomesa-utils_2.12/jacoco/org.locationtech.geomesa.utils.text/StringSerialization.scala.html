<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringSerialization.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.text</a> &gt; <span class="el_source">StringSerialization.scala</span></div><h1>StringSerialization.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.text

import com.typesafe.scalalogging.LazyLogging
import org.apache.commons.codec.binary.Hex
import org.apache.commons.csv.{CSVFormat, CSVParser, CSVPrinter}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.utils.io.WithClose

import java.nio.charset.StandardCharsets
import java.time.format.DateTimeFormatter
import java.time.{ZoneOffset, ZonedDateTime}
import java.util.regex.Pattern
import java.util.{Date, Locale}

<span class="nc bnc" id="L23" title="All 4 branches missed.">object StringSerialization extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L27">  private val dateFormat: DateTimeFormatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME.withZone(ZoneOffset.UTC)</span>

<span class="nc" id="L29">  private val AlphaNumericPattern = Pattern.compile(&quot;^[a-zA-Z0-9]+$&quot;)</span>
<span class="nc" id="L30">  private val AlphaNumeric = ('a' to 'z') ++ ('A' to 'Z') ++ ('0' to '9')</span>

  /**
    * Encode a sequence of string values to a single string
    *
    * @param values values
    * @return
    */
  def encodeSeq(values: Seq[String]): String = {
<span class="nc bnc" id="L39" title="All 2 branches missed.">    if (values.isEmpty) { &quot;&quot; } else {</span>
<span class="nc" id="L40">      val sb = new java.lang.StringBuilder()</span>
<span class="nc" id="L41">      val printer = new CSVPrinter(sb, CSVFormat.DEFAULT)</span>
<span class="nc" id="L42">      values.foreach(printer.print)</span>
<span class="nc" id="L43">      sb.toString</span>
    }
  }

  /**
    * Recover a sequence of string values encoded with `encodedSeq`
    *
    * @param values encoded string
    * @return
    */
  def decodeSeq(values: String): Seq[String] = {
<span class="nc bnc" id="L54" title="All 2 branches missed.">    if (values.isEmpty) { Seq.empty } else {</span>
<span class="nc" id="L55">      WithClose(CSVParser.parse(values, CSVFormat.DEFAULT))(_.iterator.next.iterator.asScala.toList)</span>
    }
  }

  /**
    * Encode a map of string values to a single string
    *
    * @param values values
    * @return
    */
  def encodeMap(values: scala.collection.Map[String, String]): String =
<span class="nc bnc" id="L66" title="All 2 branches missed.">    encodeSeq(values.toSeq.flatMap { case (k, v) =&gt; Seq(k, v) })</span>

  /**
    * Recover a map of string values encoded with `encodedMap`
    *
    * @param values encoded string
    * @return
    */
  def decodeMap(values: String): Map[String, String] =
<span class="nc bnc" id="L75" title="All 6 branches missed.">    decodeSeq(values).grouped(2).map { case Seq(k, v) =&gt; k -&gt; v }.toMap</span>

  /**
    * Encode a map of sequences as a string
    *
    * @param map map of keys to sequences of values
    * @return
    */
  def encodeSeqMap(map: Map[String, Seq[AnyRef]]): String = {
<span class="nc" id="L84">    val sb = new java.lang.StringBuilder</span>
<span class="nc" id="L85">    val printer = new CSVPrinter(sb, CSVFormat.DEFAULT)</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    map.foreach { case (k, v) =&gt;</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">      val strings = v.headOption match {</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        case Some(_: Date) =&gt; v.map(d =&gt; ZonedDateTime.ofInstant(d.asInstanceOf[Date].toInstant, ZoneOffset.UTC).format(dateFormat))</span>
<span class="nc" id="L89">        case _ =&gt; v</span>
      }
<span class="nc" id="L91">      printer.print(k)</span>
<span class="nc" id="L92">      strings.foreach(printer.print)</span>
<span class="nc" id="L93">      printer.println()</span>
    }
<span class="nc" id="L95">    sb.toString</span>
  }


  /**
    * Decode a map of sequences from a string encoded by @see encodeSeqMap
    *
    * @param encoded encoded map
    * @return decoded map
    */
  def decodeSeqMap(sft: SimpleFeatureType, encoded: String): Map[String, Array[AnyRef]] = {
<span class="nc" id="L106">    val bindings = sft.getAttributeDescriptors.asScala.map(d =&gt; d.getLocalName -&gt; d.getType.getBinding)</span>
<span class="nc" id="L107">    decodeSeqMap(encoded, bindings.toMap[String, Class[_]])</span>
  }

  /**
    * Decode a map of sequences from a string encoded by @see encodeSeqMap
    *
    * @param encoded encoded map
    * @return decoded map
    */
  def decodeSeqMap(encoded: String, bindings: Map[String, Class[_]]): Map[String, Array[AnyRef]] = {
    // encoded as CSV, first element of each row is key, rest is value
<span class="nc" id="L118">    WithClose(CSVParser.parse(encoded, CSVFormat.DEFAULT)) { parser =&gt;</span>
<span class="nc" id="L119">      parser.iterator.asScala.map { record =&gt;</span>
<span class="nc" id="L120">        val iter = record.iterator.asScala</span>
<span class="nc" id="L121">        val key = iter.next</span>
<span class="nc" id="L122">        val values = bindings.get(key) match {</span>
<span class="nc bnc" id="L123" title="All 8 branches missed.">          case Some(c) if c == classOf[String]              =&gt; iter.toArray[AnyRef]</span>
<span class="nc bnc" id="L124" title="All 8 branches missed.">          case Some(c) if c == classOf[Integer]             =&gt; iter.map(Integer.valueOf).toArray[AnyRef]</span>
<span class="nc bnc" id="L125" title="All 8 branches missed.">          case Some(c) if c == classOf[java.lang.Long]      =&gt; iter.map(java.lang.Long.valueOf).toArray[AnyRef]</span>
<span class="nc bnc" id="L126" title="All 8 branches missed.">          case Some(c) if c == classOf[java.lang.Float]     =&gt; iter.map(java.lang.Float.valueOf).toArray[AnyRef]</span>
<span class="nc bnc" id="L127" title="All 8 branches missed.">          case Some(c) if c == classOf[java.lang.Double]    =&gt; iter.map(java.lang.Double.valueOf).toArray[AnyRef]</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">          case Some(c) if classOf[Date].isAssignableFrom(c) =&gt; iter.map(v =&gt; Date.from(ZonedDateTime.parse(v, dateFormat).toInstant)).toArray[AnyRef]</span>
<span class="nc bnc" id="L129" title="All 8 branches missed.">          case Some(c) if c == classOf[java.lang.Boolean]   =&gt; iter.map(java.lang.Boolean.valueOf).toArray[AnyRef]</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">          case c =&gt; logger.warn(s&quot;No conversion defined for encoded attribute '$key' of type ${c.orNull}&quot;); iter.toArray[AnyRef]</span>
        }
<span class="nc" id="L132">        key -&gt; values</span>
<span class="nc" id="L133">      }.toMap</span>
    }
  }

  /**
    * Encode non-alphanumeric characters in a string with
    * underscore plus hex digits representing the bytes. Note
    * that multibyte characters will be represented with multiple
    * underscores and bytes...e.g. _8a_2f_3b
    */
  def alphaNumericSafeString(input: String): String = {
<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (AlphaNumericPattern.matcher(input).matches()) { input } else {</span>
<span class="nc" id="L145">      val sb = new StringBuilder</span>
<span class="nc" id="L146">      input.foreach { c =&gt;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (AlphaNumeric.contains(c)) { sb.append(c) } else {</span>
<span class="nc" id="L148">          val hex = Hex.encodeHex(c.toString.getBytes(StandardCharsets.UTF_8))</span>
<span class="nc" id="L149">          val encoded = hex.grouped(2).map(arr =&gt; &quot;_&quot; + arr(0) + arr(1)).mkString.toLowerCase(Locale.US)</span>
<span class="nc" id="L150">          sb.append(encoded)</span>
        }
      }
<span class="nc" id="L153">      sb.toString()</span>
    }
  }

  def decodeAlphaNumericSafeString(input: String): String = {
<span class="nc bnc" id="L158" title="All 2 branches missed.">    if (AlphaNumericPattern.matcher(input).matches()) { input } else {</span>
<span class="nc" id="L159">      val sb = new StringBuilder</span>
<span class="nc" id="L160">      var i = 0</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">      while (i &lt; input.length) {</span>
<span class="nc" id="L162">        val c = input.charAt(i)</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (c != '_') { sb.append(c) } else {</span>
<span class="nc" id="L164">          i += 2</span>
<span class="nc" id="L165">          sb.append(new String(Hex.decodeHex(Array(input.charAt(i - 1), input.charAt(i))), StandardCharsets.UTF_8))</span>
        }
<span class="nc" id="L167">        i += 1</span>
      }
<span class="nc" id="L169">      sb.toString()</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>