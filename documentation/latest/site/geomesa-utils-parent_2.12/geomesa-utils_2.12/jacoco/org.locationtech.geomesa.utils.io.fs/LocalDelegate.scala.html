<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalDelegate.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.io.fs</a> &gt; <span class="el_source">LocalDelegate.scala</span></div><h1>LocalDelegate.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.io.fs

import com.typesafe.scalalogging.LazyLogging
import org.apache.commons.compress.archivers.zip.ZipFile
import org.apache.commons.compress.archivers.{ArchiveEntry, ArchiveInputStream, ArchiveStreamFactory}
import org.apache.commons.io.input.CloseShieldInputStream
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.io.fs.FileSystemDelegate.{CreateMode, FileHandle}
import org.locationtech.geomesa.utils.io.fs.LocalDelegate.{LocalFileHandle, LocalTarHandle, LocalZipHandle}
import org.locationtech.geomesa.utils.io.{CopyingInputStream, PathUtils, WithClose}

import java.io._
import java.net.URL
import java.nio.file._
import java.nio.file.attribute.BasicFileAttributes
import java.util.Locale
import scala.collection.mutable.ArrayBuffer
import scala.util.Try

<span class="nc bnc" id="L28" title="All 4 branches missed.">class LocalDelegate extends FileSystemDelegate with LazyLogging {</span>

  import ArchiveStreamFactory.{JAR, TAR, ZIP}

  import scala.collection.JavaConverters._

<span class="nc" id="L34">  override def getHandle(path: String): FileHandle = createHandle(new File(path))</span>

  override def interpretPath(path: String): Seq[FileHandle] = {
<span class="nc" id="L37">    val firstWildcard = path.indexOf('*')</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">    if (firstWildcard == -1) {</span>
<span class="nc" id="L39">      val file = new File(path)</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">      if (file.isDirectory) {</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">        logger.warn(s&quot;Input file is a directory: ${file.getAbsolutePath}&quot;)</span>
<span class="nc" id="L42">        Seq.empty</span>
      } else {
<span class="nc" id="L44">        Seq(createHandle(file))</span>
      }
    } else {
      // find the base directory to search from based on the non-wildcard prefix
<span class="nc" id="L48">      val lastSep = path.length - 1 - path.reverse.indexOf('/', path.length - firstWildcard - 1)</span>
<span class="nc bnc" id="L49" title="All 4 branches missed.">      val (basepath, glob) = if (lastSep == path.length) {</span>
<span class="nc" id="L50">        (new File(&quot;.&quot;).toPath, path)</span>
      } else {
<span class="nc" id="L52">        (new File(path.substring(0, lastSep)).toPath, path.substring(lastSep + 1))</span>
      }
<span class="nc bnc" id="L54" title="All 4 branches missed.">      if (glob.indexOf('/') == -1 &amp;&amp; !glob.contains(&quot;**&quot;)) {</span>
        // we can just look in the current directory
<span class="nc" id="L56">        WithClose(Files.newDirectoryStream(basepath, glob)) { stream =&gt;</span>
<span class="nc" id="L57">          stream.asScala.toList.flatMap{ p =&gt;</span>
<span class="nc" id="L58">            val file = p.toFile</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">            if (file.isDirectory) { Nil } else { List(createHandle(file)) }</span>
          }
        }
      } else {
        // we have to walk the file tree
<span class="nc" id="L64">        val matcher = FileSystems.getDefault.getPathMatcher(&quot;glob:&quot; + glob)</span>
<span class="nc" id="L65">        val result = ArrayBuffer.empty[FileHandle]</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        val visitor = new SimpleFileVisitor[Path] {</span>
          override def visitFile(file: Path, attributes: BasicFileAttributes): FileVisitResult = {
<span class="nc bnc" id="L68" title="All 6 branches missed.">            if (matcher.matches(file) &amp;&amp; attributes.isRegularFile &amp;&amp; !attributes.isDirectory) {</span>
<span class="nc" id="L69">              result += createHandle(file.toFile)</span>
            }
<span class="nc" id="L71">            FileVisitResult.CONTINUE</span>
          }
        }
<span class="nc" id="L74">        Files.walkFileTree(basepath, visitor)</span>
<span class="nc" id="L75">        result.toSeq</span>
      }
    }
  }

<span class="nc" id="L80">  override def getUrl(path: String): URL = new File(path).toURI.toURL</span>

  private def createHandle(file: File): FileHandle = {
<span class="nc" id="L83">    PathUtils.getUncompressedExtension(file.getName).toLowerCase(Locale.US) match {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      case TAR       =&gt; new LocalTarHandle(file)</span>
<span class="nc bnc" id="L85" title="All 6 branches missed.">      case ZIP | JAR =&gt; new LocalZipHandle(file)</span>
<span class="nc" id="L86">      case _         =&gt; new LocalFileHandle(file)</span>
    }
  }
}

<span class="nc" id="L91">object LocalDelegate {</span>

<span class="nc" id="L93">  private val factory = new ArchiveStreamFactory()</span>

<span class="nc bnc" id="L95" title="All 4 branches missed.">  class LocalFileHandle(file: File) extends FileHandle {</span>

<span class="nc" id="L97">    override def path: String = file.getAbsolutePath</span>

<span class="nc" id="L99">    override def exists: Boolean = file.exists()</span>

<span class="nc" id="L101">    override def length: Long = file.length()</span>

    override def open: CloseableIterator[(Option[String], InputStream)] = {
<span class="nc" id="L104">      val is = PathUtils.handleCompression(new FileInputStream(file), file.getName)</span>
<span class="nc" id="L105">      CloseableIterator.single(None -&gt; is, is.close())</span>
    }

<span class="nc" id="L108">    override def write(mode: CreateMode): OutputStream = {</span>
<span class="nc" id="L109">      mode.validate()</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">      if (file.exists()) {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (mode.append) {</span>
<span class="nc" id="L112">          new FileOutputStream(file, true)</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        } else if (mode.overwrite) {</span>
<span class="nc" id="L114">          new FileOutputStream(file, false)</span>
        } else {
          // due to validation, must be mode.create
<span class="nc" id="L117">          throw new FileAlreadyExistsException(s&quot;File already exists for mode 'create': $path&quot;)</span>
        }
<span class="nc bnc" id="L119" title="All 2 branches missed.">      } else if (!mode.create) {</span>
<span class="nc" id="L120">        throw new FileNotFoundException(s&quot;File does not exist: $path&quot;)</span>
      } else {
<span class="nc" id="L122">        val parent = file.getParentFile</span>
<span class="nc bnc" id="L123" title="All 6 branches missed.">        if (parent != null &amp;&amp; !parent.exists() &amp;&amp; !parent.mkdirs()) {</span>
<span class="nc" id="L124">          throw new IOException(s&quot;Parent file does not exist and could not be created: $path&quot;)</span>
        }
<span class="nc" id="L126">        new FileOutputStream(file)</span>
      }
    }

    override def delete(recursive: Boolean): Unit = {
<span class="nc bnc" id="L131" title="All 2 branches missed.">      if (recursive) {</span>
<span class="nc" id="L132">        PathUtils.deleteRecursively(file.toPath)</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">      } else if (!file.delete()) {</span>
<span class="nc" id="L134">        throw new IOException(s&quot;Could not delete file: $path&quot;)</span>
      }
    }
  }

<span class="nc" id="L139">  class LocalZipHandle(file: File) extends LocalFileHandle(file) {</span>
    override def open: CloseableIterator[(Option[String], InputStream)] =
<span class="nc" id="L141">      new ZipFileIterator(new ZipFile(file), file.getAbsolutePath)</span>
    override def write(mode: CreateMode): OutputStream =
<span class="nc" id="L143">      factory.createArchiveOutputStream(ArchiveStreamFactory.ZIP, super.write(mode))</span>
  }

<span class="nc" id="L146">  class LocalTarHandle(file: File) extends LocalFileHandle(file) {</span>
    override def open: CloseableIterator[(Option[String], InputStream)] = {
<span class="nc" id="L148">      val uncompressed = PathUtils.handleCompression(new FileInputStream(file), file.getName)</span>
      val archive: ArchiveInputStream[_ &lt;: ArchiveEntry] =
<span class="nc" id="L150">        factory.createArchiveInputStream(ArchiveStreamFactory.TAR, uncompressed)</span>
<span class="nc" id="L151">      new ArchiveFileIterator(archive, file.getAbsolutePath)</span>
    }
    override def write(mode: CreateMode): OutputStream =
<span class="nc" id="L154">      factory.createArchiveOutputStream(ArchiveStreamFactory.TAR, super.write(mode))</span>
  }

<span class="nc bnc" id="L157" title="All 4 branches missed.">  private class StdInHandle(in: InputStream) extends FileHandle {</span>
<span class="nc" id="L158">    override def path: String = &quot;&lt;stdin&gt;&quot;</span>
<span class="nc" id="L159">    override def exists: Boolean = false</span>
<span class="nc" id="L160">    override def length: Long = Try(in.available().toLong).getOrElse(0L) // .available will throw if stream is closed</span>
    override def open: CloseableIterator[(Option[String], InputStream)] =
<span class="nc" id="L162">      CloseableIterator.single(None -&gt; CloseShieldInputStream.wrap(in))</span>
<span class="nc" id="L163">    override def write(mode: CreateMode): OutputStream = System.out</span>
<span class="nc" id="L164">    override def delete(recursive: Boolean): Unit = {}</span>
  }

<span class="nc" id="L167">  object StdInHandle {</span>
    // hook to allow for unit testing stdin
<span class="nc" id="L169">    val SystemIns: ThreadLocal[InputStream] = new ThreadLocal[InputStream]() {</span>
<span class="nc" id="L170">      override def initialValue(): InputStream = System.in</span>
    }
<span class="nc" id="L172">    def get(): FileHandle = new StdInHandle(SystemIns.get)</span>
    // avoid hanging if there isn't any input
<span class="nc bnc" id="L174" title="All 2 branches missed.">    def available(): Option[FileHandle] = if (isAvailable) { Some(get()) } else { None }</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">    def isAvailable: Boolean = SystemIns.get.available() &gt; 0</span>
  }

  // A class that caches any bytes read from the stdin input stream
<span class="nc" id="L179">  private class CachingStdInHandle(in: InputStream) extends StdInHandle(in) {</span>
<span class="nc" id="L180">    private val is = new CopyingInputStream(in, 1024)</span>
<span class="nc" id="L181">    private var cachedBytes: Array[Byte] = Array.empty</span>

<span class="nc" id="L183">    override def length: Long = super.length + cachedBytes.length</span>

    override def open: CloseableIterator[(Option[String], InputStream)] =
<span class="nc" id="L186">      CloseableIterator.single(None -&gt; new CopyOnClose())</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">    private class CopyOnClose</span>
<span class="nc" id="L189">        extends SequenceInputStream(new ByteArrayInputStream(cachedBytes), CloseShieldInputStream.wrap(is)) {</span>
      override def close(): Unit = {
<span class="nc" id="L191">        try { super.close() } finally {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">          if (is.copied &gt; 0) {</span>
<span class="nc" id="L193">            cachedBytes ++= is.replay(is.copied)</span>
          }
        }
      }
    }
  }

<span class="nc" id="L200">  object CachingStdInHandle {</span>
<span class="nc" id="L201">    def get(): FileHandle = new CachingStdInHandle(StdInHandle.SystemIns.get)</span>
    // avoid hanging if there isn't any input
<span class="nc bnc" id="L203" title="All 2 branches missed.">    def available(): Option[FileHandle] = if (isAvailable) { Some(get()) } else { None }</span>
<span class="nc" id="L204">    def isAvailable: Boolean = StdInHandle.isAvailable</span>
  }
<span class="nc" id="L206">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>