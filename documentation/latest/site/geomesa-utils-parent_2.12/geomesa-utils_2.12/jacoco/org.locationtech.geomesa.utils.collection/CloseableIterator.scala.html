<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CloseableIterator.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.collection</a> &gt; <span class="el_source">CloseableIterator.scala</span></div><h1>CloseableIterator.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.collection

import org.geotools.api.data.FeatureReader
import org.geotools.api.feature.Feature
import org.geotools.api.feature.`type`.FeatureType
import org.geotools.api.feature.simple.SimpleFeature
import org.geotools.feature.FeatureIterator
import org.locationtech.geomesa.utils.collection.CloseableIterator.{CloseableIteratorImpl, ConcatCloseableIterator, FlatMapCloseableIterator}
import org.locationtech.geomesa.utils.io.CloseQuietly

import java.io.Closeable
import scala.annotation.tailrec
import scala.collection.{GenTraversableOnce, Iterator}

/**
 * A CloseableIterator is an iterator that should be closed after use
 */
<span class="nc" id="L26">object CloseableIterator {</span>

<span class="nc" id="L28">  private val empty: CloseableIterator[Nothing] = apply(Iterator.empty)</span>

  // This apply method provides us with a simple interface for creating new CloseableIterators.
  def apply[A](iter: Iterator[A]): CloseableIterator[A] =
<span class="nc bnc" id="L32" title="All 4 branches missed.">    new CloseableIteratorImpl[A](iter, Option(iter).collect { case c: Closeable =&gt; c.close() })</span>

  // This apply method provides us with a simple interface for creating new CloseableIterators.
<span class="nc" id="L35">  def apply[A](iter: Iterator[A], close: =&gt; Unit): CloseableIterator[A] = new CloseableIteratorImpl[A](iter, close)</span>

  // for wrapping java iterators
  def apply[A](iter: java.util.Iterator[A]): CloseableIterator[A] =
<span class="nc bnc" id="L39" title="All 4 branches missed.">    new CloseableIteratorJavaWrapper[A](iter, Option(iter).collect { case c: Closeable =&gt; c.close() })</span>

  // This apply method provides us with a simple interface for creating new CloseableIterators.
  def apply[A &lt;: Feature, B &lt;: FeatureType](iter: FeatureReader[B, A]): CloseableIterator[A] =
<span class="nc" id="L43">    new CloseableFeatureReaderIterator(iter)</span>

<span class="nc" id="L45">  def apply(iter: FeatureIterator[SimpleFeature]): CloseableIterator[SimpleFeature] = new CloseableFeatureIterator(iter)</span>

<span class="nc" id="L47">  def single[A](elem: A, close: =&gt; Unit = ()): CloseableIterator[A] = new CloseableSingleIterator(elem, close)</span>

<span class="nc" id="L49">  def fill[A](length: Int, close: =&gt; Unit = ())(elem: =&gt; A): CloseableIterator[A] =</span>
<span class="nc" id="L50">    new CloseableIteratorImpl(Iterator.fill(length)(elem), close)</span>

<span class="nc" id="L52">  def empty[A]: CloseableIterator[A] = empty</span>

<span class="nc" id="L54">  def wrap[A](t: GenTraversableOnce[A]): CloseableIterator[A] = t match {</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">    case c: CloseableIterator[A] =&gt; c</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    case c: Closeable =&gt; CloseableIterator(t.toIterator, c.close())</span>
<span class="nc" id="L57">    case c =&gt; new CloseableIteratorImpl(c.toIterator, ())</span>
  }

<span class="nc" id="L60">  private class CloseableIteratorImpl[A](iter: Iterator[A], closeIter: =&gt; Unit) extends CloseableIterator[A] {</span>
<span class="nc" id="L61">    override def hasNext: Boolean = iter.hasNext</span>
<span class="nc" id="L62">    override def next(): A = iter.next()</span>
<span class="nc" id="L63">    override def close(): Unit = closeIter</span>
  }

<span class="nc" id="L66">  private class CloseableIteratorJavaWrapper[A](iter: java.util.Iterator[A], closeIter: =&gt; Unit) extends CloseableIterator[A] {</span>
<span class="nc" id="L67">    override def hasNext: Boolean = iter.hasNext</span>
<span class="nc" id="L68">    override def next(): A = iter.next()</span>
<span class="nc" id="L69">    override def close(): Unit = closeIter</span>
  }

<span class="nc" id="L72">  private final class CloseableFeatureReaderIterator[A &lt;: Feature, B &lt;: FeatureType](iter: FeatureReader[B, A])</span>
<span class="nc" id="L73">      extends CloseableIterator[A] {</span>
<span class="nc" id="L74">    override def hasNext: Boolean = iter.hasNext</span>
<span class="nc" id="L75">    override def next(): A = iter.next()</span>
<span class="nc" id="L76">    override def close(): Unit = iter.close()</span>
  }

<span class="nc" id="L79">  private final class CloseableFeatureIterator(iter: FeatureIterator[SimpleFeature])</span>
<span class="nc" id="L80">      extends CloseableIterator[SimpleFeature] {</span>
<span class="nc" id="L81">    override def hasNext: Boolean = iter.hasNext</span>
<span class="nc" id="L82">    override def next(): SimpleFeature  = iter.next()</span>
<span class="nc" id="L83">    override def close(): Unit = iter.close()</span>
  }

<span class="nc" id="L86">  private final class CloseableSingleIterator[A](elem: =&gt; A, closeIter: =&gt; Unit) extends CloseableIterator[A] {</span>
<span class="nc" id="L87">    private var result = true</span>
<span class="nc" id="L88">    override def hasNext: Boolean = result</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    override def next(): A = if (result) { result = false; elem } else { empty.next() }</span>
<span class="nc" id="L90">    override def close(): Unit = closeIter</span>
  }

  /**
    * Based on scala's ++ iterator implementation
    *
    * Avoid stack overflows when applying ++ to lots of iterators by flattening the unevaluated
    * iterators out into a vector of closures.
    */
<span class="nc" id="L99">  private final class ConcatCloseableIterator[+A](queue: scala.collection.mutable.Queue[() =&gt; CloseableIterator[A]])</span>
<span class="nc" id="L100">      extends CloseableIterator[A] {</span>

<span class="nc" id="L102">    private [this] var current: CloseableIterator[A] = queue.dequeue()()</span>

    // Advance current to the next non-empty iterator
    // current is set to empty when all iterators are exhausted
    @tailrec
    private [this] def advance(): Boolean = {
<span class="nc" id="L108">      current.close()</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (queue.isEmpty) {</span>
<span class="nc" id="L110">        current = CloseableIterator.empty</span>
<span class="nc" id="L111">        false</span>
      } else {
<span class="nc" id="L113">        current = queue.dequeue()()</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        current.hasNext || advance()</span>
      }
    }

<span class="nc bnc" id="L118" title="All 4 branches missed.">    override def hasNext: Boolean = current.hasNext || advance()</span>
<span class="nc" id="L119">    override def next(): A = current.next</span>

    override def close(): Unit = {
<span class="nc" id="L122">      current.close()</span>
<span class="nc" id="L123">      queue.foreach(_.apply().close())</span>
<span class="nc" id="L124">      queue.clear()</span>
    }
  }

<span class="nc" id="L128">  private final class FlatMapCloseableIterator[A, B](source: CloseableIterator[A], f: A =&gt; GenTraversableOnce[B])</span>
<span class="nc" id="L129">      extends CloseableIterator[B] {</span>

<span class="nc" id="L131">    private var cur: CloseableIterator[B] = empty</span>

    @tailrec
<span class="nc bnc" id="L134" title="All 2 branches missed.">    override def hasNext: Boolean = cur.hasNext || {</span>
<span class="nc" id="L135">      cur.close()</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">      if (source.hasNext) {</span>
<span class="nc" id="L137">        cur = CloseableIterator.wrap(f(source.next()))</span>
<span class="nc" id="L138">        hasNext</span>
      } else {
<span class="nc" id="L140">        cur = empty</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        false</span>
      }
    }

<span class="nc bnc" id="L145" title="All 2 branches missed.">    override def next(): B = if (hasNext) { cur.next() } else { empty.next() }</span>

<span class="nc" id="L147">    override def close(): Unit = CloseQuietly(cur, source).foreach(f =&gt; throw f)</span>
  }
}

/**
 * An iterator that should be closed after use.
 *
 * For convenience, some methods that consume the iterator will automatically close the iterator when invoked:
 *
 * &lt;ul&gt;
 * &lt;li&gt;`toList`&lt;/li&gt;
 * &lt;li&gt;`foreach`&lt;/li&gt;
 * &lt;li&gt;`size`&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Note that other methods (for example, `length`) may end up invoking these methods, due to the internal implementation of
 * collections.
 *
 * @tparam A iterator values
 */
<span class="nc" id="L167">trait CloseableIterator[+A] extends Iterator[A] with Closeable {</span>

  // note: in scala 2.12, toList ends up calling foreach, which closes the iterator
  // override def toList: List[A] = try { super.toList } finally { close() }

<span class="nc" id="L172">  override def foreach[U](f: A =&gt; U): Unit = try { super.foreach(f) } finally { close() }</span>

<span class="nc" id="L174">  override def size: Int =  try { super.size } finally { close() }</span>

<span class="nc" id="L176">  override def map[B](f: A =&gt; B): CloseableIterator[B] = new CloseableIteratorImpl(super.map(f), close())</span>

<span class="nc" id="L178">  override def filter(p: A =&gt; Boolean): CloseableIterator[A] = new CloseableIteratorImpl(super.filter(p), close())</span>

<span class="nc" id="L180">  override def withFilter(p: A =&gt; Boolean): CloseableIterator[A] = filter(p)</span>

<span class="nc" id="L182">  override def filterNot(p: A =&gt; Boolean): CloseableIterator[A] = new CloseableIteratorImpl(super.filterNot(p), close())</span>

<span class="nc" id="L184">  override def take(n: Int): CloseableIterator[A] = new CloseableIteratorImpl(super.take(n), close())</span>

<span class="nc" id="L186">  override def takeWhile(p: A =&gt; Boolean): CloseableIterator[A] = new CloseableIteratorImpl(super.takeWhile(p), close())</span>

<span class="nc" id="L188">  override def drop(n: Int): CloseableIterator[A] = new CloseableIteratorImpl(super.drop(n), close())</span>

<span class="nc" id="L190">  override def dropWhile(p: A =&gt; Boolean): CloseableIterator[A] = new CloseableIteratorImpl(super.dropWhile(p), close())</span>

<span class="nc" id="L192">  override def collect[B](pf: PartialFunction[A, B]): CloseableIterator[B] = new CloseableIteratorImpl(super.collect(pf), close())</span>

  def concat[B &gt;: A](xs: =&gt; GenTraversableOnce[B]): CloseableIterator[B] = {
<span class="nc bnc" id="L195" title="All 2 branches missed.">    lazy val applied = CloseableIterator.wrap(xs)</span>
<span class="nc" id="L196">    val queue = new scala.collection.mutable.Queue[() =&gt; CloseableIterator[B]]</span>
<span class="nc" id="L197">    queue.enqueue(() =&gt; this)</span>
<span class="nc" id="L198">    queue.enqueue(() =&gt; applied)</span>
<span class="nc" id="L199">    new ConcatCloseableIterator[B](queue)</span>
  }

<span class="nc" id="L202">  override def flatMap[B](f: A =&gt; GenTraversableOnce[B]): CloseableIterator[B] = new FlatMapCloseableIterator(this, f)</span>

  // in scala 2.13 this method is final, and can cause resource leaks due to not returning a closeable iterator
  override def ++[B &gt;: A](that: =&gt; GenTraversableOnce[B]): CloseableIterator[B] =
<span class="nc" id="L206">    throw new UnsupportedOperationException(&quot;Not safe for cross-scala usage&quot;)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>