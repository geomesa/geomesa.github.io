<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CircularByteQueue.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.collection</a> &gt; <span class="el_source">CircularByteQueue.scala</span></div><h1>CircularByteQueue.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.collection

/**
  * Growable byte queue that holds values in a circular array to minimize allocations
  *
  * @param initialSize initial buffer size
  */
<span class="nc" id="L16">class CircularByteQueue(initialSize: Int = 16) {</span>

<span class="nc" id="L18">  private var array = Array.ofDim[Byte](initialSize)</span>
<span class="nc" id="L19">  private var start = 0</span>
<span class="nc" id="L20">  private var length = 0</span>

  /**
    * Number of bytes stored in this buffer
    *
    * @return
    */
<span class="nc" id="L27">  def size: Int = length</span>

  /**
    * Current remaining capacity. In general this is not relevant, as the queue will grow as needed,
    * but it can be useful for debugging
    *
    * @return current capacity of the buffer
    */
<span class="nc" id="L35">  def capacity: Int = array.length - length</span>

  /**
    * Enqueue a single byte
    *
    * @param byte byte
    */
<span class="nc" id="L42">  def += (byte: Byte): Unit = enqueue(byte)</span>

  /**
    * Enqueue multiple bytes
    *
    * @param bytes bytes
    */
<span class="nc" id="L49">  def ++= (bytes: Array[Byte]): Unit = enqueue(bytes, 0, bytes.length)</span>

  /**
    * Enqueue a single byte
    *
    * @param byte byte
    */
  def enqueue(byte: Byte): Unit = {
<span class="nc" id="L57">    ensure(1)</span>
<span class="nc" id="L58">    var last = start + length</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">    if (last &gt;= array.length) {</span>
<span class="nc" id="L60">      last -= array.length</span>
    }
<span class="nc" id="L62">    array(last) = byte</span>
<span class="nc" id="L63">    length += 1</span>
  }

  /**
    * Enqueue multiple bytes
    *
    * @param bytes bytes
    * @param offset offset into the array to start reading, must be valid for the bytes passed in
    * @param count number of bytes to enqueue, must be valid for the size of the bytes and offset passed in
    */
  def enqueue(bytes: Array[Byte], offset: Int, count: Int): Unit = {
<span class="nc" id="L74">    ensure(count)</span>
<span class="nc" id="L75">    var first = start + length</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (first &gt;= array.length) {</span>
<span class="nc" id="L77">      first -= array.length</span>
    }
<span class="nc bnc" id="L79" title="All 2 branches missed.">    if (first + count &lt; array.length) {</span>
<span class="nc" id="L80">      System.arraycopy(bytes, offset, array, first, count)</span>
    } else {
<span class="nc" id="L82">      val tail = array.length - first</span>
<span class="nc" id="L83">      System.arraycopy(bytes, offset, array, first, tail)</span>
<span class="nc" id="L84">      System.arraycopy(bytes, offset + tail, array, 0, count - tail)</span>
    }
<span class="nc" id="L86">    length += count</span>
  }

  /**
    * Dequeue bytes
    *
    * @param count number of bytes to remove
    * @return
    */
  def dequeue(count: Int): Array[Byte] = {
<span class="nc" id="L96">    val total = math.min(length, count)</span>
<span class="nc" id="L97">    val result = Array.ofDim[Byte](total)</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (start + total &lt;= array.length) {</span>
<span class="nc" id="L99">      System.arraycopy(array, start, result, 0, total)</span>
    } else {
<span class="nc" id="L101">      val tail = array.length - start</span>
<span class="nc" id="L102">      System.arraycopy(array, start, result, 0, tail)</span>
<span class="nc" id="L103">      System.arraycopy(array, 0, result, tail, total - tail)</span>
    }
<span class="nc" id="L105">    start += total</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if (start &gt;= array.length) {</span>
<span class="nc" id="L107">      start -= array.length</span>
    }
<span class="nc" id="L109">    length -= total</span>
<span class="nc" id="L110">    result</span>
  }

  /**
    * Drop bytes
    *
    * @param count number of bytes to drop
    */
  def drop(count: Int): Unit = {
<span class="nc" id="L119">    val total = math.min(length, count)</span>
<span class="nc" id="L120">    start += total</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">    if (start &gt;= array.length) {</span>
<span class="nc" id="L122">      start -= array.length</span>
    }
<span class="nc" id="L124">    length -= total</span>
  }

  /**
    * Grow the array as needed to fit an additional number of bytes
    *
    * @param count bytes to fit
    */
  private def ensure(count: Int): Unit = {
<span class="nc bnc" id="L133" title="All 2 branches missed.">    if (length + count &gt; array.length) {</span>
<span class="nc" id="L134">      var newSize = array.length * 2</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      while (newSize &lt; length + count) {</span>
<span class="nc" id="L136">        newSize = newSize * 2</span>
      }
<span class="nc" id="L138">      val tmp = Array.ofDim[Byte](newSize)</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">      if (start + length &lt;= array.length) {</span>
<span class="nc" id="L140">        System.arraycopy(array, start, tmp, 0, length)</span>
      } else {
<span class="nc" id="L142">        val tailBytes = array.length - start</span>
<span class="nc" id="L143">        System.arraycopy(array, start, tmp, 0, tailBytes)</span>
<span class="nc" id="L144">        System.arraycopy(array, 0, tmp, tailBytes, length - tailBytes)</span>
      }
<span class="nc" id="L146">      array = tmp</span>
<span class="nc" id="L147">      start = 0</span>
    }
  }
<span class="nc" id="L150">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>