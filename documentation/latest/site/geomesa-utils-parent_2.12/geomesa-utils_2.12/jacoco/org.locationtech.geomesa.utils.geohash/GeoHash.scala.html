<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoHash.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geohash</a> &gt; <span class="el_source">GeoHash.scala</span></div><h1>GeoHash.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geohash

import com.typesafe.scalalogging.LazyLogging
import org.locationtech.jts.geom._

import scala.collection.BitSet
import scala.collection.immutable.{BitSet =&gt; IBitSet}

/**
 * GeoHashes above GeoHash.MAX_PRECISION are not supported.
 * @param x x centroid
 * @param y y centroid
 * @param bbox bounding box
 * @param bitset internal bitset
 * @param prec precision
 */
<span class="nc bnc" id="L25" title="All 9 branches missed.">case class GeoHash private(x: Double,</span>
<span class="nc" id="L26">                           y: Double,</span>
<span class="nc" id="L27">                           bbox: BoundingBox,</span>
<span class="nc" id="L28">                           bitset: BitSet,</span>
<span class="nc" id="L29">                           prec: Int, // checked in factory methods in companion object</span>
<span class="nc" id="L30">                           private val optHash: Option[String]) extends Comparable[GeoHash] {</span>
<span class="nc bnc" id="L31" title="All 4 branches missed.">  require(x &gt;= -180.0 &amp;&amp; x &lt;= 180.0)</span>
<span class="nc bnc" id="L32" title="All 4 branches missed.">  require(y &gt;= -90.0  &amp;&amp; y &lt;= 90.0)</span>

  import org.locationtech.geomesa.utils.geohash.GeoHash._

  /**
   * Hash string is calculated lazily if GeoHash object was created
   * from a Point, because calculation is expensive
   */
<span class="nc bnc" id="L40" title="All 4 branches missed.">  lazy val hash: String = optHash.getOrElse(toBase32(bitset, prec))</span>

<span class="nc bnc" id="L42" title="All 4 branches missed.">  lazy val geom: Geometry = bbox.geom</span>

  /**
   * Utility method to return the bit-string as a full binary string.
   *
   * NB:  We align our bits to the RIGHT by default, not to the LEFT.
   * This means that the most significant bit in the GeoHash (as it is
   * interpreted to a geometry) is actually the least significant bit
   * in the bit-set.  In other words:  Interpret the bit-set from
   * right to left.
   *
   * For clarity (?), this routine prints out the bits in MSB -&gt; LSB
   * order, so that their correspondence with the base-32
   * characters is directly readable.
   */
  def toBinaryString: String =
<span class="nc" id="L58">    (0 until prec).map(bitIndex =&gt; boolMap(bitset(bitIndex))).mkString</span>

  /**
    * Converts the geohash into an int.
    *
    * Note: geohashes with more than 6 base32 digits will not fit in an int
    *
    * @return the geohash as an int
    */
  def toInt: Int = {
<span class="nc" id="L68">    var i = 0</span>
<span class="nc" id="L69">    var asInt = 0</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">    while (i &lt; prec) {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">      if (bitset(i)) {</span>
<span class="nc" id="L72">        asInt += 1 &lt;&lt; prec - 1 - i</span>
      }
<span class="nc" id="L74">      i += 1</span>
    }
<span class="nc" id="L76">    asInt</span>
  }

<span class="nc" id="L79">  def getPoint: Point = GeoHash.factory.createPoint(new Coordinate(x,y))</span>

<span class="nc bnc" id="L81" title="All 4 branches missed.">  def contains(gh: GeoHash): Boolean = prec &lt;= gh.prec &amp;&amp; bitset.subsetOf(gh.bitset)</span>

<span class="nc" id="L83">  def next(): GeoHash =  GeoHash(GeoHash.next(bitset, prec), prec)</span>

<span class="nc" id="L85">  override def equals(obj: Any): Boolean = obj match {</span>
<span class="nc bnc" id="L86" title="All 10 branches missed.">    case that: GeoHash =&gt; this.bitset == that.bitset &amp;&amp; this.prec == that.prec</span>
<span class="nc" id="L87">    case _ =&gt; false</span>
  }

  // Overriding equals obligates us to override hashCode.
<span class="nc" id="L91">  override def hashCode: Int = bitset.hashCode + prec</span>

<span class="nc" id="L93">  override def compareTo(gh: GeoHash): Int = this.hash.compareTo(gh.hash)</span>
}

<span class="nc bnc" id="L96" title="All 17 branches missed.">case class Bounds(low: Double,</span>
<span class="nc" id="L97">                  high: Double) {</span>
<span class="nc bnc" id="L98" title="All 4 branches missed.">  lazy val mid: Double = (low+high)/2.0</span>
}

<span class="nc bnc" id="L101" title="All 4 branches missed.">object GeoHash extends LazyLogging {</span>

<span class="nc" id="L103">  val MAX_PRECISION = 63 // our bitset operations assume all bits fit in one Long</span>

<span class="nc" id="L105">  implicit def toGeometry(gh: GeoHash) = gh.geom</span>

<span class="nc" id="L107">  private val boolMap : Map[Boolean,String] = Map(false -&gt; &quot;0&quot;, true -&gt; &quot;1&quot;)</span>

<span class="nc bnc" id="L109" title="All 4 branches missed.">  lazy val factory: GeometryFactory = new GeometryFactory(new PrecisionModel, 4326)</span>

<span class="nc" id="L111">  private val latBounds = Bounds(-90.0,90.0)</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">  private lazy val latRange: Double = latBounds.high - latBounds.low</span>
<span class="nc" id="L113">  private val lonBounds = Bounds(-180.0,180.0)</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">  private lazy val lonRange: Double = lonBounds.high - lonBounds.low</span>

<span class="nc bnc" id="L116" title="All 4 branches missed.">  private lazy val powersOf2Map: Map[Int, Long] =</span>
<span class="nc" id="L117">    (0 to   MAX_PRECISION).map(i =&gt; (i, 1L &lt;&lt; i)).toMap // 1L &lt;&lt; i == math.pow(2,i).toLong</span>

<span class="nc bnc" id="L119" title="All 4 branches missed.">  private lazy val latDeltaMap: Map[Int, Double]  =</span>
<span class="nc" id="L120">    (0 to MAX_PRECISION).map(i =&gt; (i, latRange / powersOf2Map(i / 2))).toMap</span>

<span class="nc bnc" id="L122" title="All 4 branches missed.">  private lazy val lonDeltaMap: Map[Int, Double] =</span>
<span class="nc" id="L123">    (0 to MAX_PRECISION).map(i =&gt; (i, lonRange / powersOf2Map(i / 2 + i % 2))).toMap</span>

<span class="nc" id="L125">  private val bits = Array(16,8,4,2,1)</span>
<span class="nc" id="L126">  private val base32 = &quot;0123456789bcdefghjkmnpqrstuvwxyz&quot;</span>
<span class="nc" id="L127">  private val characterMap: Map[Char, BitSet] =</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    base32.zipWithIndex.map { case (c, i) =&gt; c -&gt; bitSetFromBase32Character(i) }.toMap</span>

<span class="nc" id="L130">  private val lonMax = 360 - math.pow(0.5, 32)</span>
<span class="nc" id="L131">  private val latMax = 180 - math.pow(0.5, 32)</span>

  // create a new GeoHash from a binary string in MSB -&gt; LSB format
  // (analogous to what is output by the &quot;toBinaryString&quot; method)
  def fromBinaryString(bitsString: String): GeoHash = {
<span class="nc" id="L136">    val numBits = bitsString.length</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">    val bitSet: BitSet = bitsString.zipWithIndex.foldLeft(BitSet())((bsSoFar, bitPosTuple) =&gt; bitPosTuple match {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">      case (bitChar, pos) if bitChar == '1' =&gt; bsSoFar + pos</span>
<span class="nc" id="L139">      case _                                =&gt; bsSoFar</span>
    })
<span class="nc" id="L141">    apply(bitSet, numBits)</span>
  }

<span class="nc" id="L144">  def apply(string: String): GeoHash = decode(string) // precision checked in decode</span>
<span class="nc" id="L145">  def apply(string: String, precision:Int): GeoHash = decode(string, Some[Int](precision)) // precision checked in decode</span>

  // We expect points in x,y order, i.e., longitude first.
<span class="nc" id="L148">  def apply(p: Point, prec: Int): GeoHash = apply(p.getX, p.getY, prec) // precision checked in apply</span>
<span class="nc" id="L149">  def apply(bs: BitSet, prec: Int): GeoHash = decode(toBase32(bs, prec), Some(prec)) // precision checked in decode</span>

  // We expect points x,y i.e., lon-lat
<span class="nc" id="L152">  def apply(lon: Double, lat: Double, prec: Int = 25): GeoHash = {</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">    require(lon &gt;= -180.0 &amp;&amp; lon &lt;= 180.0)</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">    require(lat &gt;= -90.0  &amp;&amp; lat &lt;= 90.0)</span>
<span class="nc" id="L155">    checkPrecision(prec)</span>

<span class="nc" id="L157">    val lonDelta = lonDeltaMap(prec)</span>
<span class="nc" id="L158">    val latDelta = latDeltaMap(prec)</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">    val lonIndex = if(lon == 180.0) (lonMax / lonDelta).toLong else ((lon - lonBounds.low) / lonDelta).toLong</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">    val latIndex = if(lat == 90.0)  (latMax / latDelta).toLong else ((lat - latBounds.low) / latDelta).toLong</span>

<span class="nc" id="L162">    encode(lonIndex, latIndex, lonDelta, latDelta, prec)</span>
  }

<span class="nc" id="L165">  def covering(ll: GeoHash, ur: GeoHash, prec: Int = 25): Seq[GeoHash] = {</span>
<span class="nc" id="L166">    checkPrecision(prec)</span>

<span class="nc" id="L168">    val bbox = BoundingBox(ll.getPoint, ur.getPoint)</span>

    def subsIntersecting(hash: GeoHash): Seq[GeoHash] = {
<span class="nc bnc" id="L171" title="All 2 branches missed.">      if (hash.prec == prec) List(hash)</span>
      else {
<span class="nc" id="L173">        def padLongToString(i: Long) = String.format(&quot;%5s&quot;, i.toBinaryString).replace(' ', '0')</span>
<span class="nc" id="L174">        val subs = Seq.tabulate(32) { i =&gt;</span>
<span class="nc" id="L175">          val oneBits = padLongToString(i)</span>
<span class="nc" id="L176">            .zipWithIndex</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">            .filter { case (ch, _) =&gt; ch != '0' }</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            .map { case (_, idx) =&gt; hash.prec + idx }</span>
<span class="nc" id="L179">          GeoHash(hash.bitset | BitSet(oneBits: _*), hash.prec + 5)</span>
        }
<span class="nc" id="L181">        subs.flatMap { sub =&gt;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">          if (!bbox.intersects(sub.bbox)) List()</span>
<span class="nc" id="L183">          else subsIntersecting(sub)</span>
        }
      }
    }
<span class="nc" id="L187">    val init = BoundingBox.getCoveringGeoHash(bbox, prec)</span>
<span class="nc" id="L188">    subsIntersecting(init)</span>
  }

  private def checkPrecision(precision: Int): Unit =
<span class="nc bnc" id="L192" title="All 2 branches missed.">    require(precision &lt;= MAX_PRECISION,</span>
<span class="nc" id="L193">            s&quot;GeoHash precision of $precision requested, but precisions above $MAX_PRECISION are not supported&quot;)</span>

  /**
   * Get the dimensions of the geohash grid bounded by ll and ur at precision.
   * @param g1 geohash
   * @param g2 geohash
   * @param precision precision
   * @return tuple containing (latitude span count, longitude span count)
   */
  def getLatitudeLongitudeSpanCount(g1: GeoHash, g2: GeoHash, precision: Int): (Int, Int) = {
<span class="nc bnc" id="L203" title="All 2 branches missed.">    require(g1.prec == precision,</span>
<span class="nc" id="L204">            s&quot;Geohash ${g1.hash} has precision ${g1.prec} but precision $precision is required&quot;)</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">    require(g2.prec == precision,</span>
<span class="nc" id="L206">            s&quot;Geohash ${g2.hash} has precision ${g2.prec} but precision $precision is required&quot;)</span>

<span class="nc bnc" id="L208" title="All 6 branches missed.">    val Array(latIndex1, lonIndex1) = GeoHash.gridIndicesForLatLong(g1)</span>
<span class="nc bnc" id="L209" title="All 6 branches missed.">    val Array(latIndex2, lonIndex2) = GeoHash.gridIndicesForLatLong(g2)</span>

<span class="nc" id="L211">    ((math.abs(latIndex2 - latIndex1) + 1).toInt, (math.abs(lonIndex2 - lonIndex1) + 1).toInt)</span>
  }

  /**
   * Convenience method to return both the latitude and longitude indices within
   * the grid of geohashes at the precision of the specified geohash
   *
   * @param gh the geohash
   * @return an array containing first the latitude index and then the longitude index
   */
  def gridIndicesForLatLong(gh: GeoHash): Array[Long] = {
<span class="nc bnc" id="L222" title="All 2 branches missed.">    val (lonIndex, latIndex) = extractReverseBits(gh.bitset.toBitMask.head, gh.prec)</span>
<span class="nc" id="L223">    Array(latIndex, lonIndex)</span>
  }

  /**
   * Gets a long value representing a latitude index within the grid of geohashes
   * at the precision of the specified geohash
   *
   * @param gh the geohash
   * @return latitude index
   */
  def gridIndexForLatitude(gh: GeoHash): Long = {
<span class="nc bnc" id="L234" title="All 2 branches missed.">    val (_, latIndex) = extractReverseBits(gh.bitset.toBitMask.head, gh.prec)</span>
<span class="nc" id="L235">    latIndex</span>
  }


  /**
   * Gets a long value representing a longitude index within th grid of geohashes
   * at the precision of the specified geohash
   *
   * @param gh the geohash
   * @return longitude index
   */
  def gridIndexForLongitude(gh: GeoHash): Long = {
<span class="nc bnc" id="L247" title="All 2 branches missed.">    val (lonIndex, _) = extractReverseBits(gh.bitset.toBitMask.head, gh.prec)</span>
<span class="nc" id="L248">    lonIndex</span>
  }


  /**
   * Composes a geohash from a latitude and longitude index for the grid of geohashes
   * at the specified precision.
   *
   * Note that the maximum latitude index is 2^(prec / 2) - 1 and the maximum longitude index
   * is 2^(prec / 2 + prec % 2) -1 for the given precision.  An exception will be thrown if a
   * larger index value is passed to this function.
   *
   * @param latIndex latitude index
   * @param lonIndex longitude index
   * @param prec the precision
   * @return a geohash at the specified latitude and longitude index for the given geohash precision
   */
  def composeGeoHashFromBitIndicesAndPrec(latIndex: Long, lonIndex: Long, prec: Int): GeoHash = {
<span class="nc" id="L266">    checkPrecision(prec)</span>
<span class="nc" id="L267">    encode(lonIndex, latIndex, lonDeltaMap(prec), latDeltaMap(prec), prec)</span>
  }

<span class="nc" id="L270">  def next(gh: GeoHash): GeoHash = GeoHash(GeoHash.next(gh.bitset), gh.prec)</span>

<span class="nc" id="L272">  def next(bs:BitSet, precision:Int=63) : BitSet = {</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">    (0 until precision).reverse.foldLeft(true,BitSet())((t,idx) =&gt; t match { case (carry,newBS) =&gt; {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">      if (carry) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (bs(idx)) (true, newBS)</span>
<span class="nc" id="L276">        else (false, newBS+idx)</span>
      } else {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (bs(idx)) (false, newBS+idx)</span>
<span class="nc" id="L279">        else (false, newBS)</span>
      }
    }})._2
  }


  /**
   * Create the geohash at the given latitude and longitude index with the given deltas and precision.
   * Assumes prec &lt;= 63, that is, all bits in the bitset fit in one Long
   * @param lonIndex: the longitude index (x index)
   * @param latIndex: the latitude index (y index)
   * @param lonDelta the longitude (x) delta per grid cell for the given precision
   * @param latDelta the latitude (y) delta per grid cell for the given precision
   * @param prec precision (# of bits)
   * @return the encoded GeoHash (note that calculation of the actual hash string is lazy)
   */
  def encode(lonIndex: Long, latIndex: Long, lonDelta: Double, latDelta: Double, prec: Int): GeoHash = {

<span class="nc" id="L297">    val bitSet = IBitSet.fromBitMaskNoCopy(Array(interleaveReverseBits(lonIndex, latIndex, prec)))</span>
<span class="nc" id="L298">    val bbox = bboxFromIndiciesDeltas(lonIndex, latIndex, lonDelta, latDelta)</span>

<span class="nc" id="L300">    GeoHash(bbox.midLon, bbox.midLat, bbox, bitSet, prec, None)</span>
  }

  /**
   * There is no visible difference between &quot;t4bt&quot; as a 20-bit GeoHash and
   * the same string as a 17-bit GeoHash.  Unless otherwise specified, assume
   * that the string represents a full complement of bits.
   *
   * If the call specifies a precision, then there is some additional work:
   * 1.  the full-characters (those each representing a full 5 bits) should
   *     be interpreted as they were before
   * 2.  the partial-character (zero or one; representing the remainder bits,
   *     guaranteed to be fewer than 5) must be appended
   *
   * @param string the base-32 encoded string to decode
   * @param precisionOption the desired precision as an option
   * @return the decoded GeoHash
   */
<span class="nc" id="L318">  private def decode(string: String, precisionOption: Option[Int] = None): GeoHash = {</span>
    // figure out what precision we should use
<span class="nc" id="L320">    val prec = precisionOption.getOrElse(5*string.length)</span>
<span class="nc" id="L321">    checkPrecision(prec)</span>

    // compute bit-sets for both the full and partial characters
<span class="nc bnc" id="L324" title="All 2 branches missed.">    val bitsets = string.zipWithIndex.map { case (c: Char, i: Int) =&gt; shift(i*5, characterMap(c)) }</span>

    // OR all of these bit-sets together
<span class="nc bnc" id="L327" title="All 3 branches missed.">    val finalBitset: BitSet = bitsets.size match {</span>
<span class="nc" id="L328">      case 0 =&gt; BitSet()</span>
<span class="nc" id="L329">      case 1 =&gt; bitsets(0)</span>
<span class="nc" id="L330">      case _ =&gt; bitsets.reduce(_|_)</span>
    }

<span class="nc bnc" id="L333" title="All 2 branches missed.">    val (lonIndex, latIndex) = extractReverseBits(finalBitset.toBitMask.head, prec)</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">    val (lonDelta, latDelta) = (lonDeltaMap(prec), latDeltaMap(prec))</span>
<span class="nc" id="L335">    val bbox = bboxFromIndiciesDeltas(lonIndex, latIndex, lonDelta, latDelta)</span>

<span class="nc" id="L337">    GeoHash(bbox.midLon, bbox.midLat, bbox, finalBitset, prec, Some(string))</span>
  }

  private def bboxFromIndiciesDeltas(lonIndex: Long,
                                     latIndex: Long,
                                     lonDelta: Double,
                                     latDelta: Double): BoundingBox =
<span class="nc" id="L344">    BoundingBox(Bounds(lonBounds.low+lonDelta*lonIndex, lonBounds.low+lonDelta*(lonIndex+1)),</span>
<span class="nc" id="L345">                Bounds(latBounds.low+latDelta*latIndex, latBounds.low+latDelta*(latIndex+1)))</span>

  /**
   * Reverses and interleaves every other bits of two longs into one long. The two longs must be
   * same size or first can be one bit longer than second.
   * @param first first long
   * @param second second long
   * @param numBits The total number of bits of the interleaved &amp; reversed result
   * @return long with a total of numBits bits of first and second interleaved &amp; reversed
   */
  private def interleaveReverseBits(first: Long, second: Long, numBits: Int): Long = {
    /* We start with the first value of the interleaved long, coming from first if
       numBits is odd or from second if numBits is even */
<span class="nc bnc" id="L358" title="All 2 branches missed.">    val even = (numBits &amp; 0x01) == 0</span>
<span class="nc bnc" id="L359" title="All 4 branches missed.">    val (actualFirst, actualSecond) = if(even) (second, first) else (first, second)</span>
<span class="nc" id="L360">    val numPairs = numBits &gt;&gt; 1</span>
<span class="nc" id="L361">    var result = 0L</span>
<span class="nc" id="L362">    (0 until numPairs).foreach{ pairNum =&gt;</span>
<span class="nc" id="L363">      result = (result &lt;&lt; 1) | ((actualFirst &gt;&gt; pairNum) &amp; 1L)</span>
<span class="nc" id="L364">      result = (result &lt;&lt; 1) | ((actualSecond &gt;&gt; pairNum) &amp; 1L)</span>
    }
<span class="nc bnc" id="L366" title="All 2 branches missed.">    if (!even) (result &lt;&lt; 1) | ((actualFirst &gt;&gt; numPairs) &amp; 1L) else result</span>
  }

  /**
   * Reverses and extracts every other bit up to numBits and extracts them into two longs.
   * @param value the long
   * @param numBits the number of bits to extract from the long
   * @return (first long, second long)  The first long will be one bit longer than the second if
   *         numBits is odd
   */
  private def extractReverseBits(value: Long, numBits: Int): (Long, Long) = {
<span class="nc" id="L377">    val numPairs = numBits &gt;&gt; 1</span>
<span class="nc" id="L378">    var first = 0L</span>
<span class="nc" id="L379">    var second = 0L</span>
<span class="nc" id="L380">    (0 until numPairs).foreach{ pairNum =&gt;</span>
<span class="nc" id="L381">      first = (first &lt;&lt; 1) | ((value &gt;&gt; pairNum * 2) &amp; 1L)</span>
<span class="nc" id="L382">      second = (second &lt;&lt; 1) | ((value &gt;&gt; (pairNum * 2 + 1)) &amp; 1L)</span>
    }
<span class="nc bnc" id="L384" title="All 2 branches missed.">    ((if((numBits &amp; 0x01) == 1) ((first &lt;&lt; 1) | ((value &gt;&gt; (numBits - 1)) &amp; 1L)) else first), second)</span>
  }

<span class="nc" id="L387">  private def shift(n: Int, bs: BitSet): BitSet = bs.map(_ + n)</span>

  private def bitSetFromBase32Character(charIndex: Long): BitSet =
<span class="nc bnc" id="L390" title="All 4 branches missed.">    BitSet(toPaddedBinaryString(charIndex, 5).zipWithIndex.filter { case (c, _) =&gt; c == '1' }.map(_._2): _*)</span>

  private def toPaddedBinaryString(i: Long, length: Int): String =
<span class="nc" id="L393">    String.format(&quot;%&quot; + length + &quot;s&quot;, i.toBinaryString).replace(' ', '0')</span>

  private def toBase32(bitset: BitSet, prec: Int): String = {
    // compute the precision padded to the next 5-bit boundary
<span class="nc" id="L397">    val numLeftoverBits = prec % 5</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">    val precision = prec + (numLeftoverBits match {</span>
<span class="nc" id="L399">      case 0 =&gt; 0</span>
<span class="nc" id="L400">      case _ =&gt; (5-numLeftoverBits)</span>
    })

    // take the bit positions in groups of 5, and map each set to a character
    // (based on the current bit-set); this works for off-5 precisions, because
    // the additional bits will simply not be there (assumed to be zero)
<span class="nc" id="L406">    (0 until precision).grouped(5).map(i=&gt;ch(i, bitset)).mkString</span>
  }

  private def ch(v: IndexedSeq[Int], bitset: BitSet): Char =
<span class="nc bnc" id="L410" title="All 2 branches missed.">    base32(v.foldLeft(0)((cur,i) =&gt; cur + (if (bitset(i)) bits(i%bits.length) else 0)))</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>