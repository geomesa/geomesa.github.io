<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BoundingBox.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geohash</a> &gt; <span class="el_source">BoundingBox.scala</span></div><h1>BoundingBox.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/


package org.locationtech.geomesa.utils.geohash

import org.locationtech.jts.geom._

/**
 *   A bounding box is a lat-lon rectangle defined by a &quot;lower left&quot;
 *    and an &quot;upper right&quot; point.
 *
 *   We do make the assumption that the lower left corner's latitude and longitude are less
 *   than or equal to the upper right corner's.
 *
 *   NB: Lat-lon rectangles which cross the {+|-}180 longitude line cannot be represented.
 */
<span class="nc bnc" id="L23" title="All 25 branches missed.">case class BoundingBox(ll: Point, ur: Point) {</span>
  
  import org.locationtech.geomesa.utils.geohash.BoundingBox._

<span class="nc bnc" id="L27" title="All 2 branches missed.">  require(ll.getX &lt;= ur.getX, s&quot;Bounding box lower left X: ${ll.getX} &gt; upper right X: ${ur.getX}&quot;)</span>
<span class="nc bnc" id="L28" title="All 2 branches missed.">  require(ll.getY &lt;= ur.getY, s&quot;Bounding box lower left Y: ${ll.getY} &gt; upper right Y: ${ur.getY}&quot;)</span>

<span class="nc bnc" id="L30" title="All 4 branches missed.">  lazy val envelope: Envelope = new Envelope(ll.getX, ur.getX, ll.getY, ur.getY)</span>
<span class="nc bnc" id="L31" title="All 4 branches missed.">  lazy val geom: Geometry = latLonGeoFactory.toGeometry(envelope)</span>

<span class="nc bnc" id="L33" title="All 4 branches missed.">  lazy val ul: Point = latLonGeoFactory.createPoint(new Coordinate(ll.getX, ur.getY))</span>
<span class="nc bnc" id="L34" title="All 4 branches missed.">  lazy val lr: Point = latLonGeoFactory.createPoint(new Coordinate(ur.getX, ll.getY))</span>

<span class="nc bnc" id="L36" title="All 4 branches missed.">  def intersects(bbox: BoundingBox): Boolean = covers(bbox.ll) || covers(bbox.ul) ||</span>
<span class="nc bnc" id="L37" title="All 4 branches missed.">                                               covers(bbox.lr) || covers(bbox.ur)</span>

  /**
   * This bounding box covers bbox iff no points of bbox lie in the exterior of this bounding box.
   * @param bbox
   * @return
   */
<span class="nc bnc" id="L44" title="All 4 branches missed.">  def covers(bbox: BoundingBox):Boolean = covers(bbox.ll) &amp;&amp; covers(bbox.ul) &amp;&amp;</span>
<span class="nc bnc" id="L45" title="All 4 branches missed.">                                          covers(bbox.lr) &amp;&amp; covers(bbox.ur)</span>

  /**
   * This bounding box covers pt iff pt does not line in the exterior of this bounding box.
   * @param pt
   * @return
   */
<span class="nc bnc" id="L52" title="All 4 branches missed.">  def covers(pt: Point): Boolean = (ll.getX &lt;= pt.getX &amp;&amp; pt.getX &lt;= ur.getX) &amp;&amp;</span>
<span class="nc bnc" id="L53" title="All 4 branches missed.">                                   (ll.getY &lt;= pt.getY &amp;&amp; pt.getY &lt;= ur.getY)</span>

  /**
   * This bounding box contains geom iff no points of goem lie in the exterior of this bounding box,
   * and at least one point of the interior of goem lies in the interior of this bounding box.
   * @param otherGeom
   * @return
   */
<span class="nc" id="L61">  def contains(otherGeom: Geometry): Boolean = geom.contains(otherGeom)</span>

<span class="nc bnc" id="L63" title="All 4 branches missed.">  lazy val minLon: Double = ll.getX</span>
<span class="nc bnc" id="L64" title="All 4 branches missed.">  lazy val minLat: Double = ll.getY</span>
<span class="nc bnc" id="L65" title="All 4 branches missed.">  lazy val maxLon: Double = ur.getX</span>
<span class="nc bnc" id="L66" title="All 4 branches missed.">  lazy val maxLat: Double = ur.getY</span>

  // these very simple calculations work because this class assumes min{x|y} &lt; max{x|y}
  // (no date line or pole wrap-arounds)
<span class="nc bnc" id="L70" title="All 4 branches missed.">  lazy val midLon: Double = (minLon + maxLon) / 2</span>
<span class="nc bnc" id="L71" title="All 4 branches missed.">  lazy val midLat: Double = (minLat + maxLat) / 2</span>

<span class="nc" id="L73">  def toText: String = s&quot;${ll.toText}, ${ur.toText}&quot;</span>
}

<span class="nc" id="L76">object BoundingBox {</span>

<span class="nc bnc" id="L78" title="All 4 branches missed.">  lazy val latLonGeoFactory = new GeometryFactory(new PrecisionModel(PrecisionModel.FLOATING), 4326)</span>

  def apply(x1: Double, x2: Double, y1: Double, y2: Double): BoundingBox =
<span class="nc" id="L81">     apply(Bounds(Math.min(x1, x2), Math.max(x1, x2)),</span>
<span class="nc" id="L82">           Bounds(Math.min(y1, y2), Math.max(y1, y2)))</span>

  def apply(lons: Bounds, lats: Bounds): BoundingBox = {
<span class="nc bnc" id="L85" title="All 2 branches missed.">    val Bounds(minLat, maxLat) = lats</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">    val Bounds(minLon, maxLon) = lons</span>
<span class="nc" id="L87">    new BoundingBox(</span>
<span class="nc" id="L88">      latLonGeoFactory.createPoint(new Coordinate(minLon, minLat)),</span>
<span class="nc" id="L89">      latLonGeoFactory.createPoint(new Coordinate(maxLon, maxLat)))</span>
  }

  def apply(env: Envelope): BoundingBox = {
<span class="nc" id="L93">    apply(env.getMinX, env.getMaxX, env.getMinY, env.getMaxY)</span>
  }

<span class="nc" id="L96">  def intersects(l: BoundingBox, r: BoundingBox): Boolean = l.geom.intersects(r.geom)</span>

  /**
   * get geohash that covers the bounding box to the given precision 
   * @param bbox
   * @param precision
   * @return
   */
  def getCoveringGeoHash(bbox: BoundingBox, precision: Int): GeoHash = {
<span class="nc" id="L105">    val ll = GeoHash(bbox.ll, precision).hash</span>
<span class="nc" id="L106">    val ur = GeoHash(bbox.ur.getX-1e-12, bbox.ur.getY-1e-12, precision).hash</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">    GeoHash(ll.zip(ur).takeWhile(Function.tupled(_ == _)).map(_._1).mkString)</span>
  }
<span class="nc" id="L109">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>