<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringCollectionConverterFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools.converters</a> &gt; <span class="el_source">StringCollectionConverterFactory.scala</span></div><h1>StringCollectionConverterFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools.converters

import org.geotools.util.factory.Hints
import org.geotools.util.factory.Hints.Key
import org.geotools.util.{Converter, ConverterFactory}

/**
  * Converts between strings and collections (maps and lists).
  *
  * The collection subtype(s) need to be passed into the hints using keys from ConverterFactories.
  * This is required, as we can't use reflection to figure out subtypes due to type erasure.
  * If the subtypes were incorrect, we could get serialization exceptions.
  */
<span class="nc" id="L22">class StringCollectionConverterFactory extends ConverterFactory {</span>

  import StringCollectionConverterFactory._

  def createConverter(source: Class[_], target: Class[_], hints: Hints): Converter = {
<span class="nc bnc" id="L27" title="All 10 branches missed.">    if (source != classOf[String] || hints == null || hints.isEmpty) {</span>
<span class="nc" id="L28">      null</span>
<span class="nc bnc" id="L29" title="All 2 branches missed.">    } else if (classOf[java.util.List[_]].isAssignableFrom(target)) {</span>
<span class="nc" id="L30">      val listType = hints.get(ListTypeKey).asInstanceOf[Class[_]]</span>
<span class="nc bnc" id="L31" title="All 2 branches missed.">      if (listType == null) {</span>
<span class="nc" id="L32">        null</span>
      } else {
<span class="nc" id="L34">        new StringToListConverter(listType)</span>
      }
<span class="nc bnc" id="L36" title="All 2 branches missed.">    } else if (classOf[java.util.Map[_, _]].isAssignableFrom(target)) {</span>
<span class="nc" id="L37">      val keyType   = hints.get(MapKeyTypeKey).asInstanceOf[Class[_]]</span>
<span class="nc" id="L38">      val valueType = hints.get(MapValueTypeKey).asInstanceOf[Class[_]]</span>
<span class="nc bnc" id="L39" title="All 4 branches missed.">      if (keyType == null || valueType == null) {</span>
<span class="nc" id="L40">        null</span>
      } else {
<span class="nc" id="L42">        new StringToMapConverter(keyType, valueType)</span>
      }
    } else {
<span class="nc" id="L45">      null</span>
    }
  }
}

<span class="nc" id="L50">object StringCollectionConverterFactory {</span>

<span class="nc" id="L52">  val ListTypeKey     = new Key(classOf[Class[_]])</span>
<span class="nc" id="L53">  val MapKeyTypeKey   = new Key(classOf[Class[_]])</span>
<span class="nc" id="L54">  val MapValueTypeKey = new Key(classOf[Class[_]])</span>

  /**
    * Converts a specially formatted string to a java list.
    *
    * Examples:
    *   &quot;[value1, value2]&quot; // from java List.toString
    *   &quot;value1,value2&quot; // from geomesa feature exporter conversion
    *
    * @param listType type of list elements
    */
<span class="nc" id="L65">  private class StringToListConverter(listType: Class[_]) extends Converter {</span>

    override def convert[T](source: scala.Any, target: Class[T]): T = {
<span class="nc" id="L68">      val string = source.toString.trim</span>
      // strip outer designators if any
      // java .toString looks like: [value1, value2]
      // geomesa looks like: value1,value2
<span class="nc bnc" id="L72" title="All 4 branches missed.">      val isToString = string.startsWith(&quot;[&quot;) &amp;&amp; string.endsWith(&quot;]&quot;)</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">      val stripped = if (isToString) string.substring(1, string.length - 1) else string</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">      if (stripped.isEmpty) {</span>
<span class="nc" id="L75">        new java.util.ArrayList[Any](0).asInstanceOf[T]</span>
      } else {
<span class="nc" id="L77">        val result = new java.util.ArrayList[Any]</span>
<span class="nc" id="L78">        stripped.split(&quot;,&quot;).foreach { e =&gt;</span>
<span class="nc" id="L79">          val converted = FastConverter.convert(e.trim, listType)</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">          if (converted != null) {</span>
<span class="nc" id="L81">            result.add(converted)</span>
          }
        }
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (result.isEmpty) {</span>
          // we failed to convert anything... return null and let someone else try
<span class="nc" id="L86">          null.asInstanceOf[T]</span>
        } else {
<span class="nc" id="L88">          result.asInstanceOf[T]</span>
        }
      }
    }
  }

  /**
    * Converts a specially formatted string to a java map.
    *
    * Examples:
    *   &quot;{key1=value1, key2=value2}&quot; // from java Map.toString
    *   &quot;key1-&gt;value1,key2-&gt;value2&quot; // from geomesa feature exporter conversion
    *
    * @param keyType map key type
    * @param valueType map value type
    */
<span class="nc" id="L104">  private class StringToMapConverter(keyType: Class[_], valueType: Class[_]) extends Converter {</span>

    override def convert[T](source: scala.Any, target: Class[T]): T = {
<span class="nc" id="L107">      val string = source.toString.trim</span>
      // pick our delimiter and strip outer designators if any
      // java .toString looks like: {key1=value1, key2=value2}
      // geomesa looks like: key1-&gt;value1,key2-&gt;value2
<span class="nc bnc" id="L111" title="All 4 branches missed.">      val isToString = string.startsWith(&quot;{&quot;) &amp;&amp; string.endsWith(&quot;}&quot;)</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">      val (stripped, split) = if (isToString) (string.substring(1, string.length - 1), &quot;=&quot;) else (string, &quot;-&gt;&quot;)</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">      if (stripped.isEmpty) {</span>
<span class="nc" id="L114">        new java.util.HashMap[Any, Any](0).asInstanceOf[T]</span>
      } else {
<span class="nc" id="L116">        val result = new java.util.HashMap[Any, Any]</span>
<span class="nc bnc" id="L117" title="All 8 branches missed.">        stripped.split(&quot;,&quot;).map(_.split(split)).filter(_.length == 2).foreach { case Array(k, v) =&gt;</span>
<span class="nc" id="L118">          val convertedKey = FastConverter.convert(k.trim, keyType)</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">          if (convertedKey != null) {</span>
<span class="nc" id="L120">            val convertedValue = FastConverter.convert(v.trim, valueType)</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (convertedValue != null) {</span>
<span class="nc" id="L122">              result.put(convertedKey, convertedValue)</span>
            }
          }
        }
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (result.isEmpty) {</span>
          // we failed to convert anything... return null and let someone else try
<span class="nc" id="L128">          null.asInstanceOf[T]</span>
        } else {
<span class="nc" id="L130">          result.asInstanceOf[T]</span>
        }
      }
    }
  }

<span class="nc" id="L136">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>