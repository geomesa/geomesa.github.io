<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FastConverter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools.converters</a> &gt; <span class="el_source">FastConverter.scala</span></div><h1>FastConverter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools.converters

import com.github.benmanes.caffeine.cache.{CacheLoader, Caffeine, LoadingCache}
import com.typesafe.scalalogging.StrictLogging
import org.geotools.api.filter.expression.Expression
import org.geotools.util.factory.GeoTools
import org.geotools.util.{Converter, Converters}
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty

import java.util.concurrent.TimeUnit
import scala.collection.mutable.ArrayBuffer
import scala.reflect.ClassTag
import scala.util.control.NonFatal

/**
  * Replacement for geotools `Converters`, which caches the converters for each pair of (from -&gt; to) instead of
  * re-creating them each time.
  */
<span class="nc" id="L27">object FastConverter extends StrictLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L31">  val ConverterCacheExpiry: SystemProperty = SystemProperty(&quot;geomesa.type.converter.cache.expiry&quot;, &quot;1 hour&quot;)</span>

<span class="nc" id="L33">  private val cache: LoadingCache[(Class[_], Class[_]), Array[Converter]] =</span>
<span class="nc" id="L34">    Caffeine.newBuilder().expireAfterWrite(ConverterCacheExpiry.toDuration.get.toMillis, TimeUnit.MILLISECONDS).build(</span>
<span class="nc" id="L35">      new CacheLoader[(Class[_], Class[_]), Array[Converter]]() {</span>
        override def load(key: (Class[_], Class[_])): Array[Converter] = {
<span class="nc bnc" id="L37" title="All 2 branches missed.">          val (from, to) = key</span>
<span class="nc" id="L38">          val factories = Converters.getConverterFactories(GeoTools.getDefaultHints).asScala.toArray</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">          logger.debug(s&quot;Loaded ${factories.length} converter factories: ${factories.map(_.getClass.getName).mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L40">          val converters = factories.flatMap(factory =&gt; Option(factory.createConverter(from, to, null)))</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">          logger.debug(</span>
<span class="nc" id="L42">            s&quot;Found ${converters.length} converters for ${from.getName}-&gt;${to.getName}: &quot; +</span>
<span class="nc" id="L43">              s&quot;${converters.map(_.getClass.getName).mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc bnc" id="L44" title="All 6 branches missed.">          if (to == classOf[String]) {</span>
<span class="nc" id="L45">            converters :+ ToStringConverter // add toString as a final fallback</span>
          } else {
<span class="nc" id="L47">            converters</span>
          }
        }
      }
    )

  /**
    * Convert the value into the given type
    *
    * @param value value to convert
    * @param binding type to convert to
    * @tparam T type binding
    * @return converted value, or null if it could not be converted
    */
  def convert[T](value: Any, binding: Class[T]): T = {
<span class="nc bnc" id="L62" title="All 4 branches missed.">    if (value == null || binding.isAssignableFrom(value.getClass)) {</span>
<span class="nc" id="L63">      return value.asInstanceOf[T]</span>
    }

<span class="nc" id="L66">    val converters = cache.get((value.getClass, binding))</span>

<span class="nc" id="L68">    val result = tryConvert(value, binding, converters)</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">    if (result == null) {</span>
      val msg =
<span class="nc" id="L71">        s&quot;Could not convert '$value' (of type ${value.getClass.getName}) to ${binding.getName} &quot; +</span>
<span class="nc" id="L72">          s&quot;using ${converters.map(_.getClass.getName).mkString(&quot;, &quot;)}&quot;</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">      logger.warn(msg)</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">      logger.debug(msg, new RuntimeException())</span>
    }
<span class="nc" id="L76">    result</span>
  }

  /**
   * Convert the value into one of the given type
   *
   * @param value value to convert
   * @param bindings type to convert to, in order of preference
   * @tparam T type binding
   * @return converted value, or null if it could not be converted
   */
  def convertFirst[T](value: Any, bindings: Iterator[Class[_ &lt;: T]]): T = {
<span class="nc bnc" id="L88" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L89">      return null.asInstanceOf[T]</span>
    }

<span class="nc" id="L92">    val clas = value.getClass</span>
<span class="nc" id="L93">    val errors = ArrayBuffer.empty[(Class[_], Array[Converter])]</span>

<span class="nc bnc" id="L95" title="All 2 branches missed.">    while (bindings.hasNext) {</span>
<span class="nc" id="L96">      val binding = bindings.next</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      if (binding.isAssignableFrom(clas)) {</span>
<span class="nc" id="L98">        return value.asInstanceOf[T]</span>
      }

<span class="nc" id="L101">      val converters = cache.get((clas, binding))</span>

<span class="nc" id="L103">      val result = tryConvert(value, binding, converters)</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">      if (result != null) {</span>
<span class="nc" id="L105">        return result</span>
      } else {
<span class="nc" id="L107">        errors += binding -&gt; converters</span>
      }
    }

    val msg =
<span class="nc" id="L112">      s&quot;Could not convert '$value' (of type ${value.getClass.getName}) to any of:&quot; +</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        errors.map { case (b, c) =&gt; s&quot;${b.getClass.getName} using ${c.map(_.getClass.getName).mkString(&quot;, &quot;)}&quot;}.mkString(&quot;\n  &quot;, &quot;\n  &quot;, &quot;&quot;)</span>

<span class="nc bnc" id="L115" title="All 2 branches missed.">    logger.warn(msg)</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">    logger.debug(msg, new RuntimeException())</span>

<span class="nc" id="L118">    null.asInstanceOf[T]</span>
  }

  /**
    * Convert the value into the given type, returning the default if it could not be converted or is null
    *
    * @param value value to convert
    * @param default value to return if convert results in null
    * @param ct class tag
    * @tparam T type to convert to
    * @return
    */
  def convertOrElse[T &lt;: AnyRef](value: Any, default: =&gt; T)(implicit ct: ClassTag[T]): T = {
<span class="nc" id="L131">    val attempt = convert(value, ct.runtimeClass.asInstanceOf[Class[T]])</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">    if (attempt == null) { default } else { attempt }</span>
  }

  /**
    * Evaluate and convert an expression
    *
    * @param expression expression to evaluate
    * @param binding type to convert to
    * @tparam T type binding
    * @return converted value, or null if it could not be converted
    */
<span class="nc" id="L143">  def evaluate[T](expression: Expression, binding: Class[T]): T = convert(expression.evaluate(null), binding)</span>

  /**
   * Try to convert the value
   *
   * @param value value
   * @param binding expected return type
   * @param converters converters to use
   * @tparam T expected return type
   * @return the converted value as type T, or null if could not convert
   */
  private def tryConvert[T](value: Any, binding: Class[T], converters: Array[Converter]): T = {
<span class="nc" id="L155">    var i = 0</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">    while (i &lt; converters.length) {</span>
<span class="nc" id="L157">      try {</span>
<span class="nc" id="L158">        val result = converters(i).convert(value, binding)</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L160">          return result</span>
        }
      } catch {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">          logger.trace(s&quot;Error converting $value (of type ${value.getClass.getName}) &quot; +</span>
<span class="nc" id="L165">            s&quot;to ${binding.getName} using converter ${converters(i).getClass.getName}:&quot;, e)</span>
      }
<span class="nc" id="L167">      i += 1</span>
    }
<span class="nc" id="L169">    null.asInstanceOf[T]</span>
  }

<span class="nc" id="L172">  private object ToStringConverter extends Converter {</span>
<span class="nc" id="L173">    override def convert[T](source: Any, target: Class[T]): T = source.toString.asInstanceOf[T]</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>