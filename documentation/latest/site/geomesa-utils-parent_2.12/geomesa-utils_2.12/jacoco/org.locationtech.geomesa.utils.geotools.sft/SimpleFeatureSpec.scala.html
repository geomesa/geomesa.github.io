<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleFeatureSpec.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools.sft</a> &gt; <span class="el_source">SimpleFeatureSpec.scala</span></div><h1>SimpleFeatureSpec.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools.sft

import org.apache.commons.text.StringEscapeUtils
import org.geotools.api.feature.`type`.AttributeDescriptor
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.feature.AttributeTypeBuilder
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec.AttributeSpec
import org.locationtech.jts.geom._

import java.util.regex.Pattern
import java.util.{Date, UUID}

/**
  * Intermediate format for simple feature types. Used for converting between string specs,
  * typesafe config specs and `SimpleFeatureType`s
  *
  * @param attributes attributes
  * @param options simple feature level optinos
  */
<span class="nc bnc" id="L28" title="All 25 branches missed.">case class SimpleFeatureSpec(attributes: Seq[AttributeSpec], options: Map[String, AnyRef])</span>

<span class="nc" id="L30">object SimpleFeatureSpec {</span>

  /**
    * Intermediate format for attribute descriptors
    */
<span class="nc" id="L35">  sealed trait AttributeSpec {</span>

    /**
      * Attribute name
      *
      * @return name
      */
    def name: String

    /**
      * Type binding
      *
      * @return class binding
      */
    def clazz: Class[_]

    /**
      * Attribute level options - all options are stored as strings for simplicity.
      * @see `RichAttributeDescriptors` for conversions.
      *
      * @return attribute level options
      */
    def options: Map[String, String]

    /**
      * Convert to a spec string
      *
      * @return a partial spec string
      */
    def toSpec: String = {
<span class="nc bnc" id="L65" title="All 2 branches missed.">      val opts = specOptions.map { case (k, v) =&gt; encodeAttributeOption(k, v) }</span>
<span class="nc" id="L66">      s&quot;$name:$getClassSpec${opts.mkString}&quot;</span>
    }

    /**
      * Convert to a typesafe config map
      *
      * @return a spec map
      */
<span class="nc" id="L74">    def toConfigMap: Map[String, String] = Map(&quot;name&quot; -&gt; name, &quot;type&quot; -&gt; getClassSpec) ++ configOptions</span>

    /**
      * Convert to an attribute descriptor
      *
      * @return a descriptor
      */
    def toDescriptor: AttributeDescriptor = {
<span class="nc" id="L82">      val builder = new AttributeTypeBuilder().binding(clazz)</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">      descriptorOptions.foreach { case (k, v) =&gt; builder.userData(k, v) }</span>
<span class="nc" id="L84">      builderHook(builder)</span>
<span class="nc" id="L85">      builder.buildDescriptor(name)</span>
    }

    /**
      * Gets class binding as a spec string
      *
      * @return class part of spec string
      */
<span class="nc" id="L93">    protected def getClassSpec: String = typeEncode(clazz)</span>

    /**
      * Options encoded in the spec string
      *
      * @return options to include in the spec string conversion
      */
<span class="nc" id="L100">    protected def specOptions: Map[String, String] = options</span>

    /**
      * Options encoded in the config map
      *
      * @return options to include in the config map conversion
      */
<span class="nc" id="L107">    protected def configOptions: Map[String, String] = options</span>

    /**
      * Options set in the attribute descriptor
      *
      * @return options to include in the descriptor conversion
      */
<span class="nc" id="L114">    protected def descriptorOptions: Map[String, String] = options</span>

    /**
      * Hook for modifying attribute descriptor
      *
      * @param builder attribute desctiptor builder
      */
<span class="nc" id="L121">    protected def builderHook(builder: AttributeTypeBuilder): Unit = {}</span>
  }

  import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeOptions.{OptDefault, OptIndex, OptSrid}

<span class="nc" id="L126">  private val simpleOptionPattern = Pattern.compile(&quot;[a-zA-Z0-9_]+&quot;)</span>

  def attribute(sft: SimpleFeatureType, descriptor: AttributeDescriptor): AttributeSpec = {
    import org.locationtech.geomesa.utils.geotools.RichAttributeDescriptors.RichAttributeDescriptor

    import scala.collection.JavaConverters._

<span class="nc" id="L133">    val name = descriptor.getLocalName</span>
<span class="nc" id="L134">    val binding = descriptor.getType.getBinding</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">    val options = descriptor.getUserData.asScala.map { case (k, v) =&gt; k.toString -&gt; v.toString }.toMap</span>

<span class="nc bnc" id="L137" title="All 2 branches missed.">    if (simpleTypeMap.contains(binding.getSimpleName)) {</span>
<span class="nc" id="L138">      SimpleAttributeSpec(name, binding, options)</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">    } else if (geometryTypeMap.contains(binding.getSimpleName)) {</span>
<span class="nc bnc" id="L140" title="All 8 branches missed.">      val opts = if (sft != null &amp;&amp; sft.getGeometryDescriptor == descriptor) { options + (OptDefault -&gt; &quot;true&quot;) } else { options }</span>
<span class="nc" id="L141">      GeomAttributeSpec(name, binding.asInstanceOf[Class[_ &lt;: Geometry]], opts)</span>
<span class="nc bnc" id="L142" title="All 4 branches missed.">    } else if (classOf[java.util.List[_]].isAssignableFrom(binding) || binding.isArray) {</span>
<span class="nc" id="L143">      val itemClass = Option(descriptor.getListType()).getOrElse(classOf[String])</span>
<span class="nc" id="L144">      ListAttributeSpec(name, itemClass, options)</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">    } else if (classOf[java.util.Map[_, _]].isAssignableFrom(binding)) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">      val (keyBinding, valueBinding) = descriptor.getMapTypes()</span>
<span class="nc" id="L147">      val keyClass = Option(keyBinding).getOrElse(classOf[String])</span>
<span class="nc" id="L148">      val valueClass = Option(valueBinding).getOrElse(classOf[String])</span>
<span class="nc" id="L149">      MapAttributeSpec(name, keyClass, valueClass, options)</span>
    } else {
<span class="nc" id="L151">      throw new IllegalArgumentException(s&quot;Unknown type binding $binding&quot;)</span>
    }
  }

  /**
   * Encode an attribute option for a spec string
   *
   * @param key key for the option
   * @param value value for the option
   * @return
   */
  def encodeAttributeOption(key: String, value: String): String = {
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (simpleOptionPattern.matcher(value).matches()) {</span>
<span class="nc" id="L164">      s&quot;:$key=$value&quot;</span>
    } else {
<span class="nc" id="L166">      s&quot;:$key='${StringEscapeUtils.escapeJava(value)}'&quot;</span>
    }
  }

  /**
    * Simple attribute
    */
<span class="nc bnc" id="L173" title="All 32 branches missed.">  case class SimpleAttributeSpec(name: String, clazz: Class[_], options: Map[String, String]) extends AttributeSpec</span>

  /**
    * Geometry attribute
    */
<span class="nc bnc" id="L178" title="All 32 branches missed.">  case class GeomAttributeSpec(name: String, clazz: Class[_ &lt;: Geometry], options: Map[String, String])</span>
<span class="nc" id="L179">      extends AttributeSpec {</span>

<span class="nc" id="L181">    val default: Boolean = options.get(OptDefault).exists(_.toBoolean)</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">    override def toSpec: String = if (default) { s&quot;*${super.toSpec}&quot; } else { super.toSpec }</span>

    override def builderHook(builder: AttributeTypeBuilder): Unit = {
<span class="nc bnc" id="L186" title="All 4 branches missed.">      require(!options.get(OptSrid).exists(_.toInt != 4326),</span>
<span class="nc" id="L187">        s&quot;Invalid SRID '${options(OptSrid)}'. Only 4326 is supported.&quot;)</span>
<span class="nc" id="L188">      builder.crs(org.locationtech.geomesa.utils.geotools.CRS_EPSG_4326)</span>
    }

    // default geoms are indicated by the *
    // we don't allow attribute indexing for geometries
<span class="nc" id="L193">    override protected def specOptions: Map[String, String] = options - OptDefault - OptIndex</span>
<span class="nc" id="L194">    override protected def configOptions: Map[String, String] = options - OptIndex</span>
<span class="nc" id="L195">    override protected def descriptorOptions: Map[String, String] = options - OptIndex</span>
  }

  /**
    * List attribute
    */
<span class="nc bnc" id="L201" title="All 32 branches missed.">  case class ListAttributeSpec(name: String, subClass: Class[_], options: Map[String, String]) extends AttributeSpec {</span>
    import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeConfigs.UserDataListType

<span class="nc" id="L204">    override val clazz: Class[java.util.List[_]] = classOf[java.util.List[_]]</span>
<span class="nc" id="L205">    override val getClassSpec = s&quot;List[${typeEncode(subClass)}]&quot;</span>

<span class="nc" id="L207">    override protected def specOptions: Map[String, String] = options - UserDataListType</span>
<span class="nc" id="L208">    override protected def descriptorOptions: Map[String, String] = options + (UserDataListType -&gt; subClass.getName)</span>
  }

  /**
    * Map attribute
    */
<span class="nc bnc" id="L214" title="All 39 branches missed.">  case class MapAttributeSpec(name: String, keyClass: Class[_], valueClass: Class[_], options: Map[String, String])</span>
<span class="nc" id="L215">      extends AttributeSpec {</span>
    import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.AttributeConfigs._

<span class="nc" id="L218">    override val clazz: Class[java.util.Map[_, _]] = classOf[java.util.Map[_, _]]</span>
<span class="nc" id="L219">    override val getClassSpec = s&quot;Map[${typeEncode(keyClass)},${typeEncode(valueClass)}]&quot;</span>

    override protected def specOptions: Map[String, String] =
<span class="nc" id="L222">      options - UserDataMapValueType - UserDataMapKeyType</span>
    override protected def descriptorOptions: Map[String, String] =
<span class="nc" id="L224">      options + (UserDataMapKeyType -&gt; keyClass.getName) + (UserDataMapValueType -&gt; valueClass.getName)</span>
  }

<span class="nc" id="L227">  private val typeEncode: Map[Class[_], String] = Map(</span>
<span class="nc" id="L228">    classOf[java.lang.String]    -&gt; &quot;String&quot;,</span>
<span class="nc" id="L229">    classOf[java.lang.Integer]   -&gt; &quot;Integer&quot;,</span>
<span class="nc" id="L230">    classOf[java.lang.Double]    -&gt; &quot;Double&quot;,</span>
<span class="nc" id="L231">    classOf[java.lang.Long]      -&gt; &quot;Long&quot;,</span>
<span class="nc" id="L232">    classOf[java.lang.Float]     -&gt; &quot;Float&quot;,</span>
<span class="nc" id="L233">    classOf[java.lang.Boolean]   -&gt; &quot;Boolean&quot;,</span>
<span class="nc" id="L234">    classOf[UUID]                -&gt; &quot;UUID&quot;,</span>
<span class="nc" id="L235">    classOf[Geometry]            -&gt; &quot;Geometry&quot;,</span>
<span class="nc" id="L236">    classOf[Point]               -&gt; &quot;Point&quot;,</span>
<span class="nc" id="L237">    classOf[LineString]          -&gt; &quot;LineString&quot;,</span>
<span class="nc" id="L238">    classOf[Polygon]             -&gt; &quot;Polygon&quot;,</span>
<span class="nc" id="L239">    classOf[MultiPoint]          -&gt; &quot;MultiPoint&quot;,</span>
<span class="nc" id="L240">    classOf[MultiLineString]     -&gt; &quot;MultiLineString&quot;,</span>
<span class="nc" id="L241">    classOf[MultiPolygon]        -&gt; &quot;MultiPolygon&quot;,</span>
<span class="nc" id="L242">    classOf[GeometryCollection]  -&gt; &quot;GeometryCollection&quot;,</span>
<span class="nc" id="L243">    classOf[Date]                -&gt; &quot;Date&quot;,</span>
<span class="nc" id="L244">    classOf[java.sql.Date]       -&gt; &quot;Date&quot;,</span>
<span class="nc" id="L245">    classOf[java.sql.Timestamp]  -&gt; &quot;Timestamp&quot;,</span>
<span class="nc" id="L246">    classOf[java.util.List[_]]   -&gt; &quot;List&quot;,</span>
<span class="nc" id="L247">    classOf[java.util.Map[_, _]] -&gt; &quot;Map&quot;,</span>
<span class="nc" id="L248">    classOf[Array[Byte]]         -&gt; &quot;Bytes&quot;</span>
  )

<span class="nc" id="L251">  private [sft] val simpleTypeMap = Map(</span>
<span class="nc" id="L252">    &quot;String&quot;            -&gt; classOf[java.lang.String],</span>
<span class="nc" id="L253">    &quot;java.lang.String&quot;  -&gt; classOf[java.lang.String],</span>
<span class="nc" id="L254">    &quot;string&quot;            -&gt; classOf[java.lang.String],</span>
<span class="nc" id="L255">    &quot;Integer&quot;           -&gt; classOf[java.lang.Integer],</span>
<span class="nc" id="L256">    &quot;java.lang.Integer&quot; -&gt; classOf[java.lang.Integer],</span>
<span class="nc" id="L257">    &quot;int&quot;               -&gt; classOf[java.lang.Integer],</span>
<span class="nc" id="L258">    &quot;Int&quot;               -&gt; classOf[java.lang.Integer],</span>
<span class="nc" id="L259">    &quot;0&quot;                 -&gt; classOf[java.lang.Integer],</span>
<span class="nc" id="L260">    &quot;Long&quot;              -&gt; classOf[java.lang.Long],</span>
<span class="nc" id="L261">    &quot;java.lang.Long&quot;    -&gt; classOf[java.lang.Long],</span>
<span class="nc" id="L262">    &quot;long&quot;              -&gt; classOf[java.lang.Long],</span>
<span class="nc" id="L263">    &quot;Double&quot;            -&gt; classOf[java.lang.Double],</span>
<span class="nc" id="L264">    &quot;java.lang.Double&quot;  -&gt; classOf[java.lang.Double],</span>
<span class="nc" id="L265">    &quot;double&quot;            -&gt; classOf[java.lang.Double],</span>
<span class="nc" id="L266">    &quot;0.0&quot;               -&gt; classOf[java.lang.Double],</span>
<span class="nc" id="L267">    &quot;Float&quot;             -&gt; classOf[java.lang.Float],</span>
<span class="nc" id="L268">    &quot;java.lang.Float&quot;   -&gt; classOf[java.lang.Float],</span>
<span class="nc" id="L269">    &quot;float&quot;             -&gt; classOf[java.lang.Float],</span>
<span class="nc" id="L270">    &quot;0.0f&quot;              -&gt; classOf[java.lang.Float],</span>
<span class="nc" id="L271">    &quot;Boolean&quot;           -&gt; classOf[java.lang.Boolean],</span>
<span class="nc" id="L272">    &quot;boolean&quot;           -&gt; classOf[java.lang.Boolean],</span>
<span class="nc" id="L273">    &quot;bool&quot;              -&gt; classOf[java.lang.Boolean],</span>
<span class="nc" id="L274">    &quot;java.lang.Boolean&quot; -&gt; classOf[java.lang.Boolean],</span>
<span class="nc" id="L275">    &quot;true&quot;              -&gt; classOf[java.lang.Boolean],</span>
<span class="nc" id="L276">    &quot;false&quot;             -&gt; classOf[java.lang.Boolean],</span>
<span class="nc" id="L277">    &quot;UUID&quot;              -&gt; classOf[UUID],</span>
<span class="nc" id="L278">    &quot;Date&quot;              -&gt; classOf[Date],</span>
<span class="nc" id="L279">    &quot;Timestamp&quot;         -&gt; classOf[java.sql.Timestamp],</span>
<span class="nc" id="L280">    &quot;byte[]&quot;            -&gt; classOf[Array[Byte]],</span>
<span class="nc" id="L281">    &quot;Bytes&quot;             -&gt; classOf[Array[Byte]]</span>
  )

<span class="nc" id="L284">  private [sft] val geometryTypeMap = Map(</span>
<span class="nc" id="L285">    &quot;Geometry&quot;           -&gt; classOf[Geometry],</span>
<span class="nc" id="L286">    &quot;Point&quot;              -&gt; classOf[Point],</span>
<span class="nc" id="L287">    &quot;LineString&quot;         -&gt; classOf[LineString],</span>
<span class="nc" id="L288">    &quot;Polygon&quot;            -&gt; classOf[Polygon],</span>
<span class="nc" id="L289">    &quot;MultiPoint&quot;         -&gt; classOf[MultiPoint],</span>
<span class="nc" id="L290">    &quot;MultiLineString&quot;    -&gt; classOf[MultiLineString],</span>
<span class="nc" id="L291">    &quot;MultiPolygon&quot;       -&gt; classOf[MultiPolygon],</span>
<span class="nc" id="L292">    &quot;GeometryCollection&quot; -&gt; classOf[GeometryCollection]</span>
  )

<span class="nc" id="L295">  private [sft] val listTypeMap = Map(</span>
<span class="nc" id="L296">    &quot;list&quot;           -&gt; classOf[java.util.List[_]],</span>
<span class="nc" id="L297">    &quot;List&quot;           -&gt; classOf[java.util.List[_]],</span>
<span class="nc" id="L298">    &quot;java.util.List&quot; -&gt; classOf[java.util.List[_]])</span>

<span class="nc" id="L300">  private [sft] val mapTypeMap  = Map(</span>
<span class="nc" id="L301">    &quot;map&quot;           -&gt; classOf[java.util.Map[_, _]],</span>
<span class="nc" id="L302">    &quot;Map&quot;           -&gt; classOf[java.util.Map[_, _]],</span>
<span class="nc" id="L303">    &quot;java.util.Map&quot; -&gt; classOf[java.util.Map[_, _]])</span>
<span class="nc" id="L304">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>