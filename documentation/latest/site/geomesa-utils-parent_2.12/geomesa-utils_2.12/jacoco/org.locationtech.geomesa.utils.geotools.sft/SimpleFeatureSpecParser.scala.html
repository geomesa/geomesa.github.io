<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleFeatureSpecParser.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools.sft</a> &gt; <span class="el_source">SimpleFeatureSpecParser.scala</span></div><h1>SimpleFeatureSpecParser.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools.sft

import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec._
import org.locationtech.geomesa.utils.text.BasicParser
import org.locationtech.jts.geom.Geometry
import org.parboiled.errors.{ErrorUtils, InvalidInputError, ParsingException}
import org.parboiled.scala.parserunners.{BasicParseRunner, ReportingParseRunner}
import org.parboiled.scala.{EOI, ParsingResult, Rule1}
import org.parboiled.support.MatcherPath

import scala.annotation.tailrec

/**
  * Parser for simple feature type spec strings
  */
<span class="nc" id="L25">object SimpleFeatureSpecParser {</span>

  import org.locationtech.geomesa.utils.conversions.StringOps.RichString

<span class="nc" id="L29">  private val Parser = new SimpleFeatureSpecParser()</span>

  @throws(classOf[ParsingException])
<span class="nc" id="L32">  def parse(spec: String, report: Boolean = true): SimpleFeatureSpec = parse(spec, Parser.spec, report)</span>

  @throws(classOf[ParsingException])
<span class="nc" id="L35">  def parseAttribute(spec: String, report: Boolean = true): AttributeSpec = parse(spec, Parser.attribute, report)</span>

  private def parse[T](spec: String, rule: Rule1[T], report: Boolean): T = {
<span class="nc bnc" id="L38" title="All 2 branches missed.">    if (spec == null) {</span>
<span class="nc" id="L39">      throw new IllegalArgumentException(&quot;Invalid spec: null&quot;)</span>
    }
<span class="nc bnc" id="L41" title="All 2 branches missed.">    val runner = if (report) { ReportingParseRunner(rule) } else { BasicParseRunner(rule) }</span>
<span class="nc" id="L42">    val parsing = runner.run(spec.stripMarginAndWhitespace())</span>
<span class="nc" id="L43">    parsing.result.getOrElse(throw new ParsingException(constructErrorMessage(parsing, report, spec)))</span>
  }

<span class="nc" id="L46">  private def constructErrorMessage[T](result: ParsingResult[T], report: Boolean, spec: String): String = {</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">    lazy val fallback = s&quot;Invalid spec: ${ErrorUtils.printParseErrors(result)}\n$spec&quot;</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">    if (!report) { fallback } else {</span>
<span class="nc bnc" id="L49" title="All 4 branches missed.">      result.parseErrors.collectFirst { case e: InvalidInputError =&gt;</span>
        import scala.collection.JavaConverters._
        // add a caret pointing to the invalid location
<span class="nc" id="L52">        val specAndIndex = s&quot;$spec\n${Seq.fill(math.max(0, e.getStartIndex - 1))(&quot; &quot;).mkString}^&quot;</span>
        // determine what paths the parser partially matched
<span class="nc" id="L54">        val matchers = e.getFailedMatchers.asScala.map(getFailedMatcher).distinct</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">        if (matchers.isEmpty) {</span>
<span class="nc" id="L56">          s&quot;Invalid spec at index ${e.getStartIndex}\n$specAndIndex&quot;</span>
        } else {
<span class="nc bnc" id="L58" title="All 2 branches missed.">          val expected = if (matchers.lengthCompare(1) &gt; 0) { s&quot;one of: ${matchers.mkString(&quot;, &quot;)}&quot; } else { matchers.head }</span>
<span class="nc" id="L59">          s&quot;Invalid spec at index ${e.getStartIndex} - expected $expected\n$specAndIndex&quot;</span>
        }
<span class="nc" id="L61">      }.getOrElse(fallback)</span>
    }
  }

  /**
    * Start at the failure point and go up the parse tree until
    * we get to a meaningful parser, as defined in ReportableParserMessages.
    * We should always match at least the top-level parser (spec or attribute)
    *
    * @param path failed matcher path
    * @return message indicating the last-matched matcher
    */
  @tailrec
  private def getFailedMatcher(path: MatcherPath): String = {
<span class="nc" id="L75">    ReportableParserMessages.get(path.element.matcher.getLabel) match {</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      case Some(m) =&gt; m</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      case None    =&gt; getFailedMatcher(path.parent)</span>
    }
  }

  // error messages corresponding to our rule labels
<span class="nc" id="L82">  private val ReportableParserMessages = Map(</span>
<span class="nc" id="L83">    Parser.spec            -&gt; &quot;specification&quot;,</span>
<span class="nc" id="L84">    Parser.attribute       -&gt; &quot;attribute&quot;,</span>
<span class="nc" id="L85">    Parser.name            -&gt; &quot;attribute name&quot;,</span>
<span class="nc" id="L86">    Parser.mapType         -&gt; &quot;attribute type binding&quot;,</span>
<span class="nc" id="L87">    Parser.listType        -&gt; &quot;attribute type binding&quot;,</span>
<span class="nc" id="L88">    Parser.simpleType      -&gt; &quot;attribute type binding&quot;,</span>
<span class="nc" id="L89">    Parser.geometryType    -&gt; &quot;geometry type binding&quot;,</span>
<span class="nc" id="L90">    Parser.sftOption       -&gt; &quot;feature type option&quot;,</span>
<span class="nc" id="L91">    Parser.attributeOption -&gt; &quot;attribute option&quot;,</span>
<span class="nc" id="L92">    Parser.default         -&gt; &quot;'*'&quot;,</span>
<span class="nc" id="L93">    EOI                    -&gt; &quot;end of spec&quot;</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">  ).map { case (k, v) =&gt; k.matcher.getLabel -&gt; v }</span>
}

<span class="nc" id="L97">private class SimpleFeatureSpecParser extends BasicParser {</span>

  // Valid specs can have attributes that look like the following:
  // &quot;id:Integer:opt1=v1:opt2=v2,*geom:Geometry:srid=4326,ct:List[String],mt:Map[String,Double]&quot;

  import SimpleFeatureTypes.AttributeOptions.OptDefault
  import org.parboiled.scala._

  // full simple feature spec
<span class="nc" id="L106">  def spec: Rule1[SimpleFeatureSpec] = rule(&quot;Specification&quot;) {</span>
<span class="nc" id="L107">    (whitespace ~ zeroOrMore(attribute, whitespace ~ &quot;,&quot; ~ whitespace) ~ whitespace ~ sftOptions ~ whitespace) ~ EOI ~~&gt; {</span>
<span class="nc" id="L108">      (attributes, sftOpts) =&gt; SimpleFeatureSpec(attributes, sftOpts)</span>
    }
  }

  // any attribute
<span class="nc" id="L113">  def attribute: Rule1[AttributeSpec] = rule(&quot;Attribute&quot;) {</span>
<span class="nc" id="L114">    simpleAttribute | geometryAttribute | listAttribute | mapAttribute</span>
  }

  // builds a SimpleAttributeSpec for primitive types
<span class="nc" id="L118">  private def simpleAttribute: Rule1[AttributeSpec] = rule(&quot;SimpleAttribute&quot;) {</span>
<span class="nc" id="L119">    (name ~ whitespace ~ simpleType ~ whitespace ~ attributeOptions) ~~&gt; SimpleAttributeSpec</span>
  }

  // builds a GeometrySpec
<span class="nc" id="L123">  private def geometryAttribute: Rule1[AttributeSpec] = rule(&quot;GeometryAttribute&quot;) {</span>
<span class="nc" id="L124">    (default ~ name ~ whitespace ~ geometryType ~ whitespace ~ attributeOptions) ~~&gt; {</span>
<span class="nc" id="L125">      (default, name, geom, opts) =&gt; {</span>
<span class="nc" id="L126">        GeomAttributeSpec(name, geom, opts + (OptDefault -&gt; default.getOrElse(false).toString))</span>
      }
    }
  }

  // builds a ListAttributeSpec for complex types
<span class="nc" id="L132">  private def listAttribute: Rule1[AttributeSpec] = rule(&quot;ListAttribute&quot;) {</span>
<span class="nc" id="L133">    (name ~ whitespace ~ listType ~ whitespace ~ attributeOptions) ~~&gt; ListAttributeSpec</span>
  }

  // builds a MapAttributeSpec for complex types
<span class="nc" id="L137">  private def mapAttribute: Rule1[AttributeSpec] = rule(&quot;MapAttribute&quot;) {</span>
<span class="nc" id="L138">    (name ~ whitespace ~ mapType ~ whitespace ~ attributeOptions) ~~&gt; {</span>
<span class="nc" id="L139">      (name, types, opts) =&gt; {</span>
<span class="nc" id="L140">        MapAttributeSpec(name, types._1, types._2, opts)</span>
      }
    }
  }

  // an attribute name
<span class="nc" id="L146">  private def name: Rule1[String] = rule(&quot;AttributeName&quot;) { oneOrMore(noneOf(&quot;*:, &quot;)) ~&gt; { s =&gt; s } }</span>

<span class="nc" id="L148">  private def default: Rule1[Option[Boolean]] = rule(&quot;DefaultAttribute&quot;) { optional(&quot;*&quot; ~ push(true)) }</span>

<span class="nc" id="L150">  private def simpleType: Rule1[Class[_]] = rule(&quot;SimpleTypeBinding&quot;) { &quot;:&quot; ~ whitespace ~ simpleBinding }</span>

  // matches any of the primitive types defined in simpleTypeMap
  // order matters so that Integer is matched before Int
<span class="nc" id="L154">  private def simpleBinding: Rule1[Class[_]] = rule(&quot;SimpleBinding&quot;) {</span>
<span class="nc" id="L155">    simpleTypeMap.keys.toList.sorted.reverse.map(str).reduce(_ | _) ~&gt; simpleTypeMap.apply</span>
  }

  // matches any of the geometry types defined in geometryTypeMap
<span class="nc" id="L159">  private def geometryType: Rule1[Class[_ &lt;: Geometry]] = rule(&quot;GeometryTypeBinding&quot;) {</span>
<span class="nc" id="L160">    &quot;:&quot; ~ whitespace ~ geometryTypeMap.keys.toList.sorted.reverse.map(str).reduce(_ | _) ~&gt; geometryTypeMap.apply</span>
  }

  // matches &quot;List[Foo]&quot; or &quot;List&quot; (which defaults to [String])
<span class="nc" id="L164">  private def listType: Rule1[Class[_]] = rule(&quot;ListTypeBinding&quot;) {</span>
<span class="nc" id="L165">    &quot;:&quot; ~ whitespace ~ listTypeMap.keys.map(str).reduce(_ | _) ~ whitespace ~</span>
<span class="nc" id="L166">        optional(&quot;[&quot; ~ whitespace ~ simpleBinding ~ whitespace ~ &quot;]&quot;) ~~&gt; {</span>
<span class="nc" id="L167">      inner =&gt; inner.getOrElse(classOf[String])</span>
    }
  }

  // matches &quot;Map[Foo,Bar]&quot; or Map (which defaults to [String,String])
<span class="nc" id="L172">  private def mapType: Rule1[(Class[_], Class[_])] = rule(&quot;MapTypeBinding&quot;) {</span>
<span class="nc" id="L173">    &quot;:&quot; ~ whitespace ~ mapTypeMap.keys.map(str).reduce(_ | _) ~ whitespace ~</span>
<span class="nc" id="L174">        optional(&quot;[&quot; ~ whitespace ~ simpleBinding ~ whitespace ~ &quot;,&quot; ~ whitespace ~ simpleBinding ~ whitespace ~ &quot;]&quot;) ~~&gt; {</span>
<span class="nc" id="L175">      types =&gt; types.getOrElse(classOf[String], classOf[String])</span>
    }
  }

  // options appended to a specific attribute
<span class="nc" id="L180">  private def attributeOptions: Rule1[Map[String, String]] = rule(&quot;AttributeOptions&quot;) {</span>
<span class="nc" id="L181">    optional(&quot;:&quot; ~ oneOrMore(attributeOption, whitespace ~ &quot;:&quot; ~ whitespace) ~~&gt; { _.toMap }) ~~&gt; { _.getOrElse(Map.empty) }</span>
  }

  // single attribute option
<span class="nc" id="L185">  private def attributeOption: Rule2[String, String] = rule(&quot;AttributeOption&quot;) {</span>
<span class="nc" id="L186">    oneOrMore(char | anyOf(&quot;.-&quot;)) ~&gt; { s =&gt; s } ~ whitespace ~ &quot;=&quot; ~ whitespace ~ (quotedString | singleQuotedString | unquotedString)</span>
  }

  // options for the simple feature type
<span class="nc" id="L190">  private def sftOptions: Rule1[Map[String, String]] = rule(&quot;FeatureTypeOptions&quot;) {</span>
<span class="nc" id="L191">    optional(&quot;;&quot; ~ whitespace ~ zeroOrMore(sftOption, whitespace ~ &quot;,&quot; ~ whitespace)) ~~&gt;  { o =&gt; o.map(_.toMap).getOrElse(Map.empty) }</span>
  }

  // single sft option
<span class="nc" id="L195">  private def sftOption: Rule1[(String, String)] = rule(&quot;FeatureTypeOption&quot;) {</span>
<span class="nc" id="L196">    (oneOrMore(char | anyOf(&quot;.-&quot;)) ~&gt; { s =&gt; s } ~ whitespace ~ &quot;=&quot; ~ whitespace ~ sftOptionValue) ~~&gt; { (k, v) =&gt; (k, v) }</span>
  }

  // value for an sft option
<span class="nc" id="L200">  private def sftOptionValue: Rule1[String] = rule(&quot;FeatureTypeOptionValue&quot;) {</span>
<span class="nc" id="L201">    singleQuotedString | quotedString | oneOrMore(noneOf(&quot;'\&quot;,&quot;)) ~&gt; { s =&gt; s }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>