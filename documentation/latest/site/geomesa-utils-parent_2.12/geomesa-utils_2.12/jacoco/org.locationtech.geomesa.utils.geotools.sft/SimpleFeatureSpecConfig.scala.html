<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleFeatureSpecConfig.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.geotools.sft</a> &gt; <span class="el_source">SimpleFeatureSpecConfig.scala</span></div><h1>SimpleFeatureSpecConfig.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.geotools.sft

import com.typesafe.config._
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.utils.geotools.ConfigSftParsing
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.Configs.Keywords
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes.InternalConfigs.KeywordsDelimiter
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpec._

/**
  * SimpleFeatureSpec parsing from/to typesafe config
  */
<span class="nc" id="L21">object SimpleFeatureSpecConfig {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L25">  val TypeNamePath   = &quot;type-name&quot;</span>
<span class="nc" id="L26">  val AttributesPath = &quot;attributes&quot;</span>
<span class="nc" id="L27">  val UserDataPath   = &quot;user-data&quot;</span>

<span class="nc" id="L29">  val TypePath       = &quot;type&quot;</span>
<span class="nc" id="L30">  val NamePath       = &quot;name&quot;</span>

  // config keys that are not attribute options - all other fields are assumed to be options
<span class="nc" id="L33">  private val NonOptions = Set(TypePath, NamePath)</span>

  /**
    * Parse a SimpleFeatureType spec from a typesafe Config
    *
    * @param conf config
    * @param path instead of parsing the root config, parse the nested config at this path
    * @return
    */
  def parse(conf: Config, path: Option[String]): (Option[String], SimpleFeatureSpec) = {

<span class="nc" id="L44">    val toParse = path.filter(conf.hasPath) match {</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">      case Some(p) =&gt; conf.withFallback(conf.getConfig(p))</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">      case None    =&gt; conf</span>
    }
<span class="nc" id="L48">    parse(toParse)</span>
  }

  /**
    * Convert a simple feature type to a typesafe config
    *
    * @param sft simple feature type
    * @param includeUserData include user data
    * @param includePrefix include the geomesa.sfts.XXX prefix
    * @return
    */
  def toConfig(sft: SimpleFeatureType, includeUserData: Boolean, includePrefix: Boolean): Config = {
    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

    // Update &quot;default&quot; options (dtg and geom)
<span class="nc" id="L63">    val defaults = sft.getDtgField.toSeq ++ Option(sft.getGeomField)</span>
<span class="nc" id="L64">    val attributes = sft.getAttributeDescriptors.asScala.map { ad =&gt;</span>
<span class="nc" id="L65">      val config = SimpleFeatureSpec.attribute(sft, ad).toConfigMap</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">      if (defaults.contains(ad.getLocalName)) {</span>
<span class="nc" id="L67">        config.updated(&quot;default&quot;, &quot;true&quot;).asJava</span>
      } else {
<span class="nc" id="L69">        config.asJava</span>
      }
    }

<span class="nc" id="L73">    val base = ConfigFactory.empty()</span>
<span class="nc" id="L74">      .withValue(TypeNamePath, ConfigValueFactory.fromAnyRef(sft.getTypeName))</span>
<span class="nc" id="L75">      .withValue(AttributesPath, ConfigValueFactory.fromIterable(attributes.asJava))</span>

<span class="nc bnc" id="L77" title="All 2 branches missed.">    val updated = if (includeUserData) {</span>
<span class="nc" id="L78">      val prefixes = sft.getUserDataPrefixes</span>
      // special handling for keywords delimiter
<span class="nc" id="L80">      val keywords = Map(Keywords -&gt; sft.getKeywords.asJava).filterNot(_._2.isEmpty)</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">      val toConvert = keywords ++ sft.getUserData.asScala.collect {</span>
<span class="nc bnc" id="L82" title="All 20 branches missed.">        case (k, v) if v != null &amp;&amp; prefixes.exists(k.toString.startsWith) &amp;&amp; k != Keywords =&gt; (k.toString, v)</span>
      }
<span class="nc" id="L84">      val userData = ConfigValueFactory.fromMap(toConvert.asJava)</span>
<span class="nc" id="L85">      base.withValue(UserDataPath, userData)</span>
    } else {
<span class="nc" id="L87">      base</span>
    }

<span class="nc bnc" id="L90" title="All 2 branches missed.">    if (includePrefix) {</span>
<span class="nc" id="L91">      updated.atPath(s&quot;${ConfigSftParsing.path}.${sft.getTypeName}&quot;)</span>
    } else {
<span class="nc" id="L93">      updated</span>
    }
  }

  /**
    * Convert a simple feature type to a typesafe config and renders it as a string
    *
    * @param sft simple feature type
    * @param includeUserData include user data
    * @param concise concise or verbose string
    * @return
    */
  def toConfigString(sft: SimpleFeatureType,
                     includeUserData: Boolean,
                     concise: Boolean,
                     includePrefix: Boolean,
                     json: Boolean): String = {
<span class="nc bnc" id="L110" title="All 2 branches missed.">    val opts = if (concise) {</span>
<span class="nc" id="L111">      ConfigRenderOptions.concise.setJson(json)</span>
    } else {
<span class="nc" id="L113">      ConfigRenderOptions.defaults().setFormatted(true).setComments(false).setOriginComments(false).setJson(json)</span>
    }
<span class="nc" id="L115">    toConfig(sft, includeUserData, includePrefix).root().render(opts)</span>
  }

  private def parse(conf: Config): (Option[String], SimpleFeatureSpec) = {
    import org.locationtech.geomesa.utils.conf.ConfConversions.RichConfig

<span class="nc bnc" id="L121" title="All 2 branches missed.">    val name = if (conf.hasPath(TypeNamePath)) { Option(conf.getString(TypeNamePath)) } else { None }</span>
    val attributes = {
<span class="nc bnc" id="L123" title="All 2 branches missed.">      val fields = if (conf.hasPath(&quot;fields&quot;)) { conf.getConfigList(&quot;fields&quot;) } else { conf.getConfigList(AttributesPath) }</span>
<span class="nc" id="L124">      fields.asScala.map(buildField).toSeq</span>
    }
    val opts = {
<span class="nc bnc" id="L127" title="All 2 branches missed.">      val userDataConfig = if (conf.hasPath(UserDataPath)) { conf.getConfig(UserDataPath) } else { ConfigFactory.empty }</span>
<span class="nc" id="L128">      val base = userDataConfig.toStringMap()</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      if (!base.contains(Keywords)) { base } else {</span>
        // special case to handle keywords
<span class="nc" id="L131">        base ++ userDataConfig.withOnlyPath(Keywords).toStringMap(KeywordsDelimiter)</span>
      }
    }

<span class="nc" id="L135">    (name, SimpleFeatureSpec(attributes, opts))</span>
  }

  private def buildField(conf: Config): AttributeSpec = {
    import org.locationtech.geomesa.utils.conf.ConfConversions.RichConfig

<span class="nc" id="L141">    val attribute = SimpleFeatureSpecParser.parseAttribute(s&quot;${conf.getString(NamePath)}:${conf.getString(TypePath)}&quot;)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    val options = conf.toStringMap().filterNot { case (k, _) =&gt; NonOptions.contains(k) }</span>

<span class="nc" id="L144">    attribute match {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">      case s: SimpleAttributeSpec =&gt; s.copy(options = options)</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">      case s: GeomAttributeSpec   =&gt; s.copy(options = options)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">      case s: ListAttributeSpec   =&gt; s.copy(options = options)</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">      case s: MapAttributeSpec    =&gt; s.copy(options = options)</span>
    }
  }
<span class="nc" id="L151">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>