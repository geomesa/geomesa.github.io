<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CachedThreadPool.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.concurrent</a> &gt; <span class="el_source">CachedThreadPool.scala</span></div><h1>CachedThreadPool.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.concurrent

import com.typesafe.scalalogging.LazyLogging

import java.util.concurrent._
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock
import scala.util.Try

/**
 * Executor service that will grow up to the number of threads specified.
 *
 * Assertion: core java executors offer 3 features that we want, but you can only use two of them at once:
 *   1. Add threads as needed but re-use idle threads if available
 *   2. Limit the total number of threads available
 *   3. Accept and queue tasks once the thread limit is reached
 *
 * This executor allows us to do all three. It is backed by an unlimited, cached thread pool that will handle
 * re-use and expiration of threads, while it tracks the number of threads used. It is fairly lightweight, and
 * can be instantiated for a given task and then shutdown after use.
 *
 * @param maxThreads max threads to use at once
 */
<span class="nc bnc" id="L32" title="All 4 branches missed.">class CachedThreadPool(maxThreads: Int) extends AbstractExecutorService with LazyLogging {</span>

  @volatile
<span class="nc" id="L35">  private var available = maxThreads</span>
<span class="nc" id="L36">  private val queue = new java.util.LinkedList[TrackableFutureTask[_]]()</span>
<span class="nc" id="L37">  private val tasks = new java.util.HashSet[TrackableFutureTask[_]]()</span>
<span class="nc" id="L38">  private val stopped = new AtomicBoolean(false)</span>
<span class="nc" id="L39">  private val lock = new ReentrantLock()</span>
<span class="nc" id="L40">  private val done = lock.newCondition()</span>

<span class="nc" id="L42">  override def shutdown(): Unit = stopped.set(true)</span>

  override def shutdownNow(): java.util.List[Runnable] = {
<span class="nc" id="L45">    stopped.set(true)</span>
<span class="nc" id="L46">    lock.lock()</span>
    try {
<span class="nc" id="L48">      val waiting = new java.util.ArrayList[Runnable](queue)</span>
<span class="nc" id="L49">      queue.clear()</span>
      // copy the running tasks to prevent concurrent modification errors in the synchronous cancel call
<span class="nc" id="L51">      val running = new java.util.ArrayList[Future[_]](tasks).iterator()</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">      while (running.hasNext) {</span>
<span class="nc" id="L53">        running.next.cancel(true)</span>
      }
<span class="nc" id="L55">      waiting</span>
    } finally {
<span class="nc" id="L57">      lock.unlock()</span>
    }
  }

<span class="nc" id="L61">  override def isShutdown: Boolean = stopped.get</span>

<span class="nc bnc" id="L63" title="All 4 branches missed.">  override def isTerminated: Boolean = stopped.get &amp;&amp; available == maxThreads // should be safe to read a volatile primitive</span>

  override def awaitTermination(timeout: Long, unit: TimeUnit): Boolean = {
<span class="nc" id="L66">    lock.lock()</span>
    try {
<span class="nc bnc" id="L68" title="All 2 branches missed.">      if (isTerminated) { true } else {</span>
<span class="nc" id="L69">        done.await(timeout, unit)</span>
<span class="nc" id="L70">        isTerminated</span>
      }
    } finally {
<span class="nc" id="L73">      lock.unlock()</span>
    }
  }

  override def execute(command: Runnable): Unit = {
<span class="nc bnc" id="L78" title="All 2 branches missed.">    if (stopped.get) {</span>
<span class="nc" id="L79">      throw new RejectedExecutionException(&quot;Trying to execute a task but executor service is shut down&quot;)</span>
    }
<span class="nc" id="L81">    val task = command match {</span>
<span class="nc bnc" id="L82" title="All 4 branches missed.">      case t: TrackableFutureTask[_] =&gt; t</span>
<span class="nc" id="L83">      case c =&gt; newTaskFor(c, null)</span>
    }
<span class="nc" id="L85">    runOrQueueTask(task)</span>
  }

  private def runOrQueueTask(task: TrackableFutureTask[_]): Unit = {
<span class="nc" id="L89">    lock.lock()</span>
    try {
<span class="nc bnc" id="L91" title="All 2 branches missed.">      if (available &gt; 0) {</span>
        // note that we could fairly easily create a global thread limit by backing this with a different pool
<span class="nc" id="L93">        try { CachedThreadPool.pool.execute(task) } catch {</span>
          case e: RejectedExecutionException =&gt;
            // we still need to execute the task to fulfill the executor API
<span class="nc bnc" id="L96" title="All 2 branches missed.">            logger.warn(</span>
<span class="nc" id="L97">              &quot;CachedThreadPool rejected queued task (likely due to shutdown),&quot; +</span>
<span class="nc" id="L98">                s&quot;creating new single thread executor: $task: $e&quot;)</span>
<span class="nc" id="L99">            val pool = Executors.newSingleThreadExecutor()</span>
<span class="nc" id="L100">            pool.execute(task)</span>
<span class="nc" id="L101">            pool.shutdown()</span>
        }
<span class="nc" id="L103">        available -= 1</span>
<span class="nc" id="L104">        tasks.add(task)</span>
      } else {
<span class="nc" id="L106">        queue.offer(task) // unbounded queue so should always succeed</span>
      }
    } finally {
<span class="nc" id="L109">      lock.unlock()</span>
    }
  }

  // noinspection SameParameterValue
  override protected def newTaskFor[T](runnable: Runnable, value: T): TrackableFutureTask[T] =
<span class="nc" id="L115">    new TrackableFutureTask[T](runnable, value)</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">  class TrackableFutureTask[T](runnable: Runnable, result: T) extends FutureTask[T](runnable, result) {</span>
    override def done(): Unit = {
<span class="nc" id="L119">      lock.lock()</span>
      try {
<span class="nc" id="L121">        available += 1</span>
<span class="nc" id="L122">        tasks.remove(this)</span>
<span class="nc" id="L123">        val next = queue.poll()</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (next != null) {</span>
<span class="nc" id="L125">          runOrQueueTask(next) // note: this may briefly use more than maxThreads as this thread finishes up</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        } else if (isTerminated) {</span>
<span class="nc" id="L127">          CachedThreadPool.this.done.signalAll()</span>
        }
      } finally {
<span class="nc" id="L130">        lock.unlock()</span>
      }
    }

<span class="nc" id="L134">    override def toString: String = s&quot;TrackableFutureTask[$runnable]&quot;</span>
  }
}

<span class="nc" id="L138">object CachedThreadPool {</span>

  // unlimited size but re-uses cached threads
<span class="nc" id="L141">  private val pool = ExitingExecutor(Executors.newCachedThreadPool().asInstanceOf[ThreadPoolExecutor])</span>

  /**
   * Execute a single command in a potentially cached thread
   *
   * @param command command
   */
<span class="nc" id="L148">  def execute(command: Runnable): Unit = pool.execute(command)</span>

  /**
   * Submit a single command to run in a potentially cached thread
   *
   * @param command command
   * @return
   */
<span class="nc" id="L156">  def submit(command: Runnable): Future[_] = pool.submit(command)</span>

  /**
   * Run commands in a executor with a fixed level of concurrency, potentially re-using threads. Will block
   * until any submitted tasks are complete.
   *
   * @param threads number of concurrent threads to use
   * @param func function
   */
  def executor(threads: Int)(func: ExecutorService =&gt; Unit): Unit = {
<span class="nc" id="L166">    val executor = new CachedThreadPool(threads)</span>
<span class="nc" id="L167">    val shutdown = sys.addShutdownHook(executor.shutdownNow())</span>
<span class="nc" id="L168">    try { func(executor) } finally {</span>
<span class="nc" id="L169">      executor.shutdown()</span>
    }
<span class="nc bnc" id="L171" title="All 2 branches missed.">    while (!executor.isTerminated) {</span>
<span class="nc" id="L172">      executor.awaitTermination(1, TimeUnit.MINUTES)</span>
    }
<span class="nc" id="L174">    Try(shutdown.remove())</span>
  }
<span class="nc" id="L176">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>