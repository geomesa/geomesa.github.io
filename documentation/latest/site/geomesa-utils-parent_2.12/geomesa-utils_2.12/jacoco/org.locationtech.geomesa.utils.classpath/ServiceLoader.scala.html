<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ServiceLoader.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Utils</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.utils.classpath</a> &gt; <span class="el_source">ServiceLoader.scala</span></div><h1>ServiceLoader.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.utils.classpath

import com.typesafe.scalalogging.LazyLogging

import scala.reflect.ClassTag

/**
  * Scala SPI loader helper
  */
<span class="nc bnc" id="L18" title="All 4 branches missed.">object ServiceLoader extends LazyLogging {</span>

  import scala.collection.JavaConverters._

  /**
   * Load all services
   *
   * @param loader optional classloader to use
   * @param ct classtag
   * @tparam T service type
   * @return list of services
   */
<span class="nc" id="L30">  def load[T](loader: Option[ClassLoader] = None)(implicit ct: ClassTag[T]): List[T] = {</span>
    // check if the current class is a child of the context classloader
    // this fixes service loading in Accumulo's per-namespace classpaths
<span class="nc" id="L33">    val clas = ct.runtimeClass.asInstanceOf[Class[T]]</span>
<span class="nc" id="L34">    val ldr = loader.getOrElse {</span>
      def chain(cl: ClassLoader): Stream[ClassLoader] =
<span class="nc bnc" id="L36" title="All 2 branches missed.">        if (cl == null) { Stream.empty } else { cl #:: chain(cl.getParent) }</span>
<span class="nc" id="L37">      val ccl = Thread.currentThread().getContextClassLoader</span>
<span class="nc bnc" id="L38" title="All 4 branches missed.">      if (ccl == null || chain(clas.getClassLoader).contains(ccl)) {</span>
<span class="nc" id="L39">        clas.getClassLoader</span>
      } else {
<span class="nc bnc" id="L41" title="All 2 branches missed.">        logger.warn(s&quot;Using a context ClassLoader that does not contain the class to load (${clas.getName}): $ccl&quot;)</span>
<span class="nc" id="L42">        ccl</span>
      }
    }
<span class="nc" id="L45">    java.util.ServiceLoader.load(clas, ldr).asScala.toList</span>
  }

  /**
    * Load a service. If there is not exactly 1 implementation found, throws an exception
    *
    * @param ct classtag
    * @tparam T service type
    * @throws IllegalStateException if there is not exactly 1 service found
    * @return service
    */
  @throws[IllegalStateException]
<span class="nc" id="L57">  def loadExactlyOne[T](loader: Option[ClassLoader] = None)(implicit ct: ClassTag[T]): T = {</span>
<span class="nc" id="L58">    val all = load[T](loader)</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">    if (all.lengthCompare(1) != 0) {</span>
<span class="nc" id="L60">      throw new IllegalStateException(s&quot;Expected 1 instance of ${ct.runtimeClass.getName} but found ${all.length}&quot;)</span>
    }
<span class="nc" id="L62">    all.head</span>
  }

  /**
    * Load a service. If there is not exactly 0 or 1 implementations found, throws an exception
    *
    * @param ct classtag
    * @tparam T service type
    * @throws IllegalStateException if there is not exactly 0 or 1 service found
    * @return service, if found
    */
  @throws[IllegalStateException]
<span class="nc" id="L74">  def loadAtMostOne[T](loader: Option[ClassLoader] = None)(implicit ct: ClassTag[T]): Option[T] = {</span>
<span class="nc" id="L75">    val all = load[T](loader)</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (all.lengthCompare(1) &gt; 0) {</span>
<span class="nc" id="L77">      throw new IllegalStateException(s&quot;Expected 0 or 1 instances of ${ct.runtimeClass.getName} but found ${all.length}&quot;)</span>
    }
<span class="nc" id="L79">    all.headOption</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>