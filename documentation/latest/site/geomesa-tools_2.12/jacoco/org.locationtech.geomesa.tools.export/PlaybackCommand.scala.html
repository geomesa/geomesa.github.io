<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlaybackCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.export</a> &gt; <span class="el_source">PlaybackCommand.scala</span></div><h1>PlaybackCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.`export`

import com.beust.jcommander.{Parameter, ParameterException}
import com.typesafe.scalalogging.StrictLogging
import org.apache.hadoop.mapreduce.Job
import org.geotools.api.data.{DataStore, Query, Transaction}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.filter.sort.SortOrder
import org.geotools.data.simple.SimpleFeatureCollection
import org.geotools.data.store.DataFeatureCollection
import org.geotools.factory.CommonFactoryFinder
import org.geotools.feature.simple.SimpleFeatureImpl
import org.geotools.geometry.jts.ReferencedEnvelope
import org.geotools.temporal.`object`.{DefaultInstant, DefaultPeriod, DefaultPosition}
import org.geotools.util.factory.Hints
import org.locationtech.geomesa.features.exporters.FeatureExporter
import org.locationtech.geomesa.index.geotools.GeoMesaFeatureCollection
import org.locationtech.geomesa.tools.RequiredTypeNameParam
import org.locationtech.geomesa.tools.`export`.PlaybackCommand.PlaybackIterator
import org.locationtech.geomesa.tools.export.ExportCommand.ExportParams
import org.locationtech.geomesa.tools.export.PlaybackCommand.PlaybackParams
import org.locationtech.geomesa.tools.utils.ParameterConverters.{DurationConverter, IntervalConverter}
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.io.WithClose

import java.io.Closeable
import java.util.Date
import java.util.concurrent.{Executors, LinkedBlockingQueue}
import scala.concurrent.duration.Duration
import scala.util.control.NonFatal

<span class="nc" id="L41">trait PlaybackCommand[DS &lt;: DataStore] extends ExportCommand[DS] {</span>

  import org.locationtech.geomesa.filter.ff
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L46">  override val name = &quot;playback&quot;</span>
  override def params: PlaybackParams

  override protected def export(
<span class="nc" id="L50">      ds: DS,</span>
<span class="nc" id="L51">      query: Query,</span>
      exporter: FeatureExporter,
      writeEmptyFiles: Boolean): Option[Long] = {
<span class="nc bnc" id="L54" title="All 2 branches missed.">    val features: SimpleFeatureCollection = new DataFeatureCollection(GeoMesaFeatureCollection.nextId) {</span>

<span class="nc" id="L56">      private val fs = ds.getFeatureSource(query.getTypeName)</span>
<span class="nc" id="L57">      private val transform = query.getPropertyNames</span>
<span class="nc" id="L58">      private val dtg = Option(params.dtg)</span>
<span class="nc bnc" id="L59" title="All 6 branches missed.">      private val filter = Option(query.getFilter).filter(_ != Filter.INCLUDE)</span>
<span class="nc" id="L60">      private val window = Option(params.window)</span>
<span class="nc" id="L61">      private val rate = Option(params.rate).map(_.floatValue()).getOrElse(1f)</span>
<span class="nc" id="L62">      private val live = Option(params.live).exists(_.booleanValue())</span>

<span class="nc bnc" id="L64" title="All 4 branches missed.">      private lazy val queryWithInterval = {</span>
<span class="nc" id="L65">        val dtg = Option(params.dtg).orElse(ds.getSchema(query.getTypeName).getDtgField).getOrElse {</span>
<span class="nc" id="L66">          throw new IllegalArgumentException(&quot;Schema does not have a default date field&quot;)</span>
        }
<span class="nc" id="L68">        val period = new DefaultPeriod(</span>
<span class="nc" id="L69">          new DefaultInstant(new DefaultPosition(params.interval._1)),</span>
<span class="nc" id="L70">          new DefaultInstant(new DefaultPosition(params.interval._2))</span>
        )
<span class="nc" id="L72">        val during = ff.during(ff.property(dtg), ff.literal(period))</span>
<span class="nc" id="L73">        val filterWithInterval = query.getFilter match {</span>
<span class="nc bnc" id="L74" title="All 10 branches missed.">          case null | Filter.INCLUDE =&gt; during</span>
<span class="nc" id="L75">          case f =&gt; ff.and(f, during)</span>
        }
<span class="nc" id="L77">        new Query(query.getTypeName, filterWithInterval, query.getMaxFeatures, query.getProperties, query.getHandle)</span>
      }

<span class="nc" id="L80">      override def getSchema: SimpleFeatureType = fs.getFeatures(query).getSchema</span>

<span class="nc" id="L82">      override def getBounds: ReferencedEnvelope = fs.getBounds(queryWithInterval)</span>

<span class="nc" id="L84">      override def getCount: Int = fs.getCount(queryWithInterval)</span>

      override protected def openIterator(): java.util.Iterator[SimpleFeature] = {
<span class="nc" id="L87">        val iter = new PlaybackIterator(ds, query.getTypeName, params.interval, dtg, filter, transform, window, rate, live)</span>

        // note: result needs to implement Closeable in order to be closed by the DataFeatureCollection
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (params.maxFeatures != null) {</span>
<span class="nc" id="L91">          var count = 0</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">          new java.util.Iterator[SimpleFeature] with Closeable {</span>
<span class="nc bnc" id="L93" title="All 4 branches missed.">            override def hasNext: Boolean = count &lt; params.maxFeatures &amp;&amp; iter.hasNext</span>
<span class="nc" id="L94">            override def next(): SimpleFeature = { count += 1; iter.next() }</span>
<span class="nc" id="L95">            override def close(): Unit = iter.close()</span>
          }
        } else {
<span class="nc" id="L98">          new java.util.Iterator[SimpleFeature] with Closeable {</span>
<span class="nc" id="L99">            override def hasNext: Boolean = iter.hasNext</span>
<span class="nc" id="L100">            override def next(): SimpleFeature = iter.next()</span>
<span class="nc" id="L101">            override def close(): Unit = iter.close()</span>
          }
        }
      }
    }

<span class="nc" id="L107">    try {</span>
<span class="nc" id="L108">      WithClose(CloseableIterator(features.features())) { iter =&gt;</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">        if (writeEmptyFiles || iter.hasNext) {</span>
<span class="nc" id="L110">          exporter.start(features.getSchema)</span>
<span class="nc" id="L111">          var count: Option[Long] = None</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">          while (iter.hasNext) {</span>
<span class="nc" id="L113">            val res = exporter.export(Iterator.single(iter.next))</span>
<span class="nc" id="L114">            count = count match {</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">              case None =&gt; res</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">              case Some(c) =&gt; res.map(_ + c).orElse(count)</span>
            }
          }
<span class="nc" id="L119">          count</span>
        } else {
<span class="nc" id="L121">          Some(0L)</span>
        }
      }
    } catch {
<span class="nc bnc" id="L125" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc" id="L126">        throw new RuntimeException(&quot;Could not execute export query. Please ensure &quot; +</span>
<span class="nc" id="L127">            &quot;that all arguments are correct&quot;, e)</span>
    }
  }

  override final protected def configure(job: Job, ds: DS, query: Query): Unit =
<span class="nc" id="L132">    throw new ParameterException(&quot;Distributed playback is not supported, please use --run-mode local&quot;)</span>
}

<span class="nc" id="L135">object PlaybackCommand {</span>

<span class="nc" id="L137">  private val ff = CommonFactoryFinder.getFilterFactory</span>
<span class="nc" id="L138">  private val terminal = new SimpleFeatureImpl(null, null, null, false, null)</span>

<span class="nc" id="L140">  trait PlaybackParams extends ExportParams with RequiredTypeNameParam {</span>
    @Parameter(names = Array(&quot;--interval&quot;), description = &quot;Date interval to query, in the format yyyy-MM-dd'T'HH:mm:ss.SSSZ/yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;, required = true, converter = classOf[IntervalConverter])
    var interval: (Date, Date) = _

    @Parameter(names = Array(&quot;--dtg&quot;), description = &quot;Date attribute to base playback on&quot;)
    var dtg: String = _

    @Parameter(names = Array(&quot;--step-window&quot;), description = &quot;Query the interval in discrete chunks instead of all at once ('10 minutes', '30 seconds', etc)&quot;, converter = classOf[DurationConverter])
    var window: Duration = _

    @Parameter(names = Array(&quot;--rate&quot;), description = &quot;Rate multiplier to speed-up (or slow down) features being returned&quot;)
    var rate: java.lang.Float = _

    @Parameter(names = Array(&quot;--live&quot;), description = &quot;Simulate live data by projecting the dates to current time&quot;)
    var live: java.lang.Boolean = _
  }


  /**
   * Query over a time frame and return the features in sorted order, delayed based on the date of each feature
   * to simulate the original ingestion stream
   *
   * @param ds data store
   * @param typeName simple feature type name
   * @param interval interval to query
   * @param dtg date attribute to sort by
   * @param filter additional filter predicate, if any
   * @param transforms query transforms, if any
   * @param window length of a single query window, used to chunk up the total features
   * @param rate multiplier for the rate of returning features, applied to the original delay between features
   * @param live project dates to current time
   * @param readAhead size of the read-ahead queue used for holding features before returning them
   */
<span class="nc" id="L173">  class PlaybackIterator(</span>
<span class="nc" id="L174">      ds: DataStore,</span>
<span class="nc" id="L175">      typeName: String,</span>
<span class="nc" id="L176">      interval: (Date, Date),</span>
<span class="nc" id="L177">      dtg: Option[String] = None,</span>
<span class="nc" id="L178">      filter: Option[Filter] = None,</span>
<span class="nc" id="L179">      transforms: Array[String] = null,</span>
<span class="nc" id="L180">      window: Option[Duration] = None,</span>
<span class="nc" id="L181">      rate: Float = 10f,</span>
<span class="nc" id="L182">      live: Boolean = false,</span>
<span class="nc" id="L183">      readAhead: Int = 10000</span>
<span class="nc" id="L184">    ) extends CloseableIterator[SimpleFeature] with StrictLogging {</span>

    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L188">    require(interval._2.after(interval._1), s&quot;Interval is not ordered correctly: ${interval._1}/${interval._2}&quot;)</span>

<span class="nc" id="L190">    private val sft = ds.getSchema(typeName)</span>
<span class="nc" id="L191">    private val dtgName = dtg.orElse(sft.getDtgField).getOrElse {</span>
<span class="nc" id="L192">      throw new IllegalArgumentException(&quot;Schema does not have a default date field&quot;)</span>
    }
<span class="nc" id="L194">    private val tdefs = transforms match {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      case null =&gt; null</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">      case t if t.indexOf(dtgName) == -1 =&gt; t :+ dtgName</span>
<span class="nc" id="L197">      case t =&gt; t</span>
    }
<span class="nc" id="L199">    private val dtgIndex = tdefs match {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">      case null =&gt; sft.indexOf(dtgName)</span>
<span class="nc" id="L201">      case t =&gt; t.indexOf(dtgName)</span>
    }
<span class="nc bnc" id="L203" title="All 2 branches missed.">    require(dtgIndex != -1, &quot;Invalid date field&quot;)</span>
<span class="nc" id="L204">    private val dtgProp = ff.property(dtgName)</span>
<span class="nc" id="L205">    private val sort = ff.sort(dtgName, SortOrder.ASCENDING)</span>

<span class="nc" id="L207">    private val windowMillis = window.map(_.toMillis).getOrElse(interval._2.getTime - interval._1.getTime + 1)</span>

<span class="nc" id="L209">    private var start: Long = -1</span>
<span class="nc" id="L210">    private var eventStart: Long = -1</span>

<span class="nc" id="L212">    private val features = new LinkedBlockingQueue[SimpleFeature](readAhead)</span>
<span class="nc" id="L213">    private var staged: SimpleFeature = _</span>

<span class="nc" id="L215">    private val executor = Executors.newSingleThreadExecutor()</span>
<span class="nc" id="L216">    executor.submit(new QueryRunnable())</span>

    override def hasNext: Boolean = {
<span class="nc bnc" id="L219" title="All 2 branches missed.">      if (staged != null) {</span>
<span class="nc" id="L220">        true</span>
      } else {
<span class="nc" id="L222">        staged = features.take()</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (!terminal.eq(staged)) {</span>
<span class="nc" id="L224">          true</span>
        } else {
<span class="nc" id="L226">          features.put(staged) // re-queue the terminal value to keep this method idempotent</span>
<span class="nc" id="L227">          staged = null</span>
<span class="nc" id="L228">          false</span>
        }
      }
    }

    override def next(): SimpleFeature = {
<span class="nc" id="L234">      val feature = staged</span>
<span class="nc" id="L235">      staged = null</span>
<span class="nc" id="L236">      val featureTime = feature.getAttribute(dtgIndex).asInstanceOf[Date].getTime</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">      if (start == -1L) {</span>
        // emit the first feature as soon as it's available, and set the clock to start timing from here
<span class="nc bnc" id="L239" title="All 2 branches missed.">        logger.debug(&quot;Starting replay clock&quot;)</span>
<span class="nc" id="L240">        start = System.currentTimeMillis()</span>
<span class="nc" id="L241">        eventStart = featureTime</span>
      }
<span class="nc" id="L243">      val featureRelativeTime = start + ((featureTime - eventStart) / rate).toLong</span>
<span class="nc" id="L244">      val sleep = featureRelativeTime - System.currentTimeMillis()</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">      if (sleep &gt; 0) {</span>
<span class="nc" id="L246">        Thread.sleep(sleep)</span>
      }
<span class="nc bnc" id="L248" title="All 2 branches missed.">      if (live) {</span>
<span class="nc" id="L249">        feature.setAttribute(dtgIndex, new Date(featureRelativeTime))</span>
      }
<span class="nc" id="L251">      feature</span>
    }

<span class="nc" id="L254">    override def close(): Unit = executor.shutdownNow()</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">    private class QueryRunnable extends Runnable {</span>
      override def run(): Unit = {
<span class="nc" id="L258">        try {</span>
<span class="nc" id="L259">          var from = interval._1</span>
<span class="nc" id="L260">          var to = new Date(from.getTime + windowMillis)</span>
<span class="nc" id="L261">          var loop = true</span>

<span class="nc bnc" id="L263" title="All 4 branches missed.">          while (loop &amp;&amp; !Thread.currentThread().isInterrupted) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (interval._2.before(to)) {</span>
              // this query will finish the last window
<span class="nc" id="L266">              to = interval._2</span>
<span class="nc" id="L267">              loop = false</span>
            }

<span class="nc bnc" id="L270" title="All 2 branches missed.">            logger.debug(s&quot;Running query window $from to $to&quot;)</span>

            val during = {
<span class="nc" id="L273">              val period = new DefaultPeriod(</span>
<span class="nc" id="L274">                new DefaultInstant(new DefaultPosition(from)),</span>
<span class="nc" id="L275">                new DefaultInstant(new DefaultPosition(to))</span>
              )
<span class="nc" id="L277">              ff.during(dtgProp, ff.literal(period))</span>
            }
<span class="nc" id="L279">            val query = new Query(typeName, filter.map(ff.and(_, during)).getOrElse(during), tdefs: _*)</span>
<span class="nc" id="L280">            query.setSortBy(sort)</span>
            // prevent ContentDataStore from sorting on disk
<span class="nc" id="L282">            query.getHints.put(Hints.MAX_MEMORY_SORT, java.lang.Integer.MAX_VALUE)</span>

<span class="nc" id="L284">            var count = 0L</span>

            // populate the queue - this will block if we get too far ahead
<span class="nc" id="L287">            CloseableIterator(ds.getFeatureReader(query, Transaction.AUTO_COMMIT)).foreach { f =&gt;</span>
<span class="nc" id="L288">              features.put(f)</span>
<span class="nc" id="L289">              count += 1</span>
            }

<span class="nc bnc" id="L292" title="All 2 branches missed.">            logger.debug(s&quot;Returned $count features from query window $from to $to&quot;)</span>

            // increment time window
<span class="nc" id="L295">            from = to</span>
<span class="nc" id="L296">            to = new Date(from.getTime + windowMillis)</span>
          }
        } catch {
<span class="nc bnc" id="L299" title="All 4 branches missed.">          case NonFatal(e) =&gt; logger.error(&quot;Error querying playback:&quot;, e)</span>
        } finally {
<span class="nc" id="L301">          features.put(terminal)</span>
        }
      }
    }
  }
<span class="nc" id="L306">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>