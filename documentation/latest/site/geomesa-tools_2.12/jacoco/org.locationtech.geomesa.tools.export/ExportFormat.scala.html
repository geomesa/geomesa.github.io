<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExportFormat.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.export</a> &gt; <span class="el_source">ExportFormat.scala</span></div><h1>ExportFormat.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.`export`

import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.utils.bin.BinaryOutputEncoder
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty

import java.util.Locale

/**
  * Export format enumeration
  *
  * @param name common name
  * @param extensions file extensions corresponding to the format
  * @param streaming does this format support writing to an output stream, or not (i.e. requires a random-access file)
  * @param countable does this format accurately count bytes as they're written, or not (i.e. only after `close()`)
  * @param bytesPerAttribute estimated bytes per attribute
  */
<span class="nc" id="L26">sealed abstract class ExportFormat(</span>
<span class="nc" id="L27">    val name: String,</span>
<span class="nc" id="L28">    val extensions: Seq[String],</span>
<span class="nc" id="L29">    val streaming: Boolean,</span>
<span class="nc" id="L30">    val countable: Boolean,</span>
<span class="nc" id="L31">    bytesPerAttribute: Float) {</span>

<span class="nc" id="L33">  val bytesPerFeatureProperty: SystemProperty =</span>
<span class="nc" id="L34">    SystemProperty(s&quot;org.locationtech.geomesa.export.$name.bytes-per-feature&quot;)</span>

  /**
    * Estimated bytes per feature
    *
    * @param sft simple feature type
    * @return
    */
  def bytesPerFeature(sft: SimpleFeatureType): Float = {
<span class="nc" id="L43">    bytesPerFeatureProperty.toFloat.orElse(ExportFormat.BytesPerFeatureProperty.toFloat).getOrElse {</span>
<span class="nc" id="L44">      (sft.getAttributeCount + 1) * bytesPerAttribute // +1 for feature id</span>
    }
  }

<span class="nc" id="L48">  override def toString: String = name</span>
}

<span class="nc" id="L51">object ExportFormat {</span>

<span class="nc" id="L53">  val BytesPerFeatureProperty: SystemProperty = SystemProperty(&quot;org.locationtech.geomesa.export.bytes-per-feature&quot;)</span>

<span class="nc" id="L55">  val Formats: Seq[ExportFormat] =</span>
<span class="nc" id="L56">    Seq(Arrow, Avro, AvroNative, Bin, Csv, Gml2, Gml3, Json, Leaflet, Null, Orc, Parquet, Shp, Tsv)</span>

  def apply(name: String): Option[ExportFormat] =
<span class="nc bnc" id="L59" title="All 4 branches missed.">    Formats.find(f =&gt; f.name.equalsIgnoreCase(name) || f.extensions.contains(name.toLowerCase(Locale.US)))</span>

  // note: these estimated sizes are based on exporting 86602 gdelt records from 2018-01-01
  // with the attributes GLOBALEVENTID,SQLDATE,MonthYear,Actor1Code,Actor1Name,dtg,geom

<span class="nc" id="L64">  case object Arrow extends ExportFormat(&quot;arrow&quot;, Seq(&quot;arrow&quot;), true, true, 6.6f) {</span>
    override def bytesPerFeature(sft: SimpleFeatureType): Float = {
<span class="nc" id="L66">      val base = super.bytesPerFeature(sft)</span>
<span class="nc bnc" id="L67" title="All 6 branches missed.">      if (sft == org.locationtech.geomesa.arrow.ArrowEncodedSft) {</span>
<span class="nc" id="L68">        base * 1000 // default batch size</span>
      } else {
<span class="nc" id="L70">        base</span>
      }
    }
  }

<span class="nc" id="L75">  case object Avro extends ExportFormat(&quot;avro&quot;, Seq(&quot;avro&quot;), true, true, 1.9f)</span>

<span class="nc" id="L77">  case object AvroNative extends ExportFormat(&quot;avro-native&quot;, Seq(&quot;avro&quot;), true, true, 1.9f)</span>

<span class="nc" id="L79">  case object Bin extends ExportFormat(&quot;bin&quot;, Seq(&quot;bin&quot;), true, true, -1) {</span>
    override def bytesPerFeature(sft: SimpleFeatureType): Float = {
<span class="nc" id="L81">      val base = bytesPerFeatureProperty.toInt.orElse(ExportFormat.BytesPerFeatureProperty.toInt).getOrElse {</span>
        // note: assume there is a label field, which, if wrong, should cause us
        // to under-count but then adjust and keep writing
<span class="nc" id="L84">        24</span>
      }
<span class="nc bnc" id="L86" title="All 6 branches missed.">      if (sft == BinaryOutputEncoder.BinEncodedSft) {</span>
<span class="nc" id="L87">        base * 1000 // default batch size</span>
      } else {
<span class="nc" id="L89">        base</span>
      }
    }
  }

<span class="nc" id="L94">  case object Csv extends ExportFormat(&quot;csv&quot;, Seq(&quot;csv&quot;), true, true, 12)</span>

<span class="nc" id="L96">  case object Json extends ExportFormat(&quot;json&quot;, Seq(&quot;json&quot;, &quot;geojson&quot;), true, true, 32)</span>

<span class="nc" id="L98">  case object Gml2 extends ExportFormat(&quot;gml2&quot;, Seq(&quot;gml2&quot;), true, false, 78)</span>

<span class="nc" id="L100">  case object Gml3 extends ExportFormat(&quot;gml&quot;, Seq(&quot;xml&quot;, &quot;gml&quot;, &quot;gml3&quot;), true, false, 73)</span>

<span class="nc" id="L102">  case object Leaflet extends ExportFormat(&quot;leaflet&quot;, Seq(&quot;html&quot;), true, true, 32)</span>

<span class="nc" id="L104">  case object Null extends ExportFormat(&quot;null&quot;, Seq.empty, true, true, 0)</span>

<span class="nc" id="L106">  case object Orc extends ExportFormat(&quot;orc&quot;, Seq(&quot;orc&quot;), false, false, 1.4f)</span>

<span class="nc" id="L108">  case object Parquet extends ExportFormat(&quot;parquet&quot;, Seq(&quot;parquet&quot;), false, false, 1.6f)</span>

<span class="nc" id="L110">  case object Shp extends ExportFormat(&quot;shp&quot;, Seq(&quot;shp&quot;), false, false, 105)</span>

<span class="nc" id="L112">  case object Tsv extends ExportFormat(&quot;tsv&quot;, Seq(&quot;tsv&quot;), true, true,  12)</span>
<span class="nc" id="L113">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>