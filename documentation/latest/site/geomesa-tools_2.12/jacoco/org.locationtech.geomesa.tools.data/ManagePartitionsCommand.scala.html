<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ManagePartitionsCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.data</a> &gt; <span class="el_source">ManagePartitionsCommand.scala</span></div><h1>ManagePartitionsCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.data

import com.beust.jcommander.{Parameter, ParameterException, Parameters}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.conf.partition.{TablePartition, TimePartition}
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.tools._
import org.locationtech.geomesa.tools.data.ManagePartitionsCommand._
import org.locationtech.geomesa.tools.utils.ParameterConverters.IntervalConverter
import org.locationtech.geomesa.tools.utils.Prompt
import org.locationtech.geomesa.utils.concurrent.CachedThreadPool
import org.locationtech.geomesa.utils.index.IndexMode
import org.locationtech.geomesa.utils.text.StringSerialization

import java.time.{ZoneOffset, ZonedDateTime}
import scala.collection.mutable.ArrayBuffer

/**
  * List, add, delete partitioned tables
  */
<span class="nc" id="L31">trait ManagePartitionsCommand extends CommandWithSubCommands {</span>

<span class="nc" id="L33">  override val name = &quot;manage-partitions&quot;</span>
<span class="nc" id="L34">  override val params = new ManagePartitionsParams()</span>

<span class="nc" id="L36">  override val subCommands: Seq[Command] = Seq(list, add, adopt, delete, generate)</span>

  protected def list: ListPartitionsCommand[_]
  protected def add: AddPartitionsCommand[_]
  protected def adopt: AdoptPartitionCommand[_]
  protected def delete: DeletePartitionsCommand[_]
  protected def generate: NamePartitionsCommand[_]
}

<span class="nc" id="L45">object ManagePartitionsCommand {</span>

  import scala.collection.JavaConverters._

  @Parameters(commandDescription = &quot;Manage partitioned schemas&quot;)
<span class="nc" id="L50">  class ManagePartitionsParams {}</span>

  /**
    * List existing partitions
    */
<span class="nc" id="L55">  trait ListPartitionsCommand[DS &lt;: GeoMesaDataStore[DS]] extends PartitionsCommand[DS] {</span>

<span class="nc" id="L57">    override val name = &quot;list&quot;</span>

    override protected def execute(ds: DS, sft: SimpleFeatureType, partition: TablePartition): Unit = {
<span class="nc bnc" id="L60" title="All 2 branches missed.">      Command.user.info(s&quot;Partitions for schema ${params.featureName}:&quot;)</span>
<span class="nc" id="L61">      val partitions = ArrayBuffer.empty[String]</span>
      def loadSingle(index: GeoMesaFeatureIndex[_, _]): Unit = {
<span class="nc" id="L63">        val p = index.getPartitions</span>
<span class="nc" id="L64">        partitions.synchronized(partitions ++= p)</span>
      }
<span class="nc" id="L66">      ds.manager.indices(sft).toList.map(i =&gt; CachedThreadPool.submit(() =&gt; loadSingle(i))).foreach(_.get)</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">      partitions.distinct.sorted.foreach(p =&gt; Command.output.info(p))</span>
    }
  }

  /**
    * Add new partitions
    */
<span class="nc" id="L74">  trait AddPartitionsCommand[DS &lt;: GeoMesaDataStore[DS]] extends ModifyPartitionsCommand[DS] {</span>

<span class="nc" id="L76">    override val name = &quot;add&quot;</span>

    override protected def modify(ds: DS, sft: SimpleFeatureType, partition: TablePartition, p: String): Unit = {
<span class="nc bnc" id="L79" title="All 2 branches missed.">      Command.user.info(s&quot;Adding partition '$p'&quot;)</span>
      def createSingle(index: GeoMesaFeatureIndex[_, _]): Unit =
<span class="nc" id="L81">        ds.adapter.createTable(index, Some(p), index.getSplits(Some(p)))</span>
<span class="nc" id="L82">      ds.manager.indices(sft, mode = IndexMode.Write).toList</span>
<span class="nc" id="L83">          .map(i =&gt; CachedThreadPool.submit(() =&gt; createSingle(i)))</span>
<span class="nc" id="L84">          .foreach(_.get)</span>
    }
  }

  /**
    * Adopt an existing set of index tables as a new partitions
    */
<span class="nc" id="L91">  trait AdoptPartitionCommand[DS &lt;: GeoMesaDataStore[DS]] extends PartitionsCommand[DS] {</span>

<span class="nc" id="L93">    override val name = &quot;adopt&quot;</span>
    override def params: AdoptPartitionParam

    override protected def execute(ds: DS, sft: SimpleFeatureType, partition: TablePartition): Unit = {
<span class="nc bnc" id="L97" title="All 4 branches missed.">      val time = Option(partition).collect { case p: TimePartition =&gt; p }.getOrElse {</span>
<span class="nc" id="L98">        throw new UnsupportedOperationException(s&quot;Unsupported partition implementation: ${partition.getClass.getName}&quot;)</span>
      }
<span class="nc bnc" id="L100" title="All 2 branches missed.">      val (start, end) = {</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        val (s, e) = new IntervalConverter(&quot;value&quot;).convert(params.value)</span>
<span class="nc" id="L102">        (ZonedDateTime.ofInstant(s.toInstant, ZoneOffset.UTC), ZonedDateTime.ofInstant(e.toInstant, ZoneOffset.UTC))</span>
      }
<span class="nc" id="L104">      val tables = params.tables.asScala</span>

<span class="nc bnc" id="L106" title="All 2 branches missed.">      Command.user.info(s&quot;Adopting tables ${tables.mkString(&quot;, &quot;)} as partition ${params.partition}&quot;)</span>

<span class="nc" id="L108">      val indices = ds.manager.indices(sft)</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (indices.lengthCompare(tables.length) != 0) {</span>
<span class="nc" id="L110">        throw new IllegalArgumentException(s&quot;Expected an index table for each index: ${indices.map(_.name).mkString(&quot;, &quot;)}&quot;)</span>
      }
      // match tables first, to fail fast if there is no match
<span class="nc" id="L113">      val indexNames = indices.map { index =&gt;</span>
<span class="nc" id="L114">        val name = StringSerialization.alphaNumericSafeString(index.name)</span>
<span class="nc" id="L115">        val attributes = index.attributes.map(StringSerialization.alphaNumericSafeString).mkString(&quot;_&quot;)</span>
<span class="nc" id="L116">        val version = s&quot;v${index.version}&quot;</span>
<span class="nc" id="L117">        (index, name, attributes, version)</span>
      }
<span class="nc" id="L119">      val tableToIndexName = indexNames</span>
        .toList
<span class="nc bnc" id="L121" title="All 2 branches missed.">        .sortWith(_._3.length &gt; _._3.length) // Sorted so we get best match first</span>
<span class="nc" id="L122">        .foldLeft(Map[String,(GeoMesaFeatureIndex[_,_],String,String,String)]()){</span>
<span class="nc" id="L123">          (mappedTables,indexName) =&gt;</span>
<span class="nc" id="L124">          val fullMatches = tables.filter(table =&gt;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            !mappedTables.contains(table) // Don't match again</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">              &amp;&amp; table.contains(indexName._2) // Correct type name as in z3, attr, id...</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">              &amp;&amp; table.contains(indexName._3) // Correct attributes</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">              &amp;&amp; table.contains(indexName._4) // Correct version</span>
          )
<span class="nc bnc" id="L130" title="All 2 branches missed.">          if (fullMatches.lengthCompare(1) &gt;= 0) {</span>
<span class="nc" id="L131">            mappedTables + (fullMatches.head -&gt; indexName)</span>
          } else {
<span class="nc" id="L133">           throw new IllegalArgumentException(s&quot;Could not match a table to an index of '${indexName._3}'&quot;)</span>
          }
        }
<span class="nc bnc" id="L136" title="All 2 branches missed.">      tableToIndexName.foreach { case (table, indexName) =&gt;</span>
<span class="nc" id="L137">        ds.metadata.insert(sft.getTypeName, indexName._1.tableNameKey(Some(params.partition)), table)</span>
      }
<span class="nc" id="L139">      time.register(params.partition, start, end)</span>

<span class="nc bnc" id="L141" title="All 2 branches missed.">      Command.user.info(&quot;Done&quot;)</span>
    }
  }

  /**
    * Delete existing partitions
    */
<span class="nc" id="L148">  trait DeletePartitionsCommand[DS &lt;: GeoMesaDataStore[DS]] extends ModifyPartitionsCommand[DS] {</span>

<span class="nc" id="L150">    override val name = &quot;delete&quot;</span>
    override def params: PartitionsParam with OptionalForceParam

    override protected def execute(ds: DS, sft: SimpleFeatureType, partition: TablePartition): Unit = {
<span class="nc bnc" id="L154" title="All 2 branches missed.">      lazy val prompt = s&quot;Deleting partition(s) '${params.partitions.asScala.mkString(&quot;', '&quot;)}'. Continue (y/n)? &quot;</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">      if (params.force || Prompt.confirm(prompt)) {</span>
<span class="nc" id="L156">        super.execute(ds, sft, partition)</span>
      } else {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        Command.user.info(&quot;Delete cancelled&quot;)</span>
      }
    }

    override protected def modify(ds: DS, sft: SimpleFeatureType, partition: TablePartition, p: String): Unit = {
<span class="nc bnc" id="L163" title="All 2 branches missed.">      Command.user.info(s&quot;Deleting partition '$p'&quot;)</span>
      def deleteSingle(index: GeoMesaFeatureIndex[_, _]): Unit =
<span class="nc" id="L165">        ds.adapter.deleteTables(index.deleteTableNames(Some(p)))</span>
<span class="nc" id="L166">      ds.manager.indices(sft).toList.map(i =&gt; CachedThreadPool.submit(() =&gt; deleteSingle(i))).foreach(_.get)</span>
    }
  }

  /**
    * Map from values (e.g. dates) to partition names
    */
<span class="nc" id="L173">  trait NamePartitionsCommand[DS &lt;: GeoMesaDataStore[DS]] extends PartitionsCommand[DS] {</span>

    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc" id="L177">    override val name = &quot;name&quot;</span>
    override def params: NamePartitionsParam

    override protected def execute(ds: DS, sft: SimpleFeatureType, partition: TablePartition): Unit = {
<span class="nc bnc" id="L181" title="All 2 branches missed.">      if (partition.isInstanceOf[TimePartition]) {</span>
<span class="nc" id="L182">        val sf = new ScalaSimpleFeature(sft, &quot;&quot;)</span>
<span class="nc" id="L183">        params.values.asScala.foreach { value =&gt;</span>
<span class="nc" id="L184">          sf.setAttribute(sft.getDtgIndex.get, value)</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">          Command.output.info(s&quot;$value -&gt; ${partition.partition(sf)}&quot;)</span>
        }
      } else {
<span class="nc" id="L188">        throw new UnsupportedOperationException(s&quot;Unsupported partition implementation: ${partition.getClass.getName}&quot;)</span>
      }
    }
  }

  /**
    * Base trait to facilitate acting on each partition
    */
<span class="nc" id="L196">  trait ModifyPartitionsCommand[DS &lt;: GeoMesaDataStore[DS]] extends PartitionsCommand[DS] {</span>

    override def params: PartitionsParam

    override protected def execute(ds: DS, sft: SimpleFeatureType, partition: TablePartition): Unit = {
<span class="nc" id="L201">      params.partitions.asScala.foreach(modify(ds, sft, partition, _))</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">      Command.user.info(&quot;Done&quot;)</span>
    }

    protected def modify(ds: DS, sft: SimpleFeatureType, partition: TablePartition, p: String): Unit
  }

  /**
    * Base trait for dealing with partitions
    */
<span class="nc" id="L211">  trait PartitionsCommand[DS &lt;: GeoMesaDataStore[DS]] extends DataStoreCommand[DS] {</span>

    override def params: RequiredTypeNameParam

    override def execute(): Unit = {
<span class="nc" id="L216">      withDataStore { ds =&gt;</span>
<span class="nc" id="L217">        val sft = ds.getSchema(params.featureName)</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (sft == null) {</span>
<span class="nc" id="L219">          throw new ParameterException(s&quot;Schema '${params.featureName}' does not exist in the data store. &quot; +</span>
<span class="nc" id="L220">              s&quot;Available types: ${ds.getTypeNames.mkString(&quot;, &quot;)}&quot;)</span>
        }
<span class="nc" id="L222">        TablePartition(ds, sft) match {</span>
<span class="nc bnc" id="L223" title="All 4 branches missed.">          case None =&gt; Command.user.error(s&quot;Schema is not partitioned&quot;)</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">          case Some(p) =&gt; execute(ds, sft, p)</span>
        }
      }
    }

    protected def execute(ds: DS, sft: SimpleFeatureType, partition: TablePartition): Unit
  }

<span class="nc" id="L232">  trait PartitionsParam extends RequiredTypeNameParam {</span>
    @Parameter(names = Array(&quot;--partition&quot;), description = &quot;Partition(s) to operate on&quot;, required = true)
    var partitions: java.util.List[String] = _
  }

<span class="nc" id="L237">  trait AdoptPartitionParam extends RequiredTypeNameParam {</span>
    @Parameter(names = Array(&quot;--partition&quot;), description = &quot;Partition name to adopt&quot;, required = true)
    var partition: String = _

    @Parameter(names = Array(&quot;--table&quot;), description = &quot;Name(s) of the index table(s) to adopt&quot;, required = true)
    var tables: java.util.List[String] = _

    @Parameter(names = Array(&quot;--value&quot;), description = &quot;Value used to bound the partition&quot;, required = true)
    var value: String = _
  }

<span class="nc" id="L248">  trait NamePartitionsParam extends RequiredTypeNameParam {</span>
    @Parameter(names = Array(&quot;--value&quot;), description = &quot;Value(s) used to generate partitions&quot;, required = true)
    var values: java.util.List[String] = _
  }
<span class="nc" id="L252">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>