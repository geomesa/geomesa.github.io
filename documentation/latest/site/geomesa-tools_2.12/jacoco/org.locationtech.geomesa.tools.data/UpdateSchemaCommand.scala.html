<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UpdateSchemaCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.data</a> &gt; <span class="el_source">UpdateSchemaCommand.scala</span></div><h1>UpdateSchemaCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.data

import com.beust.jcommander.{Parameter, ParameterException}
import org.geotools.api.data.DataStore
import org.geotools.feature.AttributeTypeBuilder
import org.geotools.feature.simple.SimpleFeatureTypeBuilder
import org.locationtech.geomesa.tools._
import org.locationtech.geomesa.tools.data.UpdateSchemaCommand.UpdateSchemaParams
import org.locationtech.geomesa.tools.utils.{NoopParameterSplitter, Prompt}
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.geotools.sft.SimpleFeatureSpecParser

import java.io.IOException
import java.util.Collections
import scala.util.control.NonFatal

/**
  * Invoke `updateSchema` on a datastore
  *
  * @tparam DS data store type
  */
<span class="nc" id="L30">trait UpdateSchemaCommand[DS &lt;: DataStore] extends DataStoreCommand[DS] {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  import scala.collection.JavaConverters._

<span class="nc" id="L36">  override val name = &quot;update-schema&quot;</span>
  override def params: UpdateSchemaParams

<span class="nc" id="L39">  override def execute(): Unit = withDataStore(update)</span>

  protected def update(ds: DS): Unit = {
    // ensure we have an operation
<span class="nc" id="L43">    params.validate().foreach(e =&gt; throw e)</span>

<span class="nc" id="L45">    val sft = try { ds.getSchema(params.featureName) } catch { case _: IOException =&gt; null }</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">    if (sft == null) {</span>
<span class="nc" id="L47">      throw new ParameterException(s&quot;Schema '${params.featureName}' does not exist in the data store&quot;)</span>
    }

<span class="nc" id="L50">    var n = 0</span>
    // numbering for our prompts
<span class="nc" id="L52">    def number: Int = { n += 1; n }</span>
<span class="nc" id="L53">    val prompts = new StringBuilder()</span>
<span class="nc" id="L54">    var canRenameTables = false</span>

<span class="nc" id="L56">    val builder = new SimpleFeatureTypeBuilder()</span>
<span class="nc" id="L57">    builder.init(sft)</span>

<span class="nc" id="L59">    Option(params.rename).foreach { rename =&gt;</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">      rename.indexOf(':') match {</span>
<span class="nc" id="L61">        case -1 =&gt; builder.setName(rename)</span>
<span class="nc" id="L62">        case i  =&gt; builder.setNamespaceURI(rename.substring(0, i)); builder.setName(rename.substring(i + 1))</span>
      }
<span class="nc" id="L64">      prompts.append(s&quot;\n  $number: Renaming schema to '$rename'&quot;)</span>
<span class="nc" id="L65">      canRenameTables = true</span>
    }

<span class="nc bnc" id="L68" title="All 6 branches missed.">    params.renameAttributes.asScala.grouped(2).foreach { case Seq(from, to) =&gt;</span>
<span class="nc" id="L69">      val i = sft.indexOf(from.asInstanceOf[String])</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">      if (i == -1) {</span>
<span class="nc" id="L71">        throw new ParameterException(s&quot;Attribute '$from' does not exist in the schema&quot;)</span>
      }
<span class="nc" id="L73">      val attribute = new AttributeTypeBuilder()</span>
<span class="nc" id="L74">      attribute.init(sft.getDescriptor(i))</span>
<span class="nc" id="L75">      builder.set(i, attribute.buildDescriptor(to.asInstanceOf[String]))</span>
<span class="nc bnc" id="L76" title="All 6 branches missed.">      if (sft.getGeomField == from) {</span>
<span class="nc" id="L77">        builder.setDefaultGeometry(to.asInstanceOf[String])</span>
      }
<span class="nc" id="L79">      prompts.append(s&quot;\n  $number: Renaming attribute '$from' to '$to'&quot;)</span>
<span class="nc bnc" id="L80" title="All 4 branches missed.">      canRenameTables = canRenameTables || sft.getIndices.exists(_.attributes.contains(from))</span>
    }

<span class="nc bnc" id="L83" title="All 4 branches missed.">    if (canRenameTables &amp;&amp; params.renameTables) {</span>
<span class="nc" id="L84">      prompts.append(s&quot;\n  $number: Renaming index tables (WARNING may be expensive)&quot;)</span>
    }

<span class="nc" id="L87">    params.attributes.asScala.foreach { attribute =&gt;</span>
<span class="nc" id="L88">      val spec = try { SimpleFeatureSpecParser.parseAttribute(attribute) } catch {</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(s&quot;Invalid attribute spec: $attribute&quot;, e)</span>
      }
<span class="nc" id="L91">      builder.add(spec.toDescriptor)</span>
<span class="nc" id="L92">      prompts.append(s&quot;\n  $number: Adding attribute '${spec.name}' of type ${spec.clazz.getName}&quot;)</span>
    }

<span class="nc" id="L95">    val updated = builder.buildFeatureType()</span>
<span class="nc" id="L96">    updated.getUserData.putAll(sft.getUserData)</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">    if (!params.plusKeywords.isEmpty) {</span>
<span class="nc" id="L99">      val keywords = params.plusKeywords.asScala</span>
<span class="nc" id="L100">      updated.addKeywords(keywords.toSet)</span>
<span class="nc" id="L101">      prompts.append(s&quot;\n  $number: Adding keywords: '${keywords.mkString(&quot;', '&quot;)}'&quot;)</span>
    }
<span class="nc bnc" id="L103" title="All 2 branches missed.">    if (!params.minusKeywords.isEmpty) {</span>
<span class="nc" id="L104">      val keywords = params.minusKeywords.asScala</span>
<span class="nc" id="L105">      updated.removeKeywords(keywords.toSet)</span>
<span class="nc" id="L106">      prompts.append(s&quot;\n  $number: Removing keywords: '${keywords.mkString(&quot;', '&quot;)}'&quot;)</span>
    }
<span class="nc bnc" id="L108" title="All 2 branches missed.">    if (!params.userData.isEmpty) {</span>
<span class="nc" id="L109">      params.userData.asScala.foreach { ud =&gt;</span>
<span class="nc" id="L110">        ud.split(&quot;:&quot;, 2) match {</span>
<span class="nc bnc" id="L111" title="All 6 branches missed.">          case Array(k, v) =&gt;</span>
<span class="nc" id="L112">            updated.getUserData.put(k, v) match {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">              case null =&gt; prompts.append(s&quot;\n  $number: Adding user data: '$k=$v'&quot;)</span>
<span class="nc" id="L114">              case old  =&gt; prompts.append(s&quot;\n  $number: Updating user data: '$k=$v' (was '$old')&quot;)</span>
            }
<span class="nc" id="L116">          case _ =&gt; throw new ParameterException(s&quot;Invalid user data entry - expected 'key:value': $ud&quot;)</span>
        }
      }
    }

<span class="nc" id="L121">    Option(params.enableStats).map(_.booleanValue()).foreach { enable =&gt;</span>
<span class="nc" id="L122">      sft.setStatsEnabled(enable)</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">      prompts.append(s&quot;\n  $number: ${if (enable) { &quot;En&quot; } else { &quot;Dis&quot; }}abling stats&quot;)</span>
    }

<span class="nc bnc" id="L126" title="All 2 branches missed.">    if (params.renameTables) {</span>
<span class="nc" id="L127">      updated.getUserData.put(SimpleFeatureTypes.Configs.UpdateRenameTables, java.lang.Boolean.TRUE)</span>
    }
<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (params.noBackup) {</span>
<span class="nc" id="L130">      updated.getUserData.put(SimpleFeatureTypes.Configs.UpdateBackupMetadata, java.lang.Boolean.FALSE)</span>
    }

<span class="nc bnc" id="L133" title="All 2 branches missed.">    Command.user.info(s&quot;Preparing to update schema '${sft.getTypeName}':$prompts&quot;)</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">    if (params.force || Prompt.confirm(&quot;Continue (y/n)? &quot;)) {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      Command.user.info(&quot;Updating, please wait...&quot;)</span>
<span class="nc" id="L136">      ds.updateSchema(sft.getTypeName, updated)</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">      Command.user.info(&quot;Update complete&quot;)</span>
    }
  }
}

<span class="nc" id="L142">object UpdateSchemaCommand {</span>

  // @Parameters(commandDescription = &quot;Update a GeoMesa feature type&quot;)
<span class="nc" id="L145">  trait UpdateSchemaParams extends RequiredTypeNameParam with OptionalForceParam {</span>

    @Parameter(names = Array(&quot;--rename&quot;), description = &quot;Update the feature type name&quot;)
    var rename: String = _

    @Parameter(
      names = Array(&quot;--rename-attribute&quot;),
      description = &quot;Rename an existing attribute, by specifying the current name and the new name&quot;,
      splitter = classOf[NoopParameterSplitter],
      arity = 2)
<span class="nc" id="L155">    var renameAttributes: java.util.List[String] = Collections.emptyList()</span>

    @Parameter(
      names = Array(&quot;--add-attribute&quot;),
      description = &quot;Add a new attribute, specified as a GeoTools spec string (e.g. 'dtg:Date:index=true')&quot;,
      splitter = classOf[NoopParameterSplitter])
<span class="nc" id="L161">    var attributes: java.util.List[String] = Collections.emptyList()</span>

    @Parameter(
      names = Array(&quot;--add-keyword&quot;),
      description = &quot;Add a new keyword to the feature type user data&quot;,
      splitter = classOf[NoopParameterSplitter])
<span class="nc" id="L167">    var plusKeywords: java.util.List[String] = Collections.emptyList()</span>

    @Parameter(
      names = Array(&quot;--remove-keyword&quot;),
      description = &quot;Remove a keyword from the feature type user data&quot;,
      splitter = classOf[NoopParameterSplitter])
<span class="nc" id="L173">    var minusKeywords: java.util.List[String] = Collections.emptyList()</span>

    @Parameter(
      names = Array(&quot;--add-user-data&quot;),
      description = &quot;Add a new entry or update an existing entry in the feature type user data, delineated with a colon (:)&quot;,
      splitter = classOf[NoopParameterSplitter])
<span class="nc" id="L179">    var userData: java.util.List[String] = Collections.emptyList()</span>

    @Parameter(
      names = Array(&quot;--enable-stats&quot;),
      description = &quot;Enable or disable stats for the feature type&quot;,
      arity = 1)
    var enableStats: java.lang.Boolean = _

    @Parameter(
      names = Array(&quot;--rename-tables&quot;),
      description = &quot;When updating the type name, also rename index tables to match the new type name&quot;)
<span class="nc" id="L190">    var renameTables: Boolean = false</span>

    @Parameter(
      names = Array(&quot;--no-backup&quot;),
      description = &quot;Don't back up data store metadata before updating the schema&quot;)
<span class="nc" id="L195">    var noBackup: Boolean = false</span>

    def validate(): Option[ParameterException] = {
<span class="nc bnc" id="L198" title="All 2 branches missed.">      if (rename == null &amp;&amp;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">          Seq(renameAttributes, attributes, plusKeywords, minusKeywords, userData).forall(_.isEmpty)) {</span>
<span class="nc" id="L200">        Some(new ParameterException(&quot;Please specify an update operation&quot;))</span>
      } else {
<span class="nc" id="L202">        None</span>
      }
    }
  }
<span class="nc" id="L206">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>