<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GetSftConfigCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.status</a> &gt; <span class="el_source">GetSftConfigCommand.scala</span></div><h1>GetSftConfigCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.status

import com.beust.jcommander._
import org.geotools.api.data.{DataStore, FileDataStore}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.tools.status.GetSftConfigCommand.{Spec, TypeSafe}
import org.locationtech.geomesa.tools.{Command, DataStoreCommand, ProvidedTypeNameParam, TypeNameParam}
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes

import java.util
import java.util.Collections

<span class="nc" id="L21">trait GetSftConfigCommand[DS &lt;: DataStore] extends DataStoreCommand[DS] {</span>

<span class="nc" id="L23">  override val name: String = &quot;get-sft-config&quot;</span>

  override def params: GetSftConfigParams

<span class="nc" id="L27">  override def execute(): Unit = withDataStore(showSftConfig)</span>

  protected def showSftConfig(ds: DS): Unit = {
    import scala.collection.JavaConverters._
    for {
<span class="nc bnc" id="L32" title="All 4 branches missed.">      p &lt;- Option(params).collect { case p: ProvidedTypeNameParam =&gt; p }</span>
<span class="nc bnc" id="L33" title="All 4 branches missed.">      f &lt;- Option(ds).collect { case f: FileDataStore =&gt; f }</span>
<span class="nc" id="L34">    } { p.featureName = f.getSchema.getTypeName }</span>

<span class="nc bnc" id="L36" title="All 2 branches missed.">    Command.user.info(s&quot;Retrieving SFT for type name '${params.featureName}'&quot;)</span>

<span class="nc" id="L38">    val sft = withDataStore(getSchema)</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">    if (sft == null) {</span>
<span class="nc" id="L40">      throw new ParameterException(s&quot;Schema '${params.featureName}' does not exist in the provided datastore&quot;)</span>
    }
<span class="nc" id="L42">    params.format.asScala.map(_.toLowerCase).foreach {</span>
<span class="nc bnc" id="L43" title="All 10 branches missed.">      case TypeSafe =&gt; Command.output.info(SimpleFeatureTypes.toConfigString(sft, !params.excludeUserData, params.concise))</span>
<span class="nc bnc" id="L44" title="All 10 branches missed.">      case Spec =&gt; Command.output.info(SimpleFeatureTypes.encodeType(sft, !params.excludeUserData))</span>
      // shouldn't happen due to parameter validation
<span class="nc" id="L46">      case f =&gt; throw new ParameterException(s&quot;Invalid format '$f'. Valid values are '$TypeSafe' and '$Spec'&quot;)</span>
    }
  }

<span class="nc" id="L50">  def getSchema(ds: DS): SimpleFeatureType = ds.getSchema(params.featureName)</span>
}

<span class="nc" id="L53">object GetSftConfigCommand {</span>
<span class="nc" id="L54">  val Spec = &quot;spec&quot;</span>
<span class="nc" id="L55">  val TypeSafe = &quot;config&quot;</span>
}

// @Parameters(commandDescription = &quot;Get the SimpleFeatureType of a feature&quot;)
<span class="nc" id="L59">trait GetSftConfigParams extends TypeNameParam {</span>
  @Parameter(names = Array(&quot;--concise&quot;), description = &quot;Render in concise format&quot;, required = false)
<span class="nc" id="L61">  var concise: Boolean = false</span>

  @Parameter(
    names = Array(&quot;--format&quot;),
    description = &quot;Output formats (allowed values are spec or config)&quot;,
    required = false,
    validateValueWith = Array(classOf[FormatValidator]))
<span class="nc" id="L68">  var format: java.util.List[String] = Collections.singletonList(Spec)</span>

  @Parameter(names = Array(&quot;--exclude-user-data&quot;), description = &quot;Exclude user data&quot;, required = false)
<span class="nc" id="L71">  var excludeUserData: Boolean = false</span>
}

<span class="nc" id="L74">class FormatValidator extends IValueValidator[java.util.List[String]] {</span>
  override def validate(name: String, value: util.List[String]): Unit = {
    import scala.collection.JavaConverters._
<span class="nc bnc" id="L77" title="All 18 branches missed.">    if (value == null || value.isEmpty || value.asScala.map(_.toLowerCase ).exists(v =&gt; v != Spec &amp;&amp; v != TypeSafe)) {</span>
<span class="nc" id="L78">      throw new ParameterException(s&quot;Invalid value for format: ${Option(value).map(_.asScala.mkString(&quot;,&quot;)).orNull}&quot;)</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>