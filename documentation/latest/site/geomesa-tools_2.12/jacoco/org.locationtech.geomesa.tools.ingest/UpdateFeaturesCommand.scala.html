<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UpdateFeaturesCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.ingest</a> &gt; <span class="el_source">UpdateFeaturesCommand.scala</span></div><h1>UpdateFeaturesCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.ingest

import com.beust.jcommander.{IParameterValidator, IStringConverter, Parameter, ParameterException}
import org.apache.accumulo.access.{AccessExpression, IllegalAccessExpressionException}
import org.geotools.api.data.{DataStore, Transaction}
import org.geotools.api.filter.Filter
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.security.SecurityUtils
import org.locationtech.geomesa.tools._
import org.locationtech.geomesa.tools.ingest.UpdateFeaturesCommand.UpdateFeaturesParams
import org.locationtech.geomesa.tools.utils.{NoopParameterSplitter, Prompt}
import org.locationtech.geomesa.utils.io.WithClose

import scala.util.Try

<span class="nc" id="L24">trait UpdateFeaturesCommand[DS &lt;: DataStore] extends DataStoreCommand[DS] {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L28">  override val name = &quot;update-features&quot;</span>
  override def params: UpdateFeaturesParams

  override def execute(): Unit = {
<span class="nc" id="L32">    val attributes = params.attributes.asScala.toMap</span>
<span class="nc" id="L33">    val vis = Option(params.visibility).filterNot(_.isBlank)</span>
<span class="nc bnc" id="L34" title="All 4 branches missed.">    if (attributes.isEmpty &amp;&amp; vis.isEmpty) {</span>
<span class="nc" id="L35">      throw new ParameterException(&quot;Must specify at least one --set or --set-visibility&quot;)</span>
    }
<span class="nc" id="L37">    withDataStore { ds =&gt;</span>
<span class="nc" id="L38">      val sft = Try(ds.getSchema(params.featureName)).getOrElse(null)</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">      if (sft == null) {</span>
<span class="nc" id="L40">        throw new ParameterException(s&quot;Schema '${params.featureName}' does not exist in the data store&quot;)</span>
<span class="nc bnc" id="L41" title="All 4 branches missed.">      } else if (attributes.keys.exists(a =&gt; sft.indexOf(a) == -1)) {</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">        val missing = attributes.keys.filter(a =&gt; sft.indexOf(a) == -1).mkString(&quot;'&quot;, &quot;', '&quot;, &quot;'&quot;)</span>
<span class="nc" id="L43">        throw new ParameterException(</span>
<span class="nc" id="L44">          s&quot;Attribute(s) $missing do not exist in schema '${params.featureName}'. Available attributes: &quot; +</span>
<span class="nc" id="L45">            sft.getAttributeDescriptors.asScala.map(_.getLocalName).mkString(&quot;, &quot;))</span>
      }
<span class="nc" id="L47">      val filter = Option(params.cqlFilter).getOrElse(Filter.INCLUDE)</span>
<span class="nc" id="L48">      val msg = new StringBuilder(s&quot;Updating schema '${params.featureName}', setting &quot;)</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">      if (attributes.nonEmpty) {</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">        msg.append(attributes.map { case (k, v) =&gt; s&quot;'$k' to '$v'&quot; }.mkString(&quot;attribute(s) &quot;, &quot;, &quot;, &quot;&quot;))</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">        if (vis.nonEmpty) {</span>
<span class="nc" id="L52">          msg.append(&quot; and &quot;)</span>
        }
      }
<span class="nc" id="L55">      vis.foreach(v =&gt; msg.append(s&quot;visibility to '$v'&quot;))</span>
<span class="nc bnc" id="L56" title="All 6 branches missed.">      if (filter == Filter.INCLUDE) {</span>
<span class="nc" id="L57">        msg.append(&quot; for all features&quot;)</span>
      } else {
<span class="nc" id="L59">        msg.append(s&quot;&quot;&quot; for features matching filter &quot;${ECQL.toCQL(filter)}&quot;&quot;&quot;&quot;)</span>
      }
<span class="nc bnc" id="L61" title="All 2 branches missed.">      Command.user.info(msg.toString())</span>
<span class="nc bnc" id="L62" title="All 4 branches missed.">      if (params.force || Prompt.confirm(&quot;Continue (y/n)? &quot;)) {</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        Command.user.info(s&quot;Updating features, please wait...&quot;)</span>
<span class="nc" id="L64">        var count = 0L</span>
<span class="nc" id="L65">        WithClose(ds.getFeatureWriter(params.featureName, filter, Transaction.AUTO_COMMIT)) { writer =&gt;</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">          while (writer.hasNext) {</span>
<span class="nc" id="L67">            val next = writer.next()</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">            attributes.foreach { case (k, v) =&gt; next.setAttribute(k, v) }</span>
<span class="nc" id="L69">            vis.foreach(next.getUserData.put(SecurityUtils.FEATURE_VISIBILITY, _))</span>
<span class="nc" id="L70">            writer.write()</span>
<span class="nc" id="L71">            count += 1</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">            if (count % 10000 == 0) {</span>
<span class="nc" id="L73">              print('.')</span>
            }
          }
<span class="nc" id="L76">          println()</span>
        }
<span class="nc bnc" id="L78" title="All 2 branches missed.">        Command.user.info(s&quot;Complete - updated $count total features&quot;)</span>
      }
    }
  }
}

<span class="nc" id="L84">object UpdateFeaturesCommand {</span>

  // @Parameters(commandDescription = &quot;Update attributes or visibilities of features in GeoMesa.&quot;)
<span class="nc" id="L87">  trait UpdateFeaturesParams extends RequiredTypeNameParam with OptionalCqlFilterParam with OptionalForceParam {</span>

    @Parameter(
      names = Array(&quot;--set&quot;),
      description = &quot;Name and value of an attribute to update, e.g. 'name=bob'&quot;,
      validateWith = Array(classOf[TupleValidator]),
      converter = classOf[TupleConverter],
      splitter = classOf[NoopParameterSplitter])
<span class="nc" id="L95">    var attributes: java.util.List[(String, String)] = new java.util.ArrayList[(String, String)]()</span>

    @Parameter(
      names = Array(&quot;--set-visibility&quot;),
      description = &quot;Visibility to set on updated features&quot;,
      validateWith = Array(classOf[VisibilityValidator]))
    var visibility: String = _
  }

<span class="nc" id="L104">  class TupleConverter extends IStringConverter[(String, String)] {</span>
    override def convert(value: String): (String, String) = {
<span class="nc" id="L106">      value.split(&quot;=&quot;, 2) match {</span>
<span class="nc bnc" id="L107" title="All 6 branches missed.">        case Array(one, two) =&gt; (one, two)</span>
      }
    }
  }

<span class="nc" id="L112">  class TupleValidator extends IParameterValidator {</span>
    @throws[ParameterException]
    override def validate(name: String, value: String): Unit = {
<span class="nc bnc" id="L115" title="All 6 branches missed.">      if (value == null || value.isEmpty || value.indexOf('=') == -1) {</span>
<span class="nc" id="L116">        throw new ParameterException(s&quot;Parameter $name $value is not a valid tuple of the form 'k=v'&quot;)</span>
      }
    }
  }

<span class="nc" id="L121">  class VisibilityValidator extends IParameterValidator {</span>
    @throws[ParameterException]
    override def validate(name: String, value: String): Unit = {
<span class="nc" id="L124">      try { AccessExpression.validate(value) } catch {</span>
        case e: IllegalAccessExpressionException =&gt;
<span class="nc" id="L126">          throw new ParameterException(s&quot;Parameter $name $value is not a valid visibility: ${e.getMessage}&quot;, e)</span>
      }
    }
  }
<span class="nc" id="L130">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>