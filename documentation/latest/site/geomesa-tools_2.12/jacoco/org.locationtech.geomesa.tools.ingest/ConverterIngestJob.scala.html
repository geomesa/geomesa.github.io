<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConverterIngestJob.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.ingest</a> &gt; <span class="el_source">ConverterIngestJob.scala</span></div><h1>ConverterIngestJob.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.ingest

import com.typesafe.config.{Config, ConfigRenderOptions}
import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.io.{LongWritable, Text}
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat
import org.apache.hadoop.mapreduce.{Job, Mapper}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.data.DataUtilities
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.jobs.mapreduce.{ConverterInputFormat, GeoMesaOutputFormat, JobWithLibJars}
import org.locationtech.geomesa.jobs.{Awaitable, JobResult, StatusCallback}
import org.locationtech.geomesa.tools.ingest.IngestCommand.IngestCounters
import org.locationtech.geomesa.tools.utils.JobRunner

import java.io.File

/**
 * Distributed job that uses converters to process input files
 *
 * @param dsParams data store connection
 * @param sft simple feature type
 * @param converterConfig converter definition
 * @param paths input files
 * @param libjarsFiles lib jars
 * @param libjarsPaths lib jars paths
 */
<span class="nc" id="L37">class ConverterIngestJob(</span>
<span class="nc" id="L38">    dsParams: Map[String, String],</span>
<span class="nc" id="L39">    sft: SimpleFeatureType,</span>
<span class="nc" id="L40">    converterConfig: Config,</span>
<span class="nc" id="L41">    paths: Seq[String],</span>
    libjarsFiles: Seq[String],
    libjarsPaths: Iterator[() =&gt; Seq[File]]
<span class="nc" id="L44">  ) extends Awaitable with JobWithLibJars {</span>

  import ConverterInputFormat.ConverterCounters
  import GeoMesaOutputFormat.OutputCounters

<span class="nc" id="L49">  private val failCounters =</span>
<span class="nc" id="L50">    Seq((ConverterCounters.Group, ConverterCounters.Failed), (OutputCounters.Group, OutputCounters.Failed))</span>

<span class="nc" id="L52">  private val job = {</span>
<span class="nc" id="L53">    val job = Job.getInstance(new Configuration, &quot;GeoMesa Tools Ingest&quot;)</span>
<span class="nc" id="L54">    setLibJars(job, libjarsFiles, libjarsPaths)</span>
<span class="nc" id="L55">    configureJob(job)</span>
<span class="nc" id="L56">    JobRunner.submit(job)</span>
<span class="nc" id="L57">    job</span>
  }

  protected def mapCounters(job: Job): Seq[(String, Long)] = {
<span class="nc" id="L61">    Seq(</span>
<span class="nc" id="L62">      (IngestCounters.Ingested, job.getCounters.findCounter(OutputCounters.Group, OutputCounters.Written).getValue),</span>
<span class="nc" id="L63">      (IngestCounters.Failed, failCounters.map(c =&gt; job.getCounters.findCounter(c._1, c._2).getValue).sum)</span>
    )
  }

<span class="nc" id="L67">  protected def reduceCounters(job: Job): Seq[(String, Long)] = Seq.empty</span>

  override def await(reporter: StatusCallback): JobResult =
<span class="nc" id="L70">    JobRunner.monitor(job, reporter, mapCounters(job), reduceCounters(job))</span>

  def configureJob(job: Job): Unit = {
<span class="nc" id="L73">    job.setJarByClass(getClass)</span>
<span class="nc" id="L74">    job.setMapperClass(classOf[ConverterIngestJob.IngestMapper])</span>
<span class="nc" id="L75">    job.setInputFormatClass(classOf[ConverterInputFormat])</span>
<span class="nc" id="L76">    job.setOutputFormatClass(classOf[GeoMesaOutputFormat])</span>
<span class="nc" id="L77">    job.setMapOutputKeyClass(classOf[Text])</span>
<span class="nc" id="L78">    job.setOutputValueClass(classOf[ScalaSimpleFeature])</span>
<span class="nc" id="L79">    job.setNumReduceTasks(0)</span>
<span class="nc" id="L80">    job.getConfiguration.set(&quot;mapred.map.tasks.speculative.execution&quot;, &quot;false&quot;)</span>
<span class="nc" id="L81">    job.getConfiguration.set(&quot;mapred.reduce.tasks.speculative.execution&quot;, &quot;false&quot;)</span>
<span class="nc" id="L82">    job.getConfiguration.set(&quot;mapreduce.job.user.classpath.first&quot;, &quot;true&quot;)</span>

<span class="nc" id="L84">    FileInputFormat.setInputPaths(job, paths.mkString(&quot;,&quot;))</span>
<span class="nc" id="L85">    ConverterInputFormat.setConverterConfig(job, converterConfig.root().render(ConfigRenderOptions.concise()))</span>
<span class="nc" id="L86">    ConverterInputFormat.setSft(job, sft)</span>

<span class="nc" id="L88">    GeoMesaOutputFormat.setOutput(job.getConfiguration, dsParams, sft)</span>
  }
}

<span class="nc" id="L92">object ConverterIngestJob {</span>

  /**
   * Takes the input and writes it to the output - all our main work is done in the input format
   */
<span class="nc bnc" id="L97" title="All 4 branches missed.">  class IngestMapper extends Mapper[LongWritable, SimpleFeature, Text, SimpleFeature] with LazyLogging {</span>

    type Context = Mapper[LongWritable, SimpleFeature, Text, SimpleFeature]#Context

<span class="nc" id="L101">    private val text: Text = new Text</span>

    override def map(key: LongWritable, sf: SimpleFeature, context: Context): Unit = {
<span class="nc bnc" id="L104" title="All 2 branches missed.">      logger.debug(s&quot;map key ${key.toString}, map value ${DataUtilities.encodeFeature(sf)}&quot;)</span>
<span class="nc" id="L105">      context.write(text, sf)</span>
    }
  }
<span class="nc" id="L108">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>