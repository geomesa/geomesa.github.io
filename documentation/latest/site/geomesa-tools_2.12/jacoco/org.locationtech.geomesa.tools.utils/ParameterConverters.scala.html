<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParameterConverters.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools.utils</a> &gt; <span class="el_source">ParameterConverters.scala</span></div><h1>ParameterConverters.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools.utils

import com.beust.jcommander.converters.BaseConverter
import com.beust.jcommander.{IValueValidator, ParameterException}
import org.geotools.api.filter.Filter
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.convert.Modes.ErrorMode
import org.locationtech.geomesa.tools.`export`.ExportFormat
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.text.Suffixes.Memory
import org.locationtech.geomesa.utils.text.{DurationParsing, TextTools}

import java.util.Date
import scala.concurrent.duration.Duration
import scala.util.control.NonFatal
import scala.util.{Failure, Success, Try}

<span class="nc" id="L26">object ParameterConverters {</span>

<span class="nc" id="L28">  class HintConverter(name: String) extends BaseConverter[java.util.Map[String, String]](name) {</span>
    override def convert(value: String): java.util.Map[String, String] = {
<span class="nc" id="L30">      try {</span>
<span class="nc" id="L31">        val map = new java.util.HashMap[String, String]()</span>
<span class="nc" id="L32">        value.split(&quot;;&quot;).foreach { part =&gt;</span>
<span class="nc bnc" id="L33" title="All 6 branches missed.">          val Array(k, v) = part.split(&quot;=&quot;)</span>
<span class="nc" id="L34">          map.put(k.trim, v.trim)</span>
        }
<span class="nc" id="L36">        map</span>
      } catch {
<span class="nc bnc" id="L38" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(getErrorString(value, s&quot;hint map: $e&quot;))</span>
      }
    }
  }

<span class="nc" id="L43">  class DurationConverter(name: String) extends BaseConverter[Duration](name) {</span>
    override def convert(value: String): Duration = {
<span class="nc" id="L45">      try { DurationParsing.caseInsensitive(value) } catch {</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(getErrorString(value, s&quot;duration: $e&quot;))</span>
      }
    }
  }

<span class="nc" id="L51">  class FilterConverter(name: String) extends BaseConverter[Filter](name) {</span>
    override def convert(value: String): Filter = {
<span class="nc" id="L53">      try {</span>
<span class="nc" id="L54">        ECQL.toFilter(value)</span>
      } catch {
<span class="nc bnc" id="L56" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(getErrorString(value, s&quot;filter: $e&quot;))</span>
      }
    }
  }

<span class="nc" id="L61">  class ExportFormatConverter(name: String) extends BaseConverter[ExportFormat](name) {</span>
    override def convert(value: String): ExportFormat = {
<span class="nc" id="L63">      ExportFormat(value).getOrElse {</span>
<span class="nc" id="L64">        val valid = ExportFormat.Formats.flatMap(f =&gt; f.extensions :+ f.name).distinct</span>
<span class="nc" id="L65">        throw new ParameterException(getErrorString(value, s&quot;an export format. Valid formats are: ${TextTools.wordList(valid)}&quot;))</span>
      }
    }
  }

<span class="nc" id="L70">  class KeyValueConverter(name: String) extends BaseConverter[(String, String)](name) {</span>
    override def convert(value: String): (String, String) = {
<span class="nc" id="L72">      try {</span>
<span class="nc" id="L73">        val i = value.indexOf('=')</span>
<span class="nc bnc" id="L74" title="All 4 branches missed.">        if (i == -1 || value.indexOf('=', i + 1) != -1) {</span>
<span class="nc" id="L75">          throw new IllegalArgumentException(&quot;key-value pairs must be separated by a single '='&quot;)</span>
        }
<span class="nc" id="L77">        (value.substring(0, i), value.substring(i + 1))</span>
      } catch {
<span class="nc bnc" id="L79" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(getErrorString(value, s&quot;format: $e&quot;))</span>
      }
    }
  }

<span class="nc" id="L84">  class DateConverter(name: String) extends BaseConverter[Date](name) {</span>
    override def convert(value: String): Date = {
<span class="nc" id="L86">      try {</span>
<span class="nc" id="L87">        val date = FastConverter.convert(value, classOf[Date])</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (date == null) {</span>
<span class="nc" id="L89">          throw new IllegalArgumentException(s&quot;Could not convert $value to date&quot;)</span>
        }
<span class="nc" id="L91">        date</span>
      } catch {
<span class="nc bnc" id="L93" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(getErrorString(value, s&quot;format: $e&quot;))</span>
      }
    }
  }

<span class="nc" id="L98">  class IntervalConverter(name: String) extends BaseConverter[(Date, Date)](name) {</span>
    override def convert(value: String): (Date, Date) = {
<span class="nc" id="L100">      try {</span>
<span class="nc" id="L101">        val i = value.indexOf('/')</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">        if (i == -1 || value.indexOf('/', i + 1) != -1) {</span>
<span class="nc" id="L103">          throw new IllegalArgumentException(&quot;Interval from/to must be separated by a single '/'&quot;)</span>
        }
<span class="nc" id="L105">        val start = FastConverter.convert(value.substring(0, i), classOf[Date])</span>
<span class="nc" id="L106">        val end = FastConverter.convert(value.substring(i + 1), classOf[Date])</span>
<span class="nc bnc" id="L107" title="All 4 branches missed.">        if (start == null || end == null) {</span>
<span class="nc" id="L108">          throw new IllegalArgumentException(s&quot;Could not convert $value to date interval&quot;)</span>
        }
<span class="nc" id="L110">        (start, end)</span>
      } catch {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(getErrorString(value, s&quot;format: $e&quot;))</span>
      }
    }
  }

<span class="nc" id="L117">  class ErrorModeConverter(name: String) extends BaseConverter[ErrorMode](name) {</span>
    override def convert(value: String): ErrorMode = {
<span class="nc" id="L119">      Try(ErrorMode(value)) match {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        case Success(m) =&gt; m</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        case Failure(e) =&gt; throw new ParameterException(e.getMessage)</span>
      }
    }
  }

<span class="nc" id="L126">  class BytesConverter(name: String) extends BaseConverter[java.lang.Long](name) {</span>
    override def convert(value: String): java.lang.Long = {
<span class="nc" id="L128">      Memory.bytes(value) match {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        case Success(b) =&gt; b</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        case Failure(e) =&gt; throw new ParameterException(s&quot;Invalid byte string '$value'&quot;, e)</span>
      }
    }
  }

<span class="nc" id="L135">  class BytesValidator extends IValueValidator[String] {</span>
    override def validate(name: String, value: String): Unit =
<span class="nc" id="L137">      Memory.bytes(value).failed.foreach(e =&gt; throw new ParameterException(s&quot;Invalid byte string '$value'&quot;, e))</span>
  }
<span class="nc" id="L139">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>