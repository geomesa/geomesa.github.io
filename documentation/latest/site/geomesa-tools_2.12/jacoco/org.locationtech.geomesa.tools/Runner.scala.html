<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Runner.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools</a> &gt; <span class="el_source">Runner.scala</span></div><h1>Runner.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools

import com.beust.jcommander.{JCommander, ParameterException}
import com.facebook.nailgun.NGContext
import com.typesafe.scalalogging.LazyLogging
import org.locationtech.geomesa.tools.Command.CommandException
import org.locationtech.geomesa.tools.Runner.{CommandResult, Executor}
import org.locationtech.geomesa.tools.`export`.{ConvertCommand, GenerateAvroSchemaCommand}
import org.locationtech.geomesa.tools.help.{ClasspathCommand, HelpCommand, NailgunCommand, ScalaConsoleCommand}
import org.locationtech.geomesa.tools.status.{AutoCompleteCommand, ConfigureCommand, EnvironmentCommand, VersionCommand}
import org.locationtech.geomesa.tools.utils.{GeoMesaIStringConverterFactory, NailgunServer}

import java.util.Locale
import scala.collection.JavaConverters._
import scala.collection.mutable.ArrayBuffer
import scala.util.control.NonFatal

<span class="nc" id="L26">trait Runner extends LazyLogging {</span>

  def name: String

  /**
   * A list of environment variables used to load the classpath, used for error messages after
   * ClassNotFoundExceptions
   *
   * @return
   */
<span class="nc" id="L36">  protected def classpathEnvironments: Seq[String] = Seq.empty</span>

  /**
   * Main command line invocation
   *
   * @param args command line args
   */
<span class="nc" id="L43">  def main(args: Array[String]): Unit = execute(new MainExecutor(args))</span>

  /**
   * Nailgun main invocation
   *
   * @param context context
   */
<span class="nc" id="L50">  def nailMain(context: NGContext): Unit = execute(new NailgunExecutor(context))</span>

  private def execute(executor: Executor): Unit = {
<span class="nc" id="L53">    val result = try { executor.execute(); CommandResult(0) } catch {</span>
<span class="nc bnc" id="L54" title="All 6 branches missed.">      case e @ (_: ClassNotFoundException | _: NoClassDefFoundError) =&gt;</span>
        // log the underling exception to the log file, but don't show to the user
<span class="nc" id="L56">        val msg = s&quot;Warning: Missing dependency for command execution: ${e.getMessage}&quot;</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">        logger.error(msg, e)</span>
<span class="nc" id="L58">        CommandResult(1, Seq(Left(msg)) ++ getEnvironmentErrors.map(Left.apply[String, Throwable]))</span>
<span class="nc bnc" id="L59" title="All 6 branches missed.">      case e @ (_: ParameterException | _: CommandException) =&gt;</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        logger.error(&quot;Error executing command:&quot;, e)</span>
<span class="nc" id="L61">        CommandResult(1, failureMessages(e))</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">      case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        logger.error(&quot;Error executing command:&quot;, e)</span>
<span class="nc" id="L64">        CommandResult(1, Seq(Right(e)))</span>
    }

<span class="nc" id="L67">    result.errors.foreach {</span>
<span class="nc bnc" id="L68" title="All 4 branches missed.">      case Left(msg) =&gt; Command.user.error(msg)</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">      case Right(e)  =&gt; Command.user.error(e.getMessage, e)</span>
    }

<span class="nc" id="L72">    sys.exit(result.code)</span>
  }

<span class="nc" id="L75">  private def failureMessages(e: Throwable, indent: String = &quot;&quot;, prefix: String = &quot;&quot;): Seq[Left[String, Throwable]] = {</span>
<span class="nc" id="L76">    val messages = ArrayBuffer.empty[Left[String, Throwable]]</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">    val message = if (indent == &quot;&quot;) { e.getMessage } else { s&quot;$indent$prefix${e.toString}&quot; }</span>
<span class="nc" id="L78">    messages += Left(message)</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">    if (e.getCause != null) {</span>
<span class="nc" id="L80">      messages ++= failureMessages(e.getCause, indent + &quot;  &quot;, &quot;Caused by: &quot;)</span>
    }
<span class="nc" id="L82">    e.getSuppressed.foreach { e =&gt;</span>
<span class="nc" id="L83">      messages ++= failureMessages(e, indent + &quot;  &quot;, &quot;Suppressed: &quot;)</span>
    }
<span class="nc" id="L85">    messages.toSeq</span>
  }

  def parseCommand(args: Array[String]): Command = {
    val jc =
<span class="nc" id="L90">      JCommander.newBuilder()</span>
<span class="nc" id="L91">          .programName(name)</span>
<span class="nc" id="L92">          .addConverterFactory(new GeoMesaIStringConverterFactory)</span>
          .build()

<span class="nc" id="L95">    val commands = this.commands ++ Seq(new HelpCommand(this, jc), new AutoCompleteCommand(this, jc))</span>
<span class="nc" id="L96">    commands.foreach { command =&gt;</span>
<span class="nc" id="L97">      jc.addCommand(command.name, command.params)</span>
<span class="nc" id="L98">      command.subCommands.foreach(sub =&gt; jc.getCommands.get(command.name).addCommand(sub.name, sub.params))</span>
    }

    def logAndThrowError(e: ParameterException): Unit = {
<span class="nc bnc" id="L102" title="All 2 branches missed.">      Command.user.error(s&quot;Error parsing arguments: ${e.getMessage}&quot;)</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">      Command.user.info(usage(jc, jc.getParsedCommand))</span>
<span class="nc" id="L104">      throw e</span>
    }

<span class="nc" id="L107">    try { jc.parse(args: _*) } catch {</span>
<span class="nc" id="L108">      case e: ParameterException =&gt; logAndThrowError(e)</span>
    }

<span class="nc bnc" id="L111" title="All 6 branches missed.">    val parsed = commands.find(_.name == jc.getParsedCommand).getOrElse(new DefaultCommand(jc))</span>
<span class="nc" id="L112">    resolveEnvironment(parsed)</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">    val command = if (parsed.subCommands.isEmpty) { parsed } else {</span>
      lazy val available =
<span class="nc bnc" id="L115" title="All 2 branches missed.">        s&quot;Use '${parsed.name} &lt;sub-command&gt;', where sub-command is one of: &quot; +</span>
<span class="nc" id="L116">            parsed.subCommands.map(_.name).mkString(&quot;, &quot;)</span>
<span class="nc" id="L117">      val sub = Option(jc.getCommands.get(parsed.name).getParsedCommand).getOrElse {</span>
<span class="nc" id="L118">        throw new ParameterException(s&quot;No sub-command specified. $available&quot;)</span>
      }
<span class="nc bnc" id="L120" title="All 6 branches missed.">      parsed.subCommands.find(_.name == sub).getOrElse {</span>
<span class="nc" id="L121">        throw new ParameterException(s&quot;Sub-command '$sub' not found. $available&quot;)</span>
      }
    }
<span class="nc" id="L124">    command.validate().foreach(logAndThrowError)</span>
<span class="nc" id="L125">    command</span>
  }

  def usage(jc: JCommander): String = {
<span class="nc" id="L129">    val out = new StringBuilder()</span>
<span class="nc" id="L130">    out.append(s&quot;Usage: $name [command] [command options]\n&quot;)</span>
<span class="nc" id="L131">    val commands = jc.getCommands.asScala.keys.toSeq.sorted</span>
<span class="nc" id="L132">    out.append(&quot;  Commands:\n&quot;)</span>
<span class="nc" id="L133">    val maxLen = commands.map(_.length).max + 4</span>
<span class="nc" id="L134">    commands.foreach { name =&gt;</span>
<span class="nc" id="L135">      val spaces = &quot; &quot; * (maxLen - name.length)</span>
<span class="nc" id="L136">      out.append(s&quot;    $name$spaces${jc.getUsageFormatter.getCommandDescription(name)}\n&quot;)</span>
    }
<span class="nc" id="L138">    out.toString()</span>
  }

  def usage(jc: JCommander, name: String): String = {
<span class="nc" id="L142">    Option(name).flatMap(n =&gt; Option(jc.getCommands.get(n))) match {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      case None =&gt; usage(jc)</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">      case Some(command) =&gt;</span>
<span class="nc" id="L145">        val out = new java.lang.StringBuilder()</span>
<span class="nc" id="L146">        command.getUsageFormatter.usage(out)</span>
<span class="nc" id="L147">        out.toString</span>
    }
  }

  /**
   * Commands available to this runner. The default impl handles common commands
   * and placeholders for script functions
   *
   * @return
   */
  protected def commands: Seq[Command] = {
<span class="nc" id="L158">    Seq(</span>
<span class="nc" id="L159">      new ConvertCommand,</span>
<span class="nc" id="L160">      new ConfigureCommand,</span>
<span class="nc" id="L161">      new ClasspathCommand,</span>
<span class="nc" id="L162">      new EnvironmentCommand,</span>
<span class="nc" id="L163">      new GenerateAvroSchemaCommand,</span>
<span class="nc" id="L164">      new NailgunCommand,</span>
<span class="nc" id="L165">      new ScalaConsoleCommand,</span>
<span class="nc" id="L166">      new VersionCommand</span>
    )
  }

<span class="nc" id="L170">  protected def resolveEnvironment(command: Command): Unit = {}</span>

  private def getEnvironmentErrors: Option[String] = {
<span class="nc" id="L173">    val env = classpathEnvironments</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">    if (env.forall(sys.env.contains)) { None } else {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">      val envMsg = if (env.size == 1) { &quot;is not set as an environment variable&quot; } else { &quot;are not set as environment variables&quot; }</span>
<span class="nc" id="L176">      val types = env.map(e =&gt; e.take(1) ++ e.drop(1).toLowerCase(Locale.US).replace(&quot;_home&quot;, &quot;&quot;)).mkString(&quot; and &quot;)</span>
      val msg =
<span class="nc" id="L178">        s&quot;\nWarning: ${env.mkString(&quot; and/or &quot;)} $envMsg.&quot; +</span>
<span class="nc" id="L179">            s&quot;\nGeoMesa tools will not run without the appropriate $types JARs in the tools classpath.&quot; +</span>
<span class="nc" id="L180">            s&quot;\nPlease ensure that those JARs are present in the classpath by running '$name classpath'.&quot; +</span>
<span class="nc" id="L181">            &quot;\nTo take corrective action, copy the necessary JAR files in the GeoMesa tools lib directory &quot; +</span>
<span class="nc" id="L182">            &quot;using the provided 'install-dependencies.sh' and 'install-*-support.sh' scripts.&quot;</span>
<span class="nc" id="L183">      Some(msg)</span>
    }
  }

<span class="nc bnc" id="L187" title="All 2 branches missed.">  class DefaultCommand(jc: JCommander) extends Command {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">    override def execute(): Unit = Command.user.info(usage(jc))</span>
<span class="nc" id="L189">    override val name: String = &quot;&quot;</span>
<span class="nc" id="L190">    override val params: Any = null</span>
  }

<span class="nc bnc" id="L193" title="All 2 branches missed.">  class MainExecutor(args: Array[String]) extends Executor {</span>
<span class="nc" id="L194">    override def execute(): Unit = parseCommand(args).execute()</span>
  }

<span class="nc bnc" id="L197" title="All 2 branches missed.">  class NailgunExecutor(context: NGContext) extends Executor {</span>
    override def execute(): Unit = {
<span class="nc" id="L199">      val command = parseCommand(context.getArgs)</span>
<span class="nc" id="L200">      context.getNGServer match {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        case ng: NailgunServer =&gt; ng.execute(command)</span>
<span class="nc" id="L202">        case ng =&gt; throw new IllegalStateException(s&quot;Expected a NailgunServer but got: $ng&quot;)</span>
      }
    }
  }
}

<span class="nc" id="L208">object Runner {</span>

  trait Executor {
    def execute(): Unit
  }

  /**
   * Result of executing a command
   *
   * @param code exit code
   * @param errors error messages or exceptions with full stack traces
   */
<span class="nc bnc" id="L220" title="All 21 branches missed.">  case class CommandResult(code: Int, errors: Seq[Either[String, Throwable]] = Seq.empty)</span>
<span class="nc" id="L221">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>