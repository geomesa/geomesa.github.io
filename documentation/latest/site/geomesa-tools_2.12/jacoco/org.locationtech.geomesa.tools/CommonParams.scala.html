<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CommonParams.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.tools</a> &gt; <span class="el_source">CommonParams.scala</span></div><h1>CommonParams.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.tools

import com.beust.jcommander.{Parameter, ParameterException}
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.convert.Modes.ErrorMode
import org.locationtech.geomesa.index.api.GeoMesaFeatureIndex
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.index.attribute.AttributeIndex
import org.locationtech.geomesa.tools.DistributedRunParam.RunModes
import org.locationtech.geomesa.tools.utils.ParameterConverters.{ErrorModeConverter, FilterConverter, HintConverter}
import org.locationtech.geomesa.tools.utils.ParameterValidators.PositiveInteger
import org.locationtech.geomesa.utils.index.IndexMode.IndexMode

import java.util
import java.util.regex.Pattern

/**
  * Shared parameters as individual traits
  */

trait QueryParams extends CatalogParam with RequiredTypeNameParam with CqlFilterParam with OptionalAttributesParam

<span class="nc" id="L31">trait CatalogParam {</span>
  @Parameter(names = Array(&quot;-c&quot;, &quot;--catalog&quot;), description = &quot;Catalog table for GeoMesa datastore&quot;, required = true)
  var catalog: String = _
}

trait TypeNameParam {
  def featureName: String
}

<span class="nc" id="L40">trait RequiredTypeNameParam extends TypeNameParam {</span>
  @Parameter(names = Array(&quot;-f&quot;, &quot;--feature-name&quot;), description = &quot;Simple Feature Type name on which to operate&quot;, required = true)
  var featureName: String = _
}

<span class="nc" id="L45">trait OptionalTypeNameParam extends TypeNameParam {</span>
  @Parameter(names = Array(&quot;-f&quot;, &quot;--feature-name&quot;), description = &quot;Simple Feature Type name on which to operate&quot;)
  var featureName: String = _
}

<span class="nc" id="L50">trait ProvidedTypeNameParam extends TypeNameParam {</span>
  var featureName: String = _
}

<span class="nc" id="L54">trait PasswordParams {</span>
  @Parameter(names = Array(&quot;-p&quot;, &quot;--password&quot;), description = &quot;Connection password&quot;)
  var password: String = _
}

<span class="nc" id="L59">trait KerberosParams {</span>
  @Parameter(names = Array(&quot;--keytab&quot;), description = &quot;Path to Kerberos keytab file&quot;)
  var keytab: String = _
}

<span class="nc" id="L64">trait CredentialsParams extends PasswordParams {</span>
  @Parameter(names = Array(&quot;-u&quot;, &quot;--user&quot;), description = &quot;Connection user name&quot;)
  var user: String = _
}

trait FeatureSpecParam {
  def spec: String
}

<span class="nc" id="L73">trait RequiredFeatureSpecParam extends FeatureSpecParam {</span>
  @Parameter(names = Array(&quot;-s&quot;, &quot;--spec&quot;),
    description = &quot;SimpleFeatureType specification as a GeoTools spec string, SFT config, or file with either&quot;, required = true)
  var spec: String = _
}

<span class="nc" id="L79">trait OptionalFeatureSpecParam extends FeatureSpecParam {</span>
  @Parameter(names = Array(&quot;-s&quot;, &quot;--spec&quot;), description = &quot;SimpleFeatureType specification as a GeoTools spec string, SFT config, or file with either&quot;)
  var spec: String = _
}

trait CqlFilterParam {
  def cqlFilter: Filter
}

<span class="nc" id="L88">trait RequiredCqlFilterParam extends CqlFilterParam {</span>
  @Parameter(names = Array(&quot;-q&quot;, &quot;--cql&quot;), description = &quot;CQL predicate&quot;, required = true, converter = classOf[FilterConverter])
  var cqlFilter: Filter = _
}

<span class="nc" id="L93">trait OptionalCqlFilterParam extends CqlFilterParam {</span>
  @Parameter(names = Array(&quot;-q&quot;, &quot;--cql&quot;), description = &quot;CQL predicate&quot;, converter = classOf[FilterConverter])
  var cqlFilter: Filter = _
}

<span class="nc" id="L98">trait QueryHintsParams {</span>
  @Parameter(names = Array(&quot;--hints&quot;), description = &quot;Query hints to set, in the form key1=value1;key2=value2&quot;, required = false, converter = classOf[HintConverter])
  var hints: java.util.Map[String, String] = _
}

<span class="nc" id="L103">trait OptionalDtgParam {</span>
  @Parameter(names = Array(&quot;--dtg&quot;), description = &quot;DateTime field name to use as the default dtg&quot;)
  var dtgField: String = _
}

trait AttributesParam {
  def attributes: java.util.List[String]
}

<span class="nc" id="L112">trait OptionalAttributesParam extends AttributesParam {</span>
  @Parameter(names = Array(&quot;-a&quot;, &quot;--attributes&quot;), description = &quot;Attributes to evaluate (comma-separated)&quot;)
  var attributes: java.util.List[String] = _
}

<span class="nc" id="L117">trait RequiredAttributesParam extends AttributesParam {</span>
  @Parameter(names = Array(&quot;-a&quot;, &quot;--attributes&quot;), description = &quot;Attributes to evaluate (comma-separated)&quot;, required = true)
  var attributes: java.util.List[String] = _
}

<span class="nc" id="L122">trait OptionalForceParam {</span>
  @Parameter(names = Array(&quot;--force&quot;), description = &quot;Force execution without prompt&quot;)
<span class="nc" id="L124">  var force: Boolean = false</span>
}

<span class="nc" id="L127">trait OptionalPatternParam {</span>
  @Parameter(names = Array(&quot;--pattern&quot;), description = &quot;Regular expression for simple feature type names&quot;)
  var pattern: Pattern = _
}

<span class="nc" id="L132">trait OptionalZookeepersParam {</span>
  @Parameter(names = Array(&quot;-z&quot;, &quot;--zookeepers&quot;), description = &quot;Zookeepers (host[:port], comma separated)&quot;)
  var zookeepers: String = _
}

<span class="nc" id="L137">trait InputFilesParam {</span>
  @Parameter(description = &quot;&lt;file&gt;...&quot;)
<span class="nc" id="L139">  var files: java.util.List[String] = new util.ArrayList[String]()</span>
}

<span class="nc" id="L142">trait OptionalInputFormatParam extends InputFilesParam {</span>
  @Parameter(names = Array(&quot;--input-format&quot;), description = &quot;File format of input files (shp, csv, tsv, avro, etc). Optional, auto-detection will be attempted&quot;)
  var inputFormat: String = _
}

<span class="nc" id="L147">trait ConverterConfigParam {</span>
  @Parameter(names = Array(&quot;-C&quot;, &quot;--converter&quot;), description = &quot;GeoMesa converter specification as a config string, file name, or name of an available converter&quot;)
  var config: String = _

  @Parameter(names = Array(&quot;--converter-error-mode&quot;), description = &quot;Override the converter error mode - 'log-errors' or 'raise-errors'&quot;, converter = classOf[ErrorModeConverter])
  var errorMode: ErrorMode = _
}

<span class="nc" id="L155">object IndexParam {</span>

  @throws[ParameterException]
  def loadIndex[DS &lt;: GeoMesaDataStore[DS]](ds: DS,
                                            typeName: String,
                                            index: String,
                                            mode: IndexMode): GeoMesaFeatureIndex[_, _] = {
<span class="nc" id="L162">    val sft = ds.getSchema(typeName)</span>
<span class="nc" id="L163">    val indices = ds.manager.indices(sft, mode)</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">    lazy val available = {</span>
      val names = scala.collection.mutable.Map.empty[String, Int].withDefaultValue(0)
<span class="nc" id="L167">      indices.foreach(i =&gt; names.put(i.name, names(i.name) + 1))</span>
<span class="nc bnc" id="L168" title="All 8 branches missed.">      (indices.map(_.identifier) ++ names.collect { case (n, 1) =&gt; n }).distinct.sorted.mkString(&quot;, &quot;)</span>
    }

<span class="nc" id="L171">    def single(indices: Seq[GeoMesaFeatureIndex[_, _]]): Option[GeoMesaFeatureIndex[_, _]] = indices match {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">      case Nil =&gt; None</span>
<span class="nc bnc" id="L173" title="All 6 branches missed.">      case Seq(i) =&gt; Some(i)</span>
<span class="nc" id="L174">      case _ =&gt; throw new ParameterException(s&quot;Specified index '$index' is ambiguous. Available indices are: $available&quot;)</span>
    }

<span class="nc" id="L177">    def byId: Option[GeoMesaFeatureIndex[_, _]] = indices.find(_.identifier.equalsIgnoreCase(index))</span>
<span class="nc" id="L178">    def byName: Option[GeoMesaFeatureIndex[_, _]] = single(indices.filter(_.name.equalsIgnoreCase(index)))</span>
    // check for attr vs join index name
<span class="nc bnc" id="L180" title="All 2 branches missed.">    def byJoin: Option[GeoMesaFeatureIndex[_, _]] = if (!index.equalsIgnoreCase(AttributeIndex.name)) { None } else {</span>
<span class="nc bnc" id="L181" title="All 6 branches missed.">      single(indices.filter(_.name == AttributeIndex.JoinIndexName))</span>
    }

<span class="nc" id="L184">    byId.orElse(byName).orElse(byJoin).getOrElse {</span>
<span class="nc" id="L185">      throw new ParameterException(s&quot;Specified index '$index' not found. Available indices are: $available&quot;)</span>
    }
  }
}

<span class="nc" id="L190">trait IndexParam {</span>
  def index: String
}

<span class="nc" id="L194">trait OptionalIndexParam extends IndexParam {</span>

  @Parameter(names = Array(&quot;--index&quot;), description = &quot;Specify a particular GeoMesa index&quot;, required = false)
  var index: String = _

  @throws[ParameterException]
  def loadIndex[DS &lt;: GeoMesaDataStore[DS]](ds: DS, typeName: String, mode: IndexMode): Option[GeoMesaFeatureIndex[_, _]] =
<span class="nc" id="L201">    Option(index).filterNot(_.isEmpty).map(IndexParam.loadIndex(ds, typeName, _, mode))</span>
}

<span class="nc" id="L204">trait RequiredIndexParam extends IndexParam {</span>

  @Parameter(names = Array(&quot;--index&quot;), description = &quot;Specify a particular GeoMesa index&quot;, required = true)
  var index: String = _

  @throws[ParameterException]
  def loadIndex[DS &lt;: GeoMesaDataStore[DS]](ds: DS, typeName: String, mode: IndexMode): GeoMesaFeatureIndex[_, _] =
<span class="nc" id="L211">    IndexParam.loadIndex(ds, typeName, index, mode)</span>
}

<span class="nc" id="L214">trait IndicesParam {</span>

  import scala.collection.JavaConverters._

  @Parameter(names = Array(&quot;--index&quot;), description = &quot;Specify GeoMesa index(es) - comma-separate or use multiple flags&quot;, required = true)
  var indexNames: java.util.List[String] = _

  @throws[ParameterException]
  def loadIndices[DS &lt;: GeoMesaDataStore[DS]](ds: DS, typeName: String, mode: IndexMode): Seq[GeoMesaFeatureIndex[_, _]] =
<span class="nc" id="L223">    indexNames.asScala.map(IndexParam.loadIndex(ds, typeName, _, mode)).toSeq</span>
}

<span class="nc" id="L226">trait DistributedRunParam {</span>

  @Parameter(names = Array(&quot;--run-mode&quot;), description = &quot;Run locally or on a cluster&quot;, required = false)
  var runMode: String = _

  lazy val mode: Option[RunModes.RunMode] = {
<span class="nc" id="L232">    Option(runMode).map {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">      case m if m.equalsIgnoreCase(RunModes.Local.toString) =&gt; RunModes.Local</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">      case m if m.equalsIgnoreCase(RunModes.Distributed.toString) =&gt; RunModes.Distributed</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">      case m if m.equalsIgnoreCase(&quot;distributedcombine&quot;) =&gt;</span>
<span class="nc" id="L236">        DistributedRunParam.this match {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">          case p: DistributedCombineParam =&gt;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            Command.user.warn(&quot;Using deprecated run-mode 'DistributedCombine' - please use --combine-inputs instead&quot;)</span>
<span class="nc" id="L239">            p.combineInputs = true</span>
<span class="nc" id="L240">            RunModes.Distributed</span>

<span class="nc" id="L242">          case _ =&gt; throw invalid()</span>
        }

<span class="nc" id="L245">      case _ =&gt; throw invalid()</span>
    }
  }

  private def invalid(): ParameterException =
<span class="nc" id="L250">    new ParameterException(s&quot;Invalid --run-mode '$runMode': valid values are 'local' or 'distributed'&quot;)</span>
}

<span class="nc" id="L253">object DistributedRunParam {</span>
<span class="nc" id="L254">  object RunModes extends Enumeration {</span>
    type RunMode = Value
<span class="nc" id="L256">    val Distributed, Local = Value</span>
  }
}

<span class="nc" id="L260">trait DistributedCombineParam {</span>
  @Parameter(
    names = Array(&quot;--combine-inputs&quot;),
    description = &quot;Combine multiple input files into a single input split (distributed jobs)&quot;)
<span class="nc" id="L264">  var combineInputs: Boolean = false</span>

  @Parameter(names = Array(&quot;--split-max-size&quot;), description = &quot;Maximum size of a split in bytes (distributed jobs)&quot;)
  var maxSplitSize: Integer = _
}

<span class="nc" id="L270">trait OutputPathParam {</span>
  @Parameter(names = Array(&quot;--output&quot;), description = &quot;Path to use for writing output&quot;, required = true)
  var outputPath: String = _
}

<span class="nc" id="L275">trait TempPathParam {</span>
  @Parameter(names = Array(&quot;--temp-path&quot;), description = &quot;Path to temp dir for writing output. &quot; +
      &quot;Note that this may be useful when using s3 since it is slow as a sink&quot;, required = false)
  var tempPath: String = _
}

<span class="nc" id="L281">trait NumReducersParam {</span>
  @Parameter(
    names = Array(&quot;--num-reducers&quot;),
    description = &quot;Number of reducers to use when sorting or merging (for distributed jobs)&quot;,
    validateWith = Array(classOf[PositiveInteger]))
  var reducers: java.lang.Integer = _
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>