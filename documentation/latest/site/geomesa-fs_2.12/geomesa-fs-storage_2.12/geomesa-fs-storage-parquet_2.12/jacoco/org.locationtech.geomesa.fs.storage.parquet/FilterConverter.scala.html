<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilterConverter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage Parquet</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.parquet</a> &gt; <span class="el_source">FilterConverter.scala</span></div><h1>FilterConverter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.parquet

import org.apache.parquet.filter2.predicate.FilterPredicate.Visitor
import org.apache.parquet.filter2.predicate.Operators._
import org.apache.parquet.filter2.predicate.{FilterApi, FilterPredicate, UserDefinedPredicate}
import org.apache.parquet.io.api.Binary
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.filter.visitor.FilterExtractingVisitor
import org.locationtech.geomesa.fs.storage.parquet.io.GeometrySchema.BoundingBoxField
import org.locationtech.geomesa.index.strategies.SpatialFilterStrategy
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.geotools.{GeometryUtils, ObjectType}
import org.locationtech.geomesa.utils.text.StringSerialization

import java.util.Date
import scala.reflect.ClassTag

<span class="nc" id="L28">object FilterConverter {</span>

  def convert(sft: SimpleFeatureType, filter: Filter): (Option[FilterPredicate], Option[Filter]) = {
<span class="nc bnc" id="L31" title="All 6 branches missed.">    if (filter == Filter.INCLUDE) { (None, None) } else {</span>
<span class="nc" id="L32">      FilterHelper.propertyNames(filter).foldLeft((Option.empty[FilterPredicate], Option(filter)))(reduce(sft))</span>
    }
  }

  private def reduce(
      sft: SimpleFeatureType
    )(result: (Option[FilterPredicate], Option[Filter]),
      name: String): (Option[FilterPredicate], Option[Filter]) = {
<span class="nc bnc" id="L40" title="All 2 branches missed.">    val (parquet, geotools) = result</span>
<span class="nc" id="L41">    val filter = geotools.orNull</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">    if (filter == null) {</span>
<span class="nc" id="L43">      return result // no more filter to evaluate</span>
    }

<span class="nc" id="L46">    val bindings = ObjectType.selectType(sft.getDescriptor(name))</span>
<span class="nc" id="L47">    val col = StringSerialization.alphaNumericSafeString(name)</span>

<span class="nc bnc" id="L49" title="All 2 branches missed.">    val (predicate, remaining): (Option[FilterPredicate], Option[Filter]) = bindings.head match {</span>
      // note: non-points use repeated values, which aren't supported in parquet predicates
<span class="nc bnc" id="L51" title="All 6 branches missed.">      case ObjectType.GEOMETRY =&gt; spatial(sft, name, filter, col, bindings.last)</span>
<span class="nc bnc" id="L52" title="All 6 branches missed.">      case ObjectType.DATE     =&gt; temporal(sft, name, filter, FilterApi.longColumn(col))</span>
<span class="nc bnc" id="L53" title="All 6 branches missed.">      case ObjectType.STRING   =&gt; attribute(sft, name, filter, FilterApi.binaryColumn(col), Binary.fromString)</span>
<span class="nc bnc" id="L54" title="All 6 branches missed.">      case ObjectType.INT      =&gt; attribute(sft, name, filter, FilterApi.intColumn(col), identity[java.lang.Integer])</span>
<span class="nc bnc" id="L55" title="All 6 branches missed.">      case ObjectType.LONG     =&gt; attribute(sft, name, filter, FilterApi.longColumn(col), identity[java.lang.Long])</span>
<span class="nc bnc" id="L56" title="All 6 branches missed.">      case ObjectType.FLOAT    =&gt; attribute(sft, name, filter, FilterApi.floatColumn(col), identity[java.lang.Float])</span>
<span class="nc bnc" id="L57" title="All 6 branches missed.">      case ObjectType.DOUBLE   =&gt; attribute(sft, name, filter, FilterApi.doubleColumn(col), identity[java.lang.Double])</span>
<span class="nc bnc" id="L58" title="All 6 branches missed.">      case ObjectType.BOOLEAN  =&gt; boolean(sft, name, filter, FilterApi.booleanColumn(col))</span>
<span class="nc" id="L59">      case _ =&gt; (None, Some(filter))</span>
    }

<span class="nc" id="L62">    ((predicate.toSeq ++ parquet).reduceLeftOption(FilterApi.and), remaining)</span>
  }

  private def spatial(
      sft: SimpleFeatureType,
      name: String,
      filter: Filter,
      col: String,
      typed: ObjectType): (Option[FilterPredicate], Option[Filter]) = {
<span class="nc bnc" id="L71" title="All 2 branches missed.">    val (spatial, _) = FilterExtractingVisitor(filter, name, sft, SpatialFilterStrategy.spatialCheck)</span>
<span class="nc" id="L72">    val xyBounds = spatial.map(FilterHelper.extractGeometries(_, name)).flatMap { extracted =&gt;</span>
<span class="nc bnc" id="L73" title="All 4 branches missed.">      Some(extracted).filter(e =&gt; e.nonEmpty &amp;&amp; !e.disjoint).map { e =&gt;</span>
<span class="nc" id="L74">        e.values.map(GeometryUtils.bounds).reduce { (a, b) =&gt;</span>
<span class="nc" id="L75">          (math.min(a._1, b._1), math.min(a._2, b._2), math.max(a._3, b._3), math.max(a._4, b._4))</span>
        }
      }
    }

<span class="nc bnc" id="L80" title="All 2 branches missed.">    val predicate = xyBounds.map { case (xmin, ymin, xmax, ymax) =&gt;</span>
      // filter against the bbox field
<span class="nc" id="L82">      val bboxGroup = BoundingBoxField(col, encoded = true).bbox</span>
<span class="nc" id="L83">      val bboxXminCol = FilterApi.floatColumn(s&quot;$bboxGroup.${BoundingBoxField.XMin}&quot;)</span>
      val bbox = {
<span class="nc" id="L85">        val yminCol = FilterApi.floatColumn(s&quot;$bboxGroup.${BoundingBoxField.YMin}&quot;)</span>
<span class="nc" id="L86">        val xmaxCol = FilterApi.floatColumn(s&quot;$bboxGroup.${BoundingBoxField.XMax}&quot;)</span>
<span class="nc" id="L87">        val ymaxCol = FilterApi.floatColumn(s&quot;$bboxGroup.${BoundingBoxField.YMax}&quot;)</span>
<span class="nc" id="L88">        Seq[FilterPredicate](</span>
<span class="nc" id="L89">          FilterApi.ltEq(bboxXminCol, Float.box(xmax.toFloat)),</span>
<span class="nc" id="L90">          FilterApi.gtEq(xmaxCol, Float.box(xmin.toFloat)),</span>
<span class="nc" id="L91">          FilterApi.ltEq(yminCol, Float.box(ymax.toFloat)),</span>
<span class="nc" id="L92">          FilterApi.gtEq(ymaxCol, Float.box(ymin.toFloat))</span>
<span class="nc" id="L93">        ).reduce(FilterApi.and)</span>
      }
<span class="nc bnc" id="L95" title="All 6 branches missed.">      if (typed == ObjectType.POINT) {</span>
        // point types that are natively encoded don't have bbox fields, as we can filter on them directly
<span class="nc" id="L97">        val xcol = FilterApi.doubleColumn(s&quot;$col.x&quot;)</span>
<span class="nc" id="L98">        val ycol = FilterApi.doubleColumn(s&quot;$col.y&quot;)</span>
<span class="nc" id="L99">        val xy = Seq[FilterPredicate](</span>
<span class="nc" id="L100">          FilterApi.gtEq(xcol, Double.box(xmin)),</span>
<span class="nc" id="L101">          FilterApi.gtEq(ycol, Double.box(ymin)),</span>
<span class="nc" id="L102">          FilterApi.ltEq(xcol, Double.box(xmax)),</span>
<span class="nc" id="L103">          FilterApi.ltEq(ycol, Double.box(ymax))</span>
<span class="nc" id="L104">        ).reduce(FilterApi.and)</span>
        // if x/y don't exist, then the bbox will (in WKB encoding)
<span class="nc" id="L106">        FilterApi.or(bbox, xy)</span>
      } else {
        // add null for back-compatibility with files that don't contain bbox cols
<span class="nc" id="L109">        FilterApi.or(FilterApi.eq(bboxXminCol, null.asInstanceOf[java.lang.Float]), bbox)</span>
      }
    }
    // since we don't know what the actual file encoding is up front, we always have to evaluate the full predicate post-read
<span class="nc" id="L113">    (predicate, Some(filter))</span>
  }

  private def temporal(
      sft: SimpleFeatureType,
      name: String,
      filter: Filter,
      col: LongColumn): (Option[FilterPredicate], Option[Filter]) = {
<span class="nc bnc" id="L121" title="All 2 branches missed.">    val (predicate, remaining) = attribute[Date, java.lang.Long](sft, name, filter, col, _.getTime)</span>
    // note: we need to account for both millisecond and microsecond encoded dates
    // since the reasonable overlap of the two is pretty non-existent, we just use an OR of both potential ranges
<span class="nc" id="L124">    val millisOrMicros = predicate.map(p =&gt; FilterApi.or(p, p.accept(MillisToMicrosVisitor)))</span>
<span class="nc" id="L125">    (millisOrMicros, remaining)</span>
  }

  private def attribute[T : ClassTag, U &lt;: Comparable[U]](
      sft: SimpleFeatureType,
      name: String,
      filter: Filter,
      col: Column[U] with SupportsLtGt,
      conversion: T =&gt; U): (Option[FilterPredicate], Option[Filter]) = {
<span class="nc bnc" id="L134" title="All 2 branches missed.">    val (attribute, nonAttribute) = FilterExtractingVisitor(filter, name, sft)</span>
<span class="nc" id="L135">    val binding = implicitly[ClassTag[T]].runtimeClass.asInstanceOf[Class[T]]</span>
<span class="nc" id="L136">    val bounds = attribute.map(FilterHelper.extractAttributeBounds(_, name, binding))</span>
<span class="nc" id="L137">    val predicate = bounds.flatMap { extracted =&gt;</span>
<span class="nc bnc" id="L138" title="All 6 branches missed.">      Some(extracted).filter(e =&gt; e.nonEmpty &amp;&amp; !e.disjoint &amp;&amp; e.values.forall(_.isBounded)).map { e =&gt;</span>
<span class="nc" id="L139">        val filters = e.values.map { bounds =&gt;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">          if (bounds.isEquals) {</span>
<span class="nc" id="L141">            FilterApi.eq(col, conversion(bounds.lower.value.get))</span>
          } else {
<span class="nc" id="L143">            val lower: Option[FilterPredicate] = bounds.lower.value.map { value =&gt;</span>
<span class="nc" id="L144">              val converted = conversion(value)</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">              if (bounds.lower.inclusive) { FilterApi.gtEq(col, converted) } else { FilterApi.gt(col, converted) }</span>
            }
<span class="nc" id="L147">            val upper: Option[FilterPredicate] = bounds.upper.value.map { value =&gt;</span>
<span class="nc" id="L148">              val converted = conversion(value)</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">              if (bounds.upper.inclusive) { FilterApi.ltEq(col, converted) } else { FilterApi.lt(col, converted) }</span>
            }
<span class="nc bnc" id="L151" title="All 8 branches missed.">            (lower, upper) match {</span>
<span class="nc bnc" id="L152" title="All 4 branches missed.">              case (Some(lo), Some(hi)) =&gt; FilterApi.and(lo, hi)</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">              case (Some(f), None) =&gt; f</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">              case (None, Some(f)) =&gt; f</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">              case (None, None) =&gt; throw new IllegalStateException() // shouldn't happen due to checks above</span>
            }
          }
        }
<span class="nc" id="L159">        merge(filters)</span>
      }
    }
<span class="nc bnc" id="L162" title="All 2 branches missed.">    val remaining = if (bounds.exists(_.precise)) { nonAttribute } else { Some(filter) }</span>
<span class="nc" id="L163">    (predicate, remaining)</span>
  }

  private def boolean(
      sft: SimpleFeatureType,
      name: String,
      filter: Filter,
      col: BooleanColumn): (Option[FilterPredicate], Option[Filter]) = {
<span class="nc bnc" id="L171" title="All 2 branches missed.">    val (attribute, nonAttribute) = FilterExtractingVisitor(filter, name, sft)</span>
<span class="nc" id="L172">    val bounds = attribute.map(FilterHelper.extractAttributeBounds(_, name, classOf[java.lang.Boolean]))</span>
<span class="nc" id="L173">    val predicate = bounds.flatMap { extracted =&gt;</span>
<span class="nc bnc" id="L174" title="All 6 branches missed.">      Some(extracted).filter(e =&gt; e.nonEmpty &amp;&amp; !e.disjoint &amp;&amp; e.values.forall(_.isEquals)).map { e =&gt;</span>
<span class="nc" id="L175">        e.values.map(bounds =&gt; FilterApi.eq(col, bounds.lower.value.get)).reduce(FilterApi.or)</span>
      }
    }
<span class="nc bnc" id="L178" title="All 2 branches missed.">    val remaining = if (bounds.exists(_.precise)) { nonAttribute } else { Some(filter) }</span>
<span class="nc" id="L179">    (predicate, remaining)</span>
  }

  /**
    * Merge OR'd filters
    *
    * Detect and re-write &quot;not equals&quot; filters to handle null values
    *
    * FilterHelper methods make &quot;foo != x&quot; comes out as &quot;foo &lt; x OR foo &gt; x&quot;
   *
    * that won't return null values - not normally a concern since we don't index them in key-value dbs,
    * but we want to handle that case here
    *
    * @param filters filters
    * @return combined filter
    */
  private def merge[T &lt;: Comparable[T]](filters: Seq[FilterPredicate]): FilterPredicate = {
<span class="nc bnc" id="L196" title="All 2 branches missed.">    lazy val values = filters.collect {</span>
<span class="nc bnc" id="L197" title="All 4 branches missed.">      case f: Lt[T] =&gt; (f.getColumn.asInstanceOf[Column[T] with SupportsEqNotEq], f.getValue)</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">      case f: Gt[T] =&gt; (f.getColumn.asInstanceOf[Column[T] with SupportsEqNotEq], f.getValue)</span>
    }.distinct

<span class="nc bnc" id="L201" title="All 2 branches missed.">    if (filters.lengthCompare(2) == 0 &amp;&amp;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        filters.exists(_.isInstanceOf[Lt[_]]) &amp;&amp;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        filters.exists(_.isInstanceOf[Gt[_]]) &amp;&amp;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        values.lengthCompare(1) == 0) {</span>
<span class="nc" id="L205">      FilterApi.notEq(values.head._1, values.head._2)</span>
    } else {
<span class="nc" id="L207">      filters.reduce(FilterApi.or)</span>
    }
  }

  /**
   * Visitor that replaces all millisecond-encoded date values with microsecond-encoded ones. Note that it is not
   * robust, in that it only works if all values are Longs
   */
<span class="nc" id="L215">  private object MillisToMicrosVisitor extends Visitor[FilterPredicate] {</span>

    import scala.collection.JavaConverters._

    private def millisToMicros[T &lt;: Comparable[T]](value: T): T =
<span class="nc" id="L220">      Long.box(value.asInstanceOf[java.lang.Long] * 1000L).asInstanceOf[T]</span>

    override def visit[T &lt;: Comparable[T]](eq: Eq[T]): FilterPredicate =
<span class="nc" id="L223">      FilterApi.eq(eq.getColumn.asInstanceOf[Column[T] with SupportsEqNotEq], millisToMicros(eq.getValue))</span>
    override def visit[T &lt;: Comparable[T]](notEq: NotEq[T]): FilterPredicate =
<span class="nc" id="L225">      FilterApi.notEq(notEq.getColumn.asInstanceOf[Column[T] with SupportsEqNotEq], millisToMicros(notEq.getValue))</span>
    override def visit[T &lt;: Comparable[T]](lt: Lt[T]): FilterPredicate =
<span class="nc" id="L227">      FilterApi.lt(lt.getColumn.asInstanceOf[Column[T] with SupportsLtGt], millisToMicros(lt.getValue))</span>
    override def visit[T &lt;: Comparable[T]](ltEq: LtEq[T]): FilterPredicate =
<span class="nc" id="L229">      FilterApi.ltEq(ltEq.getColumn.asInstanceOf[Column[T] with SupportsLtGt], millisToMicros(ltEq.getValue))</span>
    override def visit[T &lt;: Comparable[T]](gt: Gt[T]): FilterPredicate =
<span class="nc" id="L231">      FilterApi.gt(gt.getColumn.asInstanceOf[Column[T] with SupportsLtGt], millisToMicros(gt.getValue))</span>
    override def visit[T &lt;: Comparable[T]](gtEq: GtEq[T]): FilterPredicate =
<span class="nc" id="L233">      FilterApi.gtEq(gtEq.getColumn.asInstanceOf[Column[T] with SupportsLtGt], millisToMicros(gtEq.getValue))</span>
<span class="nc" id="L234">    override def visit(and: And): FilterPredicate = FilterApi.and(and.getLeft.accept(this), and.getRight.accept(this))</span>
<span class="nc" id="L235">    override def visit(or: Or): FilterPredicate = FilterApi.or(or.getLeft.accept(this), or.getRight.accept(this))</span>
<span class="nc" id="L236">    override def visit(not: Not): FilterPredicate = FilterApi.not(not.getPredicate.accept(this))</span>
    override def visit[T &lt;: Comparable[T]](in: In[T]): FilterPredicate =
<span class="nc" id="L238">      FilterApi.in(in.getColumn.asInstanceOf[Column[T] with SupportsEqNotEq], in.getValues.asScala.map(millisToMicros).asJava)</span>
    override def visit[T &lt;: Comparable[T]](notIn: NotIn[T]): FilterPredicate =
<span class="nc" id="L240">      FilterApi.notIn(notIn.getColumn.asInstanceOf[Column[T] with SupportsEqNotEq], notIn.getValues.asScala.map(millisToMicros).asJava)</span>
    override def visit[T &lt;: Comparable[T]](contains: Contains[T]): FilterPredicate =
<span class="nc" id="L242">      throw new UnsupportedOperationException(&quot;visit Contains is not supported&quot;)</span>
<span class="nc" id="L243">    override def visit[T &lt;: Comparable[T], U &lt;: UserDefinedPredicate[T]](udp: UserDefined[T, U]): FilterPredicate = udp</span>
<span class="nc" id="L244">    override def visit[T &lt;: Comparable[T], U &lt;: UserDefinedPredicate[T]](udp: LogicalNotUserDefined[T, U]): FilterPredicate = udp</span>
  }
<span class="nc" id="L246">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>