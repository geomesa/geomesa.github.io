<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OrcAttributeReader.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage ORC IO</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.orc.io</a> &gt; <span class="el_source">OrcAttributeReader.scala</span></div><h1>OrcAttributeReader.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.orc.io

import org.apache.orc.storage.ql.exec.vector._
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.filter.identity.FeatureIdImpl
import org.geotools.geometry.jts.JTSFactoryFinder
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.text.WKBUtils
import org.locationtech.jts.geom._

import java.util.UUID

/**
  * Populates a simple feature from a given Orc row
  */
trait OrcAttributeReader {
  def apply(sf: SimpleFeature, row: Int): Unit
}

<span class="nc" id="L29">object OrcAttributeReader {</span>

<span class="nc" id="L31">  private val gf = JTSFactoryFinder.getGeometryFactory</span>

  /**
    * Create a reader for an ORC batch
    *
    * @param sft simple feature type
    * @param batch row batch
    * @param columns columns to read, corresponding to simple feature attributes
    * @param fid read feature id or not
    * @return
    */
  def apply(sft: SimpleFeatureType,
            batch: VectorizedRowBatch,
<span class="nc" id="L44">            columns: Option[Set[Int]] = None,</span>
<span class="nc" id="L45">            fid: Boolean = true): OrcAttributeReader = {</span>
<span class="nc" id="L46">    val builder = Seq.newBuilder[OrcAttributeReader]</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">    builder.sizeHint(columns.map(_.size).getOrElse(sft.getAttributeCount) + (if (fid) { 1 } else { 0 }))</span>

<span class="nc" id="L49">    var i = 0</span>
<span class="nc" id="L50">    var col = 0</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">    while (i &lt; sft.getAttributeCount) {</span>
<span class="nc" id="L52">      val descriptor = sft.getDescriptor(i)</span>
<span class="nc" id="L53">      val bindings = ObjectType.selectType(descriptor)</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">      if (columns.forall(_.contains(i))) {</span>
<span class="nc" id="L55">        val reader = bindings.head match {</span>
<span class="nc bnc" id="L56" title="All 6 branches missed.">          case ObjectType.GEOMETRY =&gt; createGeometryReader(bindings(1), batch.cols, col, i)</span>
<span class="nc bnc" id="L57" title="All 6 branches missed.">          case ObjectType.DATE     =&gt; new DateReader(batch.cols(col).asInstanceOf[TimestampColumnVector], i)</span>
<span class="nc bnc" id="L58" title="All 6 branches missed.">          case ObjectType.STRING   =&gt; new StringReader(batch.cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc bnc" id="L59" title="All 6 branches missed.">          case ObjectType.INT      =&gt; new IntReader(batch.cols(col).asInstanceOf[LongColumnVector], i)</span>
<span class="nc bnc" id="L60" title="All 6 branches missed.">          case ObjectType.LONG     =&gt; new LongReader(batch.cols(col).asInstanceOf[LongColumnVector], i)</span>
<span class="nc bnc" id="L61" title="All 6 branches missed.">          case ObjectType.FLOAT    =&gt; new FloatReader(batch.cols(col).asInstanceOf[DoubleColumnVector], i)</span>
<span class="nc bnc" id="L62" title="All 6 branches missed.">          case ObjectType.DOUBLE   =&gt; new DoubleReader(batch.cols(col).asInstanceOf[DoubleColumnVector], i)</span>
<span class="nc bnc" id="L63" title="All 6 branches missed.">          case ObjectType.BOOLEAN  =&gt; new BooleanReader(batch.cols(col).asInstanceOf[LongColumnVector], i)</span>
<span class="nc bnc" id="L64" title="All 6 branches missed.">          case ObjectType.BYTES    =&gt; new BytesReader(batch.cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc bnc" id="L65" title="All 6 branches missed.">          case ObjectType.UUID     =&gt; new UuidReader(batch.cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc bnc" id="L66" title="All 6 branches missed.">          case ObjectType.LIST     =&gt; new ListReader(batch.cols(col).asInstanceOf[ListColumnVector], i, bindings(1))</span>
<span class="nc bnc" id="L67" title="All 6 branches missed.">          case ObjectType.MAP      =&gt; new MapReader(batch.cols(col).asInstanceOf[MapColumnVector], i, bindings(1), bindings(2))</span>
<span class="nc" id="L68">          case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type ${bindings.head}&quot;)</span>
        }
<span class="nc" id="L70">        builder += reader</span>
      }
<span class="nc" id="L72">      i += 1</span>
<span class="nc" id="L73">      col += SimpleFeatureTypeDescription.fieldCount(descriptor)</span>
    }

<span class="nc bnc" id="L76" title="All 2 branches missed.">    if (fid) {</span>
<span class="nc" id="L77">      builder += new FidReader(batch.cols(col).asInstanceOf[BytesColumnVector])</span>
    }

<span class="nc" id="L80">    new SequenceReader(builder.result)</span>
  }

  // noinspection LanguageFeature
  private def createGeometryReader(binding: ObjectType, cols: Array[ColumnVector], col: Int, i: Int): OrcAttributeReader = {
<span class="nc" id="L85">    implicit def toDoubleColumnVector(vec: ColumnVector): DoubleColumnVector = vec.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L86">    implicit def toListColumnVector(vec: ColumnVector): ListColumnVector = vec.asInstanceOf[ListColumnVector]</span>

<span class="nc" id="L88">    def x: ColumnVector = cols(col)</span>
<span class="nc" id="L89">    def y: ColumnVector = cols(col + 1)</span>

<span class="nc" id="L91">    binding match {</span>
<span class="nc bnc" id="L92" title="All 6 branches missed.">      case ObjectType.POINT           =&gt; new PointReader(x, y, i)</span>
<span class="nc bnc" id="L93" title="All 6 branches missed.">      case ObjectType.LINESTRING      =&gt; new LineStringReader(x, y, i)</span>
<span class="nc bnc" id="L94" title="All 6 branches missed.">      case ObjectType.MULTIPOINT      =&gt; new MultiPointReader(x, y, i)</span>
<span class="nc bnc" id="L95" title="All 6 branches missed.">      case ObjectType.POLYGON         =&gt; new PolygonReader(x, y, i)</span>
<span class="nc bnc" id="L96" title="All 6 branches missed.">      case ObjectType.MULTILINESTRING =&gt; new MultiLineStringReader(x, y, i)</span>
<span class="nc bnc" id="L97" title="All 6 branches missed.">      case ObjectType.MULTIPOLYGON    =&gt; new MultiPolygonReader(x, y, i)</span>
<span class="nc bnc" id="L98" title="All 6 branches missed.">      case ObjectType.GEOMETRY        =&gt; new GeometryWkbReader(cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc" id="L99">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type $binding&quot;)</span>
    }
  }

  // invokes a sequence of readers in a single call
<span class="nc" id="L104">  class SequenceReader(readers: Seq[OrcAttributeReader]) extends OrcAttributeReader {</span>
<span class="nc" id="L105">    override def apply(sf: SimpleFeature, row: Int): Unit = readers.foreach(_.apply(sf, row))</span>
  }

  // reads a feature ID from a vector and sets it in a simple feature
<span class="nc" id="L109">  class FidReader(vector: BytesColumnVector) extends OrcAttributeReader {</span>
    override def apply(sf: SimpleFeature, row: Int): Unit =
<span class="nc" id="L111">      sf.getIdentifier.asInstanceOf[FeatureIdImpl].setID(vector.toString(row))</span>
  }

  // reads a date from a vector and sets it in a simple feature
<span class="nc" id="L115">  class DateReader(val vector: TimestampColumnVector, val attribute: Int)</span>
<span class="nc" id="L116">      extends VectorReaderAdapter[TimestampColumnVector] with GetVectorDate</span>

  // reads a string from a vector and sets it in a simple feature
<span class="nc" id="L119">  class StringReader(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L120">      extends VectorReaderAdapter[BytesColumnVector] with GetVectorString</span>

  // reads an int from a vector and sets it in a simple feature
<span class="nc" id="L123">  class IntReader(val vector: LongColumnVector, val attribute: Int)</span>
<span class="nc" id="L124">      extends VectorReaderAdapter[LongColumnVector] with GetVectorInt</span>

  // reads a long from a vector and sets it in a simple feature
<span class="nc" id="L127">  class LongReader(val vector: LongColumnVector, val attribute: Int)</span>
<span class="nc" id="L128">      extends VectorReaderAdapter[LongColumnVector] with GetVectorLong</span>

  // reads a float from a vector and sets it in a simple feature
<span class="nc" id="L131">  class FloatReader(val vector: DoubleColumnVector, val attribute: Int)</span>
<span class="nc" id="L132">      extends VectorReaderAdapter[DoubleColumnVector] with GetVectorFloat</span>

  // reads a double from a vector and sets it in a simple feature
<span class="nc" id="L135">  class DoubleReader(val vector: DoubleColumnVector, val attribute: Int)</span>
<span class="nc" id="L136">      extends VectorReaderAdapter[DoubleColumnVector] with GetVectorDouble</span>

  // reads a boolean from a vector and sets it in a simple feature
<span class="nc" id="L139">  class BooleanReader(val vector: LongColumnVector, val attribute: Int)</span>
<span class="nc" id="L140">      extends VectorReaderAdapter[LongColumnVector] with GetVectorBoolean</span>

  // reads a byte array from a vector and sets it in a simple feature
<span class="nc" id="L143">  class BytesReader(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L144">      extends VectorReaderAdapter[BytesColumnVector] with GetVectorBytes</span>

  // reads a UUID from a vector and sets it in a simple feature
<span class="nc" id="L147">  class UuidReader(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L148">      extends VectorReaderAdapter[BytesColumnVector] with GetVectorUuid</span>

  /**
    * Reads a point attribute from a vector and sets it in a simple feature
    *
    * @param x x coordinates
    * @param y y coordinates
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L157">  class PointReader(x: DoubleColumnVector, y: DoubleColumnVector, attribute: Int) extends OrcAttributeReader {</span>
    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L159" title="All 4 branches missed.">      if (x.noNulls || !x.isNull(row)) {</span>
<span class="nc" id="L160">        sf.setAttribute(attribute, gf.createPoint(new Coordinate(x.vector(row), y.vector(row))))</span>
      } else {
<span class="nc" id="L162">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  /**
    * Reads a linestring attribute from a vector and sets it in a simple feature.
    * A linestring is modeled as a list of points.
    *
    * @see PointReader
    *
    * @param xx outer list vector for x coordinates, containing a double vector for points
    * @param yy outer list vector for y coordinates, containing a double vector for points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L177">  class LineStringReader(xx: ListColumnVector, yy: ListColumnVector, attribute: Int) extends OrcAttributeReader {</span>
<span class="nc" id="L178">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L179">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L182" title="All 4 branches missed.">      if (xx.noNulls || !xx.isNull(row)) {</span>
<span class="nc" id="L183">        val offset = xx.offsets(row).toInt</span>
<span class="nc" id="L184">        val length = xx.lengths(row).toInt</span>
<span class="nc" id="L185">        val coordinates = Array.ofDim[Coordinate](length)</span>
<span class="nc" id="L186">        var i = 0</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        while (i &lt; length) {</span>
<span class="nc" id="L188">          coordinates(i) = new Coordinate(x.vector(offset + i), y.vector(offset + i))</span>
<span class="nc" id="L189">          i += 1</span>
        }
<span class="nc" id="L191">        sf.setAttribute(attribute, gf.createLineString(coordinates))</span>
      } else {
<span class="nc" id="L193">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  /**
    * Reads a multi-point attribute from a vector and sets it in a simple feature.
    * A multi-point is modeled as a list of points.
    *
    * @see PointReader
    *
    * @param xx outer list vector for x coordinates, containing a double vector for points
    * @param yy outer list vector for y coordinates, containing a double vector for points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L208">  class MultiPointReader(xx: ListColumnVector, yy: ListColumnVector, attribute: Int) extends OrcAttributeReader {</span>
<span class="nc" id="L209">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L210">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L213" title="All 4 branches missed.">      if (xx.noNulls || !xx.isNull(row)) {</span>
<span class="nc" id="L214">        val offset = xx.offsets(row).toInt</span>
<span class="nc" id="L215">        val length = xx.lengths(row).toInt</span>
<span class="nc" id="L216">        val coordinates = Array.ofDim[Coordinate](length)</span>
<span class="nc" id="L217">        var i = 0</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        while (i &lt; length) {</span>
<span class="nc" id="L219">          coordinates(i) = new Coordinate(x.vector(offset + i), y.vector(offset + i))</span>
<span class="nc" id="L220">          i += 1</span>
        }
<span class="nc" id="L222">        sf.setAttribute(attribute, gf.createMultiPointFromCoords(coordinates))</span>
      } else {
<span class="nc" id="L224">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  /**
    * Reads a polygon attribute from a vector and sets it in a simple feature.
    * A polygon is modeled as a list of lines, with the first value being the shell,
    * and any subsequent values being interior holes.
    *
    * @see LineStringReader
    *
    * @param xxx outer list vector for x coordinates, containing a list vector for individual lines
    * @param yyy outer list vector for y coordinates, containing a list vector for individual lines
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L240">  class PolygonReader(xxx: ListColumnVector, yyy: ListColumnVector, attribute: Int) extends OrcAttributeReader {</span>
<span class="nc" id="L241">    private val xx = xxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L242">    private val yy = yyy.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L243">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L244">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L247" title="All 4 branches missed.">      if (xxx.noNulls || !xxx.isNull(row)) {</span>
<span class="nc" id="L248">        val lineOffset = xxx.offsets(row).toInt</span>
<span class="nc" id="L249">        val lineLength = xxx.lengths(row).toInt</span>
<span class="nc" id="L250">        val lines = Array.ofDim[LinearRing](lineLength)</span>
<span class="nc" id="L251">        var j = 0</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        while (j &lt; lineLength) {</span>
<span class="nc" id="L253">          val offset = xx.offsets(lineOffset + j).toInt</span>
<span class="nc" id="L254">          val length = xx.lengths(lineOffset + j).toInt</span>
<span class="nc" id="L255">          val coordinates = Array.ofDim[Coordinate](length)</span>
<span class="nc" id="L256">          var i = 0</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">          while (i &lt; length) {</span>
<span class="nc" id="L258">            coordinates(i) = new Coordinate(x.vector(offset + i), y.vector(offset + i))</span>
<span class="nc" id="L259">            i += 1</span>
          }
<span class="nc" id="L261">          lines(j) = gf.createLinearRing(coordinates)</span>
<span class="nc" id="L262">          j += 1</span>
        }
<span class="nc bnc" id="L264" title="All 2 branches missed.">        val polygon = if (lineLength == 1) { gf.createPolygon(lines.head) } else { gf.createPolygon(lines.head, lines.tail) }</span>
<span class="nc" id="L265">        sf.setAttribute(attribute, polygon)</span>
      } else {
<span class="nc" id="L267">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  /**
    * Reads a multi-linestring attribute from a vector and sets it in a simple feature.
    * A multi-linestring is modeled as a list of lines.
    *
    * @see LineStringReader
    *
    * @param xxx outer list vector for x coordinates, containing a list vector for individual lines
    * @param yyy outer list vector for y coordinates, containing a list vector for individual lines
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L282">  class MultiLineStringReader(xxx: ListColumnVector, yyy: ListColumnVector, attribute: Int) extends OrcAttributeReader {</span>
<span class="nc" id="L283">    private val xx = xxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L284">    private val yy = yyy.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L285">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L286">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L289" title="All 4 branches missed.">      if (xxx.noNulls || !xxx.isNull(row)) {</span>
<span class="nc" id="L290">        val lineOffset = xxx.offsets(row).toInt</span>
<span class="nc" id="L291">        val lineLength = xxx.lengths(row).toInt</span>
<span class="nc" id="L292">        val lines = Array.ofDim[LineString](lineLength)</span>
<span class="nc" id="L293">        var j = 0</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        while (j &lt; lineLength) {</span>
<span class="nc" id="L295">          val offset = xx.offsets(lineOffset + j).toInt</span>
<span class="nc" id="L296">          val length = xx.lengths(lineOffset + j).toInt</span>
<span class="nc" id="L297">          val coordinates = Array.ofDim[Coordinate](length)</span>
<span class="nc" id="L298">          var i = 0</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">          while (i &lt; length) {</span>
<span class="nc" id="L300">            coordinates(i) = new Coordinate(x.vector(offset + i), y.vector(offset + i))</span>
<span class="nc" id="L301">            i += 1</span>
          }
<span class="nc" id="L303">          lines(j) = gf.createLineString(coordinates)</span>
<span class="nc" id="L304">          j += 1</span>
        }
<span class="nc" id="L306">        sf.setAttribute(attribute, gf.createMultiLineString(lines))</span>
      } else {
<span class="nc" id="L308">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  /**
    * Reads a multi-polygon attribute from a vector and sets it in a simple feature.
    * A multi-polygon is modeled as a list of polygons.
    *
    * @see PolygonReader
    *
    * @param xxxx outer list vector for x coordinates, containing a list vector for individual polygons
    * @param yyyy outer list vector for y coordinates, containing a list vector for individual polygons
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L323">  class MultiPolygonReader(xxxx: ListColumnVector, yyyy: ListColumnVector, attribute: Int) extends OrcAttributeReader {</span>
<span class="nc" id="L324">    private val xxx = xxxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L325">    private val yyy = yyyy.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L326">    private val xx = xxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L327">    private val yy = yyy.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L328">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L329">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L332" title="All 4 branches missed.">      if (xxxx.noNulls || !xxxx.isNull(row)) {</span>
<span class="nc" id="L333">        val polygonOffset = xxxx.offsets(row).toInt</span>
<span class="nc" id="L334">        val polygonLength = xxxx.lengths(row).toInt</span>
<span class="nc" id="L335">        val polygons = Array.ofDim[Polygon](polygonLength)</span>
<span class="nc" id="L336">        var k = 0</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        while (k &lt; polygonLength) {</span>
<span class="nc" id="L338">          val lineOffset = xxx.offsets(polygonOffset + k).toInt</span>
<span class="nc" id="L339">          val lineLength = xxx.lengths(polygonOffset + k).toInt</span>
<span class="nc" id="L340">          val lines = Array.ofDim[LinearRing](lineLength)</span>
<span class="nc" id="L341">          var j = 0</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">          while (j &lt; lineLength) {</span>
<span class="nc" id="L343">            val offset = xx.offsets(lineOffset + j).toInt</span>
<span class="nc" id="L344">            val length = xx.lengths(lineOffset + j).toInt</span>
<span class="nc" id="L345">            val coordinates = Array.ofDim[Coordinate](length)</span>
<span class="nc" id="L346">            var i = 0</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            while (i &lt; length) {</span>
<span class="nc" id="L348">              coordinates(i) = new Coordinate(x.vector(offset + i), y.vector(offset + i))</span>
<span class="nc" id="L349">              i += 1</span>
            }
<span class="nc" id="L351">            lines(j) = gf.createLinearRing(coordinates)</span>
<span class="nc" id="L352">            j += 1</span>
          }
<span class="nc bnc" id="L354" title="All 2 branches missed.">          polygons(k) = if (lineLength == 1) { gf.createPolygon(lines.head) } else { gf.createPolygon(lines.head, lines.tail)}</span>
<span class="nc" id="L355">          k += 1</span>
        }
<span class="nc" id="L357">        sf.setAttribute(attribute, gf.createMultiPolygon(polygons))</span>
      } else {
<span class="nc" id="L359">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  // reads a WKB geometry from a vector and sets it in a simple feature
<span class="nc" id="L365">  class GeometryWkbReader(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L366">      extends VectorReaderAdapter[BytesColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L368" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L369">        var bytes = vector.vector(row)</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">        if (vector.start(row) != 0 || vector.length(row) != bytes.length) {</span>
<span class="nc" id="L371">          val tmp = Array.ofDim[Byte](vector.length(row))</span>
<span class="nc" id="L372">          System.arraycopy(bytes, vector.start(row), tmp, 0, tmp.length)</span>
<span class="nc" id="L373">          bytes = tmp</span>
        }
<span class="nc" id="L375">        WKBUtils.read(bytes)</span>
      } else {
<span class="nc" id="L377">        null</span>
      }
    }
  }

  /**
    * Reads a java.util.List attribute from a vector
    *
    * @param vector vector
    * @param attribute simple feature attribute index
    * @param binding list value type
    */
<span class="nc" id="L389">  class ListReader(vector: ListColumnVector, attribute: Int, binding: ObjectType) extends OrcAttributeReader {</span>

<span class="nc" id="L391">    private val reader = getInnerReader(binding, vector.child)</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L394" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L395">        val offset = vector.offsets(row).toInt</span>
<span class="nc" id="L396">        val length = vector.lengths(row).toInt</span>
<span class="nc" id="L397">        val value = new java.util.ArrayList[AnyRef](length)</span>
<span class="nc" id="L398">        var i = offset</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">        while (i &lt; offset + length) {</span>
<span class="nc" id="L400">          value.add(reader.getValue(i))</span>
<span class="nc" id="L401">          i += 1</span>
        }
<span class="nc" id="L403">        sf.setAttribute(attribute, value)</span>
      } else {
<span class="nc" id="L405">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  /**
    * Reads a java.util.Map attribute from a vector
    *
    * @param vector vector
    * @param attribute simple feature attribute index
    * @param keyBinding map key type
    * @param valueBinding map value type
    */
<span class="nc" id="L418">  class MapReader(vector: MapColumnVector, attribute: Int, keyBinding: ObjectType, valueBinding: ObjectType)</span>
<span class="nc" id="L419">      extends OrcAttributeReader {</span>

<span class="nc" id="L421">    private val keyReader = getInnerReader(keyBinding, vector.keys)</span>
<span class="nc" id="L422">    private val valueReader = getInnerReader(valueBinding, vector.values)</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc bnc" id="L425" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L426">        val offset = vector.offsets(row).toInt</span>
<span class="nc" id="L427">        val length = vector.lengths(row).toInt</span>
<span class="nc" id="L428">        val value = new java.util.HashMap[AnyRef, AnyRef](length)</span>
<span class="nc" id="L429">        var i = 0</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        while (i &lt; length) {</span>
<span class="nc" id="L431">          value.put(keyReader.getValue(i + offset), valueReader.getValue(i + offset))</span>
<span class="nc" id="L432">          i += 1</span>
        }
<span class="nc" id="L434">        sf.setAttribute(attribute, value)</span>
      } else {
<span class="nc" id="L436">        sf.setAttribute(attribute, null)</span>
      }
    }
  }

  // reads a value out of a typed vector
  trait GetVectorValue[T &lt;: ColumnVector] {
    protected val vector: T
    def getValue(row: Int): AnyRef
  }

  // reads a value out of a vector and sets it into a simple feature
<span class="nc" id="L448">  trait VectorReaderAdapter[T &lt;: ColumnVector] extends OrcAttributeReader with GetVectorValue[T]{</span>
    def attribute: Int
<span class="nc" id="L450">    override def apply(sf: SimpleFeature, row: Int): Unit = sf.setAttribute(attribute, getValue(row))</span>
  }

  // reads a date from a vector
<span class="nc" id="L454">  trait GetVectorDate extends GetVectorValue[TimestampColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L456" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L457">        new java.util.Date(vector.asScratchTimestamp(row).toInstant.toEpochMilli)</span>
      } else {
<span class="nc" id="L459">        null</span>
      }
    }
  }

  // reads a string from a vector
<span class="nc" id="L465">  trait GetVectorString extends GetVectorValue[BytesColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L467" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L468">        vector.toString(row)</span>
      } else {
<span class="nc" id="L470">        null</span>
      }
    }
  }

  // reads an int from a vector
<span class="nc" id="L476">  trait GetVectorInt extends GetVectorValue[LongColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L478" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L479">        Int.box(vector.vector(row).toInt)</span>
      } else {
<span class="nc" id="L481">        null</span>
      }
    }
  }

  // reads a long from a vector
<span class="nc" id="L487">  trait GetVectorLong extends GetVectorValue[LongColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L489" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L490">        Long.box(vector.vector(row))</span>
      } else {
<span class="nc" id="L492">        null</span>
      }
    }
  }

  // reads a float from a vector
<span class="nc" id="L498">  trait GetVectorFloat extends GetVectorValue[DoubleColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L500" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L501">        Float.box(vector.vector(row).toFloat)</span>
      } else {
<span class="nc" id="L503">        null</span>
      }
    }
  }

  // reads a double from a vector
<span class="nc" id="L509">  trait GetVectorDouble extends GetVectorValue[DoubleColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L511" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L512">        Double.box(vector.vector(row))</span>
      } else {
<span class="nc" id="L514">        null</span>
      }
    }
  }

  // reads a boolean from a vector
<span class="nc" id="L520">  trait GetVectorBoolean extends GetVectorValue[LongColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L522" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        Boolean.box(vector.vector(row) &gt; 0L)</span>
      } else {
<span class="nc" id="L525">        null</span>
      }
    }
  }

  // reads a byte array from a vector
<span class="nc" id="L531">  trait GetVectorBytes extends GetVectorValue[BytesColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L533" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L534">        var bytes = vector.vector(row)</span>
<span class="nc bnc" id="L535" title="All 4 branches missed.">        if (vector.start(row) != 0 || vector.length(row) != bytes.length) {</span>
<span class="nc" id="L536">          val tmp = Array.ofDim[Byte](vector.length(row))</span>
<span class="nc" id="L537">          System.arraycopy(bytes, vector.start(row), tmp, 0, tmp.length)</span>
<span class="nc" id="L538">          bytes = tmp</span>
        }
<span class="nc" id="L540">        bytes</span>
      } else {
<span class="nc" id="L542">        null</span>
      }
    }
  }

  // reads a UUID from a vector
<span class="nc" id="L548">  trait GetVectorUuid extends GetVectorValue[BytesColumnVector] {</span>
    override def getValue(row: Int): AnyRef = {
<span class="nc bnc" id="L550" title="All 4 branches missed.">      if (vector.noNulls || !vector.isNull(row)) {</span>
<span class="nc" id="L551">        UUID.fromString(vector.toString(row))</span>
      } else {
<span class="nc" id="L553">        null</span>
      }
    }
  }

  /**
    * Gets a reader for getting a value directly out of a vector
    *
    * @param binding binding
    * @param vec vector
    * @return
    */
  private def getInnerReader(binding: ObjectType, vec: ColumnVector): GetVectorValue[ColumnVector] = {
<span class="nc" id="L566">    val reader = binding match {</span>
<span class="nc bnc" id="L567" title="All 6 branches missed.">      case ObjectType.DATE     =&gt; new GetVectorDate { override val vector: TimestampColumnVector = vec.asInstanceOf[TimestampColumnVector] }</span>
<span class="nc bnc" id="L568" title="All 6 branches missed.">      case ObjectType.STRING   =&gt; new GetVectorString { override val vector: BytesColumnVector = vec.asInstanceOf[BytesColumnVector] }</span>
<span class="nc bnc" id="L569" title="All 6 branches missed.">      case ObjectType.INT      =&gt; new GetVectorInt { override val vector: LongColumnVector = vec.asInstanceOf[LongColumnVector] }</span>
<span class="nc bnc" id="L570" title="All 6 branches missed.">      case ObjectType.LONG     =&gt; new GetVectorLong { override val vector: LongColumnVector = vec.asInstanceOf[LongColumnVector] }</span>
<span class="nc bnc" id="L571" title="All 6 branches missed.">      case ObjectType.FLOAT    =&gt; new GetVectorFloat { override val vector: DoubleColumnVector = vec.asInstanceOf[DoubleColumnVector] }</span>
<span class="nc bnc" id="L572" title="All 6 branches missed.">      case ObjectType.DOUBLE   =&gt; new GetVectorDouble { override val vector: DoubleColumnVector = vec.asInstanceOf[DoubleColumnVector] }</span>
<span class="nc bnc" id="L573" title="All 6 branches missed.">      case ObjectType.BOOLEAN  =&gt; new GetVectorBoolean { override val vector: LongColumnVector = vec.asInstanceOf[LongColumnVector] }</span>
<span class="nc bnc" id="L574" title="All 6 branches missed.">      case ObjectType.BYTES    =&gt; new GetVectorBytes { override val vector: BytesColumnVector = vec.asInstanceOf[BytesColumnVector] }</span>
<span class="nc bnc" id="L575" title="All 6 branches missed.">      case ObjectType.UUID     =&gt; new GetVectorUuid { override val vector: BytesColumnVector = vec.asInstanceOf[BytesColumnVector] }</span>
<span class="nc" id="L576">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type $binding&quot;)</span>
    }
<span class="nc" id="L578">    reader.asInstanceOf[GetVectorValue[ColumnVector]]</span>
  }
<span class="nc" id="L580">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>