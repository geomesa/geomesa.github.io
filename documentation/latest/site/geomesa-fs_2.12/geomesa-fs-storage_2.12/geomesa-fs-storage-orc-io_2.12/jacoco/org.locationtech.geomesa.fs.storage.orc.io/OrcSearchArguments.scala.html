<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OrcSearchArguments.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage ORC IO</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.orc.io</a> &gt; <span class="el_source">OrcSearchArguments.scala</span></div><h1>OrcSearchArguments.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.orc.io

import org.apache.orc.TypeDescription
import org.apache.orc.storage.ql.io.sarg.{PredicateLeaf, SearchArgument, SearchArgumentFactory}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.filter.{Bounds, FilterHelper}
import org.locationtech.jts.geom.{Geometry, Point}

import java.sql.Timestamp

<span class="nc" id="L20">object OrcSearchArguments {</span>

  import scala.collection.JavaConverters._

  /**
    * Creates a push-down predicate for Orc files based on a CQL filter
    *
    * @param sft simple feature type
    * @param description orc file description
    * @param filter cql filter
    * @return
    */
  def apply(sft: SimpleFeatureType,
            description: TypeDescription,
            filter: Filter): Option[(SearchArgument, Array[String])] = {
    import org.apache.orc.TypeDescription.Category._

<span class="nc" id="L37">    val predicates = FilterHelper.propertyNames(filter, sft).distinct.flatMap { prop =&gt;</span>
<span class="nc" id="L38">      val binding = sft.getDescriptor(prop).getType.getBinding</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">      val preds = if (classOf[Geometry].isAssignableFrom(binding)) {</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">        if (classOf[Point] == binding) {</span>
<span class="nc" id="L41">          FilterHelper.extractGeometries(filter, prop).values.map(addPoint(prop, _))</span>
        } else {
          // orc doesn't support push-down predicates against complex fields
<span class="nc" id="L44">          Seq.empty</span>
        }
      } else {
        // count the columns before the property
<span class="nc" id="L48">        val offset = sft.getAttributeDescriptors.asScala.take(sft.indexOf(prop)).foldLeft(0) { (sum, d) =&gt;</span>
<span class="nc" id="L49">          sum + SimpleFeatureTypeDescription.fieldCount(d)</span>
        }

<span class="nc" id="L52">        val category = description.getChildren.get(offset).getCategory</span>
<span class="nc" id="L53">        val typeAndConversion = category match {</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">          case BOOLEAN   =&gt; Some(PredicateLeaf.Type.BOOLEAN, (v: Any) =&gt; v)</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">          case INT       =&gt; Some(PredicateLeaf.Type.LONG, (v: Any) =&gt; v.asInstanceOf[java.lang.Integer].longValue)</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">          case LONG      =&gt; Some(PredicateLeaf.Type.LONG, (v: Any) =&gt; v)</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">          case FLOAT     =&gt; Some(PredicateLeaf.Type.FLOAT, (v: Any) =&gt; v.asInstanceOf[java.lang.Float].doubleValue)</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">          case DOUBLE    =&gt; Some(PredicateLeaf.Type.FLOAT, (v: Any) =&gt; v)</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">          case STRING    =&gt; Some(PredicateLeaf.Type.STRING, (v: Any) =&gt; v)</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">          case TIMESTAMP =&gt; Some(PredicateLeaf.Type.TIMESTAMP, (v: Any) =&gt; new Timestamp(v.asInstanceOf[java.util.Date].getTime))</span>
<span class="nc bnc" id="L61" title="All 8 branches missed.">          case BINARY | LIST | MAP =&gt; None // orc doesn't support push-down predicates against complex fields</span>
<span class="nc bnc" id="L62" title="All 16 branches missed.">          case BYTE | CHAR | SHORT | DATE | DECIMAL | VARCHAR | STRUCT =&gt;</span>
<span class="nc" id="L63">            throw new IllegalArgumentException(s&quot;SimpleFeature TypeDefinition should not have type '$category'&quot;)</span>
        }
<span class="nc bnc" id="L65" title="All 2 branches missed.">        typeAndConversion.toSeq.flatMap { case (typ, conversion) =&gt;</span>
<span class="nc" id="L66">          FilterHelper.extractAttributeBounds(filter, prop, binding).values.flatMap(add(prop, _, typ, conversion))</span>
        }
      }

<span class="nc bnc" id="L70" title="All 2 branches missed.">      if (preds.isEmpty) {</span>
<span class="nc" id="L71">        Seq.empty</span>
      } else {
<span class="nc" id="L73">        Seq(preds)</span>
      }
    }

<span class="nc bnc" id="L77" title="All 2 branches missed.">    if (predicates.isEmpty) { None } else {</span>
<span class="nc" id="L78">      val arg = SearchArgumentFactory.newBuilder</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">      if (predicates.length &gt; 1) {</span>
<span class="nc" id="L80">        arg.startAnd()</span>
      }
<span class="nc" id="L82">      predicates.foreach { preds =&gt;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (preds.length == 1) {</span>
<span class="nc" id="L84">          preds.head.apply(arg)</span>
        } else {
<span class="nc" id="L86">          arg.startOr()</span>
<span class="nc" id="L87">          preds.foreach(_.apply(arg))</span>
<span class="nc" id="L88">          arg.end()</span>
        }
      }
<span class="nc bnc" id="L91" title="All 2 branches missed.">      if (predicates.length &gt; 1) {</span>
<span class="nc" id="L92">        arg.end()</span>
      }
      // note: column name array does not matter at all
<span class="nc" id="L95">      Some((arg.build, Array.empty))</span>
    }
  }

  private def add(
      prop: String,
      bounds: Bounds[_],
      typ: PredicateLeaf.Type,
      convert: Any =&gt; Any): Option[SearchArgument.Builder =&gt; Unit] = {
<span class="nc bnc" id="L104" title="All 2 branches missed.">    if (bounds.isRange) {</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">      if (bounds.isBoundedBothSides) {</span>
        // between seems to be endpoint inclusive, so should not have any false negatives regardless of bounds inclusiveness
<span class="nc" id="L107">        Some(arg =&gt; arg.between(prop, typ, convert(bounds.lower.value.get), convert(bounds.upper.value.get)))</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">      } else if (bounds.isBounded) {</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (bounds.upper.value.isDefined) {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">          if (bounds.upper.inclusive) {</span>
<span class="nc" id="L111">            Some(arg =&gt; arg.lessThanEquals(prop, typ, convert(bounds.upper.value.get)))</span>
          } else {
<span class="nc" id="L113">            Some(arg =&gt; arg.lessThan(prop, typ, convert(bounds.upper.value.get)))</span>
          }
<span class="nc bnc" id="L115" title="All 2 branches missed.">        } else if (bounds.lower.inclusive) {</span>
<span class="nc" id="L116">          Some(arg =&gt; arg.startNot().lessThan(prop, typ, convert(bounds.lower.value.get)).end())</span>
        } else {
<span class="nc" id="L118">          Some(arg =&gt; arg.startNot().lessThanEquals(prop, typ, convert(bounds.lower.value.get)).end())</span>
        }
      } else {
<span class="nc" id="L121">        None</span>
      }
    } else {
<span class="nc" id="L124">      Some(arg =&gt; arg.equals(prop, typ, convert(bounds.lower.value.get)))</span>
    }
  }

  private def addPoint(prop: String, bounds: Geometry): SearchArgument.Builder =&gt; Unit = {
<span class="nc" id="L129">    val x = SimpleFeatureTypeDescription.geometryXField(prop)</span>
<span class="nc" id="L130">    val y = SimpleFeatureTypeDescription.geometryYField(prop)</span>
<span class="nc" id="L131">    val envelope = bounds.getEnvelopeInternal</span>

<span class="nc" id="L133">    arg =&gt; {</span>
<span class="nc" id="L134">      arg.startAnd()</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      if (envelope.getMinX == envelope.getMaxX) {</span>
<span class="nc" id="L136">        arg.equals(x, PredicateLeaf.Type.FLOAT, envelope.getMinX)</span>
      } else {
<span class="nc" id="L138">        arg.between(x, PredicateLeaf.Type.FLOAT, envelope.getMinX, envelope.getMaxX)</span>
      }
<span class="nc bnc" id="L140" title="All 2 branches missed.">      if (envelope.getMinY == envelope.getMaxY) {</span>
<span class="nc" id="L141">        arg.equals(y, PredicateLeaf.Type.FLOAT, envelope.getMinY)</span>
      } else {
<span class="nc" id="L143">        arg.between(y, PredicateLeaf.Type.FLOAT, envelope.getMinY, envelope.getMaxY)</span>
      }
<span class="nc" id="L145">      arg.end()</span>
    }
  }
<span class="nc" id="L148">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>