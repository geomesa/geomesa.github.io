<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OrcFileSystemReader.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage ORC IO</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.orc.io</a> &gt; <span class="el_source">OrcFileSystemReader.scala</span></div><h1>OrcFileSystemReader.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.orc.io

import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.fs.Path
import org.apache.orc.storage.ql.io.sarg.SearchArgument
import org.apache.orc.{OrcFile, Reader}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.features.{ScalaSimpleFeature, TransformSimpleFeature}
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.fs.storage.api.FileSystemStorage.FileSystemPathReader
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.Transform.Transforms

import scala.collection.mutable.ArrayBuffer

<span class="nc" id="L26">class OrcFileSystemReader(</span>
<span class="nc" id="L27">    sft: SimpleFeatureType,</span>
<span class="nc" id="L28">    config: Configuration,</span>
<span class="nc" id="L29">    filter: Option[Filter],</span>
<span class="nc" id="L30">    transform: Option[(String, SimpleFeatureType)]</span>
<span class="nc" id="L31">  ) extends FileSystemPathReader {</span>

<span class="nc bnc" id="L33" title="All 2 branches missed.">  private val (options, columns) = {</span>
<span class="nc" id="L34">    val options = new Reader.Options(config)</span>
<span class="nc" id="L35">    val readOptions = OrcFileSystemReader.readOptions(sft, filter, transform)</span>
<span class="nc" id="L36">    readOptions.columns.foreach(c =&gt; options.include(OrcFileSystemReader.include(sft, c)))</span>
    // note: push down will exclude whole record batches, but doesn't actually filter inside a batch
<span class="nc bnc" id="L38" title="All 2 branches missed.">    readOptions.pushDown.foreach { case (sarg, cols) =&gt; options.searchArgument(sarg, cols) }</span>
<span class="nc" id="L39">    (options, readOptions.columns)</span>
  }

<span class="nc" id="L42">  override def read(path: Path): CloseableIterator[SimpleFeature] = new PathReader(path)</span>

<span class="nc bnc" id="L44" title="All 2 branches missed.">  private class PathReader(file: Path) extends CloseableIterator[SimpleFeature] {</span>
<span class="nc" id="L45">    private val feature = new ScalaSimpleFeature(sft, &quot;&quot;)</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">    private val transformed = transform.map { case (tdefs, tsft) =&gt;</span>
<span class="nc" id="L47">      val sf = TransformSimpleFeature(sft, tsft, tdefs)</span>
<span class="nc" id="L48">      sf.setFeature(feature)</span>
<span class="nc" id="L49">      sf</span>
    }
<span class="nc" id="L51">    private val result = transformed.getOrElse(feature)</span>

<span class="nc" id="L53">    private val reader = OrcFile.createReader(file, OrcFile.readerOptions(config).useUTCTimestamp(true))</span>
<span class="nc" id="L54">    private val rows = reader.rows(options)</span>
<span class="nc" id="L55">    private val batch = reader.getSchema.createRowBatch()</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    private val attributeReader = if (batch.cols.length &gt; 0) { OrcAttributeReader(sft, batch, columns) } else { null }</span>

<span class="nc" id="L58">    private var staged: Boolean = false</span>
<span class="nc" id="L59">    private var i = 0</span>

    override def hasNext: Boolean = {
<span class="nc bnc" id="L62" title="All 2 branches missed.">      if (staged) { true } else {</span>
<span class="nc" id="L63">        stageNext()</span>
<span class="nc" id="L64">        staged</span>
      }
    }

    /**
      * Note: same feature is mutated and returned for each call to .next
      *
      * @return
      */
    override def next(): SimpleFeature = {
<span class="nc bnc" id="L74" title="All 4 branches missed.">      if (staged || hasNext) {</span>
<span class="nc" id="L75">        staged = false</span>
<span class="nc" id="L76">        result</span>
      } else {
<span class="nc" id="L78">        Iterator.empty.next</span>
      }
    }

<span class="nc" id="L82">    override def close(): Unit = rows.close()</span>

    private def stageNext(): Unit = {
<span class="nc" id="L85">      var loop = true</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">      while (loop) {</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (i &lt; batch.size) {</span>
<span class="nc" id="L88">          attributeReader.apply(feature, i)</span>
<span class="nc" id="L89">          i += 1</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">          if (OrcFileSystemReader.this.filter.forall(_.evaluate(feature))) {</span>
<span class="nc" id="L91">            staged = true</span>
<span class="nc" id="L92">            loop = false</span>
          }
        } else {
<span class="nc" id="L95">          i = 0</span>
<span class="nc" id="L96">          loop = rows.nextBatch(batch)</span>
        }
      }
    }
  }
}

<span class="nc" id="L103">object OrcFileSystemReader {</span>

  import org.locationtech.geomesa.filter.RichTransform.RichTransform

  /**
    * Create low-level reading options used by ORC
    *
    * @param sft simple feature type
    * @param filter ecql filter
    * @param transform transform
    * @return
    */
  def readOptions(
      sft: SimpleFeatureType,
      filter: Option[Filter],
      transform: Option[(String, SimpleFeatureType)]): OrcReadOptions = {
<span class="nc bnc" id="L119" title="All 2 branches missed.">    val columns = transform.map { case (tdefs, _) =&gt;</span>
<span class="nc" id="L120">      val fromFilter = filter.map(FilterHelper.propertyNames(_, sft)).getOrElse(Seq.empty)</span>
<span class="nc" id="L121">      val fromTransform = Transforms(sft, tdefs).flatMap(_.properties)</span>
<span class="nc" id="L122">      (fromFilter ++ fromTransform).toSet[String].map(sft.indexOf)</span>
    }
    // push down will exclude whole record batches, but doesn't actually filter inside a batch
<span class="nc" id="L125">    val pushDown = filter.flatMap { f =&gt;</span>
<span class="nc" id="L126">      OrcSearchArguments(sft, SimpleFeatureTypeDescription(sft), f)</span>
    }
<span class="nc" id="L128">    OrcReadOptions(columns, pushDown)</span>
  }

  /**
    * Construct the array used to include columns corresponding to the simple feature transform.
    *
    * Included columns don't just align with the top-level fields - complex fields need to have additional
    * entries in the array for their children.
    *
    * @param sft simple feature type
    * @param columns attributes to read
    * @param fid read fid
    * @return
    */
<span class="nc" id="L142">  def include(sft: SimpleFeatureType, columns: Set[Int], fid: Boolean = true): Array[Boolean] = {</span>
<span class="nc" id="L143">    val buffer = ArrayBuffer[Boolean](true) // outer struct</span>

<span class="nc" id="L145">    var i = 0</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">    while (i &lt; sft.getAttributeCount) {</span>
<span class="nc" id="L147">      val bindings = ObjectType.selectType(sft.getDescriptor(i))</span>
<span class="nc" id="L148">      val count = bindings.head match {</span>
<span class="nc bnc" id="L149" title="All 6 branches missed.">        case ObjectType.GEOMETRY =&gt;</span>
<span class="nc" id="L150">          bindings(1) match {</span>
<span class="nc bnc" id="L151" title="All 6 branches missed.">            case ObjectType.POINT =&gt; 2 // x + y</span>
<span class="nc bnc" id="L152" title="All 14 branches missed.">            case ObjectType.LINESTRING | ObjectType.MULTIPOINT =&gt; 4 // list of x, list of y</span>
<span class="nc bnc" id="L153" title="All 14 branches missed.">            case ObjectType.POLYGON | ObjectType.MULTILINESTRING =&gt; 6 // list of list of x, list of list of y</span>
<span class="nc bnc" id="L154" title="All 6 branches missed.">            case ObjectType.MULTIPOLYGON =&gt; 8 // list of list of list of x, list of list of list of y</span>
<span class="nc bnc" id="L155" title="All 6 branches missed.">            case ObjectType.GEOMETRY =&gt; 1 // wkb</span>
          }
<span class="nc bnc" id="L157" title="All 6 branches missed.">        case ObjectType.LIST =&gt; 2</span>
<span class="nc bnc" id="L158" title="All 6 branches missed.">        case ObjectType.MAP =&gt; 3</span>
<span class="nc" id="L159">        case _ =&gt; 1</span>
      }
<span class="nc" id="L161">      val include = columns.contains(i)</span>
<span class="nc" id="L162">      var j = 0</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">      while (j &lt; count) {</span>
<span class="nc" id="L164">        buffer += include</span>
<span class="nc" id="L165">        j += 1</span>
      }
<span class="nc" id="L167">      i += 1</span>
    }

<span class="nc" id="L170">    buffer += fid</span>

<span class="nc" id="L172">    buffer.toArray</span>
  }

<span class="nc bnc" id="L175" title="All 25 branches missed.">  case class OrcReadOptions(columns: Option[Set[Int]], pushDown: Option[(SearchArgument, Array[String])])</span>
<span class="nc" id="L176">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>