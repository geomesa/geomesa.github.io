<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OrcAttributeWriter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage ORC IO</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.orc.io</a> &gt; <span class="el_source">OrcAttributeWriter.scala</span></div><h1>OrcAttributeWriter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.orc.io

import org.apache.orc.storage.ql.exec.vector._
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.text.WKBUtils
import org.locationtech.jts.geom._

import java.nio.charset.StandardCharsets
import java.util.UUID

/**
  * Writes a simple feature to a given Orc row
  */
trait OrcAttributeWriter {
  def apply(sf: SimpleFeature, row: Int): Unit
}

<span class="nc" id="L28">object OrcAttributeWriter {</span>

  /**
    * Create a writer for simple feature to the given vector batch
    *
    * @param sft simple feature type
    * @param batch vector batch
    * @param fid write feature id or not
    * @return
    */
<span class="nc" id="L38">  def apply(sft: SimpleFeatureType, batch: VectorizedRowBatch, fid: Boolean = true): OrcAttributeWriter = {</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">    require(batch.cols.length == SimpleFeatureTypeDescription.fieldCount(sft, fid),</span>
<span class="nc" id="L40">      s&quot;ORC schema does not match SimpleFeatureType: ${batch.cols.map(_.getClass.getName).mkString(&quot;\n\t&quot;, &quot;\n\t&quot;, &quot;&quot;)}&quot;)</span>

<span class="nc" id="L42">    val builder = Seq.newBuilder[OrcAttributeWriter]</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    builder.sizeHint(sft.getAttributeCount + (if (fid) { 1 } else { 0 }))</span>

<span class="nc" id="L45">    var i = 0</span>
<span class="nc" id="L46">    var col = 0</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">    while (i &lt; sft.getAttributeCount) {</span>
<span class="nc" id="L48">      val descriptor = sft.getDescriptor(i)</span>
<span class="nc" id="L49">      val bindings = ObjectType.selectType(descriptor)</span>
<span class="nc" id="L50">      val writer = bindings.head match {</span>
<span class="nc bnc" id="L51" title="All 6 branches missed.">        case ObjectType.GEOMETRY =&gt; createGeometryWriter(bindings(1), batch.cols, col, i)</span>
<span class="nc bnc" id="L52" title="All 6 branches missed.">        case ObjectType.DATE     =&gt; new DateWriter(batch.cols(col).asInstanceOf[TimestampColumnVector], i)</span>
<span class="nc bnc" id="L53" title="All 6 branches missed.">        case ObjectType.STRING   =&gt; new StringWriter(batch.cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc bnc" id="L54" title="All 6 branches missed.">        case ObjectType.INT      =&gt; new IntWriter(batch.cols(col).asInstanceOf[LongColumnVector], i)</span>
<span class="nc bnc" id="L55" title="All 6 branches missed.">        case ObjectType.LONG     =&gt; new LongWriter(batch.cols(col).asInstanceOf[LongColumnVector], i)</span>
<span class="nc bnc" id="L56" title="All 6 branches missed.">        case ObjectType.FLOAT    =&gt; new FloatWriter(batch.cols(col).asInstanceOf[DoubleColumnVector], i)</span>
<span class="nc bnc" id="L57" title="All 6 branches missed.">        case ObjectType.DOUBLE   =&gt; new DoubleWriter(batch.cols(col).asInstanceOf[DoubleColumnVector], i)</span>
<span class="nc bnc" id="L58" title="All 6 branches missed.">        case ObjectType.BOOLEAN  =&gt; new BooleanWriter(batch.cols(col).asInstanceOf[LongColumnVector], i)</span>
<span class="nc bnc" id="L59" title="All 6 branches missed.">        case ObjectType.BYTES    =&gt; new BytesWriter(batch.cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc bnc" id="L60" title="All 6 branches missed.">        case ObjectType.UUID     =&gt; new UuidWriter(batch.cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc bnc" id="L61" title="All 6 branches missed.">        case ObjectType.LIST     =&gt; new ListWriter(batch.cols(col).asInstanceOf[ListColumnVector], i, bindings(1))</span>
<span class="nc bnc" id="L62" title="All 6 branches missed.">        case ObjectType.MAP      =&gt; new MapWriter(batch.cols(col).asInstanceOf[MapColumnVector], i, bindings(1), bindings(2))</span>
<span class="nc" id="L63">        case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type ${bindings.head}&quot;)</span>
      }
<span class="nc" id="L65">      builder += writer</span>
<span class="nc" id="L66">      i += 1</span>
<span class="nc" id="L67">      col += SimpleFeatureTypeDescription.fieldCount(descriptor)</span>
    }

<span class="nc bnc" id="L70" title="All 2 branches missed.">    if (fid) {</span>
<span class="nc" id="L71">      builder += new FidWriter(batch.cols(col).asInstanceOf[BytesColumnVector])</span>
    }

<span class="nc" id="L74">    new SequenceWriter(builder.result)</span>
  }

  // noinspection LanguageFeature
  private def createGeometryWriter(binding: ObjectType, cols: Array[ColumnVector], col: Int, i: Int): OrcAttributeWriter = {
<span class="nc" id="L79">    implicit def toDoubleColumnVector(vec: ColumnVector): DoubleColumnVector = vec.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L80">    implicit def toListColumnVector(vec: ColumnVector): ListColumnVector = vec.asInstanceOf[ListColumnVector]</span>

<span class="nc" id="L82">    def x: ColumnVector = cols(col)</span>
<span class="nc" id="L83">    def y: ColumnVector = cols(col + 1)</span>

<span class="nc" id="L85">    binding match {</span>
<span class="nc bnc" id="L86" title="All 6 branches missed.">      case ObjectType.POINT           =&gt; new PointWriter(x, y, i)</span>
<span class="nc bnc" id="L87" title="All 6 branches missed.">      case ObjectType.LINESTRING      =&gt; new LineStringWriter(x, y, i)</span>
<span class="nc bnc" id="L88" title="All 6 branches missed.">      case ObjectType.MULTIPOINT      =&gt; new MultiPointWriter(x, y, i)</span>
<span class="nc bnc" id="L89" title="All 6 branches missed.">      case ObjectType.POLYGON         =&gt; new PolygonWriter(x, y, i)</span>
<span class="nc bnc" id="L90" title="All 6 branches missed.">      case ObjectType.MULTILINESTRING =&gt; new MultiLineStringWriter(x, y, i)</span>
<span class="nc bnc" id="L91" title="All 6 branches missed.">      case ObjectType.MULTIPOLYGON    =&gt; new MultiPolygonWriter(x, y, i)</span>
<span class="nc bnc" id="L92" title="All 6 branches missed.">      case ObjectType.GEOMETRY        =&gt; new GeometryWkbWriter(cols(col).asInstanceOf[BytesColumnVector], i)</span>
<span class="nc" id="L93">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type $binding&quot;)</span>
    }
  }

  // invokes a sequence of writers in a single call
<span class="nc" id="L98">  class SequenceWriter(writers: Seq[OrcAttributeWriter]) extends OrcAttributeWriter {</span>
<span class="nc" id="L99">    override def apply(sf: SimpleFeature, row: Int): Unit = writers.foreach(_.apply(sf, row))</span>
  }

  // writes a feature ID to a vector
<span class="nc" id="L103">  class FidWriter(val vector: BytesColumnVector) extends OrcAttributeWriter with SetVectorString {</span>
<span class="nc" id="L104">    override def apply(sf: SimpleFeature, row: Int): Unit = setValue(sf.getID, row)</span>
  }

  // writes a string attribute to a vector
<span class="nc" id="L108">  class StringWriter(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L109">      extends VectorWriterAdapter[String, BytesColumnVector] with SetVectorString</span>

  // writes a date attribute to a vector
<span class="nc" id="L112">  class DateWriter(val vector: TimestampColumnVector, val attribute: Int)</span>
<span class="nc" id="L113">      extends VectorWriterAdapter[java.util.Date, TimestampColumnVector] with SetVectorDate</span>

  // writes an int attribute to a vector
<span class="nc" id="L116">  class IntWriter(val vector: LongColumnVector, val attribute: Int)</span>
<span class="nc" id="L117">      extends VectorWriterAdapter[java.lang.Integer, LongColumnVector] with SetVectorInt</span>

  // writes a long attribute to a vector
<span class="nc" id="L120">  class LongWriter(val vector: LongColumnVector, val attribute: Int)</span>
<span class="nc" id="L121">      extends VectorWriterAdapter[java.lang.Long, LongColumnVector] with SetVectorLong</span>

  // writes a float attribute to a vector
<span class="nc" id="L124">  class FloatWriter(val vector: DoubleColumnVector, val attribute: Int)</span>
<span class="nc" id="L125">      extends VectorWriterAdapter[java.lang.Float, DoubleColumnVector] with SetVectorFloat</span>

  // writes a double attribute to a vector
<span class="nc" id="L128">  class DoubleWriter(val vector: DoubleColumnVector, val attribute: Int)</span>
<span class="nc" id="L129">      extends VectorWriterAdapter[java.lang.Double, DoubleColumnVector] with SetVectorDouble</span>

  // writes a boolean attribute to a vector
<span class="nc" id="L132">  class BooleanWriter(val vector: LongColumnVector, val attribute: Int)</span>
<span class="nc" id="L133">      extends VectorWriterAdapter[java.lang.Boolean, LongColumnVector] with SetVectorBoolean</span>

  // writes a byte array attribute to a vector
<span class="nc" id="L136">  class BytesWriter(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L137">      extends VectorWriterAdapter[Array[Byte], BytesColumnVector] with SetVectorBytes</span>

  // writes a UUID attribute to a vector
<span class="nc" id="L140">  class UuidWriter(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L141">      extends OrcAttributeWriter with SetVectorString {</span>
    override def apply(sf: SimpleFeature, row: Int): Unit =
<span class="nc" id="L143">      setValue(Option(sf.getAttribute(attribute).asInstanceOf[UUID]).map(_.toString).orNull, row)</span>
  }

  /**
    * Writes a point attribute to a vector
    *
    * @param x x coordinates
    * @param y y coordinates
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L153">  class PointWriter(x: DoubleColumnVector, y: DoubleColumnVector, attribute: Int) extends OrcAttributeWriter {</span>
    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc" id="L155">      val value = sf.getAttribute(attribute).asInstanceOf[Point]</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L157">        x.vector(row) = value.getX</span>
<span class="nc" id="L158">        y.vector(row) = value.getY</span>
      } else {
<span class="nc" id="L160">        x.noNulls = false</span>
<span class="nc" id="L161">        y.noNulls = false</span>
<span class="nc" id="L162">        x.isNull(row) = true</span>
<span class="nc" id="L163">        y.isNull(row) = true</span>
      }
    }
  }

  /**
    * Writes a linestring attribute to a vector. A linestring is modeled as a list of points.
    *
    * @see PointWriter
    *
    * @param xx outer list vector for x coordinates, containing a double vector for points
    * @param yy outer list vector for y coordinates, containing a double vector for points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L177">  class LineStringWriter(xx: ListColumnVector, yy: ListColumnVector, attribute: Int) extends OrcAttributeWriter {</span>
<span class="nc" id="L178">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L179">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc" id="L182">      val value = sf.getAttribute(attribute).asInstanceOf[LineString]</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L184">        val length = value.getNumPoints</span>
<span class="nc" id="L185">        Seq(xx, yy).foreach { vector =&gt;</span>
<span class="nc" id="L186">          vector.child.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L187">          vector.offsets(row) = vector.childCount</span>
<span class="nc" id="L188">          vector.lengths(row) = length</span>
        }
<span class="nc" id="L190">        var i = 0</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        while (i &lt; length) {</span>
<span class="nc" id="L192">          val pt = value.getCoordinateN(i)</span>
<span class="nc" id="L193">          x.vector(xx.childCount + i) = pt.x</span>
<span class="nc" id="L194">          y.vector(yy.childCount + i) = pt.y</span>
<span class="nc" id="L195">          i += 1</span>
        }
<span class="nc" id="L197">        xx.childCount += length</span>
<span class="nc" id="L198">        yy.childCount += length</span>
      } else {
<span class="nc" id="L200">        xx.noNulls = false</span>
<span class="nc" id="L201">        yy.noNulls = false</span>
<span class="nc" id="L202">        xx.isNull(row) = true</span>
<span class="nc" id="L203">        yy.isNull(row) = true</span>
      }
    }
  }

  /**
    * Writes a multi-point attribute to a vector. A multi-point is modeled as a list of points.
    *
    * @see PointWriter
    *
    * @param xx outer list vector for x coordinates, containing a double vector for points
    * @param yy outer list vector for y coordinates, containing a double vector for points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L217">  class MultiPointWriter(xx: ListColumnVector, yy: ListColumnVector, attribute: Int) extends OrcAttributeWriter {</span>
<span class="nc" id="L218">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L219">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc" id="L222">      val value = sf.getAttribute(attribute).asInstanceOf[MultiPoint]</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L224">        val length = value.getNumPoints</span>
<span class="nc" id="L225">        Seq(xx, yy).foreach { vector =&gt;</span>
<span class="nc" id="L226">          vector.child.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L227">          vector.offsets(row) = vector.childCount</span>
<span class="nc" id="L228">          vector.lengths(row) = length</span>
        }
<span class="nc" id="L230">        var i = 0</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        while (i &lt; length) {</span>
<span class="nc" id="L232">          val pt = value.getGeometryN(i).asInstanceOf[Point]</span>
<span class="nc" id="L233">          x.vector(xx.childCount + i) = pt.getX</span>
<span class="nc" id="L234">          y.vector(yy.childCount + i) = pt.getY</span>
<span class="nc" id="L235">          i += 1</span>
        }
<span class="nc" id="L237">        xx.childCount += length</span>
<span class="nc" id="L238">        yy.childCount += length</span>
      } else {
<span class="nc" id="L240">        xx.noNulls = false</span>
<span class="nc" id="L241">        yy.noNulls = false</span>
<span class="nc" id="L242">        xx.isNull(row) = true</span>
<span class="nc" id="L243">        yy.isNull(row) = true</span>
      }
    }
  }

  /**
    * Writes a polygon attribute to a vector. A polygon is modeled as a list of lines, with the first
    * value being the shell, and any subsequent values being interior holes.
    *
    * @see LineStringWriter
    *
    * @param xxx outer list vector for x coordinates, containing a list vector for individual lines
    * @param yyy outer list vector for y coordinates, containing a list vector for individual lines
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L258">  class PolygonWriter(xxx: ListColumnVector, yyy: ListColumnVector, attribute: Int) extends OrcAttributeWriter {</span>
    // list of points for each line
<span class="nc" id="L260">    private val xx = xxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L261">    private val yy = yyy.child.asInstanceOf[ListColumnVector]</span>
    // points
<span class="nc" id="L263">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L264">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc" id="L267">      val polygon = sf.getAttribute(attribute).asInstanceOf[Polygon]</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (polygon != null) {</span>
<span class="nc" id="L269">        val lineCount = polygon.getNumInteriorRing + 1</span>
<span class="nc" id="L270">        Seq(xxx, yyy).foreach { vector =&gt;</span>
<span class="nc" id="L271">          vector.child.ensureSize(vector.childCount + lineCount, true)</span>
<span class="nc" id="L272">          vector.offsets(row) = vector.childCount</span>
<span class="nc" id="L273">          vector.lengths(row) = lineCount</span>
        }
<span class="nc" id="L275">        var j = 0</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        while (j &lt; lineCount) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">          val line = if (j == 0) { polygon.getExteriorRing } else { polygon.getInteriorRingN(j - 1) }</span>
<span class="nc" id="L278">          val length = line.getNumPoints</span>
<span class="nc" id="L279">          Seq(xx, yy).foreach { vector =&gt;</span>
<span class="nc" id="L280">            vector.child.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L281">            vector.offsets(xxx.childCount + j) = vector.childCount</span>
<span class="nc" id="L282">            vector.lengths(xxx.childCount + j) = length</span>
          }
<span class="nc" id="L284">          var i = 0</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">          while (i &lt; length) {</span>
<span class="nc" id="L286">            val pt = line.getCoordinateN(i)</span>
<span class="nc" id="L287">            x.vector(xx.childCount + i) = pt.x</span>
<span class="nc" id="L288">            y.vector(yy.childCount + i) = pt.y</span>
<span class="nc" id="L289">            i += 1</span>
          }
<span class="nc" id="L291">          xx.childCount += length</span>
<span class="nc" id="L292">          yy.childCount += length</span>
<span class="nc" id="L293">          j += 1</span>
        }
<span class="nc" id="L295">        xxx.childCount += lineCount</span>
<span class="nc" id="L296">        yyy.childCount += lineCount</span>
      } else {
<span class="nc" id="L298">        xxx.noNulls = false</span>
<span class="nc" id="L299">        yyy.noNulls = false</span>
<span class="nc" id="L300">        xxx.isNull(row) = true</span>
<span class="nc" id="L301">        yyy.isNull(row) = true</span>
      }
    }
  }

  /**
    * Writes a multi-linestring attribute to a vector. A multi-linestring is modeled as a list of lines.
    *
    * @see LineStringWriter
    *
    * @param xxx outer list vector for x coordinates, containing a list vector for individual lines
    * @param yyy outer list vector for y coordinates, containing a list vector for individual lines
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L315">  class MultiLineStringWriter(xxx: ListColumnVector, yyy: ListColumnVector, attribute: Int) extends OrcAttributeWriter {</span>
    // list of points for each line
<span class="nc" id="L317">    private val xx = xxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L318">    private val yy = yyy.child.asInstanceOf[ListColumnVector]</span>
    // points
<span class="nc" id="L320">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L321">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc" id="L324">      val value = sf.getAttribute(attribute).asInstanceOf[MultiLineString]</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L326">        val lineCount = value.getNumGeometries</span>
<span class="nc" id="L327">        Seq(xxx, yyy).foreach { vector =&gt;</span>
<span class="nc" id="L328">          vector.child.ensureSize(vector.childCount + lineCount, true)</span>
<span class="nc" id="L329">          vector.offsets(row) = vector.childCount</span>
<span class="nc" id="L330">          vector.lengths(row) = lineCount</span>
        }
<span class="nc" id="L332">        var j = 0</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        while (j &lt; lineCount) {</span>
<span class="nc" id="L334">          val line = value.getGeometryN(j).asInstanceOf[LineString]</span>
<span class="nc" id="L335">          val length = line.getNumPoints</span>
<span class="nc" id="L336">          Seq(xx, yy).foreach { vector =&gt;</span>
<span class="nc" id="L337">            vector.child.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L338">            vector.offsets(xxx.childCount + j) = vector.childCount</span>
<span class="nc" id="L339">            vector.lengths(xxx.childCount + j) = length</span>
          }
<span class="nc" id="L341">          var i = 0</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">          while (i &lt; length) {</span>
<span class="nc" id="L343">            val pt = line.getCoordinateN(i)</span>
<span class="nc" id="L344">            x.vector(xx.childCount + i) = pt.x</span>
<span class="nc" id="L345">            y.vector(yy.childCount + i) = pt.y</span>
<span class="nc" id="L346">            i += 1</span>
          }
<span class="nc" id="L348">          xx.childCount += length</span>
<span class="nc" id="L349">          yy.childCount += length</span>
<span class="nc" id="L350">          j += 1</span>
        }
<span class="nc" id="L352">        xxx.childCount += lineCount</span>
<span class="nc" id="L353">        yyy.childCount += lineCount</span>
      } else {
<span class="nc" id="L355">        xxx.noNulls = false</span>
<span class="nc" id="L356">        yyy.noNulls = false</span>
<span class="nc" id="L357">        xxx.isNull(row) = true</span>
<span class="nc" id="L358">        yyy.isNull(row) = true</span>
      }
    }
  }

  /**
    * Writes a multi-polygon attribute to a vector. A multi-polygon is modeled as a list of polygons.
    *
    * @see PolygonWriter
    *
    * @param xxxx outer list vector for x coordinates, containing a list vector for individual polygons
    * @param yyyy outer list vector for y coordinates, containing a list vector for individual polygons
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L372">  class MultiPolygonWriter(xxxx: ListColumnVector, yyyy: ListColumnVector, attribute: Int) extends OrcAttributeWriter {</span>
    // list of lines for each polygon
<span class="nc" id="L374">    private val xxx = xxxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L375">    private val yyy = yyyy.child.asInstanceOf[ListColumnVector]</span>
    // list of points for each line
<span class="nc" id="L377">    private val xx = xxx.child.asInstanceOf[ListColumnVector]</span>
<span class="nc" id="L378">    private val yy = yyy.child.asInstanceOf[ListColumnVector]</span>
    // points
<span class="nc" id="L380">    private val x = xx.child.asInstanceOf[DoubleColumnVector]</span>
<span class="nc" id="L381">    private val y = yy.child.asInstanceOf[DoubleColumnVector]</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc" id="L384">      val multiPolygon = sf.getAttribute(attribute).asInstanceOf[MultiPolygon]</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">      if (multiPolygon != null) {</span>
<span class="nc" id="L386">        val polygonCount = multiPolygon.getNumGeometries</span>
<span class="nc" id="L387">        Seq(xxxx, yyyy).foreach { vector =&gt;</span>
<span class="nc" id="L388">          vector.child.ensureSize(vector.childCount + polygonCount, true)</span>
<span class="nc" id="L389">          vector.offsets(row) = vector.childCount</span>
<span class="nc" id="L390">          vector.lengths(row) = polygonCount</span>
        }
<span class="nc" id="L392">        var k = 0</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        while (k &lt; polygonCount) {</span>
<span class="nc" id="L394">          val polygon = multiPolygon.getGeometryN(k).asInstanceOf[Polygon]</span>
<span class="nc" id="L395">          val lineCount = polygon.getNumInteriorRing + 1</span>
<span class="nc" id="L396">          Seq(xxx, yyy).foreach { vector =&gt;</span>
<span class="nc" id="L397">            vector.child.ensureSize(vector.childCount + lineCount, true)</span>
<span class="nc" id="L398">            vector.offsets(xxxx.childCount + k) = vector.childCount</span>
<span class="nc" id="L399">            vector.lengths(xxxx.childCount + k) = lineCount</span>
          }
<span class="nc" id="L401">          var j = 0</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">          while (j &lt; lineCount) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            val line = if (j == 0) { polygon.getExteriorRing } else { polygon.getInteriorRingN(j - 1) }</span>
<span class="nc" id="L404">            val length = line.getNumPoints</span>
<span class="nc" id="L405">            Seq(xx, yy).foreach { vector =&gt;</span>
<span class="nc" id="L406">              vector.child.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L407">              vector.offsets(xxx.childCount + j) = vector.childCount</span>
<span class="nc" id="L408">              vector.lengths(xxx.childCount + j) = length</span>
            }
<span class="nc" id="L410">            var i = 0</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            while (i &lt; length) {</span>
<span class="nc" id="L412">              val pt = line.getCoordinateN(i)</span>
<span class="nc" id="L413">              x.vector(xx.childCount + i) = pt.x</span>
<span class="nc" id="L414">              y.vector(yy.childCount + i) = pt.y</span>
<span class="nc" id="L415">              i += 1</span>
            }
<span class="nc" id="L417">            xx.childCount += length</span>
<span class="nc" id="L418">            yy.childCount += length</span>
<span class="nc" id="L419">            j += 1</span>
          }
<span class="nc" id="L421">          xxx.childCount += lineCount</span>
<span class="nc" id="L422">          yyy.childCount += lineCount</span>
<span class="nc" id="L423">          k += 1</span>
        }
<span class="nc" id="L425">        xxxx.childCount += polygonCount</span>
<span class="nc" id="L426">        yyyy.childCount += polygonCount</span>
      } else {
<span class="nc" id="L428">        xxxx.noNulls = false</span>
<span class="nc" id="L429">        yyyy.noNulls = false</span>
<span class="nc" id="L430">        xxxx.isNull(row) = true</span>
<span class="nc" id="L431">        yyyy.isNull(row) = true</span>
      }
    }
  }

  // writes a geometry attribute to a vector
<span class="nc" id="L437">  class GeometryWkbWriter(val vector: BytesColumnVector, val attribute: Int)</span>
<span class="nc" id="L438">      extends VectorWriterAdapter[Geometry, BytesColumnVector] {</span>
    override def setValue(value: Geometry, row: Int): Unit = {
<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L441">        vector.noNulls = false</span>
<span class="nc" id="L442">        vector.isNull(row) = true</span>
      } else {
<span class="nc" id="L444">        val bytes = WKBUtils.write(value)</span>
<span class="nc" id="L445">        vector.setRef(row, bytes, 0, bytes.length)</span>
      }
    }
  }

  /**
    * Writes a java.util.List attribute to a vector
    *
    * @param vector vector
    * @param attribute simple feature attribute index
    * @param binding list value type
    */
<span class="nc" id="L457">  class ListWriter(vector: ListColumnVector, attribute: Int, binding: ObjectType) extends OrcAttributeWriter {</span>

<span class="nc" id="L459">    private val writer = getInnerWriter(binding, vector.child)</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
<span class="nc" id="L462">      val value = sf.getAttribute(attribute).asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L464">        val length = value.size</span>
<span class="nc" id="L465">        vector.child.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L466">        vector.offsets(row) = vector.childCount</span>
<span class="nc" id="L467">        vector.lengths(row) = length</span>
<span class="nc" id="L468">        var i = 0</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        while (i &lt; length) {</span>
<span class="nc" id="L470">          writer.setValue(value.get(i), vector.childCount + i)</span>
<span class="nc" id="L471">          i += 1</span>
        }
<span class="nc" id="L473">        vector.childCount += length</span>
      } else {
<span class="nc" id="L475">        vector.noNulls = false</span>
<span class="nc" id="L476">        vector.isNull(row) = true</span>
      }
    }
  }

  /**
    * Writes a java.util.Map attribute to a vector
    *
    * @param vector vector
    * @param attribute simple feature attribute index
    * @param keyBinding map key type
    * @param valueBinding map value type
    */
<span class="nc" id="L489">  class MapWriter(vector: MapColumnVector, attribute: Int, keyBinding: ObjectType, valueBinding: ObjectType)</span>
<span class="nc" id="L490">      extends OrcAttributeWriter {</span>

<span class="nc" id="L492">    private val keyWriter = getInnerWriter(keyBinding, vector.keys)</span>
<span class="nc" id="L493">    private val valueWriter = getInnerWriter(valueBinding, vector.values)</span>

    override def apply(sf: SimpleFeature, row: Int): Unit = {
      import scala.collection.JavaConverters._

<span class="nc" id="L498">      val value = sf.getAttribute(attribute).asInstanceOf[java.util.Map[AnyRef, AnyRef]]</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L500">        val length = value.size</span>
<span class="nc" id="L501">        vector.keys.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L502">        vector.values.ensureSize(vector.childCount + length, true)</span>
<span class="nc" id="L503">        vector.offsets(row) = vector.childCount</span>
<span class="nc" id="L504">        vector.lengths(row) = length</span>
<span class="nc" id="L505">        var i = 0</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        value.asScala.foreach { case (k, v) =&gt;</span>
<span class="nc" id="L507">          keyWriter.setValue(k, vector.childCount + i)</span>
<span class="nc" id="L508">          valueWriter.setValue(v.asInstanceOf[AnyRef], vector.childCount + i)</span>
<span class="nc" id="L509">          i += 1</span>
        }
<span class="nc" id="L511">        vector.childCount += length</span>
      } else {
<span class="nc" id="L513">        vector.noNulls = false</span>
<span class="nc" id="L514">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes a typed value to a vector
  trait SetVectorValue[T &lt;: AnyRef, U &lt;: ColumnVector] {
    protected val vector: U
    def setValue(value: T, row: Int): Unit
  }

  // gets a value from a simple feature and writes it to a vector
<span class="nc" id="L526">  trait VectorWriterAdapter[T &lt;: AnyRef, U &lt;: ColumnVector] extends OrcAttributeWriter with SetVectorValue[T, U] {</span>
    def attribute: Int
<span class="nc" id="L528">    override def apply(sf: SimpleFeature, row: Int): Unit = setValue(sf.getAttribute(attribute).asInstanceOf[T], row)</span>
  }

  // writes a string to a vector
<span class="nc" id="L532">  trait SetVectorString extends SetVectorValue[String, BytesColumnVector] {</span>
    override def setValue(value: String, row: Int): Unit = {
<span class="nc bnc" id="L534" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L535">        val bytes = value.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L536">        vector.setRef(row, bytes, 0, bytes.length)</span>
      } else {
<span class="nc" id="L538">        vector.noNulls = false</span>
<span class="nc" id="L539">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes a date to a vector
<span class="nc" id="L545">  trait SetVectorDate extends SetVectorValue[java.util.Date, TimestampColumnVector] {</span>
    override def setValue(value: java.util.Date, row: Int): Unit = {
<span class="nc bnc" id="L547" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L548">        vector.getScratchTimestamp.setTime(value.getTime)</span>
<span class="nc" id="L549">        vector.setFromScratchTimestamp(row)</span>
      } else {
<span class="nc" id="L551">        vector.noNulls = false</span>
<span class="nc" id="L552">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes an int to a vector
<span class="nc" id="L558">  trait SetVectorInt extends SetVectorValue[java.lang.Integer, LongColumnVector] {</span>
    override def setValue(value: java.lang.Integer, row: Int): Unit = {
<span class="nc bnc" id="L560" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L561">        vector.vector(row) = value.longValue</span>
      } else {
<span class="nc" id="L563">        vector.noNulls = false</span>
<span class="nc" id="L564">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes a long to a vector
<span class="nc" id="L570">  trait SetVectorLong extends SetVectorValue[java.lang.Long, LongColumnVector] {</span>
    override def setValue(value: java.lang.Long, row: Int): Unit = {
<span class="nc bnc" id="L572" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L573">        vector.vector(row) = value.longValue</span>
      } else {
<span class="nc" id="L575">        vector.noNulls = false</span>
<span class="nc" id="L576">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes a float to a vector
<span class="nc" id="L582">  trait SetVectorFloat extends SetVectorValue[java.lang.Float, DoubleColumnVector] {</span>
    override def setValue(value: java.lang.Float, row: Int): Unit = {
<span class="nc bnc" id="L584" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L585">        vector.vector(row) = value.doubleValue</span>
      } else {
<span class="nc" id="L587">        vector.noNulls = false</span>
<span class="nc" id="L588">        vector.isNull(row) = true</span>
      }
    }
  }

<span class="nc" id="L593">  trait SetVectorDouble extends SetVectorValue[java.lang.Double, DoubleColumnVector] {</span>
    override def setValue(value: java.lang.Double, row: Int): Unit = {
<span class="nc bnc" id="L595" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L596">        vector.vector(row) = value.doubleValue</span>
      } else {
<span class="nc" id="L598">        vector.noNulls = false</span>
<span class="nc" id="L599">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes a boolean to a vector
<span class="nc" id="L605">  trait SetVectorBoolean extends SetVectorValue[java.lang.Boolean, LongColumnVector] {</span>
    override def setValue(value: java.lang.Boolean, row: Int): Unit = {
<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        vector.vector(row) = if (value) { 1L } else { 0L }</span>
      } else {
<span class="nc" id="L610">        vector.noNulls = false</span>
<span class="nc" id="L611">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes a byte array to a vector
<span class="nc" id="L617">  trait SetVectorBytes extends SetVectorValue[Array[Byte], BytesColumnVector] {</span>
    override def setValue(value: Array[Byte], row: Int): Unit = {
<span class="nc bnc" id="L619" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L620">        vector.setRef(row, value, 0, value.length)</span>
      } else {
<span class="nc" id="L622">        vector.noNulls = false</span>
<span class="nc" id="L623">        vector.isNull(row) = true</span>
      }
    }
  }

  // writes a UUID to a vector
<span class="nc" id="L629">  trait SetVectorUuid extends SetVectorValue[UUID, BytesColumnVector] {</span>
    override def setValue(value: UUID, row: Int): Unit = {
<span class="nc bnc" id="L631" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L632">        val bytes = value.toString.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L633">        vector.setRef(row, bytes, 0, bytes.length)</span>
      } else {
<span class="nc" id="L635">        vector.noNulls = false</span>
<span class="nc" id="L636">        vector.isNull(row) = true</span>
      }
    }
  }

  /**
    * Gets a writer for setting a value directly into a vector
    *
    * @param binding binding
    * @param vec vector
    * @return
    */
  private def getInnerWriter(binding: ObjectType, vec: ColumnVector): SetVectorValue[AnyRef, ColumnVector] = {
<span class="nc" id="L649">    val writer = binding match {</span>
<span class="nc bnc" id="L650" title="All 6 branches missed.">      case ObjectType.DATE     =&gt; new SetVectorDate { override val vector: TimestampColumnVector = vec.asInstanceOf[TimestampColumnVector] }</span>
<span class="nc bnc" id="L651" title="All 6 branches missed.">      case ObjectType.STRING   =&gt; new SetVectorString { override val vector: BytesColumnVector = vec.asInstanceOf[BytesColumnVector] }</span>
<span class="nc bnc" id="L652" title="All 6 branches missed.">      case ObjectType.INT      =&gt; new SetVectorInt { override val vector: LongColumnVector = vec.asInstanceOf[LongColumnVector] }</span>
<span class="nc bnc" id="L653" title="All 6 branches missed.">      case ObjectType.LONG     =&gt; new SetVectorLong { override val vector: LongColumnVector = vec.asInstanceOf[LongColumnVector] }</span>
<span class="nc bnc" id="L654" title="All 6 branches missed.">      case ObjectType.FLOAT    =&gt; new SetVectorFloat { override val vector: DoubleColumnVector = vec.asInstanceOf[DoubleColumnVector] }</span>
<span class="nc bnc" id="L655" title="All 6 branches missed.">      case ObjectType.DOUBLE   =&gt; new SetVectorDouble { override val vector: DoubleColumnVector = vec.asInstanceOf[DoubleColumnVector] }</span>
<span class="nc bnc" id="L656" title="All 6 branches missed.">      case ObjectType.BOOLEAN  =&gt; new SetVectorBoolean { override val vector: LongColumnVector = vec.asInstanceOf[LongColumnVector] }</span>
<span class="nc bnc" id="L657" title="All 6 branches missed.">      case ObjectType.BYTES    =&gt; new SetVectorBytes { override val vector: BytesColumnVector = vec.asInstanceOf[BytesColumnVector] }</span>
<span class="nc bnc" id="L658" title="All 6 branches missed.">      case ObjectType.UUID     =&gt; new SetVectorUuid { override val vector: BytesColumnVector = vec.asInstanceOf[BytesColumnVector] }</span>
<span class="nc" id="L659">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type $binding&quot;)</span>
    }
<span class="nc" id="L661">    writer.asInstanceOf[SetVectorValue[AnyRef, ColumnVector]]</span>
  }
<span class="nc" id="L663">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>