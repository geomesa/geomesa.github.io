<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileSystemThreadedReader.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.common</a> &gt; <span class="el_source">FileSystemThreadedReader.scala</span></div><h1>FileSystemThreadedReader.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.common

import com.typesafe.scalalogging.StrictLogging
import org.apache.hadoop.fs.Path
import org.geotools.api.feature.simple.SimpleFeature
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.fs.storage.api.FileSystemStorage.FileSystemPathReader
import org.locationtech.geomesa.fs.storage.api.StorageMetadata.{StorageFileAction, StorageFilePath}
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.concurrent.PhaserUtils
import org.locationtech.geomesa.utils.io.WithClose

import java.util.concurrent._
import scala.util.control.NonFatal

/**
  * Multi-threaded file reads
  *
  * @param es executor service used by the read tasks
  * @param phaser phaser for tracking read task completion
  * @param queue intermediate queue populated by the read tasks
  */
<span class="nc" id="L31">class FileSystemThreadedReader private (es: ExecutorService, phaser: Phaser, queue: BlockingQueue[SimpleFeature])</span>
<span class="nc" id="L32">    extends CloseableIterator[SimpleFeature] {</span>

<span class="nc" id="L34">  private val localQueue = new java.util.LinkedList[SimpleFeature]()</span>

<span class="nc" id="L36">  private var current: SimpleFeature = _</span>

  override def hasNext: Boolean = {
<span class="nc bnc" id="L39" title="All 2 branches missed.">    if (current != null) {</span>
<span class="nc" id="L40">      return true</span>
    }
<span class="nc" id="L42">    current = localQueue.pollFirst</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    if (current != null) {</span>
<span class="nc" id="L44">      return true</span>
    }

<span class="nc bnc" id="L47" title="All 2 branches missed.">    while (!phaser.isTerminated) {</span>
<span class="nc" id="L48">      current = queue.poll(100, TimeUnit.MILLISECONDS)</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">      if (current != null) {</span>
<span class="nc" id="L50">        queue.drainTo(localQueue, 10000)</span>
<span class="nc" id="L51">        return true</span>
      }
    }
    // last check - if phaser.isTerminated, the queue should have whatever values are left
<span class="nc" id="L55">    current = queue.poll()</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">    if (current != null) {</span>
<span class="nc" id="L57">      queue.drainTo(localQueue, 10000)</span>
<span class="nc" id="L58">      true</span>
    } else {
<span class="nc" id="L60">      false</span>
    }
  }

  override def next(): SimpleFeature = {
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (hasNext) {</span>
<span class="nc" id="L66">      val ret = current</span>
<span class="nc" id="L67">      current = null</span>
<span class="nc" id="L68">      ret</span>
    } else {
<span class="nc" id="L70">      Iterator.empty.next</span>
    }
  }

  override def close(): Unit = {
<span class="nc" id="L75">    try { es.shutdownNow() } finally {</span>
<span class="nc" id="L76">      phaser.forceTermination() // unregister any tasks that didn't start</span>
    }
  }
}

<span class="nc" id="L81">object FileSystemThreadedReader extends StrictLogging {</span>

  def apply(
      readers: Iterator[(FileSystemPathReader, Seq[StorageFilePath])],
      threads: Int): CloseableIterator[SimpleFeature] = {

<span class="nc bnc" id="L87" title="All 2 branches missed.">    if (threads &lt; 2) {</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">      CloseableIterator(readers).flatMap { case (reader, files) =&gt;</span>
<span class="nc" id="L89">        val mods = scala.collection.mutable.HashSet.empty[String]</span>
        // ensure files are sorted in reverse chronological order
<span class="nc" id="L91">        CloseableIterator(files.sorted.iterator).flatMap(f =&gt; read(reader, f, mods))</span>
      }
    } else {
<span class="nc" id="L94">      val queue = new LinkedBlockingQueue[SimpleFeature](2000000)</span>
<span class="nc" id="L95">      val es = Executors.newFixedThreadPool(threads)</span>

<span class="nc" id="L97">      val phaser = new Phaser(1) {</span>
        override protected def onAdvance(phase: Int, registeredParties: Int): Boolean = {
          // when all tasks have been completed, shutdown the executor service
<span class="nc" id="L100">          es.shutdown()</span>
<span class="nc" id="L101">          true // return true to indicate the phaser should terminate</span>
        }
      }

<span class="nc" id="L105">      try {</span>
<span class="nc" id="L106">        var child = new Phaser(phaser) // ensure that we don't register too many parties on this phaser</span>
<span class="nc" id="L107">        var parties = 0 // track registered parties</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        readers.foreach { case (reader, files) =&gt;</span>
          // group our files by actions which can be parallelized
<span class="nc" id="L110">          val groups = scala.collection.mutable.ListBuffer.empty[Seq[StorageFilePath]]</span>
<span class="nc" id="L111">          var group = scala.collection.mutable.ArrayBuffer.empty[StorageFilePath]</span>
          // ensure files are sorted in reverse chronological order
<span class="nc" id="L113">          files.sorted.foreach { file =&gt;</span>
<span class="nc bnc" id="L114" title="All 6 branches missed.">            if (file.file.action == StorageFileAction.Append) {</span>
<span class="nc" id="L115">              group += file</span>
            } else {
<span class="nc bnc" id="L117" title="All 2 branches missed.">              if (group.nonEmpty) {</span>
<span class="nc" id="L118">                groups += group.toSeq</span>
<span class="nc" id="L119">                group = scala.collection.mutable.ArrayBuffer.empty[StorageFilePath]</span>
              }
<span class="nc" id="L121">              groups += Seq(file)</span>
            }
          }
<span class="nc bnc" id="L124" title="All 2 branches missed.">          if (group.nonEmpty) {</span>
<span class="nc" id="L125">            groups += group.toSeq // add the last group</span>
          }

          // each chained reader task will register at most groups.length parties
<span class="nc" id="L129">          parties += groups.length</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">          if (parties &gt; PhaserUtils.MaxParties) {</span>
<span class="nc" id="L131">            parties = groups.length</span>
<span class="nc" id="L132">            child = new Phaser(phaser)</span>
          }
<span class="nc" id="L134">          child.register() // register new task</span>
<span class="nc" id="L135">          es.submit(new ChainedReaderTask(es, child, reader, groups.head, groups.tail.toSeq, queue))</span>
        }
      } catch {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        case NonFatal(e) =&gt; es.shutdownNow(); throw e</span>
      } finally {
<span class="nc" id="L140">        phaser.arriveAndDeregister()</span>
      }

<span class="nc" id="L143">      new FileSystemThreadedReader(es, phaser, queue)</span>
    }
  }

  /**
    * Reads a file
    *
    * @param reader reader
    * @param file file to read
    * @param mods collection to track modifications
    * @return
    */
  private def read(
      reader: FileSystemPathReader,
      file: StorageFilePath,
      mods: scala.collection.mutable.Set[String]): CloseableIterator[SimpleFeature] = {
<span class="nc" id="L159">    file.file.action match {</span>
<span class="nc bnc" id="L160" title="All 6 branches missed.">      case StorageFileAction.Append =&gt; new AppendingReaderIterator(reader, file.path, mods)</span>
<span class="nc bnc" id="L161" title="All 6 branches missed.">      case StorageFileAction.Modify =&gt; new ModifyingReaderIterator(reader, file.path, mods)</span>
<span class="nc bnc" id="L162" title="All 6 branches missed.">      case StorageFileAction.Delete =&gt; new DeletingReaderIterator(reader, file.path, mods)</span>
<span class="nc" id="L163">      case _ =&gt; throw new UnsupportedOperationException(s&quot;Unexpected storage action: ${file.file.action}&quot;)</span>
    }
  }

  /**
    * Performs a set of chained (dependent) reads. The groups must be handled serially, but the files within a
    * given group can be read in parallel.
    *
    * @param es executor service for submitting new read tasks
    * @param phaser phaser to track run lifecycle
    * @param reader reader
    * @param group current group of files that can be read in parallel
    * @param chain remaining groups of files that must be read sequentially
    * @param queue result queue
    * @param mods modifications/deletes for this group of files
    */
<span class="nc" id="L179">  private class ChainedReaderTask(</span>
<span class="nc" id="L180">      es: ExecutorService,</span>
<span class="nc" id="L181">      phaser: Phaser,</span>
<span class="nc" id="L182">      reader: FileSystemPathReader,</span>
<span class="nc" id="L183">      group: Seq[StorageFilePath],</span>
<span class="nc" id="L184">      chain: Seq[Seq[StorageFilePath]],</span>
<span class="nc" id="L185">      queue: BlockingQueue[SimpleFeature],</span>
<span class="nc" id="L186">      mods: scala.collection.mutable.Set[String] = scala.collection.mutable.HashSet.empty[String]</span>
<span class="nc" id="L187">    ) extends Runnable {</span>

    override def run(): Unit = {
<span class="nc bnc" id="L190" title="All 2 branches missed.">      val child = new Phaser(1) {</span>
        override protected def onAdvance(phase: Int, registeredParties: Int): Boolean = {
          // when this group is done, submit the next group for processing
          try {
<span class="nc bnc" id="L194" title="All 2 branches missed.">            if (chain.nonEmpty) {</span>
<span class="nc" id="L195">              phaser.register() // register new task</span>
<span class="nc" id="L196">              es.submit(new ChainedReaderTask(es, phaser, reader, chain.head, chain.tail, queue, mods))</span>
            }
<span class="nc" id="L198">            true // return true to indicate the phaser should terminate</span>
          } finally {
<span class="nc" id="L200">            phaser.arriveAndDeregister()</span>
          }
        }
      }
      try {
<span class="nc" id="L205">        group.foreach { file =&gt;</span>
<span class="nc" id="L206">          child.register() // register new task</span>
<span class="nc" id="L207">          es.submit(new ReaderTask(child, queue, file.path, read(reader, file, mods)))</span>
        }
      } finally {
<span class="nc" id="L210">        child.arriveAndDeregister()</span>
      }
    }
  }

  /**
    * Task to run a reader and add the results to a result queue
    *
    * @param phaser phaser for tracking completion of this task
    * @param queue result queue
    * @param path file path (for logging)
    * @param iter lazily evaluated iterator for reading the path
    */
<span class="nc" id="L223">  private class ReaderTask(</span>
<span class="nc" id="L224">      phaser: Phaser,</span>
<span class="nc" id="L225">      queue: BlockingQueue[SimpleFeature],</span>
<span class="nc" id="L226">      path: Path,</span>
<span class="nc" id="L227">      iter: =&gt; CloseableIterator[SimpleFeature]</span>
<span class="nc" id="L228">    ) extends Runnable {</span>

    override def run(): Unit = {
<span class="nc" id="L231">      try {</span>
<span class="nc" id="L232">        WithClose(iter)(_.foreach(queue.put))</span>
      } catch {
<span class="nc bnc" id="L234" title="All 4 branches missed.">        case NonFatal(e) =&gt; logger.error(s&quot;Error reading file $path&quot;, e)</span>
      } finally {
<span class="nc" id="L236">        phaser.arriveAndDeregister()</span>
      }
    }
  }

  /**
    * Reads a file, skipping features marked as modified
    *
    * @param reader reader
    * @param path file path
    * @param mods set of modified feature IDs that shouldn't be returned
    */
<span class="nc" id="L248">  private class AppendingReaderIterator(</span>
      reader: FileSystemPathReader,
<span class="nc" id="L250">      path: Path,</span>
<span class="nc" id="L251">      mods: scala.collection.Set[String]</span>
<span class="nc" id="L252">    ) extends CloseableIterator[SimpleFeature] {</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">    logger.debug(s&quot;Reading file $path&quot;)</span>

<span class="nc" id="L256">    private var count = 0</span>

<span class="nc" id="L258">    private val delegate = {</span>
<span class="nc" id="L259">      val iter = CloseableIterator.wrap(reader.read(path))</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      if (mods.isEmpty) {</span>
<span class="nc" id="L261">        iter</span>
      } else {
<span class="nc bnc" id="L263" title="All 2 branches missed.">        iter.filter { f =&gt; if (mods.contains(f.getID)) { count += 1; false } else { true } }</span>
      }
    }

<span class="nc" id="L267">    override def hasNext: Boolean = delegate.hasNext</span>

    override def next(): SimpleFeature = {
<span class="nc" id="L270">      count += 1</span>
      // need to copy the feature as it can be re-used
<span class="nc" id="L272">      ScalaSimpleFeature.copy(delegate.next())</span>
    }

    override def close(): Unit = {
<span class="nc bnc" id="L276" title="All 2 branches missed.">      logger.debug(s&quot;File $path produced $count records&quot;)</span>
<span class="nc" id="L277">      delegate.close()</span>
    }
  }


  /**
    * Reads a file, skipping features marked as modified
    *
    * @param reader reader
    * @param path file path
    * @param mods set of modified feature IDs that shouldn't be returned
    */
<span class="nc" id="L289">  private class ModifyingReaderIterator(</span>
      reader: FileSystemPathReader,
<span class="nc" id="L291">      path: Path,</span>
<span class="nc" id="L292">      mods: scala.collection.mutable.Set[String]</span>
<span class="nc" id="L293">    ) extends CloseableIterator[SimpleFeature] {</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">    logger.debug(s&quot;Reading modifying file $path&quot;)</span>

<span class="nc" id="L297">    private var count = 0</span>

<span class="nc" id="L299">    private val delegate = CloseableIterator.wrap(reader.read(path)).filter { f =&gt; count += 1; mods.add(f.getID) }</span>

<span class="nc" id="L301">    override def hasNext: Boolean = delegate.hasNext</span>

    override def next(): SimpleFeature = {
      // need to copy the feature as it can be re-used
<span class="nc" id="L305">      ScalaSimpleFeature.copy(delegate.next())</span>
    }

    override def close(): Unit = {
<span class="nc bnc" id="L309" title="All 2 branches missed.">      logger.debug(s&quot;File $path produced $count modified records&quot;)</span>
<span class="nc" id="L310">      delegate.close()</span>
    }
  }

  /**
    * Reads a file, tracking deletes
    *
    * @param reader reader
    * @param path file path
    * @param mods deleted feature ids will be added here
    */
<span class="nc" id="L321">  private class DeletingReaderIterator(</span>
      reader: FileSystemPathReader,
      path: Path,
<span class="nc" id="L324">      mods: scala.collection.mutable.Set[String]</span>
<span class="nc" id="L325">    ) extends CloseableIterator[SimpleFeature] {</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">    logger.debug(s&quot;Reading deleting file $path&quot;)</span>

<span class="nc" id="L329">    try {</span>
<span class="nc" id="L330">      var count = 0</span>
<span class="nc" id="L331">      WithClose(reader.read(path)) { features =&gt;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        while (features.hasNext) {</span>
<span class="nc" id="L333">          mods.add(features.next().getID)</span>
<span class="nc" id="L334">          count += 1</span>
        }
      }
<span class="nc bnc" id="L337" title="All 2 branches missed.">      logger.debug(s&quot;File $path produced $count deleted records&quot;)</span>
    } catch {
<span class="nc bnc" id="L339" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.error(s&quot;Error reading deleting file $path&quot;, e)</span>
    }

<span class="nc" id="L342">    override def hasNext: Boolean = false</span>

<span class="nc" id="L344">    override def next(): SimpleFeature = Iterator.empty.next()</span>

<span class="nc" id="L346">    override def close(): Unit = {}</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>