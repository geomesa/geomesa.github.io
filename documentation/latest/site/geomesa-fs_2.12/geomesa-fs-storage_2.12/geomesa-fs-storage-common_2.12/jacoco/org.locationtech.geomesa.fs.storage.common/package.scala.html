<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>package.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.common</a> &gt; <span class="el_source">package.scala</span></div><h1>package.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage

import com.typesafe.config._
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.fs.storage.api.NamedOptions
import org.locationtech.geomesa.fs.storage.common.metadata.MetadataSerialization.Persistence.PartitionSchemeConfig
import org.locationtech.geomesa.utils.conf.GeoMesaSystemProperties.SystemProperty
import org.locationtech.geomesa.utils.text.Suffixes.Memory
import pureconfig.generic.semiauto.deriveConvert
import pureconfig.{ConfigConvert, ConfigSource}

import scala.util.control.NonFatal
import scala.util.{Failure, Success, Try}

<span class="nc" id="L23">package object common {</span>

<span class="nc" id="L25">  val RenderOptions: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true)</span>
<span class="nc" id="L26">  val ParseOptions: ConfigParseOptions = ConfigParseOptions.defaults()</span>
<span class="nc" id="L27">  val FileValidationEnabled: SystemProperty = SystemProperty(&quot;geomesa.fs.validate.file&quot;, &quot;false&quot;)</span>

<span class="nc bnc" id="L29" title="All 72 branches missed.">  implicit val NamedOptionsConvert: ConfigConvert[NamedOptions] = deriveConvert[NamedOptions]</span>

<span class="nc" id="L31">  object StorageSerialization {</span>

    /**
      * Serialize configuration options as a typesafe config string
      *
      * @param options options
      * @return
      */
<span class="nc" id="L39">    def serialize(options: NamedOptions): String = NamedOptionsConvert.to(options).render(RenderOptions)</span>

    /**
      * Deserialize configuration options, e.g. for partition schemes and metadata connections
      *
      * @param options options as a typesafe config string
      * @return
      */
    def deserialize(options: String): NamedOptions = {
<span class="nc" id="L48">      val config = ConfigFactory.parseString(options, ParseOptions)</span>
<span class="nc" id="L49">      try { ConfigSource.fromConfig(config).loadOrThrow[NamedOptions] } catch {</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">        case NonFatal(e) =&gt; Try(deserializeOldScheme(config)).getOrElse(throw e)</span>
      }
    }

    private def deserializeOldScheme(config: Config): NamedOptions = {
<span class="nc" id="L55">      val parsed = ConfigSource.fromConfig(config).loadOrThrow[PartitionSchemeConfig]</span>
<span class="nc" id="L56">      NamedOptions(parsed.scheme, parsed.options)</span>
    }
  }

<span class="nc" id="L60">  object StorageKeys {</span>
<span class="nc" id="L61">    val EncodingKey    = &quot;geomesa.fs.encoding&quot;</span>
<span class="nc" id="L62">    val LeafStorageKey = &quot;geomesa.fs.leaf-storage&quot;</span>
<span class="nc" id="L63">    val MetadataKey    = &quot;geomesa.fs.metadata&quot;</span>
<span class="nc" id="L64">    val SchemeKey      = &quot;geomesa.fs.scheme&quot;</span>
<span class="nc" id="L65">    val FileSizeKey    = &quot;geomesa.fs.file-size&quot;</span>
<span class="nc" id="L66">    val ObserversKey   = &quot;geomesa.fs.observers&quot;</span>
  }

  /**
    * Implicit methods to set/retrieve storage configuration options in SimpleFeatureType user data
    *
    * @param sft simple feature type
    */
<span class="nc bnc" id="L74" title="All 12 branches missed.">  implicit class RichSimpleFeatureType(val sft: SimpleFeatureType) extends AnyVal {</span>

    import StorageKeys._
    import StorageSerialization.{deserialize, serialize}

<span class="nc" id="L79">    def setEncoding(encoding: String): Unit = sft.getUserData.put(EncodingKey, encoding)</span>
<span class="nc" id="L80">    def removeEncoding(): Option[String] = remove(EncodingKey)</span>

<span class="nc" id="L82">    def setLeafStorage(leafStorage: Boolean): Unit = sft.getUserData.put(LeafStorageKey, leafStorage.toString)</span>
<span class="nc" id="L83">    def removeLeafStorage(): Option[Boolean] = remove(LeafStorageKey).map(_.toBoolean)</span>

<span class="nc" id="L85">    def setScheme(name: String, options: Map[String, String] = Map.empty): Unit =</span>
<span class="nc" id="L86">      sft.getUserData.put(SchemeKey, serialize(NamedOptions(name, options)))</span>
    // noinspection ScalaDeprecation
    def removeScheme(): Option[NamedOptions] =
<span class="nc" id="L89">      remove(SchemeKey).map(deserialize).orElse(remove(&quot;geomesa.fs.partition-scheme.config&quot;).map(deserialize))</span>

<span class="nc" id="L91">    def setMetadata(name: String, options: Map[String, String] = Map.empty): Unit =</span>
<span class="nc" id="L92">      sft.getUserData.put(MetadataKey, serialize(NamedOptions(name, options)))</span>
<span class="nc" id="L93">    def removeMetadata(): Option[NamedOptions] = remove(MetadataKey).map(deserialize)</span>

<span class="nc" id="L95">    def setTargetFileSize(size: String): Unit = {</span>
      // validate input
<span class="nc" id="L97">      Memory.bytes(size).failed.foreach(e =&gt; throw new IllegalArgumentException(&quot;Invalid file size&quot;, e))</span>
<span class="nc" id="L98">      sft.getUserData.put(FileSizeKey, size)</span>
    }
    def removeTargetFileSize(): Option[Long] = {
<span class="nc" id="L101">      remove(FileSizeKey).map { s =&gt;</span>
<span class="nc" id="L102">        Memory.bytes(s) match {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">          case Success(b) =&gt; b</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">          case Failure(e) =&gt; throw new IllegalArgumentException(&quot;Invalid file size&quot;, e)</span>
        }
      }
    }

<span class="nc" id="L109">    def setObservers(names: Seq[String]): Unit = sft.getUserData.put(ObserversKey, names.mkString(&quot;,&quot;))</span>
<span class="nc" id="L110">    def getObservers: Seq[String] = {</span>
<span class="nc" id="L111">      val obs = sft.getUserData.get(ObserversKey).asInstanceOf[String]</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">      if (obs == null || obs.isEmpty) { Seq.empty } else { obs.split(&quot;,&quot;) }</span>
    }

<span class="nc" id="L115">    private def remove(key: String): Option[String] = Option(sft.getUserData.remove(key).asInstanceOf[String])</span>
  }
<span class="nc" id="L117">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>