<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StorageConfiguration.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.common.jobs</a> &gt; <span class="el_source">StorageConfiguration.scala</span></div><h1>StorageConfiguration.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.common.jobs

import com.esotericsoftware.kryo.io.{Input, Output}
import com.esotericsoftware.kryo.{Kryo, KryoSerializable}
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.fs.Path
import org.apache.hadoop.io.Writable
import org.apache.hadoop.mapreduce.Job
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.Filter
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.fs.storage.api.StorageMetadata.StorageFileAction.StorageFileAction
import org.locationtech.geomesa.fs.storage.api.StorageMetadata.{StorageFileAction, StorageFilePath}
import org.locationtech.geomesa.fs.storage.common.utils.StorageUtils.FileType
import org.locationtech.geomesa.fs.storage.common.utils.StorageUtils.FileType.FileType
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes

import java.io.{DataInput, DataOutput}

<span class="nc" id="L29">object StorageConfiguration {</span>

<span class="nc" id="L31">  object Counters {</span>

<span class="nc" id="L33">    val Group    = &quot;org.locationtech.geomesa.jobs.fs&quot;</span>

<span class="nc" id="L35">    val Features = &quot;features&quot;</span>
<span class="nc" id="L36">    val Written  = &quot;written&quot;</span>
<span class="nc" id="L37">    val Failed   = &quot;failed&quot;</span>

<span class="nc" id="L39">    val PartitionPrefix = &quot;p-&quot;</span>

<span class="nc" id="L41">    def partition(name: String): String = PartitionPrefix + name</span>
  }

<span class="nc" id="L44">  val PathKey                = &quot;geomesa.fs.path&quot;</span>
<span class="nc" id="L45">  val PartitionsKey          = &quot;geomesa.fs.partitions&quot;</span>
<span class="nc" id="L46">  val FileTypeKey            = &quot;geomesa.fs.output.file-type&quot;</span>
<span class="nc" id="L47">  val FileSizeKey            = &quot;geomesa.fs.output.file-size&quot;</span>
<span class="nc" id="L48">  val SftNameKey             = &quot;geomesa.fs.sft.name&quot;</span>
<span class="nc" id="L49">  val SftSpecKey             = &quot;geomesa.fs.sft.spec&quot;</span>
<span class="nc" id="L50">  val FilterKey              = &quot;geomesa.fs.filter&quot;</span>
<span class="nc" id="L51">  val TransformSpecKey       = &quot;geomesa.fs.transform.spec&quot;</span>
<span class="nc" id="L52">  val TransformDefinitionKey = &quot;geomesa.fs.transform.defs&quot;</span>
<span class="nc" id="L53">  val PathActionKey          = &quot;geomesa.fs.path.action&quot;</span>

  def setSft(conf: Configuration, sft: SimpleFeatureType): Unit = {
<span class="nc" id="L56">    val name = Option(sft.getName.getNamespaceURI).map(ns =&gt; s&quot;$ns:${sft.getTypeName}&quot;).getOrElse(sft.getTypeName)</span>
<span class="nc" id="L57">    conf.set(SftNameKey, name)</span>
<span class="nc" id="L58">    conf.set(SftSpecKey, SimpleFeatureTypes.encodeType(sft, includeUserData = true))</span>
  }
  def getSft(conf: Configuration): SimpleFeatureType =
<span class="nc" id="L61">    SimpleFeatureTypes.createType(conf.get(SftNameKey), conf.get(SftSpecKey))</span>

<span class="nc" id="L63">  def getSftName(conf: Configuration): String = conf.get(SftNameKey)</span>
<span class="nc" id="L64">  def getSftSpec(conf: Configuration): String = conf.get(SftSpecKey)</span>

<span class="nc" id="L66">  def setRootPath(conf: Configuration, path: Path): Unit = conf.set(PathKey, path.toString)</span>
<span class="nc" id="L67">  def getRootPath(conf: Configuration): Path = new Path(conf.get(PathKey))</span>

  def setPartitions(conf: Configuration, partitions: Array[String]): Unit =
<span class="nc" id="L70">    conf.setStrings(PartitionsKey, partitions: _*)</span>
<span class="nc" id="L71">  def getPartitions(conf: Configuration): Array[String] = conf.getStrings(PartitionsKey)</span>

<span class="nc" id="L73">  def setFileType(conf: Configuration, fileType: FileType): Unit = conf.set(FileTypeKey, fileType.toString)</span>
<span class="nc" id="L74">  def getFileType(conf: Configuration): FileType = FileType.withName(conf.get(FileTypeKey))</span>

<span class="nc" id="L76">  def setTargetFileSize(conf: Configuration, fileSize: Long): Unit = conf.set(FileSizeKey, fileSize.toString)</span>
<span class="nc" id="L77">  def getTargetFileSize(conf: Configuration): Option[Long] = Option(conf.get(FileSizeKey)).map(_.toLong)</span>

<span class="nc" id="L79">  def setFilter(conf: Configuration, filter: Filter): Unit = conf.set(FilterKey, ECQL.toCQL(filter))</span>
  def getFilter(conf: Configuration, sft: SimpleFeatureType): Option[Filter] =
<span class="nc" id="L81">    Option(conf.get(FilterKey)).map(FastFilterFactory.toFilter(sft, _))</span>

  def setTransforms(conf: Configuration, transforms: (String, SimpleFeatureType)): Unit = {
<span class="nc bnc" id="L84" title="All 2 branches missed.">    val (tdefs, tsft) = transforms</span>
<span class="nc" id="L85">    conf.set(TransformDefinitionKey, tdefs)</span>
<span class="nc" id="L86">    conf.set(TransformSpecKey, SimpleFeatureTypes.encodeType(tsft, includeUserData = true))</span>
  }
  def getTransforms(conf: Configuration): Option[(String, SimpleFeatureType)] = {
<span class="nc" id="L89">    for { defs &lt;- Option(conf.get(TransformDefinitionKey)); spec &lt;- Option(conf.get(TransformSpecKey)) } yield {</span>
<span class="nc" id="L90">      (defs, SimpleFeatureTypes.createType(&quot;&quot;, spec))</span>
    }
  }

  def setPathActions(conf: Configuration, paths: Seq[StorageFilePath]): Unit = {
<span class="nc bnc" id="L95" title="All 2 branches missed.">    paths.foreach { case StorageFilePath(f, path) =&gt;</span>
<span class="nc" id="L96">      conf.set(s&quot;$PathActionKey.${path.getName}&quot;, s&quot;${f.timestamp}:${f.action}&quot;)</span>
    }
  }
  def getPathAction(conf: Configuration, path: Path): (Long, StorageFileAction) = {
<span class="nc bnc" id="L100" title="All 6 branches missed.">    val Array(ts, action) = conf.get(s&quot;$PathActionKey.${path.getName}&quot;).split(&quot;:&quot;)</span>
<span class="nc" id="L101">    (ts.toLong, StorageFileAction.withName(action))</span>
  }

  /**
    * Key used for merging feature updates.
    *
    * Implements hadoop writable for m/r, kryo serializable for spark, and comparable to sort in
    * reverse chronological order
    */
<span class="nc" id="L110">  class SimpleFeatureAction extends Writable with KryoSerializable with Comparable[SimpleFeatureAction] {</span>

<span class="nc" id="L112">    private var _id: String = _</span>
<span class="nc" id="L113">    private var _timestamp: Long = _</span>
<span class="nc" id="L114">    private var _action: StorageFileAction = _</span>

<span class="nc" id="L116">    def this(id: String, timestamp: Long, action: StorageFileAction) = {</span>
<span class="nc" id="L117">      this()</span>
<span class="nc" id="L118">      this._id = id</span>
<span class="nc" id="L119">      this._timestamp = timestamp</span>
<span class="nc" id="L120">      this._action = action</span>
    }

<span class="nc" id="L123">    def id: String = _id</span>
<span class="nc" id="L124">    def timestamp: Long = _timestamp</span>
<span class="nc" id="L125">    def action: StorageFileAction = _action</span>

    override def compareTo(o: SimpleFeatureAction): Int = {
<span class="nc" id="L128">      var res = _id.compareTo(o.id)</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      if (res == 0) {</span>
<span class="nc" id="L130">        res = _timestamp.compareTo(o.timestamp) * -1 // note: reverse chronological sort</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (res == 0) {</span>
<span class="nc" id="L132">          res = _action.compareTo(o.action)</span>
        }
      }
<span class="nc" id="L135">      res</span>
    }

    override def write(out: DataOutput): Unit = {
<span class="nc" id="L139">      out.writeUTF(_id)</span>
<span class="nc" id="L140">      out.writeLong(_timestamp)</span>
<span class="nc" id="L141">      out.writeUTF(_action.toString)</span>
    }

    override def readFields(in: DataInput): Unit = {
<span class="nc" id="L145">      _id = in.readUTF()</span>
<span class="nc" id="L146">      _timestamp = in.readLong()</span>
<span class="nc" id="L147">      _action = StorageFileAction.withName(in.readUTF())</span>
    }

    override def write(kryo: Kryo, output: Output): Unit = {
<span class="nc" id="L151">      output.writeString(_id)</span>
<span class="nc" id="L152">      output.writeLong(_timestamp)</span>
<span class="nc" id="L153">      output.writeString(_action.toString)</span>
    }

    override def read(kryo: Kryo, input: Input): Unit = {
<span class="nc" id="L157">      _id = input.readString()</span>
<span class="nc" id="L158">      _timestamp = input.readLong()</span>
<span class="nc" id="L159">      _action = StorageFileAction.withName(input.readString())</span>
    }
  }
}

<span class="nc" id="L164">trait StorageConfiguration {</span>
  def configureOutput(sft: SimpleFeatureType, job: Job): Unit
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>