<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>package.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.common.metadata</a> &gt; <span class="el_source">package.scala</span></div><h1>package.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.common

import com.typesafe.config.{Config, ConfigRenderOptions, ConfigValue, ConfigValueFactory}
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.fs.storage.api.StorageMetadata.{PartitionBounds, PartitionMetadata, StorageFile, StorageFileAction}
import org.locationtech.geomesa.fs.storage.common.metadata.PartitionAction.PartitionAction
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.jts.geom.Envelope
import pureconfig.ConfigReader.Result
import pureconfig._
import pureconfig.error.{CannotConvert, ConfigReaderFailures}

import java.util.Collections
import scala.reflect.ClassTag

<span class="nc" id="L24">package object metadata {</span>

  import scala.collection.JavaConverters._

  /**
    * Creates a new simple feature type with the namespace in the simple feature type name
    *
    * @param sft simple feature type
    * @param namespace optional namespace
    * @return
    */
  def namespaced(sft: SimpleFeatureType, namespace: Option[String]): SimpleFeatureType =
<span class="nc" id="L36">    namespace.map(ns =&gt; SimpleFeatureTypes.renameSft(sft, s&quot;$ns:${sft.getTypeName}&quot;)).getOrElse(sft)</span>

  /**
    * Merge configs for a single partition into a single aggregate config
    *
    * @param configs updates for a given partition
    * @return
    */
  def mergePartitionConfigs(configs: Seq[PartitionConfig]): Option[PartitionConfig] = {
<span class="nc bnc" id="L45" title="All 6 branches missed.">    configs.sortBy(_.timestamp).dropWhile(_.action != PartitionAction.Add).reduceLeftOption { (result, update) =&gt;</span>
<span class="nc" id="L46">      update.action match {</span>
<span class="nc bnc" id="L47" title="All 6 branches missed.">        case PartitionAction.Add    =&gt; result + update</span>
<span class="nc bnc" id="L48" title="All 6 branches missed.">        case PartitionAction.Remove =&gt; result - update</span>
      }
    }
  }

  // case classes for serializing to disk

<span class="nc bnc" id="L55" title="All 18 branches missed.">  case class CompactedConfig(partitions: Seq[PartitionConfig])</span>

<span class="nc bnc" id="L57" title="All 45 branches missed.">  case class PartitionConfig(</span>
<span class="nc" id="L58">      name: String,</span>
<span class="nc" id="L59">      action: PartitionAction,</span>
<span class="nc" id="L60">      files: Seq[StorageFile],</span>
<span class="nc" id="L61">      count: Long,</span>
<span class="nc" id="L62">      envelope: Seq[Double],</span>
<span class="nc" id="L63">      timestamp: Long) {</span>

    def +(other: PartitionConfig): PartitionConfig = {
<span class="nc bnc" id="L66" title="All 6 branches missed.">      require(action == PartitionAction.Add, &quot;Can't aggregate into non-add actions&quot;)</span>
<span class="nc" id="L67">      val ts = math.max(timestamp, other.timestamp)</span>
<span class="nc bnc" id="L68" title="All 4 branches missed.">      val env = if (envelope.isEmpty) { other.envelope } else if (other.envelope.isEmpty) { envelope } else {</span>
<span class="nc bnc" id="L69" title="All 6 branches missed.">        val Seq(xmin1, ymin1, xmax1, ymax1) = envelope</span>
<span class="nc bnc" id="L70" title="All 6 branches missed.">        val Seq(xmin2, ymin2, xmax2, ymax2) = other.envelope</span>
<span class="nc" id="L71">        Seq(math.min(xmin1, xmin2), math.min(ymin1, ymin2), math.max(xmax1, xmax2), math.max(ymax1, ymax2))</span>
      }
<span class="nc" id="L73">      PartitionConfig(name, action, files ++ other.files, count + other.count, env, ts)</span>
    }

    def -(other: PartitionConfig): PartitionConfig = {
<span class="nc bnc" id="L77" title="All 6 branches missed.">      require(action == PartitionAction.Add, &quot;Can't aggregate into non-add actions&quot;)</span>
<span class="nc" id="L78">      val ts = math.max(timestamp, other.timestamp)</span>
<span class="nc" id="L79">      val names = scala.collection.mutable.Map.empty[String, Int].withDefault(_ =&gt; 0)</span>
<span class="nc" id="L80">      other.files.foreach(f =&gt; names(f.name) += 1)</span>
      // keep oldest files if there are duplicates
<span class="nc" id="L82">      val fs = files.sortBy(_.timestamp)(Ordering.Long.reverse).filter { f =&gt;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        names(f.name) match {</span>
<span class="nc" id="L84">          case 0 =&gt; true</span>
<span class="nc" id="L85">          case i =&gt; names.put(f.name, i - 1); false</span>
        }
      }
<span class="nc" id="L88">      PartitionConfig(name, action, fs, math.max(0, count - other.count), envelope, ts)</span>
    }

    def toMetadata: PartitionMetadata = {
<span class="nc" id="L92">      val bounds = envelope match {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        case Nil =&gt; None</span>
<span class="nc bnc" id="L94" title="All 6 branches missed.">        case Seq(xmin, ymin, xmax, ymax) =&gt; Some(PartitionBounds(xmin, ymin, xmax, ymax))</span>
<span class="nc" id="L95">        case _ =&gt; throw new IllegalStateException(s&quot;Invalid envelope: $envelope&quot;)</span>
      }
<span class="nc" id="L97">      PartitionMetadata(name, files, bounds, count)</span>
    }
  }

<span class="nc" id="L101">  object PartitionAction extends Enumeration {</span>
    type PartitionAction = Value
<span class="nc" id="L103">    val Add, Remove, Clear = Value</span>
  }

<span class="nc" id="L106">  object EnvelopeConfig {</span>
    def apply(env: Envelope): Seq[Double] =
<span class="nc bnc" id="L108" title="All 4 branches missed.">      if (env == null || env.isNull) { Seq.empty } else { Seq(env.getMinX, env.getMinY, env.getMaxX, env.getMaxY) }</span>
  }

  // pureconfig converters for our case classes

  // noinspection ForwardReference
<span class="nc" id="L114">  sealed trait MetadataConverter {</span>

    def name: String
    def suffix: String

    protected def partitionWriter: ConfigWriter[PartitionConfig]
    protected def compactedWriter: ConfigWriter[CompactedConfig]
    protected def options: ConfigRenderOptions

<span class="nc" id="L123">    private val partitionCt = ClassTag[PartitionConfig](classOf[PartitionConfig])</span>
<span class="nc" id="L124">    private val compactedCt = ClassTag[CompactedConfig](classOf[CompactedConfig])</span>

    def renderPartition(partition: PartitionConfig): String =
<span class="nc" id="L127">      partitionWriter.to(partition).render(options)</span>
    def parsePartition(config: Config): PartitionConfig =
<span class="nc" id="L129">      ConfigSource.fromConfig(config).loadOrThrow[PartitionConfig](partitionCt, PartitionReader)</span>

    def renderCompaction(compaction: Seq[PartitionConfig]): String =
<span class="nc" id="L132">      compactedWriter.to(CompactedConfig(compaction)).render(options)</span>
    def parseCompaction(config: Config): Seq[PartitionConfig] =
<span class="nc" id="L134">      ConfigSource.fromConfig(config).loadOrThrow[CompactedConfig](compactedCt, CompactedReader).partitions</span>
  }

<span class="nc" id="L137">  object MetadataConverter {</span>

<span class="nc" id="L139">    private val options = Seq(RenderCompact, RenderPretty)</span>

    def apply(name: String): MetadataConverter = {
<span class="nc" id="L142">      options.find(_.name.equalsIgnoreCase(name)).getOrElse {</span>
<span class="nc" id="L143">        throw new IllegalArgumentException(</span>
<span class="nc" id="L144">          s&quot;Render type '$name' does not exist. Available types: ${options.map(_.name).mkString(&quot;, &quot;)}&quot;)</span>
      }
    }
  }

<span class="nc" id="L149">  object RenderPretty extends MetadataConverter {</span>
<span class="nc" id="L150">    override val name: String = FileBasedMetadata.Config.RenderPretty</span>
<span class="nc" id="L151">    override val suffix: String = &quot;.json&quot;</span>
<span class="nc" id="L152">    override protected val partitionWriter: ConfigWriter[PartitionConfig] =</span>
<span class="nc" id="L153">      ConfigWriter.fromFunction(writePartitionConfigVerbose)</span>
<span class="nc" id="L154">    override protected val compactedWriter: ConfigWriter[CompactedConfig] =</span>
<span class="nc" id="L155">      ConfigWriter.fromFunction(writeCompactedConfig(partitionWriter))</span>
<span class="nc" id="L156">    override protected val options: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true)</span>
  }

<span class="nc" id="L159">  object RenderCompact extends MetadataConverter {</span>
<span class="nc" id="L160">    override val name: String = FileBasedMetadata.Config.RenderCompact</span>
<span class="nc" id="L161">    override val suffix: String = &quot;.conf&quot;</span>
<span class="nc" id="L162">    override protected val partitionWriter: ConfigWriter[PartitionConfig] =</span>
<span class="nc" id="L163">      ConfigWriter.fromFunction(writePartitionConfigCompact)</span>
<span class="nc" id="L164">    override protected val compactedWriter: ConfigWriter[CompactedConfig] =</span>
<span class="nc" id="L165">      ConfigWriter.fromFunction(writeCompactedConfig(partitionWriter))</span>
<span class="nc" id="L166">    override protected val options: ConfigRenderOptions = ConfigRenderOptions.concise().setJson(false)</span>
  }

<span class="nc" id="L169">  class EnumerationReader[T &lt;: Enumeration](enum: T) extends ConfigReader[T#Value] {</span>
    override def from(cur: ConfigCursor): Result[T#Value] = {
<span class="nc" id="L171">      cur.asString.right.flatMap { s =&gt;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        lazy val reason =</span>
          CannotConvert(s, enum.getClass.getName, s&quot;value $s is not a valid enum: ${enum.values.mkString(&quot;, &quot;)}&quot;)
<span class="nc" id="L174">        enum.values.find(_.toString.startsWith(s)).asInstanceOf[Option[T#Value]].toRight(cur.failed(reason).left.get)</span>
      }
    }
  }

<span class="nc" id="L179">  private val PartitionReader = ConfigReader.fromCursor(readPartitionConfig)</span>
<span class="nc" id="L180">  private val CompactedReader = ConfigReader.fromCursor(readCompactedConfig)</span>
<span class="nc" id="L181">  private val StorageFileCompactReader = ConfigReader.fromCursor(readStorageFileCompact)</span>
<span class="nc" id="L182">  private val StorageFileVerboseReader = ConfigReader.fromCursor(readStorageFileVerbose)</span>
<span class="nc" id="L183">  private val BoundReader = ConfigReader.fromCursor(readBound)</span>
<span class="nc" id="L184">  private val PartitionActionReader = new EnumerationReader(PartitionAction)</span>
<span class="nc" id="L185">  private val StorageFileActionReader = new EnumerationReader(StorageFileAction)</span>

  private def writeCompactedConfig(delegate: ConfigWriter[PartitionConfig])(compacted: CompactedConfig): ConfigValue =
<span class="nc" id="L188">    ConfigValueFactory.fromMap(Collections.singletonMap(&quot;partitions&quot;, compacted.partitions.map(delegate.to).asJava))</span>

  private def readCompactedConfig(cur: ConfigCursor): Either[ConfigReaderFailures, CompactedConfig] = {
    for {
<span class="nc" id="L192">      obj  &lt;- cur.asObjectCursor.right</span>
<span class="nc" id="L193">      par  &lt;- obj.atKey(&quot;partitions&quot;).right.flatMap(_.asListCursor).right</span>
<span class="nc" id="L194">      list &lt;- convertList[PartitionConfig](par)(PartitionReader).right</span>
    } yield {
<span class="nc" id="L196">      CompactedConfig(list)</span>
    }
  }

  private def writePartitionConfigCompact(partition: PartitionConfig): ConfigValue = {
<span class="nc" id="L201">    val list = new java.util.ArrayList[AnyRef](5)</span>
<span class="nc" id="L202">    list.add(partition.action.toString.take(1))</span>
<span class="nc" id="L203">    list.add(Long.box(partition.timestamp))</span>
<span class="nc" id="L204">    list.add(partition.envelope.asJava)</span>
<span class="nc" id="L205">    list.add(Long.box(partition.count))</span>
<span class="nc" id="L206">    list.add(partition.files.map(writeStorageFileCompact).asJava)</span>
<span class="nc" id="L207">    ConfigValueFactory.fromMap(Collections.singletonMap(partition.name, list))</span>
  }

  private def writePartitionConfigVerbose(partition: PartitionConfig): ConfigValue = {
<span class="nc" id="L211">    val map = new java.util.HashMap[String, AnyRef](6)</span>
<span class="nc" id="L212">    map.put(&quot;name&quot;, partition.name)</span>
<span class="nc" id="L213">    map.put(&quot;action&quot;, partition.action.toString)</span>
<span class="nc" id="L214">    map.put(&quot;files&quot;, partition.files.map(writeStorageFileVerbose).asJava)</span>
<span class="nc" id="L215">    map.put(&quot;count&quot;, Long.box(partition.count))</span>
<span class="nc" id="L216">    map.put(&quot;timestamp&quot;, Long.box(partition.timestamp))</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">    if (partition.envelope.nonEmpty) {</span>
<span class="nc" id="L218">      val envelope = new java.util.HashMap[String, AnyRef](4)</span>
<span class="nc" id="L219">      envelope.put(&quot;xmin&quot;, Double.box(partition.envelope.head))</span>
<span class="nc" id="L220">      envelope.put(&quot;ymin&quot;, Double.box(partition.envelope(1)))</span>
<span class="nc" id="L221">      envelope.put(&quot;xmax&quot;, Double.box(partition.envelope(2)))</span>
<span class="nc" id="L222">      envelope.put(&quot;ymax&quot;, Double.box(partition.envelope(3)))</span>
<span class="nc" id="L223">      map.put(&quot;envelope&quot;, envelope)</span>
    }
<span class="nc" id="L225">    ConfigValueFactory.fromMap(map)</span>
  }

  private def readPartitionConfig(cur: ConfigCursor): Either[ConfigReaderFailures, PartitionConfig] = {
<span class="nc" id="L229">    val compact = readPartitionConfigCompact(cur)</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">    if (compact.isRight) { compact } else { readPartitionConfigVerbose(cur).left.flatMap(_ =&gt; compact) }</span>
  }

  private def readPartitionConfigCompact(cur: ConfigCursor): Either[ConfigReaderFailures, PartitionConfig] = {
<span class="nc" id="L234">    cur.asObjectCursor.right.flatMap { obj =&gt;</span>
<span class="nc" id="L235">      val name = obj.keys.head</span>
<span class="nc" id="L236">      obj.atKeyOrUndefined(name).asListCursor.right.flatMap { list =&gt;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (list.size != 5) {</span>
<span class="nc" id="L238">          cur.failed(CannotConvert(cur.valueOpt.map(_.toString).getOrElse(&quot;&quot;),</span>
<span class="nc" id="L239">            classOf[PartitionConfig].getSimpleName, s&quot;value ${cur.valueOpt.orNull} does not have the expected 6 elements&quot;))</span>
        } else {
          for {
<span class="nc" id="L242">            action &lt;- PartitionActionReader.from(list.atIndexOrUndefined(0)).right</span>
<span class="nc" id="L243">            ts     &lt;- list.atIndexOrUndefined(1).asLong.right</span>
<span class="nc" id="L244">            env    &lt;- list.atIndexOrUndefined(2).asListCursor.right.flatMap(readEnvelope).right</span>
<span class="nc" id="L245">            count  &lt;- list.atIndexOrUndefined(3).asLong.right</span>
<span class="nc" id="L246">            files  &lt;- list.atIndexOrUndefined(4).asListCursor.right.flatMap(convertList(_)(StorageFileCompactReader)).right</span>
          } yield {
<span class="nc" id="L248">            PartitionConfig(name, action, files, count, env, ts)</span>
          }
        }
      }
    }
  }

  private def readPartitionConfigVerbose(cur: ConfigCursor): Either[ConfigReaderFailures, PartitionConfig] = {
    def readEnvelope(obj: ConfigObjectCursor): Either[ConfigReaderFailures, Seq[Double]] = {
<span class="nc" id="L257">      obj.atKeyOrUndefined(&quot;envelope&quot;) match {</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        case envelope if envelope.isUndefined =&gt; Right(Seq.empty)</span>
        case envelope =&gt;
          for {
<span class="nc" id="L261">            env  &lt;- envelope.asObjectCursor.right</span>
<span class="nc" id="L262">            xmin &lt;- env.atKey(&quot;xmin&quot;).right.flatMap(_.asDouble).right</span>
<span class="nc" id="L263">            ymin &lt;- env.atKey(&quot;ymin&quot;).right.flatMap(_.asDouble).right</span>
<span class="nc" id="L264">            xmax &lt;- env.atKey(&quot;xmax&quot;).right.flatMap(_.asDouble).right</span>
<span class="nc" id="L265">            ymax &lt;- env.atKey(&quot;ymax&quot;).right.flatMap(_.asDouble).right</span>
          } yield {
<span class="nc" id="L267">            Seq(xmin, ymin, xmax, ymax)</span>
          }
      }
    }

    for {
<span class="nc" id="L273">      obj    &lt;- cur.asObjectCursor.right</span>
<span class="nc" id="L274">      name   &lt;- obj.atKey(&quot;name&quot;).right.flatMap(_.asString).right</span>
<span class="nc" id="L275">      action &lt;- obj.atKey(&quot;action&quot;).right.flatMap(PartitionActionReader.from).right</span>
<span class="nc" id="L276">      files  &lt;- obj.atKey(&quot;files&quot;).right.flatMap(_.asListCursor).right.flatMap(convertList(_)(StorageFileVerboseReader)).right</span>
<span class="nc" id="L277">      count  &lt;- obj.atKey(&quot;count&quot;).right.flatMap(ConfigReader.longConfigReader.from).right</span>
<span class="nc" id="L278">      bounds &lt;- readEnvelope(obj).right</span>
<span class="nc" id="L279">      ts     &lt;- obj.atKey(&quot;timestamp&quot;).right.flatMap(ConfigReader.longConfigReader.from).right</span>
    } yield {
<span class="nc" id="L281">      PartitionConfig(name, action, files, count, bounds, ts)</span>
    }
  }

  private def writeStorageFileCompact(file: StorageFile): ConfigValue = {
<span class="nc" id="L286">    val list = new java.util.ArrayList[AnyRef](5)</span>
<span class="nc" id="L287">    list.add(file.name)</span>
<span class="nc" id="L288">    list.add(file.action.toString.take(1))</span>
<span class="nc" id="L289">    list.add(Long.box(file.timestamp))</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (file.sort.nonEmpty) {</span>
<span class="nc" id="L291">      list.add(file.sort.asJava)</span>
    }
<span class="nc bnc" id="L293" title="All 2 branches missed.">    if (file.bounds.nonEmpty) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      list.add(file.bounds.map { case (a, f, t) =&gt; Seq(a, f, t).asJava }.asJava)</span>
    }
<span class="nc" id="L296">    ConfigValueFactory.fromIterable(list)</span>
  }

  private def writeStorageFileVerbose(file: StorageFile): ConfigValue = {
<span class="nc" id="L300">    val map = new java.util.HashMap[String, AnyRef](5)</span>
<span class="nc" id="L301">    map.put(&quot;name&quot;, file.name)</span>
<span class="nc" id="L302">    map.put(&quot;timestamp&quot;, Long.box(file.timestamp))</span>
<span class="nc" id="L303">    map.put(&quot;action&quot;, file.action.toString)</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (file.sort.nonEmpty) {</span>
<span class="nc" id="L305">      map.put(&quot;sort&quot;, file.sort.asJava)</span>
    }
<span class="nc bnc" id="L307" title="All 2 branches missed.">    if (file.bounds.nonEmpty) {</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">      map.put(&quot;bounds&quot;, file.bounds.map { case (a, f, t) =&gt; Seq(a, f, t).asJava }.asJava)</span>
    }
<span class="nc" id="L310">    ConfigValueFactory.fromMap(map)</span>
  }

  private def readStorageFileCompact(cur: ConfigCursor): Either[ConfigReaderFailures, StorageFile] = {
<span class="nc" id="L314">    cur.asListCursor.right.flatMap { list =&gt;</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">      if (list.size &lt; 3 || list.size &gt; 5) {</span>
<span class="nc" id="L316">        cur.failed(CannotConvert(cur.valueOpt.map(_.toString).getOrElse(&quot;&quot;),</span>
<span class="nc" id="L317">          classOf[StorageFile].getSimpleName, s&quot;value ${cur.valueOpt.orNull} does not have the expected number of elements&quot;))</span>
      } else {
        for {
<span class="nc" id="L320">          name   &lt;- list.atIndexOrUndefined(0).asString.right</span>
<span class="nc" id="L321">          action &lt;- StorageFileActionReader.from(list.atIndexOrUndefined(1)).right</span>
<span class="nc" id="L322">          ts     &lt;- list.atIndexOrUndefined(2).asLong.right</span>
<span class="nc" id="L323">          sort   &lt;- readSort(list.atIndexOrUndefined(3)).right</span>
<span class="nc" id="L324">          bounds &lt;- readBounds(list.atIndexOrUndefined(4)).right</span>
        } yield {
<span class="nc" id="L326">          StorageFile(name, ts, action, sort, bounds)</span>
        }
      }
    }
  }

  private def readStorageFileVerbose(cur: ConfigCursor): Either[ConfigReaderFailures, StorageFile] = {
    val withAction = for {
<span class="nc" id="L334">      obj    &lt;- cur.asObjectCursor.right</span>
<span class="nc" id="L335">      name   &lt;- obj.atKey(&quot;name&quot;).right.flatMap(_.asString).right</span>
<span class="nc" id="L336">      ts     &lt;- obj.atKey(&quot;timestamp&quot;).right.flatMap(ConfigReader.longConfigReader.from).right</span>
<span class="nc" id="L337">      action &lt;- obj.atKey(&quot;action&quot;).right.flatMap(StorageFileActionReader.from).right</span>
<span class="nc" id="L338">      sort   &lt;- readSort(obj.atKeyOrUndefined(&quot;sort&quot;)).right</span>
<span class="nc" id="L339">      bounds &lt;- readBounds(obj.atKeyOrUndefined(&quot;bounds&quot;)).right</span>
    } yield {
<span class="nc" id="L341">      StorageFile(name, ts, action, sort, bounds)</span>
    }
<span class="nc bnc" id="L343" title="All 2 branches missed.">    if (withAction.isRight) { withAction } else {</span>
      // note: use 0 for timestamp to sort before any mods
<span class="nc" id="L345">      val sansAction = for { name &lt;- cur.asString.right } yield { StorageFile(name, 0L) }</span>
<span class="nc" id="L346">      sansAction.left.flatMap(_ =&gt; withAction) // if failure, replace with original error</span>
    }
  }

  private def readEnvelope(env: ConfigListCursor): Either[ConfigReaderFailures, Seq[Double]] = {
<span class="nc" id="L351">    convertList[Double](env).right.flatMap { coords =&gt;</span>
<span class="nc bnc" id="L352" title="All 4 branches missed.">      if (coords.isEmpty || coords.length == 4) { Right(coords) } else {</span>
<span class="nc" id="L353">        env.failed(CannotConvert(env.valueOpt.map(_.toString).getOrElse(&quot;&quot;),</span>
<span class="nc" id="L354">          &quot;Seq[Double]&quot;, s&quot;value ${env.valueOpt.orNull} does not have the expected 4 elements&quot;))</span>
      }
    }
  }

  private def readSort(cur: ConfigCursor): Either[ConfigReaderFailures, Seq[Int]] =
<span class="nc bnc" id="L360" title="All 2 branches missed.">    if (cur.isUndefined) { Right(Seq.empty) } else { cur.asListCursor.right.flatMap(convertList[Int]) }</span>

  private def readBounds(cur: ConfigCursor): Either[ConfigReaderFailures, Seq[(Int, String, String)]] =
<span class="nc bnc" id="L363" title="All 2 branches missed.">    if (cur.isUndefined) { Right(Seq.empty) } else { cur.asListCursor.right.flatMap(convertList(_)(BoundReader)) }</span>

  private def readBound(cur: ConfigCursor): Either[ConfigReaderFailures, (Int, String, String)] = {
<span class="nc" id="L366">    cur.asListCursor.right.flatMap { list =&gt;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">      if (list.size != 3) {</span>
<span class="nc" id="L368">        cur.failed(CannotConvert(cur.valueOpt.map(_.toString).getOrElse(&quot;&quot;),</span>
<span class="nc" id="L369">          &quot;Tuple3[Int, String, String]&quot;, s&quot;value ${cur.valueOpt.orNull} does not have 3 elements&quot;))</span>
      } else {
        for {
<span class="nc" id="L372">          attribute &lt;- list.atIndexOrUndefined(0).asInt.right</span>
<span class="nc" id="L373">          from      &lt;- list.atIndexOrUndefined(1).asString.right</span>
<span class="nc" id="L374">          to        &lt;- list.atIndexOrUndefined(2).asString.right</span>
        } yield {
<span class="nc" id="L376">          (attribute, from, to)</span>
        }
      }
    }
  }

  private def convertList[T](
      list: ConfigListCursor)
     (implicit reader: ConfigReader[T]): Either[ConfigReaderFailures, Seq[T]] = {
<span class="nc" id="L385">    val res = Seq.newBuilder[T]</span>
<span class="nc" id="L386">    var err: ConfigReaderFailures = null</span>
<span class="nc" id="L387">    var i = 0</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">    while (i &lt; list.size) {</span>
<span class="nc" id="L389">      reader.from(list.atIndexOrUndefined(i)) match {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        case Right(success) =&gt; res += success</span>
<span class="nc bnc" id="L391" title="All 4 branches missed.">        case Left(failure)  =&gt; if (err == null) { err = failure } else { err = err ++ failure }</span>
      }
<span class="nc" id="L393">      i += 1</span>
    }
<span class="nc bnc" id="L395" title="All 2 branches missed.">    if (err == null) { Right(res.result) } else { Left(err) }</span>
  }
<span class="nc" id="L397">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>