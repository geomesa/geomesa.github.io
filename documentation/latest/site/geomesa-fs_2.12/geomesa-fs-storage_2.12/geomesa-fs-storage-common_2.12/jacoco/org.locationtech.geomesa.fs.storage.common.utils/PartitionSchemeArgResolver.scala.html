<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartitionSchemeArgResolver.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.common.utils</a> &gt; <span class="el_source">PartitionSchemeArgResolver.scala</span></div><h1>PartitionSchemeArgResolver.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.common.utils

import org.apache.commons.io.IOUtils
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.fs.storage.api.{NamedOptions, PartitionSchemeFactory}
import org.locationtech.geomesa.fs.storage.common.StorageSerialization
import org.locationtech.geomesa.fs.storage.common.utils.PartitionSchemeArgResolver.SchemeArgs
import org.locationtech.geomesa.utils.conf.ArgResolver
import org.locationtech.geomesa.utils.io.{PathUtils, WithClose}

import java.nio.charset.StandardCharsets
import scala.util.control.NonFatal

<span class="nc" id="L22">object PartitionSchemeArgResolver {</span>

<span class="nc" id="L24">  private val instance = new PartitionSchemeArgResolver</span>

<span class="nc bnc" id="L26" title="All 25 branches missed.">  case class SchemeArgs(sft: SimpleFeatureType, scheme: String)</span>

  def resolve(sft: SimpleFeatureType, scheme: String): Either[Throwable, NamedOptions] =
<span class="nc" id="L29">    instance.getArg(SchemeArgs(sft, scheme))</span>
}

<span class="nc bnc" id="L32" title="All 4 branches missed.">class PartitionSchemeArgResolver extends ArgResolver[NamedOptions, SchemeArgs] {</span>

  import org.locationtech.geomesa.utils.conf.ArgResolver.ArgTypes._

<span class="nc" id="L36">  private val fileNameReg = &quot;&quot;&quot;([^.]*)\.([^.]*)&quot;&quot;&quot; // e.g. &quot;foo.bar&quot;</span>
<span class="nc" id="L37">  private val confStrings = Seq(&quot;{&quot;)</span>

  override protected def argType(args: SchemeArgs): ArgTypes = {
    // guess the type we are trying to parse, to determine which error we show for failures
    // order is important here
<span class="nc bnc" id="L42" title="All 2 branches missed.">    if (confStrings.exists(args.scheme.contains)) {</span>
<span class="nc" id="L43">      CONFSTR</span>
<span class="nc bnc" id="L44" title="All 4 branches missed.">    } else if (args.scheme.matches(fileNameReg) || args.scheme.contains(&quot;/&quot;)) {</span>
<span class="nc" id="L45">      PATH</span>
    } else {
<span class="nc" id="L47">      NAME</span>
    }
  }

<span class="nc" id="L51">  override val parseMethodList: Seq[SchemeArgs =&gt; ResEither] = List[SchemeArgs =&gt; ResEither](</span>
<span class="nc" id="L52">    getNamedScheme,</span>
<span class="nc" id="L53">    parseFile,</span>
<span class="nc" id="L54">    parseString</span>
  )

  private [PartitionSchemeArgResolver] def getNamedScheme(args: SchemeArgs): ResEither = {
<span class="nc" id="L58">    try {</span>
<span class="nc" id="L59">      val options = NamedOptions(args.scheme)</span>
<span class="nc" id="L60">      PartitionSchemeFactory.load(args.sft, options)</span>
<span class="nc" id="L61">      Right(options)</span>
    } catch {
<span class="nc bnc" id="L63" title="All 2 branches missed.">      case NonFatal(e) =&gt; Left((s&quot;Unable to load named scheme ${args.scheme}&quot;, e, NAME))</span>
    }
  }

  private [PartitionSchemeArgResolver] def parseString(args: SchemeArgs): ResEither = {
<span class="nc" id="L68">    try {</span>
<span class="nc" id="L69">      val options = StorageSerialization.deserialize(args.scheme)</span>
<span class="nc" id="L70">      PartitionSchemeFactory.load(args.sft, options)</span>
<span class="nc" id="L71">      Right(options)</span>
    } catch {
<span class="nc bnc" id="L73" title="All 2 branches missed.">      case NonFatal(e) =&gt; Left((s&quot;Unable to load scheme from arg ${args.scheme}&quot;, e, CONFSTR))</span>
    }
  }

  private [PartitionSchemeArgResolver] def parseFile(args: SchemeArgs): ResEither = {
<span class="nc" id="L78">    try {</span>
<span class="nc" id="L79">      val handle = PathUtils.interpretPath(args.scheme).headOption.getOrElse {</span>
<span class="nc" id="L80">        throw new RuntimeException(s&quot;Could not read file at ${args.scheme}&quot;)</span>
      }
<span class="nc" id="L82">      WithClose(handle.open) { is =&gt;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (is.hasNext) {</span>
<span class="nc" id="L84">          val config = IOUtils.toString(is.next._2, StandardCharsets.UTF_8)</span>
<span class="nc" id="L85">          val options = StorageSerialization.deserialize(config)</span>
<span class="nc" id="L86">          PartitionSchemeFactory.load(args.sft, options)</span>
<span class="nc" id="L87">          Right(options)</span>
        } else {
<span class="nc" id="L89">          throw new RuntimeException(s&quot;Could not read file at ${args.scheme}&quot;)</span>
        }
      }
    } catch {
<span class="nc bnc" id="L93" title="All 2 branches missed.">      case NonFatal(e) =&gt; Left((s&quot;Unable to load scheme from file ${args.scheme}&quot;, e, PATH))</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>