<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeScheme.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage Common</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.common.partitions</a> &gt; <span class="el_source">DateTimeScheme.scala</span></div><h1>DateTimeScheme.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.common.partitions

import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.fs.storage.api.PartitionScheme.SimplifiedFilter
import org.locationtech.geomesa.fs.storage.api.{NamedOptions, PartitionScheme, PartitionSchemeFactory}
import org.locationtech.geomesa.utils.text.DateParsing

import java.time.format.{DateTimeFormatter, DateTimeFormatterBuilder}
import java.time.temporal.{ChronoField, ChronoUnit, TemporalAdjusters, WeekFields}
import java.time.{DayOfWeek, ZoneOffset, ZonedDateTime}
import java.util.Date
import scala.collection.mutable.ListBuffer
import scala.util.control.NonFatal

<span class="nc bnc" id="L25" title="All 45 branches missed.">case class DateTimeScheme(</span>
<span class="nc" id="L26">    formatter: DateTimeFormatter,</span>
<span class="nc" id="L27">    pattern: String,</span>
<span class="nc" id="L28">    stepUnit: ChronoUnit,</span>
<span class="nc" id="L29">    step: Int,</span>
<span class="nc" id="L30">    dtg: String,</span>
<span class="nc" id="L31">    dtgIndex: Int</span>
<span class="nc" id="L32">  ) extends PartitionScheme {</span>

  import FilterHelper.ff
  import org.locationtech.geomesa.filter.{andOption, isTemporalFilter, partitionSubFilters}

  import ChronoUnit._

<span class="nc" id="L39">  private val truncateToPartitionStart: ZonedDateTime =&gt; ZonedDateTime = {</span>
    // note: `truncatedTo` is only valid up to DAYS, other units require additional steps
<span class="nc" id="L41">    val truncate: ZonedDateTime =&gt; ZonedDateTime = stepUnit match {</span>
<span class="nc bnc" id="L42" title="All 16 branches missed.">      case NANOS | MICROS | MILLIS | SECONDS | MINUTES | HOURS | DAYS =&gt;</span>
<span class="nc" id="L43">        dt =&gt; dt.truncatedTo(stepUnit)</span>

<span class="nc bnc" id="L45" title="All 2 branches missed.">      case WEEKS =&gt;</span>
<span class="nc" id="L46">        val adjuster = TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY) // note: java day_of_week defines monday as the first day</span>
<span class="nc" id="L47">        dt =&gt; dt.`with`(adjuster).truncatedTo(DAYS)</span>

<span class="nc bnc" id="L49" title="All 2 branches missed.">      case MONTHS =&gt;</span>
<span class="nc" id="L50">        val adjuster = TemporalAdjusters.firstDayOfMonth()</span>
<span class="nc" id="L51">        dt =&gt; dt.`with`(adjuster).truncatedTo(DAYS)</span>

<span class="nc bnc" id="L53" title="All 2 branches missed.">      case YEARS =&gt;</span>
<span class="nc" id="L54">        val adjuster = TemporalAdjusters.firstDayOfYear()</span>
<span class="nc" id="L55">        dt =&gt; dt.`with`(adjuster).truncatedTo(DAYS)</span>

      case _ =&gt;
<span class="nc" id="L58">        throw new IllegalArgumentException(s&quot;${DateTimeScheme.Config.StepUnitOpt} $stepUnit is not supported&quot;)</span>
    }
<span class="nc bnc" id="L60" title="All 2 branches missed.">    if (step == 1) {</span>
<span class="nc" id="L61">      truncate</span>
    } else {
<span class="nc" id="L63">      val chronoField = stepUnit match {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        case NANOS   =&gt; ChronoField.NANO_OF_SECOND</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        case MICROS  =&gt; ChronoField.MICRO_OF_SECOND</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        case MILLIS  =&gt; ChronoField.MILLI_OF_SECOND</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        case SECONDS =&gt; ChronoField.SECOND_OF_MINUTE</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        case MINUTES =&gt; ChronoField.MINUTE_OF_HOUR</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">        case HOURS   =&gt; ChronoField.HOUR_OF_DAY</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        case DAYS    =&gt; ChronoField.DAY_OF_YEAR</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        case WEEKS   =&gt; WeekFields.ISO.weekOfWeekBasedYear()</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        case MONTHS  =&gt; ChronoField.MONTH_OF_YEAR</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">        case YEARS   =&gt; ChronoField.YEAR</span>
<span class="nc" id="L74">        case _ =&gt; throw new IllegalArgumentException(s&quot;${DateTimeScheme.Config.StepUnitOpt} $stepUnit is not supported&quot;)</span>
      }
<span class="nc" id="L76">      val min = math.max(chronoField.range().getMinimum, 0).toInt // account for 1-based fields like {month, week, day}_of_year</span>
<span class="nc" id="L77">      truncate.andThen { dt =&gt;</span>
<span class="nc" id="L78">        val steps = dt.get(chronoField) - min</span>
<span class="nc" id="L79">        val remainder = steps % step</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (remainder == 0) { dt } else { dt.`with`(chronoField, steps + min - remainder ) }</span>
      }
    }
  }

  // TODO This may not be the best way to calculate max depth...
  // especially if we are going to use other separators
<span class="nc bnc" id="L87" title="All 2 branches missed.">  override val depth: Int = pattern.count(_ == '/') + 1</span>

  override def getPartitionName(feature: SimpleFeature): String = {
<span class="nc" id="L90">    val dt = ZonedDateTime.ofInstant(feature.getAttribute(dtgIndex).asInstanceOf[Date].toInstant, ZoneOffset.UTC)</span>
<span class="nc" id="L91">    formatter.format(truncateToPartitionStart(dt))</span>
  }

  override def getSimplifiedFilters(filter: Filter, partition: Option[String]): Option[Seq[SimplifiedFilter]] = {
<span class="nc bnc" id="L95" title="All 2 branches missed.">    getCoveringPartitions(filter).map { case (covered, intersecting) =&gt;</span>
<span class="nc" id="L96">      val result = Seq.newBuilder[SimplifiedFilter]</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">      if (covered.nonEmpty) {</span>
        // remove the temporal filter that we've already accounted for in our covered partitions
<span class="nc" id="L100">        val coveredFilter = andOption(partitionSubFilters(filter, isTemporalFilter(_, dtg))._2)</span>
<span class="nc" id="L101">        result += SimplifiedFilter(coveredFilter.getOrElse(Filter.INCLUDE), covered, partial = false)</span>
      }
<span class="nc bnc" id="L103" title="All 2 branches missed.">      if (intersecting.nonEmpty) {</span>
<span class="nc" id="L104">        result += SimplifiedFilter(filter, intersecting, partial = false)</span>
      }

<span class="nc" id="L107">      partition match {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        case None =&gt; result.result</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        case Some(p) =&gt;</span>
<span class="nc" id="L110">          val matched = result.result.find(_.partitions.contains(p))</span>
<span class="nc" id="L111">          matched.map(_.copy(partitions = Seq(p))).toSeq</span>
      }
    }
  }

  override def getIntersectingPartitions(filter: Filter): Option[Seq[String]] =
<span class="nc bnc" id="L117" title="All 2 branches missed.">    getCoveringPartitions(filter).map { case (covered, intersecting) =&gt; (covered ++ intersecting).sorted }</span>

  override def getCoveringFilter(partition: String): Filter = {
<span class="nc" id="L120">    val zdt = DateParsing.parse(partition, formatter)</span>
<span class="nc" id="L121">    val start = DateParsing.format(zdt)</span>
<span class="nc" id="L122">    val end = DateParsing.format(zdt.plus(step, stepUnit))</span>
<span class="nc" id="L123">    ff.and(ff.greaterOrEqual(ff.property(dtg), ff.literal(start)), ff.less(ff.property(dtg), ff.literal(end)))</span>
  }

  private def getCoveringPartitions(filter: Filter): Option[(Seq[String], Seq[String])] = {
<span class="nc" id="L127">    val bounds = FilterHelper.extractIntervals(filter, dtg, handleExclusiveBounds = false)</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (bounds.disjoint) {</span>
<span class="nc" id="L129">      Some((Seq.empty, Seq.empty))</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">    } else if (bounds.isEmpty || !bounds.forall(_.isBoundedBothSides)) {</span>
<span class="nc" id="L131">      None</span>
    } else {
      // there should be no duplicates in covered partitions, as our bounds will not overlap,
      // but there may be multiple partial intersects with a given partition
<span class="nc" id="L135">      val covered = ListBuffer.empty[String]</span>
<span class="nc" id="L136">      val intersecting = ListBuffer.empty[String]</span>

<span class="nc" id="L138">      bounds.values.foreach { bound =&gt;</span>
        // note: we verified both sides are bounded above
<span class="nc" id="L140">        val lower = bound.lower.value.get</span>
<span class="nc" id="L141">        val upper = bound.upper.value.get</span>
<span class="nc" id="L142">        val start = truncateToPartitionStart(lower)</span>
<span class="nc" id="L143">        val end = truncateToPartitionStart(upper)</span>

        // do our endpoints match the partition boundary, or do we need to apply a filter to the first/last partition?
<span class="nc bnc" id="L146" title="All 8 branches missed.">        val lowerBoundCovered = bound.lower.inclusive &amp;&amp; lower == start</span>

        // `stepUnit.between` claims to be upper endpoint exclusive, but doesn't seem to be...
<span class="nc" id="L149">        val steps = stepUnit.between(start, end).toInt</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (steps &lt; step) {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">          if (lowerBoundCovered &amp;&amp;</span>
<span class="nc bnc" id="L152" title="All 16 branches missed.">              ((bound.upper.exclusive &amp;&amp; upper == end) || (bound.upper.inclusive &amp;&amp; upper == end.plus(step, stepUnit).minus(1, MILLIS)))) {</span>
<span class="nc" id="L153">            covered += formatter.format(start)</span>
          } else {
<span class="nc" id="L155">            intersecting += formatter.format(start)</span>
          }
        } else {
<span class="nc bnc" id="L158" title="All 2 branches missed.">          if (lowerBoundCovered) {</span>
<span class="nc" id="L159">            covered += formatter.format(start)</span>
          } else {
<span class="nc" id="L161">            intersecting += formatter.format(start)</span>
          }
<span class="nc" id="L163">          covered ++= Iterator.iterate(start)(_.plus(step, stepUnit)).drop(1).takeWhile(_.isBefore(end)).map(formatter.format)</span>
<span class="nc bnc" id="L164" title="All 8 branches missed.">          if (bound.upper.inclusive || upper != end) {</span>
<span class="nc" id="L165">            intersecting += formatter.format(end)</span>
          }
        }
      }

<span class="nc" id="L170">      Some((covered.toSeq, intersecting.distinct.toSeq))</span>
    }
  }
}

<span class="nc" id="L175">object DateTimeScheme {</span>

<span class="nc" id="L177">  val Name = &quot;datetime&quot;</span>

  def apply(format: String, stepUnit: ChronoUnit, step: Int, dtg: String, dtgIndex: Int): DateTimeScheme =
<span class="nc" id="L180">    DateTimeScheme(DateTimeFormatter.ofPattern(format), format, stepUnit, step, dtg, dtgIndex)</span>

<span class="nc" id="L182">  object Config {</span>
<span class="nc" id="L183">    val DateTimeFormatOpt: String = &quot;datetime-format&quot;</span>
<span class="nc" id="L184">    val StepUnitOpt      : String = &quot;step-unit&quot;</span>
<span class="nc" id="L185">    val StepOpt          : String = &quot;step&quot;</span>
<span class="nc" id="L186">    val DtgAttribute     : String = &quot;dtg-attribute&quot;</span>
  }

<span class="nc" id="L189">  object Formats {</span>

<span class="nc" id="L191">    def apply(name: String): Option[Format] = all.find(_.name.equalsIgnoreCase(name))</span>

<span class="nc bnc" id="L193" title="All 39 branches missed.">    case class Format private[Formats](name: String, formatter: DateTimeFormatter, pattern: String, unit: ChronoUnit)</span>

<span class="nc" id="L195">    private[Formats] object Format {</span>
      def apply(name: String, format: String, unit: ChronoUnit): Format =
<span class="nc" id="L197">        Format(name, DateTimeFormatter.ofPattern(format), format, unit)</span>
    }

<span class="nc" id="L200">    val Minute       : Format = Format(&quot;minute&quot;,        &quot;yyyy/MM/dd/HH/mm&quot;, ChronoUnit.MINUTES)</span>
<span class="nc" id="L201">    val Hourly       : Format = Format(&quot;hourly&quot;,        &quot;yyyy/MM/dd/HH&quot;,    ChronoUnit.HOURS  )</span>
<span class="nc" id="L202">    val Daily        : Format = Format(&quot;daily&quot;,         &quot;yyyy/MM/dd&quot;,       ChronoUnit.DAYS   )</span>
<span class="nc" id="L203">    val Monthly      : Format = Format(&quot;monthly&quot;,       &quot;yyyy/MM&quot;,          ChronoUnit.MONTHS )</span>
<span class="nc" id="L204">    val JulianMinute : Format = Format(&quot;julian-minute&quot;, &quot;yyyy/DDD/HH/mm&quot;,   ChronoUnit.MINUTES)</span>
<span class="nc" id="L205">    val JulianHourly : Format = Format(&quot;julian-hourly&quot;, &quot;yyyy/DDD/HH&quot;,      ChronoUnit.HOURS  )</span>
<span class="nc" id="L206">    val JulianDaily  : Format = Format(&quot;julian-daily&quot;,  &quot;yyyy/DDD&quot;,         ChronoUnit.DAYS   )</span>

    // java.time doesn't seem to have a way to parse back out a year/week format...
    // to get around that we have to define the default day of week in the formatter
<span class="nc" id="L210">    val Weekly: Format = {</span>
      val formatter =
<span class="nc" id="L212">        new DateTimeFormatterBuilder()</span>
<span class="nc" id="L213">          .appendValue(WeekFields.ISO.weekBasedYear(), 4)</span>
<span class="nc" id="L214">          .appendLiteral(&quot;/W&quot;)</span>
<span class="nc" id="L215">          .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)</span>
<span class="nc" id="L216">          .parseDefaulting(ChronoField.DAY_OF_WEEK, 1)</span>
          .toFormatter()
<span class="nc" id="L218">      Format(&quot;weekly&quot;, formatter, &quot;YYYY/'W'ww&quot;, ChronoUnit.WEEKS)</span>
    }

<span class="nc" id="L221">    private val all = Seq(Minute, Hourly, Daily, Weekly, Monthly, JulianMinute, JulianHourly, JulianDaily)</span>
  }

<span class="nc" id="L224">  class DateTimePartitionSchemeFactory extends PartitionSchemeFactory {</span>
    override def load(sft: SimpleFeatureType, config: NamedOptions): Option[PartitionScheme] = {
      import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

<span class="nc bnc" id="L228" title="All 2 branches missed.">      lazy val step = config.options.get(Config.StepOpt).map(_.toInt).getOrElse(1)</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      lazy val dtg = config.options.get(Config.DtgAttribute).orElse(sft.getDtgField).getOrElse {</span>
<span class="nc" id="L230">        throw new IllegalArgumentException(s&quot;DateTime scheme requires valid attribute '${Config.DtgAttribute}'&quot;)</span>
      }
<span class="nc bnc" id="L232" title="All 4 branches missed.">      lazy val dtgIndex = Some(sft.indexOf(dtg)).filter(_ != -1).getOrElse {</span>
<span class="nc" id="L233">        throw new IllegalArgumentException(s&quot;Attribute '$dtg' does not exist in feature type ${sft.getTypeName}&quot;)</span>
      }

<span class="nc bnc" id="L236" title="All 6 branches missed.">      if (config.name == Name) {</span>
<span class="nc" id="L237">        val unit = config.options.get(Config.StepUnitOpt).map(c =&gt; ChronoUnit.valueOf(c.toUpperCase)).getOrElse {</span>
<span class="nc" id="L238">          throw new IllegalArgumentException(s&quot;DateTime scheme requires valid unit '${Config.StepUnitOpt}'&quot;)</span>
        }
<span class="nc" id="L240">        val format = config.options.getOrElse(Config.DateTimeFormatOpt,</span>
<span class="nc" id="L241">          throw new IllegalArgumentException(s&quot;DateTime scheme requires valid format '${Config.DateTimeFormatOpt}'&quot;))</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        require(!format.endsWith(&quot;/&quot;), &quot;Format cannot end with a slash&quot;)</span>
<span class="nc" id="L243">        val formatter = try { DateTimeFormatter.ofPattern(format) } catch {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">          case NonFatal(e) =&gt; throw new IllegalArgumentException(s&quot;Invalid date format '$format':&quot;, e)</span>
        }
<span class="nc" id="L246">        Some(DateTimeScheme(formatter, format, unit, step, dtg, dtgIndex))</span>
      } else {
<span class="nc" id="L248">        Formats(config.name).map(f =&gt; DateTimeScheme(f.formatter, f.pattern, f.unit, step, dtg, dtgIndex))</span>
      }
    }
  }
<span class="nc" id="L252">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>