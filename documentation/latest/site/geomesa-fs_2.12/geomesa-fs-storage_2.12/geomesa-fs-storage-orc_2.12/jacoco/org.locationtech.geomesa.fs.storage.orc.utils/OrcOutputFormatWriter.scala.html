<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OrcOutputFormatWriter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage ORC</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.orc.utils</a> &gt; <span class="el_source">OrcOutputFormatWriter.scala</span></div><h1>OrcOutputFormatWriter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.orc.utils

import org.apache.hadoop.io._
import org.apache.orc.TypeDescription
import org.apache.orc.mapred.{OrcList, OrcMap, OrcStruct, OrcTimestamp}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.locationtech.geomesa.fs.storage.orc.io.SimpleFeatureTypeDescription
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.text.WKBUtils
import org.locationtech.jts.geom._

import java.nio.charset.StandardCharsets
import java.util.UUID

trait OrcOutputFormatWriter {
  def apply(sf: SimpleFeature, output: OrcStruct): Unit
}

<span class="nc" id="L28">object OrcOutputFormatWriter {</span>

<span class="nc" id="L30">  def apply(sft: SimpleFeatureType, description: TypeDescription, fid: Boolean = true): OrcOutputFormatWriter = {</span>
<span class="nc" id="L31">    val builder = Seq.newBuilder[OrcOutputFormatWriter]</span>
<span class="nc bnc" id="L32" title="All 2 branches missed.">    builder.sizeHint(sft.getAttributeCount + (if (fid) { 1 } else { 0 }))</span>

<span class="nc" id="L34">    var i = 0</span>
<span class="nc" id="L35">    var col = 0</span>
<span class="nc bnc" id="L36" title="All 2 branches missed.">    while (i &lt; sft.getAttributeCount) {</span>
<span class="nc" id="L37">      val descriptor = sft.getDescriptor(i)</span>
<span class="nc" id="L38">      val bindings = ObjectType.selectType(descriptor)</span>
<span class="nc" id="L39">      val reader = bindings.head match {</span>
<span class="nc bnc" id="L40" title="All 6 branches missed.">        case ObjectType.GEOMETRY =&gt; createGeometryWriter(bindings(1), col, i, description)</span>
<span class="nc bnc" id="L41" title="All 6 branches missed.">        case ObjectType.DATE     =&gt; new DateOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L42" title="All 6 branches missed.">        case ObjectType.STRING   =&gt; new StringOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L43" title="All 6 branches missed.">        case ObjectType.INT      =&gt; new IntOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L44" title="All 6 branches missed.">        case ObjectType.LONG     =&gt; new LongOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L45" title="All 6 branches missed.">        case ObjectType.FLOAT    =&gt; new FloatOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L46" title="All 6 branches missed.">        case ObjectType.DOUBLE   =&gt; new DoubleOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L47" title="All 6 branches missed.">        case ObjectType.BOOLEAN  =&gt; new BooleanOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L48" title="All 6 branches missed.">        case ObjectType.BYTES    =&gt; new BytesOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L49" title="All 6 branches missed.">        case ObjectType.UUID     =&gt; new UuidOutputFormatWriter(col, i)</span>
<span class="nc bnc" id="L50" title="All 6 branches missed.">        case ObjectType.LIST     =&gt; new ListOutputFormatWriter(col, i, bindings(1), description)</span>
<span class="nc bnc" id="L51" title="All 6 branches missed.">        case ObjectType.MAP      =&gt; new MapOutputFormatWriter(col, i, bindings(1), bindings(2), description)</span>
<span class="nc" id="L52">        case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type ${bindings.head}&quot;)</span>
      }
<span class="nc" id="L54">      builder += reader</span>
<span class="nc" id="L55">      i += 1</span>
<span class="nc" id="L56">      col += SimpleFeatureTypeDescription.fieldCount(descriptor)</span>
    }

<span class="nc bnc" id="L59" title="All 2 branches missed.">    if (fid) {</span>
<span class="nc" id="L60">      builder += new FidOutputFormatWriter(col)</span>
    }

<span class="nc" id="L63">    new SequenceOutputFormatWriter(builder.result)</span>
  }

  private def createGeometryWriter(
      binding: ObjectType,
      col: Int,
      i: Int,
      description: TypeDescription): OrcOutputFormatWriter = {
<span class="nc" id="L71">    binding match {</span>
<span class="nc bnc" id="L72" title="All 6 branches missed.">      case ObjectType.POINT           =&gt; new PointOutputFormatWriter(col, col + 1, i)</span>
<span class="nc bnc" id="L73" title="All 6 branches missed.">      case ObjectType.LINESTRING      =&gt; new LineStringOutputFormatWriter(col, col + 1, i, description)</span>
<span class="nc bnc" id="L74" title="All 6 branches missed.">      case ObjectType.MULTIPOINT      =&gt; new MultiPointOutputFormatWriter(col, col + 1, i, description)</span>
<span class="nc bnc" id="L75" title="All 6 branches missed.">      case ObjectType.POLYGON         =&gt; new PolygonOutputFormatWriter(col, col + 1, i, description)</span>
<span class="nc bnc" id="L76" title="All 6 branches missed.">      case ObjectType.MULTILINESTRING =&gt; new MultiLineStringOutputFormatWriter(col, col + 1, i, description)</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">      case ObjectType.MULTIPOLYGON    =&gt; new MultiPolygonOutputFormatWriter(col, col + 1, i, description)</span>
<span class="nc bnc" id="L78" title="All 6 branches missed.">      case ObjectType.GEOMETRY        =&gt; new GeometryWkbOutputFormatWriter(col, i)</span>
<span class="nc" id="L79">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected geometry type $binding&quot;)</span>
    }
  }

<span class="nc" id="L83">  class SequenceOutputFormatWriter(writers: Seq[OrcOutputFormatWriter]) extends OrcOutputFormatWriter {</span>
<span class="nc" id="L84">    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = writers.foreach(_.apply(sf, output))</span>
  }

<span class="nc" id="L87">  class FidOutputFormatWriter(col: Int) extends OrcOutputFormatWriter with SetOutputFormatString {</span>
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit =
<span class="nc" id="L89">      output.setFieldValue(col, setValue(sf.getID, output.getFieldValue(col)))</span>
  }

<span class="nc" id="L92">  class DateOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L93">      extends OutputFormatWriterAdapter with SetOutputFormatDate</span>

<span class="nc" id="L95">  class StringOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L96">      extends OutputFormatWriterAdapter with SetOutputFormatString</span>

<span class="nc" id="L98">  class IntOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L99">      extends OutputFormatWriterAdapter with SetOutputFormatInt</span>

<span class="nc" id="L101">  class LongOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L102">      extends OutputFormatWriterAdapter with SetOutputFormatLong</span>

<span class="nc" id="L104">  class FloatOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L105">      extends OutputFormatWriterAdapter with SetOutputFormatFloat</span>

<span class="nc" id="L107">  class DoubleOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L108">      extends OutputFormatWriterAdapter with SetOutputFormatDouble</span>

<span class="nc" id="L110">  class BooleanOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L111">      extends OutputFormatWriterAdapter with SetOutputFormatBoolean</span>

<span class="nc" id="L113">  class BytesOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L114">      extends OutputFormatWriterAdapter with SetOutputFormatBytes</span>

<span class="nc" id="L116">  class UuidOutputFormatWriter(val col: Int, val attribute: Int)</span>
<span class="nc" id="L117">      extends OutputFormatWriterAdapter with SetOutputFormatUuid</span>

  /**
    * Reads a point attribute from a simple feature and sets it in an output format
    *
    * @param xCol index of x field, containing points
    * @param yCol index of y field, containing points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L126">  class PointOutputFormatWriter(xCol: Int, yCol: Int, attribute: Int)</span>
<span class="nc" id="L127">      extends OrcOutputFormatWriter with SetOutputFormatDouble {</span>
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
<span class="nc" id="L129">      val point = sf.getAttribute(attribute).asInstanceOf[Point]</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">      if (point == null) {</span>
<span class="nc" id="L131">        output.setFieldValue(xCol, null)</span>
<span class="nc" id="L132">        output.setFieldValue(yCol, null)</span>
      } else {
<span class="nc" id="L134">        var x = output.getFieldValue(xCol).asInstanceOf[DoubleWritable]</span>
<span class="nc" id="L135">        var y = output.getFieldValue(yCol).asInstanceOf[DoubleWritable]</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L137">          x = new DoubleWritable</span>
<span class="nc" id="L138">          output.setFieldValue(xCol, x)</span>
        }
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L141">          y = new DoubleWritable</span>
<span class="nc" id="L142">          output.setFieldValue(yCol, y)</span>
        }
<span class="nc" id="L144">        x.set(point.getX)</span>
<span class="nc" id="L145">        y.set(point.getY)</span>
      }
    }
  }

  /**
    * Reads a linestring attribute from a simple feature and sets it in an output format.
    * A linestring is modeled as a list of points.
    *
    * @see PointOutputFormatWriter
    *
    * @param xCol index of x field, containing a list of points
    * @param yCol index of y field, containing a list of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L160">  class LineStringOutputFormatWriter(xCol: Int, yCol: Int, attribute: Int, description: TypeDescription)</span>
<span class="nc" id="L161">      extends OrcOutputFormatWriter with SetOutputFormatDouble {</span>
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
<span class="nc" id="L163">      val line = sf.getAttribute(attribute).asInstanceOf[LineString]</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">      if (line == null) {</span>
<span class="nc" id="L165">        output.setFieldValue(xCol, null)</span>
<span class="nc" id="L166">        output.setFieldValue(yCol, null)</span>
      } else {
<span class="nc" id="L168">        var x = output.getFieldValue(xCol).asInstanceOf[OrcList[DoubleWritable]]</span>
<span class="nc" id="L169">        var y = output.getFieldValue(yCol).asInstanceOf[OrcList[DoubleWritable]]</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L171">          x = new OrcList[DoubleWritable](description.getChildren.get(xCol), line.getNumPoints)</span>
<span class="nc" id="L172">          output.setFieldValue(xCol, x)</span>
        } else {
<span class="nc" id="L174">          x.clear()</span>
        }
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L177">          y = new OrcList[DoubleWritable](description.getChildren.get(yCol), line.getNumPoints)</span>
<span class="nc" id="L178">          output.setFieldValue(yCol, y)</span>
        } else {
<span class="nc" id="L180">          y.clear()</span>
        }
<span class="nc" id="L182">        var i = 0</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        while (i &lt; line.getNumPoints) {</span>
<span class="nc" id="L184">          val pt = line.getCoordinateN(i)</span>
<span class="nc" id="L185">          x.add(new DoubleWritable(pt.x))</span>
<span class="nc" id="L186">          y.add(new DoubleWritable(pt.y))</span>
<span class="nc" id="L187">          i += 1</span>
        }
      }
    }
  }

  /**
    * Reads a multi-point attribute from a simple feature and sets it in an output format.
    * A multi-point is modeled as a list of points.
    *
    * @see PointOutputFormatWriter
    *
    * @param xCol index of x field, containing a list of points
    * @param yCol index of y field, containing a list of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L203">  class MultiPointOutputFormatWriter(xCol: Int, yCol: Int, attribute: Int, description: TypeDescription)</span>
<span class="nc" id="L204">      extends OrcOutputFormatWriter with SetOutputFormatDouble {</span>
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
<span class="nc" id="L206">      val multiPoint = sf.getAttribute(attribute).asInstanceOf[MultiPoint]</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">      if (multiPoint == null) {</span>
<span class="nc" id="L208">        output.setFieldValue(xCol, null)</span>
<span class="nc" id="L209">        output.setFieldValue(yCol, null)</span>
      } else {
<span class="nc" id="L211">        var x = output.getFieldValue(xCol).asInstanceOf[OrcList[DoubleWritable]]</span>
<span class="nc" id="L212">        var y = output.getFieldValue(yCol).asInstanceOf[OrcList[DoubleWritable]]</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (x == null) {</span>
<span class="nc" id="L214">          x = new OrcList[DoubleWritable](description.getChildren.get(xCol), multiPoint.getNumPoints)</span>
<span class="nc" id="L215">          output.setFieldValue(xCol, x)</span>
        } else {
<span class="nc" id="L217">          x.clear()</span>
        }
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (y == null) {</span>
<span class="nc" id="L220">          y = new OrcList[DoubleWritable](description.getChildren.get(yCol), multiPoint.getNumPoints)</span>
<span class="nc" id="L221">          output.setFieldValue(yCol, y)</span>
        } else {
<span class="nc" id="L223">          y.clear()</span>
        }
<span class="nc" id="L225">        var i = 0</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        while (i &lt; multiPoint.getNumPoints) {</span>
<span class="nc" id="L227">          val pt = multiPoint.getGeometryN(i).asInstanceOf[Point]</span>
<span class="nc" id="L228">          x.add(new DoubleWritable(pt.getX))</span>
<span class="nc" id="L229">          y.add(new DoubleWritable(pt.getY))</span>
<span class="nc" id="L230">          i += 1</span>
        }
      }
    }
  }

  /**
    * Reads a polygon attribute from a simple feature and sets it in an output format.
    * A polygon is modeled as a list of lines, with the first value being the shell,
    * and any subsequent values being interior holes.
    *
    * @see LineStringOutputFormatWriter
    *
    * @param xCol index of x field, containing a list of lists of points
    * @param yCol index of y field, containing a list of lists of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L247">  class PolygonOutputFormatWriter(xCol: Int, yCol: Int, attribute: Int, description: TypeDescription)</span>
<span class="nc" id="L248">      extends OrcOutputFormatWriter with SetOutputFormatDouble {</span>
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
<span class="nc" id="L250">      val polygon = sf.getAttribute(attribute).asInstanceOf[Polygon]</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">      if (polygon == null) {</span>
<span class="nc" id="L252">        output.setFieldValue(xCol, null)</span>
<span class="nc" id="L253">        output.setFieldValue(yCol, null)</span>
      } else {
<span class="nc" id="L255">        var xx = output.getFieldValue(xCol).asInstanceOf[OrcList[OrcList[DoubleWritable]]]</span>
<span class="nc" id="L256">        var yy = output.getFieldValue(yCol).asInstanceOf[OrcList[OrcList[DoubleWritable]]]</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (xx == null) {</span>
<span class="nc" id="L258">          xx = new OrcList[OrcList[DoubleWritable]](description.getChildren.get(xCol), polygon.getNumInteriorRing + 1)</span>
<span class="nc" id="L259">          output.setFieldValue(xCol, xx)</span>
        } else {
<span class="nc" id="L261">          xx.clear()</span>
        }
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (yy == null) {</span>
<span class="nc" id="L264">          yy = new OrcList[OrcList[DoubleWritable]](description.getChildren.get(yCol), polygon.getNumInteriorRing + 1)</span>
<span class="nc" id="L265">          output.setFieldValue(yCol, yy)</span>
        } else {
<span class="nc" id="L267">          yy.clear()</span>
        }
<span class="nc" id="L269">        var j = 0</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        while (j &lt; polygon.getNumInteriorRing + 1) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">          val line = if (j == 0) { polygon.getExteriorRing } else { polygon.getInteriorRingN(j - 1) }</span>
<span class="nc" id="L272">          val x = new OrcList[DoubleWritable](description.getChildren.get(xCol).getChildren.get(0), line.getNumPoints)</span>
<span class="nc" id="L273">          val y = new OrcList[DoubleWritable](description.getChildren.get(yCol).getChildren.get(0), line.getNumPoints)</span>
<span class="nc" id="L274">          var i = 0</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">          while (i &lt; line.getNumPoints) {</span>
<span class="nc" id="L276">            val pt = line.getCoordinateN(i)</span>
<span class="nc" id="L277">            x.add(new DoubleWritable(pt.x))</span>
<span class="nc" id="L278">            y.add(new DoubleWritable(pt.y))</span>
<span class="nc" id="L279">            i += 1</span>
          }
<span class="nc" id="L281">          xx.add(x)</span>
<span class="nc" id="L282">          yy.add(y)</span>
<span class="nc" id="L283">          j += 1</span>
        }
      }
    }
  }

  /**
    * Reads a multi-linestring attribute from a simple feature and sets it in an output format.
    * A multi-linestring is modeled as a list of lines.
    *
    * @see LineStringOutputFormatWriter
    *
    * @param xCol index of x field, containing a list of lists of points
    * @param yCol index of y field, containing a list of lists of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L299">  class MultiLineStringOutputFormatWriter(xCol: Int, yCol: Int, attribute: Int, description: TypeDescription)</span>
<span class="nc" id="L300">      extends OrcOutputFormatWriter with SetOutputFormatDouble {</span>
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
<span class="nc" id="L302">      val multiLineString = sf.getAttribute(attribute).asInstanceOf[MultiLineString]</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">      if (multiLineString == null) {</span>
<span class="nc" id="L304">        output.setFieldValue(xCol, null)</span>
<span class="nc" id="L305">        output.setFieldValue(yCol, null)</span>
      } else {
<span class="nc" id="L307">        var xx = output.getFieldValue(xCol).asInstanceOf[OrcList[OrcList[DoubleWritable]]]</span>
<span class="nc" id="L308">        var yy = output.getFieldValue(yCol).asInstanceOf[OrcList[OrcList[DoubleWritable]]]</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (xx == null) {</span>
<span class="nc" id="L310">          xx = new OrcList[OrcList[DoubleWritable]](description.getChildren.get(xCol), multiLineString.getNumGeometries)</span>
<span class="nc" id="L311">          output.setFieldValue(xCol, xx)</span>
        } else {
<span class="nc" id="L313">          xx.clear()</span>
        }
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (yy == null) {</span>
<span class="nc" id="L316">          yy = new OrcList[OrcList[DoubleWritable]](description.getChildren.get(yCol), multiLineString.getNumGeometries)</span>
<span class="nc" id="L317">          output.setFieldValue(yCol, yy)</span>
        } else {
<span class="nc" id="L319">          yy.clear()</span>
        }
<span class="nc" id="L321">        var j = 0</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        while (j &lt; multiLineString.getNumGeometries) {</span>
<span class="nc" id="L323">          val line = multiLineString.getGeometryN(j).asInstanceOf[LineString]</span>
<span class="nc" id="L324">          val x = new OrcList[DoubleWritable](description.getChildren.get(xCol).getChildren.get(0), line.getNumPoints)</span>
<span class="nc" id="L325">          val y = new OrcList[DoubleWritable](description.getChildren.get(yCol).getChildren.get(0), line.getNumPoints)</span>
<span class="nc" id="L326">          var i = 0</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">          while (i &lt; line.getNumPoints) {</span>
<span class="nc" id="L328">            val pt = line.getCoordinateN(i)</span>
<span class="nc" id="L329">            x.add(new DoubleWritable(pt.x))</span>
<span class="nc" id="L330">            y.add(new DoubleWritable(pt.y))</span>
<span class="nc" id="L331">            i += 1</span>
          }
<span class="nc" id="L333">          xx.add(x)</span>
<span class="nc" id="L334">          yy.add(y)</span>
<span class="nc" id="L335">          j += 1</span>
        }
      }
    }
  }

  /**
    * Reads a multi-polygon attribute from a simple feature and sets it in an output format.
    * A multi-polygon is modeled as a list of polygons.
    *
    * @see PolygonOutputFormatWriter
    *
    * @param xCol index of x field, containing a list of lists of lists of points
    * @param yCol index of y field, containing a list of lists of lists of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L351">  class MultiPolygonOutputFormatWriter(xCol: Int, yCol: Int, attribute: Int, description: TypeDescription)</span>
<span class="nc" id="L352">      extends OrcOutputFormatWriter with SetOutputFormatDouble {</span>
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
<span class="nc" id="L354">      val multiPolygon = sf.getAttribute(attribute).asInstanceOf[MultiPolygon]</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">      if (multiPolygon == null) {</span>
<span class="nc" id="L356">        output.setFieldValue(xCol, null)</span>
<span class="nc" id="L357">        output.setFieldValue(yCol, null)</span>
      } else {
<span class="nc" id="L359">        var xxx = output.getFieldValue(xCol).asInstanceOf[OrcList[OrcList[OrcList[DoubleWritable]]]]</span>
<span class="nc" id="L360">        var yyy = output.getFieldValue(yCol).asInstanceOf[OrcList[OrcList[OrcList[DoubleWritable]]]]</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (xxx == null) {</span>
<span class="nc" id="L362">          xxx = new OrcList[OrcList[OrcList[DoubleWritable]]](description.getChildren.get(xCol), multiPolygon.getNumGeometries)</span>
<span class="nc" id="L363">          output.setFieldValue(xCol, xxx)</span>
        } else {
<span class="nc" id="L365">          xxx.clear()</span>
        }
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (yyy == null) {</span>
<span class="nc" id="L368">          yyy = new OrcList[OrcList[OrcList[DoubleWritable]]](description.getChildren.get(yCol), multiPolygon.getNumGeometries)</span>
<span class="nc" id="L369">          output.setFieldValue(yCol, yyy)</span>
        } else {
<span class="nc" id="L371">          yyy.clear()</span>
        }
<span class="nc" id="L373">        var k = 0</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        while (k &lt; multiPolygon.getNumGeometries) {</span>
<span class="nc" id="L375">          val polygon = multiPolygon.getGeometryN(k).asInstanceOf[Polygon]</span>
<span class="nc" id="L376">          val xx = new OrcList[OrcList[DoubleWritable]](description.getChildren.get(xCol).getChildren.get(0), polygon.getNumGeometries)</span>
<span class="nc" id="L377">          val yy = new OrcList[OrcList[DoubleWritable]](description.getChildren.get(yCol).getChildren.get(0), polygon.getNumGeometries)</span>
<span class="nc" id="L378">          var j = 0</span>

<span class="nc bnc" id="L380" title="All 2 branches missed.">          while (j &lt; polygon.getNumInteriorRing + 1) {</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            val line = if (j == 0) { polygon.getExteriorRing } else { polygon.getInteriorRingN(j - 1) }</span>
<span class="nc" id="L382">            val x = new OrcList[DoubleWritable](description.getChildren.get(xCol).getChildren.get(0), line.getNumPoints)</span>
<span class="nc" id="L383">            val y = new OrcList[DoubleWritable](description.getChildren.get(yCol).getChildren.get(0), line.getNumPoints)</span>
<span class="nc" id="L384">            var i = 0</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">            while (i &lt; line.getNumPoints) {</span>
<span class="nc" id="L386">              val pt = line.getCoordinateN(i)</span>
<span class="nc" id="L387">              x.add(new DoubleWritable(pt.x))</span>
<span class="nc" id="L388">              y.add(new DoubleWritable(pt.y))</span>
<span class="nc" id="L389">              i += 1</span>
            }
<span class="nc" id="L391">            xx.add(x)</span>
<span class="nc" id="L392">            yy.add(y)</span>
<span class="nc" id="L393">            j += 1</span>
          }
<span class="nc" id="L395">          xxx.add(xx)</span>
<span class="nc" id="L396">          yyy.add(yy)</span>
<span class="nc" id="L397">          k += 1</span>
        }
      }
    }
  }

<span class="nc" id="L403">  class GeometryWkbOutputFormatWriter(val col: Int, val attribute: Int) extends OutputFormatWriterAdapter {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L405" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L406">        var field = existing.asInstanceOf[BytesWritable]</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L408">          field = new BytesWritable</span>
        }
<span class="nc" id="L410">        val bytes = WKBUtils.write(value.asInstanceOf[Geometry])</span>
<span class="nc" id="L411">        field.set(bytes, 0, bytes.length)</span>
<span class="nc" id="L412">        field</span>
      }
    }
  }

<span class="nc" id="L417">  class ListOutputFormatWriter(col: Int, attribute: Int, binding: ObjectType, description: TypeDescription)</span>
<span class="nc" id="L418">      extends OrcOutputFormatWriter {</span>
<span class="nc" id="L419">    private val converter = getConverter(binding)</span>

    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
      import scala.collection.JavaConverters._
<span class="nc" id="L423">      val value = sf.getAttribute(attribute).asInstanceOf[java.util.List[AnyRef]]</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L425">        output.setFieldValue(col, null)</span>
      } else {
<span class="nc" id="L427">        var field = output.getFieldValue(col).asInstanceOf[OrcList[WritableComparable[_]]]</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L429">          field = new OrcList(description.getChildren.get(col), value.size())</span>
<span class="nc" id="L430">          output.setFieldValue(col, field)</span>
        } else {
<span class="nc" id="L432">          field.clear()</span>
        }
<span class="nc" id="L434">        value.asScala.foreach(v =&gt; field.add(converter.setValue(v, null)))</span>
      }
    }
  }

<span class="nc" id="L439">  class MapOutputFormatWriter(col: Int,</span>
<span class="nc" id="L440">                              attribute: Int,</span>
                              keyBinding: ObjectType,
                              valueBinding: ObjectType,
<span class="nc" id="L443">                              description: TypeDescription) extends OrcOutputFormatWriter {</span>
<span class="nc" id="L444">    private val keyConverter = getConverter(keyBinding)</span>
<span class="nc" id="L445">    private val valueConverter = getConverter(valueBinding)</span>

    override def apply(sf: SimpleFeature, output: OrcStruct): Unit = {
      import scala.collection.JavaConverters._
<span class="nc" id="L449">      val value = sf.getAttribute(attribute).asInstanceOf[java.util.Map[AnyRef, AnyRef]]</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L451">        output.setFieldValue(col, null)</span>
      } else {
<span class="nc" id="L453">        var field = output.getFieldValue(col).asInstanceOf[OrcMap[WritableComparable[_], WritableComparable[_]]]</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L455">          field = new OrcMap(description.getChildren.get(col))</span>
<span class="nc" id="L456">          output.setFieldValue(col, field)</span>
        } else {
<span class="nc" id="L458">          field.clear()</span>
        }
<span class="nc bnc" id="L460" title="All 2 branches missed.">        value.asScala.foreach { case (k, v) =&gt; field.put(keyConverter.setValue(k, null), valueConverter.setValue(v, null)) }</span>
      }
    }
  }

  trait SetOutputFormatValue {
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_]
  }

<span class="nc" id="L469">  trait OutputFormatWriterAdapter extends OrcOutputFormatWriter with SetOutputFormatValue {</span>
    def col: Int
    def attribute: Int
    override def apply(sf: SimpleFeature, output: OrcStruct): Unit =
<span class="nc" id="L473">      output.setFieldValue(col, setValue(sf.getAttribute(attribute), output.getFieldValue(col)))</span>

  }

<span class="nc" id="L477">  trait SetOutputFormatDate extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L479" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L480">        var field = existing.asInstanceOf[OrcTimestamp]</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L482">          field = new OrcTimestamp</span>
        }
<span class="nc" id="L484">        field.setTime(value.asInstanceOf[java.util.Date].getTime)</span>
<span class="nc" id="L485">        field</span>
      }
    }
  }

<span class="nc" id="L490">  trait SetOutputFormatString extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L492" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L493">        var field = existing.asInstanceOf[Text]</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L495">          field = new Text</span>
        }
<span class="nc" id="L497">        field.set(value.asInstanceOf[String].getBytes(StandardCharsets.UTF_8))</span>
<span class="nc" id="L498">        field</span>
      }
    }
  }

<span class="nc" id="L503">  trait SetOutputFormatInt extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L505" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L506">        var field = existing.asInstanceOf[IntWritable]</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L508">          field = new IntWritable</span>
        }
<span class="nc" id="L510">        field.set(value.asInstanceOf[Integer].intValue)</span>
<span class="nc" id="L511">        field</span>
      }
    }
  }

<span class="nc" id="L516">  trait SetOutputFormatLong extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L518" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L519">        var field = existing.asInstanceOf[LongWritable]</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L521">          field = new LongWritable</span>
        }
<span class="nc" id="L523">        field.set(value.asInstanceOf[java.lang.Long].longValue)</span>
<span class="nc" id="L524">        field</span>
      }
    }
  }

<span class="nc" id="L529">  trait SetOutputFormatFloat extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L531" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L532">        var field = existing.asInstanceOf[FloatWritable]</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L534">          field = new FloatWritable</span>
        }
<span class="nc" id="L536">        field.set(value.asInstanceOf[java.lang.Float].floatValue)</span>
<span class="nc" id="L537">        field</span>
      }
    }
  }

<span class="nc" id="L542">  trait SetOutputFormatDouble extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L544" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L545">        var field = existing.asInstanceOf[DoubleWritable]</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L547">          field = new DoubleWritable</span>
        }
<span class="nc" id="L549">        field.set(value.asInstanceOf[java.lang.Double].doubleValue)</span>
<span class="nc" id="L550">        field</span>
      }
    }
  }

<span class="nc" id="L555">  trait SetOutputFormatBoolean extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L557" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L558">        var field = existing.asInstanceOf[BooleanWritable]</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L560">          field = new BooleanWritable</span>
        }
<span class="nc" id="L562">        field.set(value.asInstanceOf[java.lang.Boolean].booleanValue)</span>
<span class="nc" id="L563">        field</span>
      }
    }
  }

<span class="nc" id="L568">  trait SetOutputFormatBytes extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L570" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L571">        var field = existing.asInstanceOf[BytesWritable]</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L573">          field = new BytesWritable</span>
        }
<span class="nc" id="L575">        val bytes = value.asInstanceOf[Array[Byte]]</span>
<span class="nc" id="L576">        field.set(bytes, 0, bytes.length)</span>
<span class="nc" id="L577">        field</span>
      }
    }
  }

<span class="nc" id="L582">  trait SetOutputFormatUuid extends SetOutputFormatValue {</span>
    def setValue(value: AnyRef, existing: WritableComparable[_]): WritableComparable[_] = {
<span class="nc bnc" id="L584" title="All 2 branches missed.">      if (value == null) { null } else {</span>
<span class="nc" id="L585">        var field = existing.asInstanceOf[Text]</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L587">          field = new Text</span>
        }
<span class="nc" id="L589">        field.set(value.asInstanceOf[UUID].toString.getBytes(StandardCharsets.UTF_8))</span>
<span class="nc" id="L590">        field</span>
      }
    }
  }

  /**
    * Gets a converter instance
    *
    * @param binding binding
    * @return
    */
  private def getConverter(binding: ObjectType): SetOutputFormatValue = {
<span class="nc" id="L602">    binding match {</span>
<span class="nc bnc" id="L603" title="All 6 branches missed.">      case ObjectType.DATE     =&gt; new SetOutputFormatDate {}</span>
<span class="nc bnc" id="L604" title="All 6 branches missed.">      case ObjectType.STRING   =&gt; new SetOutputFormatString {}</span>
<span class="nc bnc" id="L605" title="All 6 branches missed.">      case ObjectType.INT      =&gt; new SetOutputFormatInt {}</span>
<span class="nc bnc" id="L606" title="All 6 branches missed.">      case ObjectType.LONG     =&gt; new SetOutputFormatLong {}</span>
<span class="nc bnc" id="L607" title="All 6 branches missed.">      case ObjectType.FLOAT    =&gt; new SetOutputFormatFloat {}</span>
<span class="nc bnc" id="L608" title="All 6 branches missed.">      case ObjectType.DOUBLE   =&gt; new SetOutputFormatDouble {}</span>
<span class="nc bnc" id="L609" title="All 6 branches missed.">      case ObjectType.BOOLEAN  =&gt; new SetOutputFormatBoolean {}</span>
<span class="nc bnc" id="L610" title="All 6 branches missed.">      case ObjectType.BYTES    =&gt; new SetOutputFormatBytes {}</span>
<span class="nc bnc" id="L611" title="All 6 branches missed.">      case ObjectType.UUID     =&gt; new SetOutputFormatUuid {}</span>
<span class="nc" id="L612">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type $binding&quot;)</span>
    }
  }
<span class="nc" id="L615">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>