<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OrcInputFormatReader.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Storage ORC</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.storage.orc.utils</a> &gt; <span class="el_source">OrcInputFormatReader.scala</span></div><h1>OrcInputFormatReader.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.storage.orc.utils

import org.apache.hadoop.io._
import org.apache.orc.mapred.{OrcList, OrcMap, OrcStruct, OrcTimestamp}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.filter.identity.FeatureIdImpl
import org.geotools.geometry.jts.JTSFactoryFinder
import org.locationtech.geomesa.fs.storage.orc.io.SimpleFeatureTypeDescription
import org.locationtech.geomesa.utils.geotools.ObjectType
import org.locationtech.geomesa.utils.geotools.ObjectType.ObjectType
import org.locationtech.geomesa.utils.text.WKBUtils
import org.locationtech.jts.geom.{Coordinate, LineString, LinearRing, Polygon}

import java.util.UUID

trait OrcInputFormatReader {
  def apply(input: OrcStruct, sf: SimpleFeature): Unit
}

<span class="nc" id="L28">object OrcInputFormatReader {</span>

<span class="nc" id="L30">  private val gf = JTSFactoryFinder.getGeometryFactory</span>

<span class="nc" id="L32">  def apply(sft: SimpleFeatureType, columns: Option[Set[Int]] = None, fid: Boolean = true): OrcInputFormatReader = {</span>
<span class="nc" id="L33">    val builder = Seq.newBuilder[OrcInputFormatReader]</span>
<span class="nc bnc" id="L34" title="All 2 branches missed.">    builder.sizeHint(columns.map(_.size).getOrElse(sft.getAttributeCount) + (if (fid) { 1 } else { 0 }))</span>

<span class="nc" id="L36">    var i = 0</span>
<span class="nc" id="L37">    var col = 0</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">    while (i &lt; sft.getAttributeCount) {</span>
<span class="nc" id="L39">      val descriptor = sft.getDescriptor(i)</span>
<span class="nc" id="L40">      val bindings = ObjectType.selectType(descriptor)</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">      if (columns.forall(_.contains(i))) {</span>
<span class="nc" id="L42">        val reader = bindings.head match {</span>
<span class="nc bnc" id="L43" title="All 6 branches missed.">          case ObjectType.GEOMETRY =&gt; createGeometryReader(bindings(1), col, i)</span>
<span class="nc bnc" id="L44" title="All 6 branches missed.">          case ObjectType.DATE     =&gt; new DateInputFormatReader(col, i)</span>
<span class="nc bnc" id="L45" title="All 6 branches missed.">          case ObjectType.STRING   =&gt; new StringInputFormatReader(col, i)</span>
<span class="nc bnc" id="L46" title="All 6 branches missed.">          case ObjectType.INT      =&gt; new IntInputFormatReader(col, i)</span>
<span class="nc bnc" id="L47" title="All 6 branches missed.">          case ObjectType.LONG     =&gt; new LongInputFormatReader(col, i)</span>
<span class="nc bnc" id="L48" title="All 6 branches missed.">          case ObjectType.FLOAT    =&gt; new FloatInputFormatReader(col, i)</span>
<span class="nc bnc" id="L49" title="All 6 branches missed.">          case ObjectType.DOUBLE   =&gt; new DoubleInputFormatReader(col, i)</span>
<span class="nc bnc" id="L50" title="All 6 branches missed.">          case ObjectType.BOOLEAN  =&gt; new BooleanInputFormatReader(col, i)</span>
<span class="nc bnc" id="L51" title="All 6 branches missed.">          case ObjectType.BYTES    =&gt; new BytesInputFormatReader(col, i)</span>
<span class="nc bnc" id="L52" title="All 6 branches missed.">          case ObjectType.UUID     =&gt; new UuidInputFormatReader(col, i)</span>
<span class="nc bnc" id="L53" title="All 6 branches missed.">          case ObjectType.LIST     =&gt; new ListInputFormatReader(col, i, bindings(1))</span>
<span class="nc bnc" id="L54" title="All 6 branches missed.">          case ObjectType.MAP      =&gt; new MapInputFormatReader(col, i, bindings(1), bindings(2))</span>
<span class="nc" id="L55">          case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type ${bindings.head}&quot;)</span>
        }
<span class="nc" id="L57">        builder += reader</span>
      }
<span class="nc" id="L59">      i += 1</span>
<span class="nc" id="L60">      col += SimpleFeatureTypeDescription.fieldCount(descriptor)</span>
    }

<span class="nc bnc" id="L63" title="All 2 branches missed.">    if (fid) {</span>
<span class="nc" id="L64">      builder += new FidInputFormatReader(col)</span>
    }

<span class="nc" id="L67">    new SequenceInputFormatReader(builder.result)</span>
  }

  private def createGeometryReader(binding: ObjectType, col: Int, i: Int): OrcInputFormatReader = {
<span class="nc" id="L71">    binding match {</span>
<span class="nc bnc" id="L72" title="All 6 branches missed.">      case ObjectType.POINT           =&gt; new PointInputFormatReader(col, col + 1, i)</span>
<span class="nc bnc" id="L73" title="All 6 branches missed.">      case ObjectType.LINESTRING      =&gt; new LineStringInputFormatReader(col, col + 1, i)</span>
<span class="nc bnc" id="L74" title="All 6 branches missed.">      case ObjectType.MULTIPOINT      =&gt; new MultiPointInputFormatReader(col, col + 1, i)</span>
<span class="nc bnc" id="L75" title="All 6 branches missed.">      case ObjectType.POLYGON         =&gt; new PolygonInputFormatReader(col, col + 1, i)</span>
<span class="nc bnc" id="L76" title="All 6 branches missed.">      case ObjectType.MULTILINESTRING =&gt; new MultiLineStringInputFormatReader(col, col + 1, i)</span>
<span class="nc bnc" id="L77" title="All 6 branches missed.">      case ObjectType.MULTIPOLYGON    =&gt; new MultiPolygonInputFormatReader(col, col + 1, i)</span>
<span class="nc bnc" id="L78" title="All 6 branches missed.">      case ObjectType.GEOMETRY        =&gt; new GeometryWkbInputFormatReader(col, i)</span>
<span class="nc" id="L79">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected geometry type $binding&quot;)</span>
    }
  }

<span class="nc" id="L83">  class SequenceInputFormatReader(readers: Seq[OrcInputFormatReader]) extends OrcInputFormatReader {</span>
<span class="nc" id="L84">    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = readers.foreach(_.apply(input, sf))</span>
  }

<span class="nc" id="L87">  class FidInputFormatReader(col: Int) extends OrcInputFormatReader with ConvertInputFormatString {</span>
<span class="nc" id="L88">    private var counter = -1L</span>
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L90">      val field = input.getFieldValue(col)</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L92">        counter += 1</span>
<span class="nc" id="L93">        sf.getIdentifier.asInstanceOf[FeatureIdImpl].setID(s&quot;$counter&quot;)</span>
      } else {
<span class="nc" id="L95">        sf.getIdentifier.asInstanceOf[FeatureIdImpl].setID(convert(field))</span>
      }
    }

  }

<span class="nc" id="L101">  class DateInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L102">      extends InputFormatReaderAdapter with ConvertInputFormatDate</span>

<span class="nc" id="L104">  class StringInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L105">      extends InputFormatReaderAdapter with ConvertInputFormatString</span>

<span class="nc" id="L107">  class IntInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L108">      extends InputFormatReaderAdapter with ConvertInputFormatInt</span>

<span class="nc" id="L110">  class LongInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L111">      extends InputFormatReaderAdapter with ConvertInputFormatLong</span>

<span class="nc" id="L113">  class FloatInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L114">      extends InputFormatReaderAdapter with ConvertInputFormatFloat</span>

<span class="nc" id="L116">  class DoubleInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L117">      extends InputFormatReaderAdapter with ConvertInputFormatDouble</span>

<span class="nc" id="L119">  class BooleanInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L120">      extends InputFormatReaderAdapter with ConvertInputFormatBoolean</span>

<span class="nc" id="L122">  class BytesInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L123">      extends InputFormatReaderAdapter with ConvertInputFormatBytes</span>

<span class="nc" id="L125">  class UuidInputFormatReader(val col: Int, val attribute: Int)</span>
<span class="nc" id="L126">      extends InputFormatReaderAdapter with ConvertInputFormatUuid</span>

  /**
    * Reads a point attribute from a vector and sets it in a simple feature
    *
    * @param xCol index of x field, containing points
    * @param yCol index of y field, containing points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L135">  class PointInputFormatReader(xCol: Int, yCol: Int, attribute: Int)</span>
<span class="nc" id="L136">      extends OrcInputFormatReader with ConvertInputFormatDouble {</span>
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L138">      val x = input.getFieldValue(xCol)</span>
<span class="nc" id="L139">      val y = input.getFieldValue(yCol)</span>
<span class="nc bnc" id="L140" title="All 4 branches missed.">      if (x == null || y == null) {</span>
<span class="nc" id="L141">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L143">        sf.setAttribute(attribute, gf.createPoint(new Coordinate(convertUnboxed(x), convertUnboxed(y))))</span>
      }
    }
  }

  /**
    * Reads a linestring attribute from a vector and sets it in a simple feature.
    * A linestring is modeled as a list of points.
    *
    * @see PointReader
    *
    * @param xCol index of x field, containing a list of points
    * @param yCol index of y field, containing a list of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L158">  class LineStringInputFormatReader(xCol: Int, yCol: Int, attribute: Int)</span>
<span class="nc" id="L159">      extends OrcInputFormatReader with ConvertInputFormatDouble {</span>
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L161">      val xList = input.getFieldValue(xCol).asInstanceOf[OrcList[_ &lt;: WritableComparable[_]]]</span>
<span class="nc" id="L162">      val yList = input.getFieldValue(yCol).asInstanceOf[OrcList[_ &lt;: WritableComparable[_]]]</span>
<span class="nc bnc" id="L163" title="All 4 branches missed.">      if (xList == null || yList == null) {</span>
<span class="nc" id="L164">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L166">        val coordinates = Array.ofDim[Coordinate](xList.size())</span>
<span class="nc" id="L167">        var i = 0</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        while (i &lt; coordinates.length) {</span>
<span class="nc" id="L169">          coordinates(i) = new Coordinate(convertUnboxed(xList.get(i)), convertUnboxed(yList.get(i)))</span>
<span class="nc" id="L170">          i += 1</span>
        }
<span class="nc" id="L172">        sf.setAttribute(attribute, gf.createLineString(coordinates))</span>
      }
    }
  }

  /**
    * Reads a multi-point attribute from a vector and sets it in a simple feature.
    * A multi-point is modeled as a list of points.
    *
    * @see PointReader
    *
    * @param xCol index of x field, containing a list of points
    * @param yCol index of y field, containing a list of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L187">  class MultiPointInputFormatReader(xCol: Int, yCol: Int, attribute: Int)</span>
<span class="nc" id="L188">      extends OrcInputFormatReader with ConvertInputFormatDouble {</span>
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L190">      val xList = input.getFieldValue(xCol).asInstanceOf[OrcList[_ &lt;: WritableComparable[_]]]</span>
<span class="nc" id="L191">      val yList = input.getFieldValue(yCol).asInstanceOf[OrcList[_ &lt;: WritableComparable[_]]]</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">      if (xList == null || yList == null) {</span>
<span class="nc" id="L193">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L195">        val coordinates = Array.ofDim[Coordinate](xList.size())</span>
<span class="nc" id="L196">        var i = 0</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        while (i &lt; coordinates.length) {</span>
<span class="nc" id="L198">          coordinates(i) = new Coordinate(convertUnboxed(xList.get(i)), convertUnboxed(yList.get(i)))</span>
<span class="nc" id="L199">          i += 1</span>
        }
<span class="nc" id="L201">        sf.setAttribute(attribute, gf.createMultiPoint(coordinates))</span>
      }
    }
  }

  /**
    * Reads a polygon attribute from a vector and sets it in a simple feature.
    * A polygon is modeled as a list of lines, with the first value being the shell,
    * and any subsequent values being interior holes.
    *
    * @see LineStringReader
    *
    * @param xCol index of x field, containing a list of lists of points
    * @param yCol index of y field, containing a list of lists of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L217">  class PolygonInputFormatReader(xCol: Int, yCol: Int, attribute: Int)</span>
<span class="nc" id="L218">      extends OrcInputFormatReader with ConvertInputFormatDouble {</span>
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L220">      val xxList = input.getFieldValue(xCol).asInstanceOf[OrcList[OrcList[_ &lt;: WritableComparable[_]]]]</span>
<span class="nc" id="L221">      val yyList = input.getFieldValue(yCol).asInstanceOf[OrcList[OrcList[_ &lt;: WritableComparable[_]]]]</span>
<span class="nc bnc" id="L222" title="All 4 branches missed.">      if (xxList == null || yyList == null) {</span>
<span class="nc" id="L223">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L225">        val lines = Array.ofDim[LinearRing](xxList.size)</span>
<span class="nc" id="L226">        var j = 0</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        while (j &lt; lines.length) {</span>
<span class="nc" id="L228">          val xList = xxList.get(j)</span>
<span class="nc" id="L229">          val yList = yyList.get(j)</span>
<span class="nc" id="L230">          val coordinates = Array.ofDim[Coordinate](xList.size())</span>
<span class="nc" id="L231">          var i = 0</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">          while (i &lt; coordinates.length) {</span>
<span class="nc" id="L233">            coordinates(i) = new Coordinate(convertUnboxed(xList.get(i)), convertUnboxed(yList.get(i)))</span>
<span class="nc" id="L234">            i += 1</span>
          }
<span class="nc" id="L236">          lines(j) = gf.createLinearRing(coordinates)</span>
<span class="nc" id="L237">          j += 1</span>
        }
<span class="nc bnc" id="L239" title="All 2 branches missed.">        val polygon = if (lines.length == 1) { gf.createPolygon(lines.head) } else { gf.createPolygon(lines.head, lines.tail) }</span>
<span class="nc" id="L240">        sf.setAttribute(attribute, polygon)</span>
      }
    }
  }

  /**
    * Reads a multi-linestring attribute from a vector and sets it in a simple feature.
    * A multi-linestring is modeled as a list of lines.
    *
    * @see LineStringReader
    *
    * @param xCol index of x field, containing a list of lists of points
    * @param yCol index of y field, containing a list of lists of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L255">  class MultiLineStringInputFormatReader(xCol: Int, yCol: Int, attribute: Int)</span>
<span class="nc" id="L256">      extends OrcInputFormatReader with ConvertInputFormatDouble {</span>
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L258">      val xxList = input.getFieldValue(xCol).asInstanceOf[OrcList[OrcList[_ &lt;: WritableComparable[_]]]]</span>
<span class="nc" id="L259">      val yyList = input.getFieldValue(yCol).asInstanceOf[OrcList[OrcList[_ &lt;: WritableComparable[_]]]]</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">      if (xxList == null || yyList == null) {</span>
<span class="nc" id="L261">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L263">        val lines = Array.ofDim[LineString](xxList.size)</span>
<span class="nc" id="L264">        var j = 0</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        while (j &lt; lines.length) {</span>
<span class="nc" id="L266">          val xList = xxList.get(j)</span>
<span class="nc" id="L267">          val yList = yyList.get(j)</span>
<span class="nc" id="L268">          val coordinates = Array.ofDim[Coordinate](xList.size())</span>
<span class="nc" id="L269">          var i = 0</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">          while (i &lt; coordinates.length) {</span>
<span class="nc" id="L271">            coordinates(i) = new Coordinate(convertUnboxed(xList.get(i)), convertUnboxed(yList.get(i)))</span>
<span class="nc" id="L272">            i += 1</span>
          }
<span class="nc" id="L274">          lines(j) = gf.createLineString(coordinates)</span>
<span class="nc" id="L275">          j += 1</span>
        }
<span class="nc" id="L277">        sf.setAttribute(attribute, gf.createMultiLineString(lines))</span>
      }
    }
  }

  /**
    * Reads a multi-polygon attribute from a vector and sets it in a simple feature.
    * A multi-polygon is modeled as a list of polygons.
    *
    * @see PolygonReader
    *
    * @param xCol index of x field, containing a list of lists of lists of points
    * @param yCol index of y field, containing a list of lists of lists of points
    * @param attribute simple feature attribute index
    */
<span class="nc" id="L292">  class MultiPolygonInputFormatReader(xCol: Int, yCol: Int, attribute: Int)</span>
<span class="nc" id="L293">      extends OrcInputFormatReader with ConvertInputFormatDouble {</span>
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L295">      val xxxList = input.getFieldValue(xCol).asInstanceOf[OrcList[OrcList[OrcList[_ &lt;: WritableComparable[_]]]]]</span>
<span class="nc" id="L296">      val yyyList = input.getFieldValue(yCol).asInstanceOf[OrcList[OrcList[OrcList[_ &lt;: WritableComparable[_]]]]]</span>
<span class="nc bnc" id="L297" title="All 4 branches missed.">      if (xxxList == null || yyyList == null) {</span>
<span class="nc" id="L298">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L300">        val polygons = Array.ofDim[Polygon](xxxList.size)</span>
<span class="nc" id="L301">        var k = 0</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        while (k &lt; polygons.length) {</span>
<span class="nc" id="L303">          val xxList = xxxList.get(k)</span>
<span class="nc" id="L304">          val yyList = yyyList.get(k)</span>
<span class="nc" id="L305">          val lines = Array.ofDim[LinearRing](xxList.size)</span>
<span class="nc" id="L306">          var j = 0</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">          while (j &lt; lines.length) {</span>
<span class="nc" id="L308">            val xList = xxList.get(j)</span>
<span class="nc" id="L309">            val yList = yyList.get(j)</span>
<span class="nc" id="L310">            val coordinates = Array.ofDim[Coordinate](xList.size())</span>
<span class="nc" id="L311">            var i = 0</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            while (i &lt; coordinates.length) {</span>
<span class="nc" id="L313">              coordinates(i) = new Coordinate(convertUnboxed(xList.get(i)), convertUnboxed(yList.get(i)))</span>
<span class="nc" id="L314">              i += 1</span>
            }
<span class="nc" id="L316">            lines(j) = gf.createLinearRing(coordinates)</span>
<span class="nc" id="L317">            j += 1</span>
          }
<span class="nc bnc" id="L319" title="All 2 branches missed.">          polygons(k) = if (lines.size == 1) {</span>
<span class="nc" id="L320">            gf.createPolygon(lines(0))</span>
          } else {
<span class="nc" id="L322">            gf.createPolygon(lines(0), lines.tail)</span>
          }
<span class="nc" id="L324">          k += 1</span>
        }
<span class="nc" id="L326">        sf.setAttribute(attribute, gf.createMultiPolygon(polygons))</span>
      }
    }
  }

<span class="nc" id="L331">  class GeometryWkbInputFormatReader(val col: Int, val attribute: Int) extends InputFormatReaderAdapter {</span>
<span class="nc" id="L332">    override def convert(input: AnyRef): AnyRef = WKBUtils.read(input.asInstanceOf[BytesWritable].copyBytes())</span>
  }

<span class="nc" id="L335">  class ListInputFormatReader(col: Int, attribute: Int, binding: ObjectType) extends OrcInputFormatReader {</span>
<span class="nc" id="L336">    private val converter = getConverter(binding)</span>

    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
      import scala.collection.JavaConverters._
<span class="nc" id="L340">      val value = input.getFieldValue(attribute).asInstanceOf[OrcList[_ &lt;: WritableComparable[_]]]</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L342">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L344">        val list = new java.util.ArrayList[AnyRef](value.size())</span>
<span class="nc" id="L345">        value.asScala.foreach(element =&gt; list.add(converter.convert(element)))</span>
<span class="nc" id="L346">        sf.setAttribute(attribute, list)</span>
      }
    }
  }

<span class="nc" id="L351">  class MapInputFormatReader(col: Int, attribute: Int, keyBinding: ObjectType, valueBinding: ObjectType)</span>
<span class="nc" id="L352">      extends OrcInputFormatReader {</span>
<span class="nc" id="L353">    private val keyConverter = getConverter(keyBinding)</span>
<span class="nc" id="L354">    private val valueConverter = getConverter(valueBinding)</span>

    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
      import scala.collection.JavaConverters._
<span class="nc" id="L358">      val value = input.getFieldValue(attribute).asInstanceOf[OrcMap[_ &lt;: WritableComparable[_], _ &lt;: WritableComparable[_]]]</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L360">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L362">        val map = new java.util.HashMap[AnyRef, AnyRef](value.size())</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        value.asScala.foreach { case (k, v) =&gt; map.put(keyConverter.convert(k), valueConverter.convert(v)) }</span>
<span class="nc" id="L364">        sf.setAttribute(attribute, map)</span>
      }
    }
  }

  trait ConvertInputFormatValue {
    def convert(input: AnyRef): AnyRef
  }

<span class="nc" id="L373">  trait InputFormatReaderAdapter extends OrcInputFormatReader with ConvertInputFormatValue {</span>
    def col: Int
    def attribute: Int
    override def apply(input: OrcStruct, sf: SimpleFeature): Unit = {
<span class="nc" id="L377">      val field = input.getFieldValue(col)</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">      if (field == null) {</span>
<span class="nc" id="L379">        sf.setAttribute(attribute, null)</span>
      } else {
<span class="nc" id="L381">        sf.setAttribute(attribute, convert(field))</span>
      }
    }
  }

<span class="nc" id="L386">  trait ConvertInputFormatDate extends ConvertInputFormatValue {</span>
<span class="nc" id="L387">    override def convert(input: AnyRef): java.util.Date = new java.util.Date(input.asInstanceOf[OrcTimestamp].getTime)</span>
  }

<span class="nc" id="L390">  trait ConvertInputFormatString extends ConvertInputFormatValue {</span>
<span class="nc" id="L391">    override def convert(input: AnyRef): String = input.asInstanceOf[Text].toString</span>
  }

<span class="nc" id="L394">  trait ConvertInputFormatInt extends ConvertInputFormatValue {</span>
<span class="nc" id="L395">    override def convert(input: AnyRef): java.lang.Integer = Int.box(input.asInstanceOf[IntWritable].get())</span>
  }

<span class="nc" id="L398">  trait ConvertInputFormatLong extends ConvertInputFormatValue {</span>
<span class="nc" id="L399">    override def convert(input: AnyRef): java.lang.Long = Long.box(input.asInstanceOf[LongWritable].get())</span>
  }

<span class="nc" id="L402">  trait ConvertInputFormatFloat extends ConvertInputFormatValue {</span>
<span class="nc" id="L403">    override def convert(input: AnyRef): java.lang.Float = Float.box(input.asInstanceOf[FloatWritable].get())</span>
  }

<span class="nc" id="L406">  trait ConvertInputFormatDouble extends ConvertInputFormatValue {</span>
<span class="nc" id="L407">    override def convert(input: AnyRef): java.lang.Double = Double.box(input.asInstanceOf[DoubleWritable].get())</span>
<span class="nc" id="L408">    def convertUnboxed(input: AnyRef): Double = input.asInstanceOf[DoubleWritable].get()</span>
  }

<span class="nc" id="L411">  trait ConvertInputFormatBoolean extends ConvertInputFormatValue {</span>
<span class="nc" id="L412">    override def convert(input: AnyRef): java.lang.Boolean = Boolean.box(input.asInstanceOf[BooleanWritable].get())</span>
  }

<span class="nc" id="L415">  trait ConvertInputFormatBytes extends ConvertInputFormatValue {</span>
<span class="nc" id="L416">    override def convert(input: AnyRef): Array[Byte] = input.asInstanceOf[BytesWritable].copyBytes()</span>
  }

<span class="nc" id="L419">  trait ConvertInputFormatUuid extends ConvertInputFormatValue {</span>
<span class="nc" id="L420">    override def convert(input: AnyRef): UUID = UUID.fromString(input.asInstanceOf[Text].toString)</span>
  }

  /**
    * Gets a converter instance
    *
    * @param binding binding
    * @return
    */
  private def getConverter(binding: ObjectType): ConvertInputFormatValue = {
<span class="nc" id="L430">    binding match {</span>
<span class="nc bnc" id="L431" title="All 6 branches missed.">      case ObjectType.DATE     =&gt; new ConvertInputFormatDate {}</span>
<span class="nc bnc" id="L432" title="All 6 branches missed.">      case ObjectType.STRING   =&gt; new ConvertInputFormatString {}</span>
<span class="nc bnc" id="L433" title="All 6 branches missed.">      case ObjectType.INT      =&gt; new ConvertInputFormatInt {}</span>
<span class="nc bnc" id="L434" title="All 6 branches missed.">      case ObjectType.LONG     =&gt; new ConvertInputFormatLong {}</span>
<span class="nc bnc" id="L435" title="All 6 branches missed.">      case ObjectType.FLOAT    =&gt; new ConvertInputFormatFloat {}</span>
<span class="nc bnc" id="L436" title="All 6 branches missed.">      case ObjectType.DOUBLE   =&gt; new ConvertInputFormatDouble {}</span>
<span class="nc bnc" id="L437" title="All 6 branches missed.">      case ObjectType.BOOLEAN  =&gt; new ConvertInputFormatBoolean {}</span>
<span class="nc bnc" id="L438" title="All 6 branches missed.">      case ObjectType.BYTES    =&gt; new ConvertInputFormatBytes {}</span>
<span class="nc bnc" id="L439" title="All 6 branches missed.">      case ObjectType.UUID     =&gt; new ConvertInputFormatUuid {}</span>
<span class="nc" id="L440">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unexpected object type $binding&quot;)</span>
    }
  }
<span class="nc" id="L443">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>