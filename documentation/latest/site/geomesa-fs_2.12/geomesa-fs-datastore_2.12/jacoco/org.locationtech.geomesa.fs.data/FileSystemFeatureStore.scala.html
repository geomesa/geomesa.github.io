<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileSystemFeatureStore.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.data</a> &gt; <span class="el_source">FileSystemFeatureStore.scala</span></div><h1>FileSystemFeatureStore.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.data

import com.github.benmanes.caffeine.cache.{CacheLoader, Caffeine, RemovalCause, RemovalListener}
import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.data.{FeatureReader, FeatureWriter, Query, QueryCapabilities}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.data.simple.DelegateSimpleFeatureReader
import org.geotools.data.store.{ContentEntry, ContentFeatureStore}
import org.geotools.feature.collection.DelegateSimpleFeatureIterator
import org.geotools.geometry.jts.ReferencedEnvelope
import org.locationtech.geomesa.features.ScalaSimpleFeature
import org.locationtech.geomesa.fs.data.FileSystemFeatureStore._
import org.locationtech.geomesa.fs.storage.api.FileSystemStorage.FileSystemWriter
import org.locationtech.geomesa.fs.storage.api.{CloseableFeatureIterator, FileSystemStorage}
import org.locationtech.geomesa.index.geotools.{GeoMesaFeatureWriter, FastSettableFeatureWriter}
import org.locationtech.geomesa.index.utils.ThreadManagement.{LowLevelScanner, ManagedScan, Timeout}
import org.locationtech.geomesa.utils.io.{CloseQuietly, CloseWithLogging, FlushQuietly, FlushWithLogging}

import java.io.{Closeable, Flushable}
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong
import scala.concurrent.duration.Duration

<span class="nc bnc" id="L33" title="All 4 branches missed.">class FileSystemFeatureStore(</span>
<span class="nc" id="L34">    val storage: FileSystemStorage,</span>
    entry: ContentEntry,
    query: Query,
<span class="nc" id="L37">    readThreads: Int,</span>
<span class="nc" id="L38">    writeTimeout: Duration,</span>
<span class="nc" id="L39">    queryTimeout: Option[Duration],</span>
<span class="nc" id="L40">  ) extends ContentFeatureStore(entry, query) with LazyLogging {</span>

<span class="nc" id="L42">  private val sft = storage.metadata.sft</span>

  override def getWriterInternal(query: Query, flags: Int): FeatureWriter[SimpleFeatureType, SimpleFeature] = {
    // note: check update first as sometimes we get ADD | UPDATE
<span class="nc bnc" id="L46" title="All 2 branches missed.">    if ((flags &amp; WRITER_UPDATE) == WRITER_UPDATE) {</span>
<span class="nc" id="L47">      new FileSystemFeatureWriterModify(storage, sft, query.getFilter, readThreads)</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">    } else if ((flags &amp; WRITER_ADD) == WRITER_ADD) {</span>
<span class="nc" id="L49">      new FileSystemFeatureWriterAppend(storage, sft, writeTimeout)</span>
    } else {
<span class="nc" id="L51">      throw new IllegalArgumentException(s&quot;Expected one of $WRITER_ADD or $WRITER_UPDATE, but got: $flags&quot;)</span>
    }
  }

<span class="nc" id="L55">  override def buildFeatureType(): SimpleFeatureType = sft</span>

  override def getBoundsInternal(query: Query): ReferencedEnvelope = {
<span class="nc" id="L58">    val envelope = new ReferencedEnvelope(org.locationtech.geomesa.utils.geotools.CRS_EPSG_4326)</span>
<span class="nc" id="L59">    storage.getPartitions(query.getFilter).foreach { partition =&gt;</span>
<span class="nc" id="L60">      partition.bounds.foreach(b =&gt; envelope.expandToInclude(b.envelope))</span>
    }
<span class="nc" id="L62">    envelope</span>
  }

  override def getCountInternal(query: Query): Int =
<span class="nc" id="L66">    storage.getPartitions(query.getFilter).map(_.count).sum.toInt</span>

  override def getReaderInternal(original: Query): FeatureReader[SimpleFeatureType, SimpleFeature] = {
    import org.locationtech.geomesa.index.conf.QueryHints._

<span class="nc" id="L71">    val query = new Query(original)</span>
    // The type name can sometimes be empty such as Query.ALL
<span class="nc" id="L73">    query.setTypeName(sft.getTypeName)</span>

<span class="nc" id="L75">    val reader = queryTimeout match {</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">      case None =&gt; storage.getReader(query, threads = readThreads)</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      case Some(timeout) =&gt;</span>
<span class="nc bnc" id="L78" title="All 6 branches missed.">        val filter = Option(query.getFilter).filter(_ != Filter.INCLUDE)</span>
<span class="nc" id="L79">        new ManagedScan(new FileSystemScanner(storage, query, readThreads), Timeout(timeout), query.getTypeName, filter)</span>
    }
    // get a closeable java iterator that DelegateSimpleFeatureIterator will process correctly
<span class="nc" id="L82">    val iter = new FileSystemFeatureIterator(reader)</span>

    // transforms will be set after getting the iterator
<span class="nc" id="L85">    val transformSft = query.getHints.getTransformSchema.getOrElse(sft)</span>

    // note: DelegateSimpleFeatureIterator will close the iterator by checking that it implements Closeable
<span class="nc" id="L88">    new DelegateSimpleFeatureReader(transformSft, new DelegateSimpleFeatureIterator(iter))</span>
  }

<span class="nc" id="L91">  override def canLimit: Boolean = false</span>
<span class="nc" id="L92">  override def canLimit(query: Query): Boolean = false</span>
<span class="nc" id="L93">  override def canTransact: Boolean = false</span>
<span class="nc" id="L94">  override def canEvent: Boolean = false</span>
<span class="nc" id="L95">  override def canReproject: Boolean = false</span>
<span class="nc" id="L96">  override def canSort: Boolean = false</span>
<span class="nc" id="L97">  override def canSort(query: Query): Boolean = false</span>
<span class="nc" id="L98">  override def canFilter: Boolean = true</span>
<span class="nc" id="L99">  override def canFilter(query: Query): Boolean = true</span>
<span class="nc" id="L100">  override def canRetype: Boolean = true</span>
<span class="nc" id="L101">  override def canRetype(query: Query): Boolean = true</span>

<span class="nc" id="L103">  override protected def buildQueryCapabilities(): QueryCapabilities = FileSystemFeatureStore.capabilities</span>
}

<span class="nc" id="L106">object FileSystemFeatureStore {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L110">  private val capabilities = new QueryCapabilities() {</span>
<span class="nc" id="L111">    override def isReliableFIDSupported: Boolean = true</span>
<span class="nc" id="L112">    override def isUseProvidedFIDSupported: Boolean = true</span>
  }

<span class="nc" id="L115">  private class FileSystemScanner(storage: FileSystemStorage, val query: Query, threads: Int)</span>
<span class="nc" id="L116">      extends LowLevelScanner[SimpleFeature] {</span>

<span class="nc" id="L118">    private var reader: CloseableFeatureIterator = _</span>

    override def iterator: Iterator[SimpleFeature] = synchronized {
<span class="nc" id="L121">      reader = storage.getReader(query, threads = threads)</span>
<span class="nc" id="L122">      reader</span>
    }
    override def close(): Unit = synchronized {
<span class="nc bnc" id="L125" title="All 2 branches missed.">      if (reader != null) {</span>
<span class="nc" id="L126">        reader.close()</span>
      }
    }
  }

  /**
    * Iterator for querying file system storage
    *
    * Note: implements Closeable and not AutoCloseable so that DelegateFeatureIterator will close it properly
    *
    * @param iter delegate iterator
    */
<span class="nc" id="L138">  class FileSystemFeatureIterator(iter: CloseableFeatureIterator)</span>
<span class="nc" id="L139">      extends java.util.Iterator[SimpleFeature] with Closeable {</span>
<span class="nc" id="L140">    override def hasNext: Boolean = iter.hasNext</span>
<span class="nc" id="L141">    override def next(): SimpleFeature = iter.next()</span>
<span class="nc" id="L142">    override def close(): Unit = iter.close()</span>
  }

  /**
    * Appending feature writer
    *
    * @param storage storage instance
    * @param sft simple feature type
    * @param timeout write timeout, for flushing partitions
    */
<span class="nc bnc" id="L152" title="All 4 branches missed.">  class FileSystemFeatureWriterAppend(storage: FileSystemStorage, sft: SimpleFeatureType, timeout: Duration)</span>
<span class="nc" id="L153">      extends FastSettableFeatureWriter with LazyLogging {</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">    private val removalListener = new RemovalListener[String, Closeable with Flushable]() {</span>
      override def onRemoval(key: String, value: Closeable with Flushable, cause: RemovalCause): Unit = {
<span class="nc bnc" id="L157" title="All 6 branches missed.">        if (cause == RemovalCause.EXPIRED) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">          logger.info(s&quot;Flushing writer for partition: $key&quot;)</span>
<span class="nc" id="L159">          FlushWithLogging(value)</span>
<span class="nc" id="L160">          CloseWithLogging(value)</span>
        }
      }
    }

<span class="nc" id="L165">    private val writers =</span>
<span class="nc" id="L166">      Caffeine.newBuilder()</span>
<span class="nc" id="L167">        .expireAfterAccess(timeout.toMillis, TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L168">        .removalListener[String, FileSystemWriter](removalListener)</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        .build(new CacheLoader[String, FileSystemWriter]() {</span>
<span class="nc" id="L170">          override def load(partition: String): FileSystemWriter = storage.getWriter(partition)</span>
        })

<span class="nc" id="L173">    private val featureIds = new AtomicLong(0)</span>
<span class="nc" id="L174">    private var feature: ScalaSimpleFeature = _</span>

<span class="nc" id="L176">    override def getFeatureType: SimpleFeatureType = sft</span>

<span class="nc" id="L178">    override def hasNext: Boolean = false</span>

    override def next(): ScalaSimpleFeature = {
<span class="nc" id="L181">      feature = new ScalaSimpleFeature(sft, featureIds.getAndIncrement().toString)</span>
<span class="nc" id="L182">      feature</span>
    }

    override def write(): Unit = {
<span class="nc" id="L186">      val sf = GeoMesaFeatureWriter.featureWithFid(feature)</span>
<span class="nc" id="L187">      writers.get(storage.metadata.scheme.getPartitionName(sf)).write(sf)</span>
<span class="nc" id="L188">      feature = null</span>
    }

<span class="nc" id="L191">    override def remove(): Unit = throw new IllegalArgumentException(&quot;This writer is append only&quot;)</span>

    override def close(): Unit = {
<span class="nc" id="L194">      val values = writers.asMap().values().asScala.toSeq</span>
<span class="nc" id="L195">      val flush = FlushQuietly(values)</span>
<span class="nc" id="L196">      CloseQuietly(values) match {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        case None =&gt; flush.foreach(e =&gt; throw e)</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        case Some(e) =&gt; flush.foreach(e.addSuppressed); throw e</span>
      }
    }
  }

  /**
    * Modifying feature writer
    *
    * @param storage instance
    * @param sft simple feature type
    * @param filter query filter
    * @param readThreads read threads
    */
<span class="nc bnc" id="L211" title="All 4 branches missed.">  class FileSystemFeatureWriterModify(</span>
      storage: FileSystemStorage,
<span class="nc" id="L213">      sft: SimpleFeatureType,</span>
      filter: Filter,
      readThreads: Int
<span class="nc" id="L216">    ) extends FeatureWriter[SimpleFeatureType, SimpleFeature] with LazyLogging {</span>

<span class="nc" id="L218">    private val writer = storage.getWriter(filter, threads = readThreads)</span>

<span class="nc" id="L220">    override def getFeatureType: SimpleFeatureType = sft</span>

<span class="nc" id="L222">    override def hasNext: Boolean = writer.hasNext</span>
    // TODO implement ScalaSimpleFeatureWriter and wire ScalaSimpleFeature all the way through
<span class="nc" id="L224">    override def next(): SimpleFeature = writer.next()</span>
<span class="nc" id="L225">    override def write(): Unit = writer.write()</span>
<span class="nc" id="L226">    override def remove(): Unit = writer.remove()</span>
<span class="nc" id="L227">    override def close(): Unit = writer.close()</span>
  }
<span class="nc" id="L229">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>