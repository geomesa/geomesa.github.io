<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileSystemDataStore.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.data</a> &gt; <span class="el_source">FileSystemDataStore.scala</span></div><h1>FileSystemDataStore.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.data

import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.fs.{FileSystem, Path}
import org.geotools.api.data.Query
import org.geotools.api.feature.`type`.Name
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.data.store.{ContentDataStore, ContentEntry, ContentFeatureSource}
import org.locationtech.geomesa.fs.data.FileSystemDataStore.FileSystemDataStoreConfig
import org.locationtech.geomesa.fs.storage.api._
import org.locationtech.geomesa.fs.storage.common.StorageKeys
import org.locationtech.geomesa.fs.storage.common.metadata.FileBasedMetadata
import org.locationtech.geomesa.fs.storage.common.utils.PathCache
import org.locationtech.geomesa.index.stats.RunnableStats.UnoptimizedRunnableStats
import org.locationtech.geomesa.index.stats.{GeoMesaStats, HasGeoMesaStats}
import org.locationtech.geomesa.utils.geotools.SimpleFeatureTypes
import org.locationtech.geomesa.utils.index.GeoMesaSchemaValidator
import org.locationtech.geomesa.utils.io.CloseQuietly

import scala.concurrent.duration.Duration
import scala.util.control.NonFatal

/**
 * File system data store
 *
 * @param fs file system - note, this is expected to be a shared resource, and is not cleaned up on data store dispose
 * @param config config
 */
<span class="nc bnc" id="L38" title="All 4 branches missed.">class FileSystemDataStore(fs: FileSystem, config: FileSystemDataStoreConfig)</span>
<span class="nc" id="L39">    extends ContentDataStore with HasGeoMesaStats with LazyLogging {</span>

<span class="nc" id="L41">  config.namespace.foreach(setNamespaceURI)</span>

<span class="nc" id="L43">  private val manager = FileSystemStorageManager(fs, config.conf, config.root, config.namespace)</span>

<span class="nc" id="L45">  override val stats: GeoMesaStats = new UnoptimizedRunnableStats(this)</span>

  override def createTypeNames(): java.util.List[Name] = {
<span class="nc" id="L48">    val names = new java.util.ArrayList[Name]()</span>
<span class="nc" id="L49">    manager.storages().foreach(storage =&gt; names.add(storage.metadata.sft.getName))</span>
<span class="nc" id="L50">    names</span>
  }

  override def createSchema(original: SimpleFeatureType): Unit = {
    import org.locationtech.geomesa.fs.storage.common.RichSimpleFeatureType

<span class="nc" id="L56">    manager.storage(original.getTypeName) match {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">      case Some(s) =&gt;</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        logger.warn(s&quot;Schema already exists: ${SimpleFeatureTypes.encodeType(s.metadata.sft, includeUserData = true)}&quot;)</span>

<span class="nc bnc" id="L60" title="All 2 branches missed.">      case None =&gt;</span>
        // copy the feature type so that we don't affect it when removing user data, below
<span class="nc" id="L62">        val sft = SimpleFeatureTypes.copy(original)</span>

<span class="nc" id="L64">        GeoMesaSchemaValidator.validate(sft)</span>

        // remove the configs in the user data as they're persisted separately
<span class="nc" id="L67">        val meta = sft.removeMetadata().getOrElse(FileBasedMetadata.DefaultOptions)</span>
<span class="nc" id="L68">        val scheme = sft.removeScheme().getOrElse {</span>
<span class="nc" id="L69">          throw new IllegalArgumentException(&quot;Partition scheme must be specified in the SimpleFeatureType user data&quot;)</span>
        }
<span class="nc" id="L71">        val encoding = sft.removeEncoding().orElse(config.defaultEncoding).getOrElse {</span>
<span class="nc" id="L72">          throw new IllegalArgumentException(&quot;Encoding type must be specified in either &quot; +</span>
              &quot;the SimpleFeatureType user data or the data store parameters&quot;)
        }
<span class="nc" id="L75">        val leafStorage = sft.removeLeafStorage().getOrElse {</span>
<span class="nc" id="L76">          val deprecated = scheme.options.get(&quot;leaf-storage&quot;).map { s =&gt;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">            logger.warn(&quot;Using deprecated leaf-storage partition-scheme option. Please define leaf-storage using &quot; +</span>
<span class="nc" id="L78">                s&quot;&quot;&quot;`simpleFeatureType.getUserData.put(&quot;${StorageKeys.LeafStorageKey}&quot;, &quot;$s&quot;)`&quot;&quot;&quot;)</span>
<span class="nc" id="L79">            s.toBoolean</span>
          }
<span class="nc" id="L81">          deprecated.getOrElse(true)</span>
        }
<span class="nc" id="L83">        val fileSize = sft.removeTargetFileSize()</span>

<span class="nc" id="L85">        val path = manager.defaultPath(sft.getTypeName)</span>
<span class="nc" id="L86">        val context = FileSystemContext(fs, config.conf, path, config.namespace)</span>

        val metadata =
<span class="nc" id="L89">          StorageMetadataFactory.create(context, meta, Metadata(sft, encoding, scheme, leafStorage, fileSize))</span>
<span class="nc" id="L90">        try { manager.register(path, FileSystemStorageFactory(context, metadata)) } catch {</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">          case NonFatal(e) =&gt; CloseQuietly(metadata).foreach(e.addSuppressed); throw e</span>
        }
<span class="nc" id="L93">        PathCache.register(fs, config.root)</span>
<span class="nc" id="L94">        PathCache.register(fs, path)</span>
    }
  }

  override def createFeatureSource(entry: ContentEntry): ContentFeatureSource = {
<span class="nc" id="L99">    val storage = this.storage(entry.getTypeName)</span>
<span class="nc" id="L100">    new FileSystemFeatureStore(storage, entry, Query.ALL, config.readThreads, config.writeTimeout, config.queryTimeout)</span>
  }

  /**
    * Get a handle on the underlying storage instance for a given simple feature type
    *
    * @param typeName simple feature type name
    * @return
    */
<span class="nc" id="L109">  def storage(typeName: String): FileSystemStorage = manager.storage(typeName).getOrElse {</span>
<span class="nc" id="L110">    throw new IllegalArgumentException(s&quot;Schema '$typeName' doesn't exist or could not be loaded&quot;)</span>
  }
}

<span class="nc" id="L114">object FileSystemDataStore {</span>
<span class="nc bnc" id="L115" title="All 56 branches missed.">  case class FileSystemDataStoreConfig(</span>
<span class="nc" id="L116">    conf: Configuration,</span>
<span class="nc" id="L117">    root: Path,</span>
<span class="nc" id="L118">    readThreads: Int,</span>
<span class="nc" id="L119">    writeTimeout: Duration,</span>
<span class="nc" id="L120">    queryTimeout: Option[Duration],</span>
<span class="nc" id="L121">    defaultEncoding: Option[String],</span>
<span class="nc" id="L122">    namespace: Option[String],</span>
  )
<span class="nc" id="L124">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>