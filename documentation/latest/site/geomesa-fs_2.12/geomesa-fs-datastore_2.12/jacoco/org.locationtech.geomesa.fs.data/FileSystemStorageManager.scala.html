<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileSystemStorageManager.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem DataStore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.data</a> &gt; <span class="el_source">FileSystemStorageManager.scala</span></div><h1>FileSystemStorageManager.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.data

import com.github.benmanes.caffeine.cache.{CacheLoader, Caffeine}
import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.fs.{FileSystem, Path}
import org.locationtech.geomesa.fs.storage.api._
import org.locationtech.geomesa.fs.storage.common.utils.PathCache
import org.locationtech.geomesa.utils.io.CloseQuietly

import java.util.concurrent.ConcurrentHashMap
import scala.util.control.NonFatal

/**
  * Manages the storages and associated simple feature types underneath a given path
  *
  * @param fs file system
  * @param conf configuration
  * @param root root path for the data store
  */
<span class="nc bnc" id="L29" title="All 4 branches missed.">class FileSystemStorageManager private (fs: FileSystem, conf: Configuration, root: Path, namespace: Option[String])</span>
<span class="nc" id="L30">    extends LazyLogging {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L34">  private val cache = new ConcurrentHashMap[String, (Path, FileSystemStorage)]().asScala</span>

  /**
    * Gets the storage associated with the given simple feature type, if any
    *
    * @param typeName simple feature type name
    * @return
    */
  def storage(typeName: String): Option[FileSystemStorage] = {
<span class="nc" id="L43">    cache.get(typeName).map(_._2) // check cached values</span>
<span class="nc" id="L44">        .orElse(Some(defaultPath(typeName)).filter(PathCache.exists(fs, _)).flatMap(loadPath)) // check expected (default) path</span>
<span class="nc bnc" id="L45" title="All 6 branches missed.">        .orElse(loadAll().find(_.metadata.sft.getTypeName == typeName)) // check other paths until we find it</span>
  }

  /**
    * Gets all storages under the root path
    *
    * @return
    */
  def storages(): Seq[FileSystemStorage] = {
<span class="nc" id="L54">    loadAll().foreach(_ =&gt; ()) // force loading of everything</span>
<span class="nc bnc" id="L55" title="All 4 branches missed.">    cache.map { case (_, (_, storage)) =&gt; storage }.toSeq</span>
  }

  /**
    * Caches a storage instance for future use. Avoids loading it a second time if referenced later.
    *
    * @param path path for the storage
    * @param storage storage instance
    */
  def register(path: Path, storage: FileSystemStorage): Unit =
<span class="nc" id="L65">    cache.put(storage.metadata.sft.getTypeName, (path, storage))</span>

  /**
    * Default path for a given simple feature type name. Generally the simple feature type will go under
    * a folder with the type name, but this is not required
    *
    * @param typeName simple feature type name
    * @return
    */
<span class="nc" id="L74">  def defaultPath(typeName: String): Path = new Path(root, typeName)</span>

  /**
    * Loads all storages under this root (if they aren't already loaded)
    *
    * @return
    */
  private def loadAll(): Iterator[FileSystemStorage] = {
<span class="nc bnc" id="L82" title="All 2 branches missed.">    if (!PathCache.exists(fs, root)) { Iterator.empty } else {</span>
<span class="nc" id="L83">      val dirs = PathCache.list(fs, root).filter(_.isDirectory).map(_.getPath)</span>
<span class="nc bnc" id="L84" title="All 10 branches missed.">      dirs.filterNot(path =&gt; cache.exists { case (_, (p, _)) =&gt; p == path }).flatMap(loadPath)</span>
    }
  }

  /**
    * Attempt to load a storage under the given root path. Requires an appropriate storage implementation
    * to be available on the classpath.
    *
    * @param path storage root path
    * @return
    */
  private def loadPath(path: Path): Option[FileSystemStorage] = {
<span class="nc" id="L96">    val start = System.nanoTime()</span>
<span class="nc" id="L97">    val context = FileSystemContext(fs, conf, path, namespace)</span>
<span class="nc" id="L98">    val storage = StorageMetadataFactory.load(context).map { meta =&gt;</span>
<span class="nc" id="L99">      try {</span>
<span class="nc" id="L100">        val storage = FileSystemStorageFactory(context, meta)</span>
<span class="nc" id="L101">        register(path, storage)</span>
<span class="nc" id="L102">        storage</span>
      } catch {
<span class="nc bnc" id="L104" title="All 2 branches missed.">        case NonFatal(e) =&gt; CloseQuietly(meta).foreach(e.addSuppressed); throw e</span>
      }
    }
<span class="nc bnc" id="L107" title="All 2 branches missed.">    logger.debug(</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">      s&quot;${ if (storage.isDefined) &quot;Loaded&quot; else &quot;No&quot; } storage at path '$path' in ${(System.nanoTime() - start) / 1000000L}ms&quot;)</span>
<span class="nc" id="L109">    storage</span>
  }
}

<span class="nc" id="L113">object FileSystemStorageManager {</span>

<span class="nc" id="L115">  private val cache = Caffeine.newBuilder().build(</span>
<span class="nc" id="L116">    new CacheLoader[(FileSystem, Configuration, Path, Option[String]), FileSystemStorageManager]() {</span>
      override def load(key: (FileSystem, Configuration, Path, Option[String])): FileSystemStorageManager =
<span class="nc" id="L118">        new FileSystemStorageManager(key._1, key._2, key._3, key._4)</span>
    }
  )

  /**
    * Load a cached storage manager instance
    *
    * @param fs file system
    * @param conf configuration
    * @param root data store root path
    * @return
    */
  def apply(fs: FileSystem, conf: Configuration, root: Path, namespace: Option[String]): FileSystemStorageManager =
<span class="nc" id="L131">    cache.get((fs, conf, root, namespace))</span>
<span class="nc" id="L132">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>