<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FsManageMetadataCommand.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa FileSystem Tools</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.fs.tools.ingest</a> &gt; <span class="el_source">FsManageMetadataCommand.scala</span></div><h1>FsManageMetadataCommand.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.fs.tools.ingest

import com.beust.jcommander.converters.BaseConverter
import com.beust.jcommander.validators.PositiveInteger
import com.beust.jcommander.{Parameter, ParameterException, Parameters}
import com.typesafe.scalalogging.LazyLogging
import org.apache.hadoop.fs.{FileStatus, RemoteIterator}
import org.locationtech.geomesa.fs.storage.api.FileSystemStorage
import org.locationtech.geomesa.fs.storage.api.StorageMetadata.{PartitionBounds, PartitionMetadata, StorageFile}
import org.locationtech.geomesa.fs.storage.common.metadata.{FileBasedMetadataFactory, MetadataJson}
import org.locationtech.geomesa.fs.storage.common.utils.StorageUtils
import org.locationtech.geomesa.fs.tools.FsDataStoreCommand
import org.locationtech.geomesa.fs.tools.FsDataStoreCommand.{FsParams, PartitionParam}
import org.locationtech.geomesa.fs.tools.ingest.FsManageMetadataCommand.CheckConsistencyCommand.ConsistencyChecker
import org.locationtech.geomesa.fs.tools.ingest.FsManageMetadataCommand._
import org.locationtech.geomesa.tools.utils.Prompt
import org.locationtech.geomesa.tools.{Command, CommandWithSubCommands, OptionalForceParam, RequiredTypeNameParam}
import org.locationtech.geomesa.utils.concurrent.{CachedThreadPool, PhaserUtils}
import org.locationtech.geomesa.utils.io.WithClose
import org.locationtech.jts.geom.Envelope

import java.io.{Closeable, FileNotFoundException}
import java.util
import java.util.concurrent.{ConcurrentHashMap, Phaser}
import scala.collection.mutable.ArrayBuffer
import scala.util.control.NonFatal

<span class="nc" id="L36">class FsManageMetadataCommand extends CommandWithSubCommands {</span>
<span class="nc" id="L37">  override val name: String = &quot;manage-metadata&quot;</span>
<span class="nc" id="L38">  override val params = new ManageMetadataParams</span>
<span class="nc" id="L39">  override val subCommands: Seq[Command] =</span>
<span class="nc" id="L40">    Seq(new CompactCommand(), new RegisterCommand(), new UnregisterCommand(), new CheckConsistencyCommand())</span>
}

<span class="nc" id="L43">object FsManageMetadataCommand {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L47">  class CompactCommand extends FsDataStoreCommand {</span>

<span class="nc" id="L49">    override val name = &quot;compact&quot;</span>
<span class="nc" id="L50">    override val params = new CompactParams</span>

<span class="nc" id="L52">    override def execute(): Unit = withDataStore { ds =&gt;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">      Command.user.info(&quot;Compacting metadata, please wait...&quot;)</span>
<span class="nc" id="L54">      val metadata = ds.storage(params.featureName).metadata</span>
<span class="nc" id="L55">      metadata.compact(None, None, params.threads)</span>
<span class="nc" id="L56">      val partitions = metadata.getPartitions()</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">      Command.user.info(s&quot;Compacted metadata into ${partitions.length} partitions consisting of &quot; +</span>
<span class="nc" id="L58">          s&quot;${partitions.map(_.files.size).sum} files&quot;)</span>
    }
  }

<span class="nc" id="L62">  class RegisterCommand extends FsDataStoreCommand {</span>

<span class="nc" id="L64">    override val name = &quot;register&quot;</span>
<span class="nc" id="L65">    override val params = new RegisterParams</span>

<span class="nc" id="L67">    override def execute(): Unit = withDataStore { ds =&gt;</span>
<span class="nc" id="L68">      val metadata = ds.storage(params.featureName).metadata</span>
<span class="nc" id="L69">      val files = params.files.asScala.map(StorageFile(_, System.currentTimeMillis()))</span>
<span class="nc" id="L70">      val count = Option(params.count).map(_.longValue()).getOrElse(0L)</span>
<span class="nc" id="L71">      val bounds = new Envelope</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">      Option(params.bounds).foreach { case (xmin, ymin, xmax, ymax) =&gt;</span>
<span class="nc" id="L73">        bounds.expandToInclude(xmin, ymin)</span>
<span class="nc" id="L74">        bounds.expandToInclude(xmax, ymax)</span>
      }
<span class="nc" id="L76">      metadata.addPartition(PartitionMetadata(params.partition, files.toSeq, PartitionBounds(bounds), count))</span>
<span class="nc" id="L77">      val partition = metadata.getPartition(params.partition).getOrElse(PartitionMetadata(&quot;&quot;, Seq.empty, None, 0L))</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">      Command.user.info(s&quot;Registered ${params.files.size} new files. Updated partition: ${partition.files.size} &quot; +</span>
<span class="nc" id="L79">          s&quot;files containing ${partition.count} known features&quot;)</span>
    }
  }

<span class="nc" id="L83">  class UnregisterCommand extends FsDataStoreCommand {</span>

<span class="nc" id="L85">    override val name = &quot;unregister&quot;</span>
<span class="nc" id="L86">    override val params = new UnregisterParams</span>

<span class="nc" id="L88">    override def execute(): Unit = withDataStore { ds =&gt;</span>
<span class="nc" id="L89">      val metadata = ds.storage(params.featureName).metadata</span>
<span class="nc" id="L90">      val files = params.files.asScala.map(StorageFile(_, 0L))</span>
<span class="nc" id="L91">      val count = Option(params.count).map(_.longValue()).getOrElse(0L)</span>
<span class="nc" id="L92">      metadata.removePartition(PartitionMetadata(params.partition, files.toSeq, None, count))</span>
<span class="nc" id="L93">      val partition = metadata.getPartition(params.partition).getOrElse(PartitionMetadata(&quot;&quot;, Seq.empty, None, 0L))</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      Command.user.info(s&quot;Unregistered ${params.files.size} files. Updated partition: ${partition.files.size} &quot; +</span>
<span class="nc" id="L95">          s&quot;files containing ${partition.count} known features&quot;)</span>
    }
  }

<span class="nc bnc" id="L99" title="All 4 branches missed.">  class CheckConsistencyCommand extends FsDataStoreCommand with LazyLogging {</span>

<span class="nc" id="L101">    override val name = &quot;check-consistency&quot;</span>
<span class="nc" id="L102">    override val params = new CheckConsistencyParams()</span>

    override def validate(): Option[ParameterException] = {
<span class="nc bnc" id="L105" title="All 4 branches missed.">      if (params.repair &amp;&amp; params.rebuild) {</span>
<span class="nc" id="L106">        Some(new ParameterException(&quot;Please specify at most one of --repair and --rebuild&quot;))</span>
      } else {
<span class="nc" id="L108">        None</span>
      }
    }

    override def execute(): Unit = {
<span class="nc bnc" id="L113" title="All 4 branches missed.">      if (params.rebuild &amp;&amp; !params.partitions.isEmpty) {</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        Command.user.warn(</span>
<span class="nc" id="L115">          s&quot;Rebuilding all metadata using only ${params.partitions.size} partitions - &quot; +</span>
<span class="nc" id="L116">              &quot;metadata will not exist for any other partitions&quot;)</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">        if (!params.force &amp;&amp; !Prompt.confirm(&quot;Continue (y/n)? &quot;)) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">          Command.user.info(&quot;Cancelling operation&quot;)</span>
<span class="nc" id="L119">          return</span>
        }
      }

<span class="nc" id="L123">      withDataStore { ds =&gt;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        Command.user.info(&quot;Checking consistency, please wait...&quot;)</span>
<span class="nc" id="L125">        val storage = ds.storage(params.featureName)</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">        val partitions = Option(params.partitions).collect { case p if !p.isEmpty =&gt; p.asScala.toSeq }</span>
<span class="nc" id="L127">        WithClose(new ConsistencyChecker(storage, partitions, params.rebuild, params.repair, params.threads))(_.run())</span>
      }
    }
  }

<span class="nc" id="L132">  object CheckConsistencyCommand {</span>

<span class="nc bnc" id="L134" title="All 4 branches missed.">    class ConsistencyChecker(</span>
<span class="nc" id="L135">        storage: FileSystemStorage,</span>
<span class="nc" id="L136">        partitions: Option[Seq[String]],</span>
<span class="nc" id="L137">        rebuild: Boolean,</span>
<span class="nc" id="L138">        repair: Boolean,</span>
        threads: Int
<span class="nc" id="L140">      ) extends Runnable with Closeable with LazyLogging {</span>

<span class="nc" id="L142">      private val pool = new CachedThreadPool(threads)</span>
<span class="nc" id="L143">      private val onDisk = new ConcurrentHashMap[String, ConcurrentHashMap[String, Boolean]]()</span>

<span class="nc" id="L145">      private val computeFunction = new java.util.function.Function[String, ConcurrentHashMap[String, Boolean]] {</span>
<span class="nc" id="L146">        override def apply(t: String): ConcurrentHashMap[String, Boolean] = new ConcurrentHashMap[String, Boolean]()</span>
      }

      override def run(): Unit = {
<span class="nc" id="L150">        storage.metadata.invalidate() // invalidate any cached state</span>

        // list out the files currently in the root directory, results go into onDisk
<span class="nc" id="L153">        listRoot()</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (rebuild) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">          val (count, partitions) = buildPartitionConfigs()</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">          Command.user.info(s&quot;Setting metadata to ${partitions.length} partitions containing $count data files...&quot;)</span>
<span class="nc" id="L158">          storage.metadata.setPartitions(partitions)</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">          Command.user.info(&quot;Done&quot;)</span>
        } else {
<span class="nc" id="L161">          val inconsistencies = scala.collection.mutable.Map.empty[String, ArrayBuffer[Inconsistency]]</span>
<span class="nc" id="L162">          var inconsistentCount = 0</span>

          // compare the files known to the metadata to the ones on disk
<span class="nc" id="L165">          storage.metadata.getPartitions().foreach { partition =&gt;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (partitions.forall(_.contains(partition.name))) {</span>
<span class="nc" id="L167">              val checked = scala.collection.mutable.Set.empty[String]</span>
<span class="nc" id="L168">              val partitionOnDisk = onDisk.getOrDefault(partition.name, new ConcurrentHashMap[String, Boolean]())</span>
<span class="nc" id="L169">              partition.files.foreach { file =&gt;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                if (partitionOnDisk.remove(file.name)) {</span>
                  // metadata and file are consistent
<span class="nc" id="L172">                  checked.add(file.name)</span>
                  // TODO if (params.analyze) {} // update metadata
                } else {
<span class="nc" id="L175">                  val buf = inconsistencies.getOrElseUpdate(partition.name, ArrayBuffer.empty)</span>
                  // file is missing from metadata vs file in in metadata more than once
<span class="nc bnc" id="L177" title="All 2 branches missed.">                  val duplicate = !checked.add(file.name)</span>
<span class="nc" id="L178">                  buf += Inconsistency(file, duplicate)</span>
<span class="nc" id="L179">                  inconsistentCount += 1</span>
                }
              }
<span class="nc bnc" id="L182" title="All 2 branches missed.">              if (partitionOnDisk.isEmpty) {</span>
<span class="nc" id="L183">                onDisk.remove(partition.name)</span>
              }
            }
          }

<span class="nc bnc" id="L188" title="All 4 branches missed.">          if (onDisk.isEmpty &amp;&amp; inconsistencies.isEmpty) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            Command.user.info(&quot;No inconsistencies detected&quot;)</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">          } else if (repair) {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            if (inconsistencies.nonEmpty) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">              Command.user.info(s&quot;Removing $inconsistentCount inconsistent metadata references...&quot;)</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">              inconsistencies.foreach { case (partition, files) =&gt;</span>
<span class="nc" id="L194">                storage.metadata.removePartition(PartitionMetadata(partition, files.map(_.file).toSeq, None, 0L))</span>
              }
<span class="nc bnc" id="L196" title="All 2 branches missed.">              Command.user.info(&quot;Done&quot;)</span>
            }
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (!onDisk.isEmpty) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">              val (count, partitions) = buildPartitionConfigs()</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">              Command.user.info(s&quot;Registering $count missing metadata references...&quot;)</span>
<span class="nc" id="L201">              partitions.foreach(storage.metadata.addPartition)</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">              Command.user.info(&quot;Done&quot;)</span>
            }
            // TODO if (params.analyze) {} // update metadata
          } else {
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (!onDisk.isEmpty) {</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">              lazy val strings = onDisk.asScala.toSeq.flatMap { case (partition, files) =&gt;</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                files.asScala.map { case (f, _) =&gt; s&quot;$partition,$f&quot; }</span>
              }
<span class="nc bnc" id="L210" title="All 2 branches missed.">              Command.user.warn(s&quot;Found ${strings.length} data files that do not have metadata entries:&quot;)</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">              Command.output.info(strings.sorted.mkString(&quot;  &quot;, &quot;\n  &quot;, &quot;&quot;))</span>
            }
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (inconsistencies.nonEmpty) {</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">              lazy val strings = inconsistencies.toSeq.flatMap { case (p, buf) =&gt;</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">                buf.map { case Inconsistency(f, d) =&gt; s&quot;$p,${if (d) { &quot;duplicate&quot; } else { &quot;missing&quot; }},${f.name}&quot; }</span>
              }
<span class="nc bnc" id="L217" title="All 2 branches missed.">              Command.user.warn(s&quot;Found $inconsistentCount metadata entries that do not correspond to a data file:&quot;)</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">              Command.output.info(strings.sorted.mkString(&quot;  &quot;, &quot;\n  &quot;, &quot;&quot;))</span>
            }
          }
        }
      }

<span class="nc" id="L224">      override def close(): Unit = pool.shutdown()</span>

      /**
       * List the files in the root directory. Excludes known file-based metadata files. Results are
       * added to onDisk
       */
      private def listRoot(): Unit = {
<span class="nc" id="L231">        val iter = storage.context.fs.listStatusIterator(storage.context.root)</span>
        // use a phaser to track worker thread completion
<span class="nc" id="L233">        val phaser = new Phaser(2) // 1 for this thread + 1 for the worker</span>
<span class="nc" id="L234">        pool.submit(new TopLevelListWorker(phaser, iter))</span>
        // wait for the worker threads to complete
<span class="nc" id="L236">        phaser.awaitAdvanceInterruptibly(phaser.arrive())</span>
      }

      private def buildPartitionConfigs(): (Int, Seq[PartitionMetadata]) = {
<span class="nc" id="L240">        var count = 0</span>
<span class="nc" id="L241">        val partitions = Seq.newBuilder[PartitionMetadata]</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        onDisk.asScala.foreach { case (partition, files) =&gt;</span>
<span class="nc" id="L243">          val update = Seq.newBuilder[StorageFile]</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">          files.asScala.foreach { case (name, _) =&gt;</span>
<span class="nc" id="L245">            update += StorageFile(name, System.currentTimeMillis())</span>
<span class="nc" id="L246">            count += 1</span>
          }
<span class="nc" id="L248">          partitions += PartitionMetadata(partition, update.result, None, 0L)</span>
        }
<span class="nc" id="L250">        (count, partitions.result)</span>
      }

<span class="nc bnc" id="L253" title="All 2 branches missed.">      private class TopLevelListWorker(phaser: Phaser, list: RemoteIterator[FileStatus]) extends Runnable {</span>
        override def run(): Unit = {
          try {
<span class="nc" id="L256">            var i = phaser.getRegisteredParties + 1</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">            while (list.hasNext &amp;&amp; i &lt; PhaserUtils.MaxParties) {</span>
<span class="nc" id="L258">              val status = list.next</span>
<span class="nc" id="L259">              val path = status.getPath</span>
<span class="nc" id="L260">              val name = path.getName</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">              if (status.isDirectory) {</span>
<span class="nc bnc" id="L262" title="All 6 branches missed.">                if (name != FileBasedMetadataFactory.MetadataDirectory &amp;&amp;</span>
<span class="nc bnc" id="L263" title="All 10 branches missed.">                    partitions.forall(_.exists(p =&gt; p == name || p.startsWith(s&quot;$name/&quot;)))) {</span>
<span class="nc" id="L264">                  i += 1</span>
                  // use a tiered phaser on each directory avoid the limit of 65535 registered parties
<span class="nc" id="L266">                  pool.submit(new ListWorker(new Phaser(phaser, 1), name, storage.context.fs.listStatusIterator(path)))</span>
                }
<span class="nc bnc" id="L268" title="All 6 branches missed.">              } else if (name != MetadataJson.MetadataPath) {</span>
<span class="nc" id="L269">                onDisk.computeIfAbsent(&quot;&quot;, computeFunction).put(name, java.lang.Boolean.TRUE)</span>
              }
            }
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (list.hasNext) {</span>
<span class="nc" id="L273">              pool.submit(new TopLevelListWorker(new Phaser(phaser, 1), list))</span>
            }
          } finally {
<span class="nc" id="L276">            phaser.arriveAndDeregister()</span>
          }
        }
      }

<span class="nc bnc" id="L281" title="All 2 branches missed.">      private class ListWorker(phaser: Phaser, partition: String, listDirectory: =&gt; RemoteIterator[FileStatus])</span>
<span class="nc" id="L282">          extends Runnable {</span>
        override def run(): Unit = {
<span class="nc" id="L284">          try {</span>
<span class="nc" id="L285">            var i = phaser.getRegisteredParties + 1</span>
<span class="nc" id="L286">            val iter = listDirectory</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">            while (iter.hasNext &amp;&amp; i &lt; PhaserUtils.MaxParties) {</span>
<span class="nc" id="L288">              val status = iter.next</span>
<span class="nc" id="L289">              val path = status.getPath</span>
<span class="nc" id="L290">              val name = path.getName</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">              if (status.isDirectory) {</span>
<span class="nc" id="L292">                val nextPartition = s&quot;$partition/$name&quot;</span>
<span class="nc bnc" id="L293" title="All 10 branches missed.">                if (partitions.forall(_.exists(p =&gt; p == nextPartition || p.startsWith(s&quot;$nextPartition/&quot;)))) {</span>
<span class="nc" id="L294">                  i += 1</span>
                  // use a tiered phaser on each directory avoid the limit of 65535 registered parties
<span class="nc" id="L296">                  pool.submit(new ListWorker(new Phaser(phaser, 1), nextPartition, storage.context.fs.listStatusIterator(path)))</span>
                }
              } else {
                val leafPartition =
<span class="nc bnc" id="L300" title="All 2 branches missed.">                  if (storage.metadata.leafStorage) { s&quot;$partition/${StorageUtils.leaf(name)}&quot; } else { partition }</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if (partitions.forall(_.contains(leafPartition))) {</span>
<span class="nc" id="L302">                  onDisk.computeIfAbsent(leafPartition, computeFunction).put(name, java.lang.Boolean.TRUE)</span>
                }
              }
            }
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (iter.hasNext) {</span>
<span class="nc" id="L307">              pool.submit(new ListWorker(new Phaser(phaser, 1), partition, iter))</span>
            }
          } catch {
<span class="nc bnc" id="L310" title="All 2 branches missed.">            case _: FileNotFoundException =&gt; // the partition dir was deleted... just return</span>
<span class="nc bnc" id="L311" title="All 4 branches missed.">            case NonFatal(e) =&gt; logger.error(&quot;Error scanning metadata directory:&quot;, e)</span>
          } finally {
<span class="nc" id="L313">            phaser.arriveAndDeregister() // notify that this thread is done</span>
          }
        }
      }
    }

<span class="nc bnc" id="L319" title="All 23 branches missed.">    private case class Inconsistency(file: StorageFile, duplicate: Boolean)</span>
  }

<span class="nc" id="L322">  @Parameters(commandDescription = &quot;Manage the metadata for a storage instance&quot;)</span>
  class ManageMetadataParams

<span class="nc" id="L325">  @Parameters(commandDescription = &quot;Compact the metadata for a storage instance&quot;)</span>
<span class="nc" id="L326">  class CompactParams extends FsParams with RequiredTypeNameParam {</span>
    @Parameter(names = Array(&quot;-t&quot;, &quot;--threads&quot;), description = &quot;Number of threads to use for compaction&quot;)
<span class="nc" id="L328">    var threads: Integer = 4</span>
  }

  @Parameters(commandDescription = &quot;Register new data files with a storage instance&quot;)
<span class="nc" id="L332">  class RegisterParams extends FsParams with RequiredTypeNameParam {</span>
    @Parameter(names = Array(&quot;--partition&quot;), description = &quot;Partition to update&quot;, required = true)
<span class="nc" id="L334">    var partition: String = _</span>

    @Parameter(names = Array(&quot;--files&quot;), description = &quot;Names of the files to register, must already exist in the appropriate partition folder&quot;, required = true, variableArity = true)
<span class="nc" id="L337">    var files: java.util.List[String] = new util.ArrayList[String]()</span>

    @Parameter(names = Array(&quot;--bounds&quot;), description = &quot;Geographic bounds of the data files being registered, in the form xmin,ymin,xmax,ymax&quot;, required = false, converter = classOf[BoundsConverter])
<span class="nc" id="L340">    var bounds: (Double, Double, Double, Double) = _</span>

    @Parameter(names = Array(&quot;--count&quot;), description = &quot;Number of features in the data files being registered&quot;, required = false)
<span class="nc" id="L343">    var count: java.lang.Long = _</span>
  }

  @Parameters(commandDescription = &quot;Unregister data files from a storage instance&quot;)
<span class="nc" id="L347">  class UnregisterParams extends FsParams with RequiredTypeNameParam {</span>
    @Parameter(names = Array(&quot;--partition&quot;), description = &quot;Partition to update&quot;, required = true)
<span class="nc" id="L349">    var partition: String = _</span>

    @Parameter(names = Array(&quot;--files&quot;), description = &quot;Names of the files to unregister, must already exist in the appropriate partition folder&quot;, required = true, variableArity = true)
<span class="nc" id="L352">    var files: java.util.List[String] = new util.ArrayList[String]()</span>

    @Parameter(names = Array(&quot;--count&quot;), description = &quot;Number of features in the data files being unregistered&quot;, required = false)
<span class="nc" id="L355">    var count: java.lang.Long = _</span>
  }

  @Parameters(commandDescription = &quot;Check consistency between metadata and data files&quot;)
<span class="nc" id="L359">  class CheckConsistencyParams</span>
<span class="nc" id="L360">      extends FsParams with RequiredTypeNameParam with PartitionParam with OptionalForceParam {</span>

    @Parameter(names = Array(&quot;--repair&quot;), description = &quot;Update metadata based on consistency check&quot;)
<span class="nc" id="L363">    var repair: java.lang.Boolean = false</span>

    @Parameter(names = Array(&quot;--rebuild&quot;), description = &quot;Replace all current metadata from the data files&quot;)
<span class="nc" id="L366">    var rebuild: java.lang.Boolean = false</span>

    // TODO GEOMESA-2963
    // @Parameter(names = Array(&quot;--analyze&quot;), description = &quot;Rebuild file data statistics (may be slow)&quot;)
    // var analyze: java.lang.Boolean = false

    @Parameter(
      names = Array(&quot;-t&quot;, &quot;--threads&quot;),
      description = &quot;Number of concurrent threads to use&quot;,
      validateWith = Array(classOf[PositiveInteger]))
<span class="nc" id="L376">    var threads: Integer = 4</span>
  }

<span class="nc" id="L379">  class BoundsConverter(name: String) extends BaseConverter[(Double, Double, Double, Double)](name) {</span>
    override def convert(value: String): (Double, Double, Double, Double) = {
<span class="nc" id="L381">      try {</span>
<span class="nc bnc" id="L382" title="All 6 branches missed.">        val Array(xmin, ymin, xmax, ymax) = value.split(&quot;,&quot;).map(_.trim.toDouble)</span>
<span class="nc" id="L383">        (xmin, ymin, xmax, ymax)</span>
      } catch {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        case NonFatal(e) =&gt; throw new ParameterException(getErrorString(value, s&quot;format: $e&quot;))</span>
      }
    }
  }
<span class="nc" id="L389">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>