<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RegistryFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Metrics Micrometer</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.metrics.micrometer</a> &gt; <span class="el_source">RegistryFactory.scala</span></div><h1>RegistryFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.metrics.micrometer

import com.typesafe.config.{Config, ConfigFactory}
import com.typesafe.scalalogging.StrictLogging
import io.micrometer.core.instrument.{MeterRegistry, Metrics}

import java.io.Closeable
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import scala.util.Try

/**
 * Factory for creating registries from config
 */
trait RegistryFactory {

  /**
   * Well-known name of this registry
   *
   * @return
   */
  def name: String

  /**
   * Create a registry using the default configuration
   *
   * @return
   */
  def apply(): MeterRegistry

  /**
   * Create a registry
   *
   * @param conf config
   * @return
   */
  def apply(conf: Config): MeterRegistry

  /**
   * Register with this instance, which will ensure the registry managed by this instance
   * is added to the global metrics registry, until the returned object is closed
   */
  def register(): Closeable

  /**
   * Register using the given config
   *
   * @param conf registry config
   * @return
   */
  def register(conf: Config): Closeable
}

<span class="nc" id="L62">object RegistryFactory {</span>

  // identifiers for our registry factories
  // note that we keep these here to avoid a runtime dependency on any unused registries
<span class="nc" id="L66">  val Cloudwatch = &quot;cloudwatch&quot;</span>
<span class="nc" id="L67">  val Prometheus = &quot;prometheus&quot;</span>

  /**
   * Factory for creating registries from config
   *
   * @param name Well-known name of this registry
   */
<span class="nc" id="L74">  abstract class BaseRegistryFactory(val name: String) extends RegistryFactory with StrictLogging {</span>

<span class="nc" id="L76">    private val registrations = new ConcurrentHashMap[Config, RegistryHolder]()</span>

<span class="nc" id="L78">    private val default: Config = ConfigFactory.load(name)</span>

    /**
     * Create a registry using the default configuration
     *
     * @return
     */
<span class="nc" id="L85">    override def apply(): MeterRegistry = apply(default)</span>

    /**
     * Create a registry
     *
     * @param conf config
     * @return
     */
    override def apply(conf: Config): MeterRegistry = {
<span class="nc bnc" id="L94" title="All 2 branches missed.">      logger.info(s&quot;Creating $name registry&quot;)</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">      createRegistry(if (conf.eq(default)) { conf } else { conf.withFallback(default) })</span>
    }

    /**
     * Register with this instance, which will ensure the registry managed by this instance
     * is added to the global metrics registry, until the returned object is closed
     */
<span class="nc" id="L102">    override def register(): Closeable = register(default)</span>

    /**
     * Register using the given config
     *
     * @param conf registry config
     * @return
     */
    override def register(conf: Config): Closeable =
<span class="nc bnc" id="L111" title="All 2 branches missed.">      registrations.computeIfAbsent(if (conf.eq(default)) { conf } else { conf.withFallback(default) }, new RegistryHolder(_)).register()</span>

    /**
     * Create a new registry
     *
     * @param config conf
     * @return
     */
    protected def createRegistry(config: Config): MeterRegistry

    /**
     * Holds references to a registry
     *
     * @param conf registry config
     */
<span class="nc bnc" id="L126" title="All 2 branches missed.">    private class RegistryHolder(conf: Config) {</span>

<span class="nc" id="L128">      private var registry: MeterRegistry = _</span>
<span class="nc" id="L129">      private var count = 0</span>

      /**
       * Register a consumer of the registry held by this object
       *
       * @return a handle to the registration, call `close()` to deregister
       */
      def register(): Closeable = synchronized {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">          logger.info(s&quot;Creating $name registry&quot;)</span>
<span class="nc" id="L139">          registry = createRegistry(conf)</span>
<span class="nc" id="L140">          Metrics.addRegistry(registry)</span>
<span class="nc" id="L141">          Instrumentations.bind(conf)</span>
        }
<span class="nc" id="L143">        count += 1</span>
<span class="nc" id="L144">        new Deregistration()</span>
      }

      /**
       * Deregister the lock, called internally when a registration is closed
       */
      private def deregister(): Unit = synchronized {
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (count == 1) {</span>
<span class="nc" id="L152">          Metrics.removeRegistry(registry)</span>
<span class="nc" id="L153">          Try(registry.close())</span>
<span class="nc" id="L154">          registry = null</span>
        }
<span class="nc" id="L156">        count -= 1</span>
      }

      /**
       * Registration holder that ensures only a single `deregister` is called per `register`
       */
<span class="nc bnc" id="L162" title="All 2 branches missed.">      private class Deregistration extends Closeable {</span>

<span class="nc" id="L164">        private val closed = new AtomicBoolean(false)</span>

        override def close(): Unit = {
          // ensure we only deregister once
<span class="nc bnc" id="L168" title="All 2 branches missed.">          if (closed.compareAndSet(false, true)) {</span>
<span class="nc" id="L169">            deregister()</span>
          }
        }
      }
    }
<span class="nc" id="L174">  }</span>
<span class="nc" id="L175">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>