<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MetricsDataSource.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Metrics Micrometer</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.metrics.micrometer.dbcp2</a> &gt; <span class="el_source">MetricsDataSource.scala</span></div><h1>MetricsDataSource.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.metrics.micrometer.dbcp2

import org.apache.commons.dbcp2._
import org.apache.commons.pool2.impl.{AbandonedConfig, GenericObjectPool, GenericObjectPoolConfig}

import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

/**
 * Extension of commons-dbcp data source that works with micrometer/prometheus metrics.
 * See https://github.com/micrometer-metrics/micrometer/issues/2593 for reference.
 *
 * We skip the standard jmx exposure in BasicDataSource, because we only want to register the connection pool,
 * otherwise gauges don't register correctly due to jmx name overlap.
 *
 * BasicDataSource registers jmx mbeans in at least 3 places:
 *  - itself, using the `jmxName` set by the user
 *  - its GenericObjectPool, using `config.getJmxNameBase` + `config.getJmxNamePrefix`
 *  - connections created with its PoolableConnectionFactory, using &quot;jmxName&quot; + &quot;,connectionpool=connections,connection=&quot; + `i`
 *
 * Micrometer's CommonsObjectPool2Metrics tries to register anything with the jmx name prefix 'org.apache.commons.pool2:'. It uses
 * the `name` attribute in the jmx name for a tag, and it tries to read `getFactoryType` from the underlying object as a tag.
 * It exposes pool-related values from the jmx objects (e.g. NumIdle, etc) as metrics.
 *
 * The only thing that makes sense to instrument with those values is the GenericObjectPool. Thus, we skip jmx registration for
 * this data source and the underlying connections. Indeed, since the metric name is based on the jmx name, and the metric
 * value is pulled from the object itself, registering the datasource or connections will break the metric since the object
 * doesn't have the expected pool methods.
 *
 * Note: short-lived data sources may cause error logs like `ERROR CommonsObjectPool2Metrics: can not set name tag` due to
 * already being removed from the mbean server by the time the jmx listener fires.
 */
<span class="nc" id="L41">class MetricsDataSource(jmxNamePrefix: String = &quot;dbcp&quot;) extends BasicDataSource {</span>

  // in order for gauges to work correctly, we need unique metrics tags based on the name
  // the pool will increment names until it finds one that isn't registered, but if a datasource is closed it will deregister,
  // causing a potential name conflict
  // instead we track them here with an incrementing counter
<span class="nc" id="L47">  val jmxName: String = MetricsDataSource.getUniqueName(jmxNamePrefix)</span>

  override protected def createObjectPool(
      factory: PoolableConnectionFactory,
      poolConfig: GenericObjectPoolConfig[PoolableConnection],
      abandonedConfig: AbandonedConfig): GenericObjectPool[PoolableConnection] = {
<span class="nc" id="L53">    poolConfig.setJmxEnabled(true)</span>
<span class="nc" id="L54">    poolConfig.setJmxNameBase(MetricsDataSource.NameBase)</span>
<span class="nc" id="L55">    poolConfig.setJmxNamePrefix(jmxName)</span>
<span class="nc" id="L56">    super.createObjectPool(factory, poolConfig, abandonedConfig)</span>
  }

  /**
   * Register this pool with JMX in order to expose metrics. Not thread safe.
   */
  @deprecated(&quot;Registration happens automatically&quot;)
<span class="nc" id="L63">  def registerJmx(): Unit = {}</span>
}

<span class="nc" id="L66">object MetricsDataSource {</span>

  // required for micrometer metrics:
  //  - prefix must be `org.apache.commons.pool2`
  //  - type must be either `GenericObjectPool` or `GenericKeyedObjectPool`
<span class="nc" id="L71">  private val NameBase =</span>
<span class="nc" id="L72">    s&quot;org.apache.commons.pool2:type=GenericObjectPool${Constants.JMX_CONNECTION_POOL_BASE_EXT}${Constants.JMX_CONNECTION_POOL_PREFIX},name=&quot;</span>

<span class="nc" id="L74">  private val nameCounters = new ConcurrentHashMap[String, AtomicInteger]()</span>

  private def getUniqueName(base: String): String = {
<span class="nc" id="L77">    val i = nameCounters.computeIfAbsent(base, _ =&gt; new AtomicInteger(0)).getAndIncrement()</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">    if (i == 0) { base } else { s&quot;$base$i&quot; }</span>
  }
<span class="nc" id="L80">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>