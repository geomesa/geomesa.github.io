<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedisDataStoreFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Redis Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.redis.data</a> &gt; <span class="el_source">RedisDataStoreFactory.scala</span></div><h1>RedisDataStoreFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.redis.data

import com.typesafe.scalalogging.LazyLogging
import org.apache.commons.pool2.impl.GenericObjectPoolConfig
import org.geotools.api.data.DataAccessFactory.Param
import org.geotools.api.data.{DataStore, DataStoreFactorySpi}
import org.locationtech.geomesa.index.audit.AuditWriter
import org.locationtech.geomesa.index.audit.AuditWriter.AuditLogger
import org.locationtech.geomesa.index.geotools.GeoMesaDataStore
import org.locationtech.geomesa.index.geotools.GeoMesaDataStoreFactory.{DataStoreQueryConfig, GeoMesaDataStoreConfig, GeoMesaDataStoreInfo, MetricsConfig}
import org.locationtech.geomesa.redis.data.index.RedisAgeOff
import org.locationtech.geomesa.security.{AuthUtils, AuthorizationsProvider}
import org.locationtech.geomesa.utils.audit.AuditProvider
import org.locationtech.geomesa.utils.geotools.GeoMesaParam
import redis.clients.jedis._
import redis.clients.jedis.util.{JedisURIHelper, Pool}

import java.awt.RenderingHints
import java.net.URI
import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

<span class="nc bnc" id="L31" title="All 4 branches missed.">class RedisDataStoreFactory extends DataStoreFactorySpi with LazyLogging {</span>

  import org.locationtech.geomesa.redis.data.RedisDataStoreParams._

<span class="nc" id="L35">  override def createNewDataStore(params: java.util.Map[String, _]): DataStore = createDataStore(params)</span>

  override def createDataStore(params: java.util.Map[String, _]): DataStore = {
<span class="nc" id="L38">    val connection = RedisDataStoreFactory.buildConnection(params)</span>
<span class="nc" id="L39">    val config = RedisDataStoreFactory.buildConfig(params)</span>
<span class="nc" id="L40">    val ds = new RedisDataStore(connection, config)</span>
<span class="nc" id="L41">    GeoMesaDataStore.initRemoteVersion(ds)</span>
<span class="nc" id="L42">    RedisAgeOff.init(ds)</span>
<span class="nc" id="L43">    ds</span>
  }

<span class="nc" id="L46">  override def isAvailable = true</span>

<span class="nc" id="L48">  override def getDisplayName: String = RedisDataStoreFactory.DisplayName</span>

<span class="nc" id="L50">  override def getDescription: String = RedisDataStoreFactory.Description</span>

<span class="nc" id="L52">  override def getParametersInfo: Array[Param] = Array(RedisDataStoreFactory.ParameterInfo :+ NamespaceParam: _*)</span>

  override def canProcess(params: java.util.Map[String, _]): Boolean =
<span class="nc" id="L55">    RedisDataStoreFactory.canProcess(params)</span>

<span class="nc" id="L57">  override def getImplementationHints: java.util.Map[RenderingHints.Key, _] = null</span>
}

<span class="nc bnc" id="L60" title="All 4 branches missed.">object RedisDataStoreFactory extends GeoMesaDataStoreInfo with LazyLogging {</span>

  import org.locationtech.geomesa.redis.data.RedisDataStoreParams._

<span class="nc" id="L64">  override val DisplayName = &quot;Redis (GeoMesa)&quot;</span>
<span class="nc" id="L65">  override val Description = &quot;Redis\u2122 distributed memory store&quot;</span>

<span class="nc" id="L67">  override val ParameterInfo: Array[GeoMesaParam[_ &lt;: AnyRef]] =</span>
<span class="nc" id="L68">    Array(</span>
<span class="nc" id="L69">      RedisUrlParam,</span>
<span class="nc" id="L70">      RedisCatalogParam,</span>
<span class="nc" id="L71">      RedisClusterParam,</span>
<span class="nc" id="L72">      PoolSizeParam,</span>
<span class="nc" id="L73">      SocketTimeoutParam,</span>
<span class="nc" id="L74">      QueryThreadsParam,</span>
<span class="nc" id="L75">      QueryTimeoutParam,</span>
<span class="nc" id="L76">      PipelineParam,</span>
<span class="nc" id="L77">      TestConnectionParam,</span>
<span class="nc" id="L78">      GenerateStatsParam,</span>
<span class="nc" id="L79">      AuditQueriesParam,</span>
<span class="nc" id="L80">      MetricsRegistryParam,</span>
<span class="nc" id="L81">      MetricsRegistryConfigParam,</span>
<span class="nc" id="L82">      LooseBBoxParam,</span>
<span class="nc" id="L83">      PartitionParallelScansParam,</span>
<span class="nc" id="L84">      AuthsParam,</span>
<span class="nc" id="L85">      AuthProviderParam,</span>
    )

  override def canProcess(params: java.util.Map[String, _]): Boolean =
<span class="nc" id="L89">    RedisCatalogParam.exists(params)</span>

  /**
    * Builds a redis connection from the data store parameters
    *
    * @param params params
    * @return
    */
  def buildConnection(params: java.util.Map[String, _]): Pool[_ &lt;: CloseableJedisCommands] = {
<span class="nc" id="L98">    ConnectionPoolParam.lookupOpt(params).getOrElse {</span>
<span class="nc" id="L99">      RedisClusterParam.lookup(params).booleanValue() match {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        case false =&gt;</span>
          val uri = {
<span class="nc" id="L102">            val urls = RedisUrlParam.lookup(params).split(&quot;,&quot;)</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (urls.length &gt; 1) {</span>
<span class="nc" id="L104">              throw new IllegalArgumentException(</span>
<span class="nc" id="L105">                &quot;Multiple Redis URLs can only be used in cluster mode. Set 'redis.clusterMode' to true.&quot;)</span>
            }
<span class="nc" id="L107">            val url = urls.headOption.getOrElse {</span>
<span class="nc" id="L108">              throw new IllegalArgumentException(&quot;No Redis URL provided. Please set 'redis.url'&quot;)</span>
            }
            // if there is no protocol/port, or the url is a valid redis url, use as is
            // else use the redis:// protocol to support databases, etc
            val parsed =
<span class="nc bnc" id="L113" title="All 2 branches missed.">              if (url.indexOf(&quot;:&quot;) == -1) {</span>
<span class="nc" id="L114">                Try(new URI(url))</span>
              } else {
<span class="nc" id="L116">                parse(url).orElse(parse(s&quot;redis://$url&quot;))</span>
              }
<span class="nc" id="L118">            parsed match {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">              case Success(uri) =&gt; uri</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">              case Failure(e) =&gt;</span>
<span class="nc" id="L121">                throw new IllegalArgumentException(s&quot;Could not create valid Redis connection URI from: $url&quot;, e)</span>
            }
          }
<span class="nc" id="L124">          val config = new GenericObjectPoolConfig[Jedis]()</span>
<span class="nc" id="L125">          PoolSizeParam.lookupOpt(params).foreach(s =&gt; config.setMaxTotal(s.intValue()))</span>
<span class="nc" id="L126">          config.setTestOnBorrow(TestConnectionParam.lookup(params))</span>
<span class="nc" id="L127">          val timeout = SocketTimeoutParam.lookup(params).toMillis.toInt</span>

<span class="nc" id="L129">          new JedisPool(config, uri, timeout)</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        case true =&gt;</span>
<span class="nc" id="L131">          val urls = RedisUrlParam.lookup(params).split(&quot;,&quot;)</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">          if (urls.isEmpty) {</span>
<span class="nc" id="L133">            throw new IllegalArgumentException(&quot;No Redis URLs provided. Please set 'redis.url'&quot;)</span>
          }
<span class="nc" id="L135">          val uri = URI.create(urls.head)</span>
<span class="nc" id="L136">          val objectPoolConfig = new GenericObjectPoolConfig[Connection]()</span>
<span class="nc" id="L137">          PoolSizeParam.lookupOpt(params).foreach(s =&gt; objectPoolConfig.setMaxTotal(s.intValue()))</span>
<span class="nc" id="L138">          objectPoolConfig.setTestOnBorrow(TestConnectionParam.lookup(params))</span>
<span class="nc" id="L139">          val timeout = SocketTimeoutParam.lookup(params).toMillis.toInt</span>

          val clusterNodes: java.util.Set[HostAndPort] =
<span class="nc" id="L142">            urls.map { url =&gt;</span>
<span class="nc" id="L143">              val parsed = parse(url).getOrElse {</span>
<span class="nc" id="L144">                throw new IllegalArgumentException(s&quot;Could not create valid Redis connection URI from: $url&quot;)</span>
              }
<span class="nc" id="L146">              JedisURIHelper.getHostAndPort(parsed)</span>
<span class="nc" id="L147">            }.toSet.asJava</span>
          val jedisClientConfig: JedisClientConfig =
<span class="nc" id="L149">            DefaultJedisClientConfig.builder.connectionTimeoutMillis(timeout)</span>
<span class="nc" id="L150">              .socketTimeoutMillis(timeout)</span>
<span class="nc" id="L151">              .blockingSocketTimeoutMillis(0)</span>
<span class="nc" id="L152">              .user(JedisURIHelper.getUser(uri))</span>
<span class="nc" id="L153">              .password(JedisURIHelper.getPassword(uri))</span>
<span class="nc" id="L154">              .database(JedisURIHelper.getDBIndex(uri))</span>
<span class="nc" id="L155">              .clientName(null)</span>
              .build
<span class="nc" id="L157">          new SingletonJedisClusterPool(clusterNodes, jedisClientConfig, objectPoolConfig)</span>
      }
    }
  }

  /**
    * Builds configuration from data store parameters
    *
    * @param params params
    * @return
    */
  def buildConfig(params: java.util.Map[String, _]): RedisDataStoreConfig = {
<span class="nc" id="L169">    val catalog = RedisCatalogParam.lookup(params)</span>
<span class="nc" id="L170">    val generateStats = GenerateStatsParam.lookup(params)</span>
<span class="nc" id="L171">    val pipeline = PipelineParam.lookup(params)</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">    val audit = if (!AuditQueriesParam.lookup(params)) { None } else {</span>
<span class="nc" id="L174">      Some(new AuditLogger(&quot;redis&quot;, AuditProvider.Loader.loadOrNone(params)))</span>
    }
<span class="nc" id="L176">    val metrics = MetricsRegistryParam.lookupRegistry(params)</span>
    // get the auth params passed in as a comma-delimited string
<span class="nc" id="L178">    val authProvider = AuthUtils.getProvider(params,</span>
<span class="nc" id="L179">      AuthsParam.lookupOpt(params).map(_.split(&quot;,&quot;).toSeq.filterNot(_.isEmpty)).getOrElse(Seq.empty))</span>

<span class="nc" id="L181">    val queries = RedisQueryConfig(</span>
<span class="nc" id="L182">      threads = QueryThreadsParam.lookup(params),</span>
<span class="nc" id="L183">      timeout = QueryTimeoutParam.lookupOpt(params).map(_.toMillis),</span>
<span class="nc" id="L184">      looseBBox = LooseBBoxParam.lookup(params).booleanValue(),</span>
<span class="nc" id="L185">      parallelPartitionScans = PartitionParallelScansParam.lookup(params)</span>
    )

<span class="nc" id="L188">    val ns = Option(NamespaceParam.lookUp(params).asInstanceOf[String])</span>

<span class="nc" id="L190">    RedisDataStoreConfig(catalog, generateStats, authProvider, audit, metrics, queries, pipeline, ns)</span>
  }

<span class="nc" id="L193">  private def parse(url: String): Try[URI] = Try(new URI(url)).filter(JedisURIHelper.isValid)</span>

<span class="nc bnc" id="L195" title="All 63 branches missed.">  case class RedisDataStoreConfig(</span>
<span class="nc" id="L196">      catalog: String,</span>
<span class="nc" id="L197">      generateStats: Boolean,</span>
<span class="nc" id="L198">      authProvider: AuthorizationsProvider,</span>
<span class="nc" id="L199">      audit: Option[AuditWriter],</span>
<span class="nc" id="L200">      metrics: Option[MetricsConfig],</span>
<span class="nc" id="L201">      queries: RedisQueryConfig,</span>
<span class="nc" id="L202">      pipeline: Boolean,</span>
<span class="nc" id="L203">      namespace: Option[String]</span>
<span class="nc" id="L204">    ) extends GeoMesaDataStoreConfig</span>

<span class="nc bnc" id="L206" title="All 31 branches missed.">  case class RedisQueryConfig(</span>
<span class="nc" id="L207">      threads: Int,</span>
<span class="nc" id="L208">      timeout: Option[Long],</span>
<span class="nc" id="L209">      looseBBox: Boolean,</span>
<span class="nc" id="L210">      parallelPartitionScans: Boolean</span>
<span class="nc" id="L211">    ) extends DataStoreQueryConfig</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>