<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedisQueryPlan.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Redis Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.redis.data.index</a> &gt; <span class="el_source">RedisQueryPlan.scala</span></div><h1>RedisQueryPlan.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.redis.data
package index

import org.geotools.api.feature.simple.SimpleFeature
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.filter.FilterHelper
import org.locationtech.geomesa.index.api.QueryPlan.{FeatureReducer, QueryStrategyPlan, ResultsToFeatures}
import org.locationtech.geomesa.index.api.{BoundedByteRange, QueryStrategy}
import org.locationtech.geomesa.index.planning.LocalQueryRunner.{LocalProcessor, LocalProcessorPlan}
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.index.utils.Reprojection.QueryReferenceSystems
import org.locationtech.geomesa.redis.data.index.RedisIndexAdapter.RedisResultsToFeatures
import org.locationtech.geomesa.redis.data.util.RedisBatchScan
import org.locationtech.geomesa.utils.collection.CloseableIterator
import org.locationtech.geomesa.utils.io.WithClose
import redis.clients.jedis.{Jedis, Response, UnifiedJedis}

import java.nio.charset.StandardCharsets

<span class="nc" id="L28">sealed trait RedisQueryPlan extends QueryStrategyPlan {</span>

  override type Results = SimpleFeature

  /**
    * Tables being scanned
    *
    * @return
    */
  def tables: Seq[String]

  /**
    * Ranges being scanned
    *
    * @return
    */
  def ranges: Seq[BoundedByteRange]

<span class="nc" id="L46">  override def explain(explainer: Explainer): Unit = RedisQueryPlan.explain(this, explainer)</span>

<span class="nc" id="L48">  protected def moreExplaining(explainer: Explainer): Unit = {}</span>
}

<span class="nc" id="L51">object RedisQueryPlan {</span>

  def explain(plan: RedisQueryPlan, explainer: Explainer): Unit = {
<span class="nc" id="L54">    explainer.pushLevel(s&quot;Plan: ${plan.getClass.getSimpleName}&quot;)</span>
<span class="nc" id="L55">    explainer(s&quot;Tables: ${plan.tables.mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L56">    explainer(s&quot;Ranges (${plan.ranges.size}): ${plan.ranges.take(5).map(rangeToString).mkString(&quot;, &quot;)}&quot;)</span>
<span class="nc" id="L57">    plan.moreExplaining(explainer)</span>
<span class="nc" id="L58">    explainer(s&quot;Reduce: ${plan.reducer.getOrElse(&quot;none&quot;)}&quot;)</span>
<span class="nc" id="L59">    explainer.popLevel()</span>
  }

  private [data] def rangeToString(range: BoundedByteRange): String = {
    // based on accumulo's byte representation
    def printable(b: Byte): String = {
<span class="nc" id="L65">      val c = 0xff &amp; b</span>
<span class="nc bnc" id="L66" title="All 4 branches missed.">      if (c &gt;= 32 &amp;&amp; c &lt;= 126) { c.toChar.toString } else { f&quot;%%$c%02x;&quot; }</span>
    }
<span class="nc" id="L68">    s&quot;[${range.lower.map(printable).mkString(&quot;&quot;)}::${range.upper.map(printable).mkString(&quot;&quot;)}]&quot;</span>
  }

  // plan that will not actually scan anything
<span class="nc bnc" id="L72" title="All 25 branches missed.">  case class EmptyPlan(strategy: QueryStrategy, reducer: Option[FeatureReducer] = None) extends RedisQueryPlan {</span>
<span class="nc" id="L73">    override val tables: Seq[String] = Seq.empty</span>
<span class="nc" id="L74">    override val ranges: Seq[BoundedByteRange] = Seq.empty</span>
<span class="nc" id="L75">    override val resultsToFeatures: ResultsToFeatures[SimpleFeature] = ResultsToFeatures.empty</span>
<span class="nc" id="L76">    override val sort: Option[Seq[(String, Boolean)]] = None</span>
<span class="nc" id="L77">    override val maxFeatures: Option[Int] = None</span>
<span class="nc" id="L78">    override val projection: Option[QueryReferenceSystems] = None</span>
<span class="nc" id="L79">    override def scan(): CloseableIterator[SimpleFeature] = CloseableIterator.empty</span>
  }

  // uses zrangebylex
<span class="nc bnc" id="L83" title="All 65 branches missed.">  case class ZLexPlan(</span>
<span class="nc" id="L84">      ds: RedisDataStore,</span>
<span class="nc" id="L85">      strategy: QueryStrategy,</span>
<span class="nc" id="L86">      tables: Seq[String],</span>
<span class="nc" id="L87">      ranges: Seq[BoundedByteRange],</span>
<span class="nc" id="L88">      pipeline: Boolean,</span>
<span class="nc" id="L89">      localFilter: Option[Filter],</span>
<span class="nc" id="L90">      processor: LocalProcessor,</span>
<span class="nc" id="L91">      projection: Option[QueryReferenceSystems]</span>
<span class="nc" id="L92">    ) extends RedisQueryPlan with LocalProcessorPlan {</span>

    import scala.collection.JavaConverters._

    override def scan(): CloseableIterator[SimpleFeature] = {
      // query guard hook - also handles full table scan checks
<span class="nc" id="L98">      ds.interceptors.runGuards(strategy)</span>
<span class="nc" id="L99">      val toFeatures = new RedisResultsToFeatures(strategy.index, strategy.index.sft)</span>
<span class="nc" id="L100">      val iter = tables.iterator.map(_.getBytes(StandardCharsets.UTF_8))</span>
<span class="nc" id="L101">      val scans = iter.map(singleTableScan(ds, _))</span>
      val scanner =
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (ds.config.queries.parallelPartitionScans) {</span>
          // kick off all the scans at once
<span class="nc" id="L105">          scans.foldLeft(CloseableIterator.empty[Array[Byte]])(_ concat _).map(toFeatures.apply)</span>
        } else {
          // kick off the scans sequentially as they finish
<span class="nc" id="L108">          CloseableIterator(scans).flatMap(s =&gt; s.map(toFeatures.apply))</span>
        }
<span class="nc" id="L110">      val features = localFilter.fold(scanner)(f =&gt; scanner.filter(f.evaluate))</span>
<span class="nc" id="L111">      processor(features)</span>
    }

    override def moreExplaining(explainer: Explainer): Unit = {
<span class="nc bnc" id="L115" title="All 2 branches missed.">      explainer(s&quot;Pipelining: ${if (pipeline) { &quot;enabled&quot; } else { &quot;disabled&quot; }}&quot;)</span>
<span class="nc" id="L116">      explainer(s&quot;Client-side filter: ${localFilter.fold(&quot;none&quot;)(FilterHelper.toString)}&quot;)</span>
<span class="nc" id="L117">      processor.explain(explainer)</span>
    }

    private def singleTableScan(ds: RedisDataStore, table: Array[Byte]): CloseableIterator[Array[Byte]] = {
<span class="nc bnc" id="L121" title="All 2 branches missed.">      if (pipeline) {</span>
<span class="nc" id="L122">        val result = Seq.newBuilder[Response[java.util.List[Array[Byte]]]]</span>
<span class="nc" id="L123">        result.sizeHint(ranges.length)</span>
<span class="nc" id="L124">        WithClose(ds.connection.getResource) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">          case jedis: Jedis =&gt;</span>
<span class="nc" id="L126">            WithClose(jedis.pipelined()) { pipe =&gt;</span>
              // note: use a foreach here to ensure the calls are all executing inside our close block
<span class="nc" id="L128">              ranges.foreach(range =&gt; result += pipe.zrangeByLex(table, range.lower, range.upper))</span>
<span class="nc" id="L129">              pipe.sync()</span>
            }
<span class="nc bnc" id="L131" title="All 2 branches missed.">          case jedis: UnifiedJedis =&gt;</span>
<span class="nc" id="L132">            WithClose(jedis.pipelined()) { pipe =&gt;</span>
              // note: use a foreach here to ensure the calls are all executing inside our close block
<span class="nc" id="L134">              ranges.foreach(range =&gt; result += pipe.zrangeByLex(table, range.lower, range.upper))</span>
<span class="nc" id="L135">              pipe.sync()</span>
            }
        }
<span class="nc" id="L138">        CloseableIterator(result.result.iterator.flatMap(_.get.iterator().asScala))</span>
      } else {
<span class="nc" id="L140">        RedisBatchScan(ds.connection, table, ranges, ds.config.queries.threads)</span>
      }
    }
  }
<span class="nc" id="L144">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>