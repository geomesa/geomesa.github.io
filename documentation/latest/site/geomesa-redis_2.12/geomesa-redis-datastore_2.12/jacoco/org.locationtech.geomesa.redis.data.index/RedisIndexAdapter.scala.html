<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedisIndexAdapter.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Redis Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.redis.data.index</a> &gt; <span class="el_source">RedisIndexAdapter.scala</span></div><h1>RedisIndexAdapter.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.redis.data
package index

import com.typesafe.scalalogging.{LazyLogging, StrictLogging}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.features.kryo.KryoFeatureSerializer
import org.locationtech.geomesa.index.api.IndexAdapter.{BaseIndexWriter, RequiredVisibilityWriter}
import org.locationtech.geomesa.index.api.QueryPlan.IndexResultsToFeatures
import org.locationtech.geomesa.index.api.WritableFeature.FeatureWrapper
import org.locationtech.geomesa.index.api._
import org.locationtech.geomesa.index.index.id.IdIndex
import org.locationtech.geomesa.index.planning.LocalQueryRunner.LocalProcessor
import org.locationtech.geomesa.index.utils.Explainer
import org.locationtech.geomesa.redis.data.index.RedisAgeOff.AgeOffWriter
import org.locationtech.geomesa.redis.data.index.RedisIndexAdapter.RedisIndexWriter
import org.locationtech.geomesa.redis.data.index.RedisQueryPlan.{EmptyPlan, ZLexPlan}
import org.locationtech.geomesa.utils.index.ByteArrays
import org.locationtech.geomesa.utils.io.WithClose
import redis.clients.jedis.util.Pool

import java.nio.charset.StandardCharsets
import scala.collection.mutable.ArrayBuffer
import scala.util.control.NonFatal

/**
  * Index adapter for Redis
  *
  * @param ds data store
  */
<span class="nc" id="L39">class RedisIndexAdapter(ds: RedisDataStore) extends IndexAdapter[RedisDataStore] with StrictLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  // each 'table' is a sorted set - they are created automatically when you insert values
  override def createTable(
      index: GeoMesaFeatureIndex[_, _],
      partition: Option[String],
<span class="nc" id="L47">      splits: =&gt; Seq[Array[Byte]]): Unit = index.configureTableName(partition) // writes table name to metadata</span>

  override def renameTable(from: String, to: String): Unit =
<span class="nc" id="L50">    WithClose(ds.connection.getResource)(_.renamenx(from, to))</span>

  override def deleteTables(tables: Seq[String]): Unit =
<span class="nc" id="L53">    WithClose(ds.connection.getResource)(_.del(tables: _*))</span>

  override def clearTables(tables: Seq[String], prefix: Option[Array[Byte]]): Unit = {
<span class="nc" id="L56">    require(prefix.isEmpty, &quot;Prefix truncate is not supported&quot;)</span>
    // we can delete the whole key, and it will automatically create it again on the next insert
<span class="nc" id="L58">    WithClose(ds.connection.getResource)(_.del(tables: _*))</span>
  }

  override def createQueryPlan(strategy: QueryStrategy): RedisQueryPlan = {
    import org.locationtech.geomesa.index.conf.QueryHints.RichHints

<span class="nc" id="L64">    val processor = LocalProcessor(strategy.index.sft, strategy.hints, Option(ds.config.authProvider))</span>

<span class="nc bnc" id="L66" title="All 2 branches missed.">    if (strategy.ranges.isEmpty) { EmptyPlan(strategy, processor.reducer) } else {</span>
<span class="nc" id="L67">      val tables = strategy.index.getTablesForQuery(strategy.filter.filter)</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">      val ranges = if (strategy.index.isInstanceOf[IdIndex]) {</span>
<span class="nc" id="L69">        strategy.ranges.map(RedisIndexAdapter.toRedisIdRange)</span>
      } else {
<span class="nc" id="L71">        strategy.ranges.map(RedisIndexAdapter.toRedisRange)</span>
      }
<span class="nc" id="L73">      val project = strategy.hints.getProjection</span>

<span class="nc" id="L75">      ZLexPlan(ds, strategy, tables, ranges, ds.config.pipeline, strategy.ecql, processor, project)</span>
    }
  }

  override def createWriter(
      sft: SimpleFeatureType,
      indices: Seq[GeoMesaFeatureIndex[_, _]],
      partition: Option[String],
      atomic: Boolean): RedisIndexWriter = {
<span class="nc bnc" id="L84" title="All 2 branches missed.">    require(!atomic, &quot;Redis data store does not currently support atomic writes&quot;)</span>
<span class="nc" id="L85">    val aging = ds.aging.writer(sft)</span>
<span class="nc" id="L86">    val wrapper = RedisWritableFeature.wrapper(sft)</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">    if (sft.isVisibilityRequired) {</span>
<span class="nc" id="L88">      new RedisIndexWriter(ds.connection, indices, partition, aging, wrapper) with RequiredVisibilityWriter</span>
    } else {
<span class="nc" id="L90">      new RedisIndexWriter(ds.connection, indices, partition, aging, wrapper)</span>
    }
  }

  override def getStrategyCost(strategy: FilterStrategy, explain: Explainer): Option[Long] =
<span class="nc" id="L95">    ds.stats.getCount(strategy.index.sft, strategy.primary.getOrElse(Filter.INCLUDE))</span>
}

<span class="nc bnc" id="L98" title="All 4 branches missed.">object RedisIndexAdapter extends LazyLogging {</span>

<span class="nc" id="L100">  val MinRange: Array[Byte] = &quot;-&quot;.getBytes(StandardCharsets.UTF_8)</span>
<span class="nc" id="L101">  val MaxRange: Array[Byte] = &quot;+&quot;.getBytes(StandardCharsets.UTF_8)</span>

<span class="nc" id="L103">  val InclusiveRangePrefix: Byte = &quot;[&quot;.getBytes(StandardCharsets.UTF_8).head</span>
<span class="nc" id="L104">  val ExclusiveRangePrefix: Byte = &quot;(&quot;.getBytes(StandardCharsets.UTF_8).head</span>

  /**
    * Convert a byte range to a redis zlex range
    *
    * @param byteRange geomesa range
    * @return
    */
<span class="nc" id="L112">  private def toRedisRange(byteRange: ByteRange): BoundedByteRange = byteRange match {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">    case BoundedByteRange(start, end) =&gt;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">      val rangeStart = if (start.isEmpty) { RedisIndexAdapter.MinRange } else {</span>
<span class="nc" id="L115">        val range = Array.ofDim[Byte](start.length + 1)</span>
<span class="nc" id="L116">        System.arraycopy(start, 0, range, 1, start.length)</span>
<span class="nc" id="L117">        range(0) = RedisIndexAdapter.InclusiveRangePrefix</span>
<span class="nc" id="L118">        range</span>
      }
<span class="nc bnc" id="L120" title="All 2 branches missed.">      val rangeEnd = if (end.isEmpty) { RedisIndexAdapter.MaxRange } else {</span>
<span class="nc" id="L121">        val range = Array.ofDim[Byte](end.length + 1)</span>
<span class="nc" id="L122">        System.arraycopy(end, 0, range, 1, end.length)</span>
<span class="nc" id="L123">        range(0) = RedisIndexAdapter.ExclusiveRangePrefix</span>
<span class="nc" id="L124">        range</span>
      }
<span class="nc" id="L126">      BoundedByteRange(rangeStart, rangeEnd)</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">    case SingleRowByteRange(row) =&gt;</span>
<span class="nc" id="L129">      val rangeStart = Array.ofDim[Byte](row.length + 1)</span>
<span class="nc" id="L130">      System.arraycopy(row, 0, rangeStart, 1, row.length)</span>
<span class="nc" id="L131">      rangeStart(0) = RedisIndexAdapter.InclusiveRangePrefix</span>
      // since the value is appended to the row, we have to add a suffix
<span class="nc" id="L133">      val rangeEnd = Array.ofDim[Byte](row.length + 1 + ByteRange.UnboundedUpperRange.length)</span>
<span class="nc" id="L134">      System.arraycopy(row, 0, rangeEnd, 1, row.length)</span>
<span class="nc" id="L135">      System.arraycopy(ByteRange.UnboundedUpperRange, 0, rangeEnd, row.length + 1, ByteRange.UnboundedUpperRange.length)</span>
<span class="nc" id="L136">      rangeEnd(0) = RedisIndexAdapter.ExclusiveRangePrefix</span>
<span class="nc" id="L137">      BoundedByteRange(rangeStart, rangeEnd)</span>
  }

  /**
    * Convert a byte range into a zlex range, specifically for the id index. Since we store the length
    * of the id in the row key, we have to prepend that to our ranges
    *
    * @param byteRange geomesa range
    * @return
    */
<span class="nc" id="L147">  private def toRedisIdRange(byteRange: ByteRange): BoundedByteRange = byteRange match {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">    case BoundedByteRange(start, end) =&gt;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">      val rangeStart = if (start.isEmpty) { RedisIndexAdapter.MinRange } else {</span>
        // add the two byte length prefix
<span class="nc" id="L151">        val range = Array.ofDim[Byte](start.length + 3)</span>
<span class="nc" id="L152">        System.arraycopy(start, 0, range, 3, start.length)</span>
<span class="nc" id="L153">        ByteArrays.writeShort(start.length.toShort, range, 1)</span>
<span class="nc" id="L154">        range(0) = RedisIndexAdapter.InclusiveRangePrefix</span>
<span class="nc" id="L155">        range</span>
      }
<span class="nc bnc" id="L157" title="All 2 branches missed.">      val rangeEnd = if (end.isEmpty) { RedisIndexAdapter.MaxRange } else {</span>
        // add the two byte length prefix
<span class="nc" id="L159">        val range = Array.ofDim[Byte](end.length + 3)</span>
<span class="nc" id="L160">        System.arraycopy(end, 0, range, 3, end.length)</span>
<span class="nc" id="L161">        ByteArrays.writeShort(end.length.toShort, range, 1)</span>
<span class="nc" id="L162">        range(0) = RedisIndexAdapter.ExclusiveRangePrefix</span>
<span class="nc" id="L163">        range</span>
      }
<span class="nc" id="L165">      BoundedByteRange(rangeStart, rangeEnd)</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">    case SingleRowByteRange(row) =&gt;</span>
      // add the two byte length prefix
<span class="nc" id="L169">      val rangeStart = Array.ofDim[Byte](row.length + 3)</span>
<span class="nc" id="L170">      System.arraycopy(row, 0, rangeStart, 3, row.length)</span>
<span class="nc" id="L171">      ByteArrays.writeShort(row.length.toShort, rangeStart, 1)</span>
<span class="nc" id="L172">      rangeStart(0) = RedisIndexAdapter.InclusiveRangePrefix</span>
      // since the value is appended to the row, we have to add a suffix
<span class="nc" id="L174">      val rangeEnd = Array.ofDim[Byte](row.length + 3 + ByteRange.UnboundedUpperRange.length)</span>
<span class="nc" id="L175">      System.arraycopy(row, 0, rangeEnd, 3, row.length)</span>
<span class="nc" id="L176">      System.arraycopy(ByteRange.UnboundedUpperRange, 0, rangeEnd, row.length + 3, ByteRange.UnboundedUpperRange.length)</span>
<span class="nc" id="L177">      ByteArrays.writeShort(row.length.toShort, rangeEnd, 1)</span>
<span class="nc" id="L178">      rangeEnd(0) = RedisIndexAdapter.ExclusiveRangePrefix</span>
<span class="nc" id="L179">      BoundedByteRange(rangeStart, rangeEnd)</span>
  }

<span class="nc" id="L182">  class RedisResultsToFeatures(_index: GeoMesaFeatureIndex[_, _], _sft: SimpleFeatureType)</span>
<span class="nc" id="L183">      extends IndexResultsToFeatures[Array[Byte]](_index, _sft) {</span>

<span class="nc" id="L185">    private var idSerializer: (Array[Byte], Int, Int, SimpleFeature) =&gt; String = _</span>

    override def apply(result: Array[Byte]): SimpleFeature = {
      // parse out the feature id and the serialized value from the concatenated row + value
<span class="nc" id="L189">      val idStart = index.getIdOffset(result, 0, result.length)</span>
<span class="nc" id="L190">      val idLength = ByteArrays.readShort(result, idStart)</span>
<span class="nc" id="L191">      val id = idSerializer(result, idStart + 2, idLength, null)</span>
<span class="nc" id="L192">      val valueStart = idStart + idLength + 2</span>
<span class="nc" id="L193">      serializer.deserialize(id, result, valueStart, result.length - valueStart)</span>
    }

    override protected def createSerializer: KryoFeatureSerializer = {
<span class="nc" id="L197">      idSerializer = GeoMesaFeatureIndex.idFromBytes(index.sft)</span>
<span class="nc" id="L198">      KryoFeatureSerializer.builder(index.sft).`lazy`.withUserData.withoutId.build()</span>
    }
  }

  /**
    * Writer for redis
    *
    * @param jedis connection
    * @param indices indices to write to
    * @param partition partition to write to
    * @param aging age-off writer
    * @param wrapper feature wrapper
    */
<span class="nc" id="L211">  class RedisIndexWriter(</span>
<span class="nc" id="L212">      jedis: Pool[_ &lt;: CloseableJedisCommands],</span>
      indices: Seq[GeoMesaFeatureIndex[_, _]],
<span class="nc" id="L214">      partition: Option[String],</span>
<span class="nc" id="L215">      aging: Option[AgeOffWriter],</span>
      wrapper: FeatureWrapper[RedisWritableFeature]
<span class="nc" id="L217">    ) extends BaseIndexWriter[RedisWritableFeature](indices, wrapper) {</span>

<span class="nc" id="L219">    private val batchSize = RedisSystemProperties.WriteBatchSize.toInt match {</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">      case Some(s) if s &gt; 0 =&gt; s - 1</span>
      case _ =&gt;
<span class="nc" id="L222">        throw new IllegalStateException(s&quot;Value '${RedisSystemProperties.WriteBatchSize.get}' for &quot; +</span>
<span class="nc" id="L223">            s&quot;'${RedisSystemProperties.WriteBatchSize.property}' is not a positive int&quot;)</span>
    }

<span class="nc" id="L226">    private val tables = indices.toArray.map { index =&gt;</span>
      // should always be writing to a single table here
<span class="nc" id="L228">      index.getTableName(partition).getBytes(StandardCharsets.UTF_8)</span>
    }

<span class="nc" id="L231">    private val inserts = Array.fill[java.util.Map[Array[Byte], java.lang.Double]](tables.length)(new java.util.HashMap[Array[Byte], java.lang.Double]())</span>
<span class="nc" id="L232">    private val deletes = Array.fill[ArrayBuffer[Array[Byte]]](tables.length)(ArrayBuffer.empty[Array[Byte]])</span>

<span class="nc" id="L234">    private var i = 0</span>
<span class="nc" id="L235">    private var batch = 0</span>

<span class="nc" id="L237">    private val errors = ArrayBuffer.empty[Throwable]</span>

    override protected def append(feature: RedisWritableFeature, values: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L240">      i = 0</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">      while (i &lt; values.length) {</span>
<span class="nc" id="L242">        val insert = inserts(i)</span>
<span class="nc" id="L243">        values(i) match {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">          case kv: SingleRowKeyValue[_] =&gt;</span>
<span class="nc" id="L245">            kv.values.foreach(v =&gt; insert.put(ByteArrays.concat(kv.row, v.value), 0d))</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">          case kv: MultiRowKeyValue[_] =&gt;</span>
<span class="nc" id="L247">            kv.rows.foreach(row =&gt; kv.values.foreach(v =&gt; insert.put(ByteArrays.concat(row, v.value), 0d)))</span>
        }
<span class="nc" id="L249">        i += 1</span>
      }

<span class="nc" id="L252">      aging.foreach(_.write(feature))</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (batch &lt; batchSize) {</span>
<span class="nc" id="L255">        batch += 1</span>
      } else {
<span class="nc" id="L257">        flush()</span>
      }
    }

    override protected def update(
        feature: RedisWritableFeature,
        values: Array[RowKeyValue[_]],
        previous: RedisWritableFeature,
        previousValues: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L266">      delete(previous, previousValues)</span>
<span class="nc" id="L267">      append(feature, values)</span>
    }

    override protected def delete(feature: RedisWritableFeature, values: Array[RowKeyValue[_]]): Unit = {
<span class="nc" id="L271">      i = 0</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      while (i &lt; values.length) {</span>
<span class="nc" id="L273">        val buffer = deletes(i)</span>
<span class="nc" id="L274">        values(i) match {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">          case kv: SingleRowKeyValue[_] =&gt;</span>
<span class="nc" id="L276">            kv.values.foreach(v =&gt; buffer.append(ByteArrays.concat(kv.row, v.value)))</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">          case kv: MultiRowKeyValue[_] =&gt;</span>
<span class="nc" id="L278">            kv.rows.foreach(row =&gt; kv.values.foreach(v =&gt; buffer.append(ByteArrays.concat(row, v.value))))</span>
        }
<span class="nc" id="L280">        i += 1</span>
      }

<span class="nc" id="L283">      aging.foreach(_.delete(feature))</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">      if (batch &lt; batchSize) {</span>
<span class="nc" id="L286">        batch += 1</span>
      } else {
<span class="nc" id="L288">        flush()</span>
      }
    }

    override def flush(): Unit = {
<span class="nc" id="L293">      i = 0</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      while (i &lt; tables.length) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (deletes(i).nonEmpty) {</span>
<span class="nc" id="L296">          try { WithClose(jedis.getResource)(_.zrem(tables(i), deletes(i).toSeq: _*)) } catch {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            case NonFatal(e) =&gt; errors.append(e)</span>
          }
<span class="nc" id="L299">          deletes(i).clear()</span>
        }
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (!inserts(i).isEmpty) {</span>
<span class="nc" id="L302">          try { WithClose(jedis.getResource)(_.zadd(tables(i), inserts(i))) } catch {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            case NonFatal(e) =&gt; errors.append(e)</span>
          }
<span class="nc" id="L305">          inserts(i).clear()</span>
        }
<span class="nc" id="L307">        i += 1</span>
      }
<span class="nc" id="L309">      batch = 0</span>

<span class="nc" id="L311">      try { aging.foreach(_.flush()) } catch {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        case NonFatal(e) =&gt; errors.append(e)</span>
      }

<span class="nc" id="L315">      throwErrors()</span>
    }

    override def close(): Unit = {
<span class="nc" id="L319">      try { flush() } catch {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        case NonFatal(e) =&gt; errors.append(e)</span>
      }
<span class="nc" id="L322">      try { aging.foreach(_.close()) } catch {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        case NonFatal(e) =&gt; errors.append(e)</span>
      }
<span class="nc" id="L325">      throwErrors()</span>
    }

    private def throwErrors(): Unit = {
<span class="nc bnc" id="L329" title="All 2 branches missed.">      if (errors.nonEmpty) {</span>
<span class="nc" id="L330">        val error = errors.head</span>
<span class="nc" id="L331">        errors.tail.foreach(error.addSuppressed)</span>
<span class="nc" id="L332">        errors.clear()</span>
<span class="nc" id="L333">        throw error</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>