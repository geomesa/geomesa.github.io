<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RedisGeoMesaStats.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Redis Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.redis.data.util</a> &gt; <span class="el_source">RedisGeoMesaStats.scala</span></div><h1>RedisGeoMesaStats.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.redis.data
package util

import org.locationtech.geomesa.index.stats.MetadataBackedStats.{StatsMetadataSerializer, WritableStat}
import org.locationtech.geomesa.index.stats.{MetadataBackedStats, Stat}
import org.locationtech.geomesa.redis.data.util.RedisGeoMesaStats.RedisStat
import org.locationtech.geomesa.utils.io.WithClose

import java.nio.charset.StandardCharsets
import java.security.SecureRandom
import java.util.concurrent.{LinkedBlockingQueue, TimeUnit}
import scala.util.control.NonFatal

/**
  * Redis stats implementation
  *
  * @param ds data store
  */
<span class="nc" id="L27">class RedisGeoMesaStats(ds: RedisDataStore, metadata: RedisBackedMetadata[Stat])</span>
<span class="nc" id="L28">    extends MetadataBackedStats(ds, metadata) {</span>

  @volatile
<span class="nc" id="L31">  private var run = true</span>
<span class="nc" id="L32">  private var errors = 0</span>

  // note: the default values ensure that these will always be Somes
<span class="nc" id="L35">  private val retries = RedisSystemProperties.TransactionRetries.toInt.get</span>
<span class="nc" id="L36">  private val pause = RedisSystemProperties.TransactionPause.toDuration.get.toMillis</span>
<span class="nc" id="L37">  private val rand = new SecureRandom()</span>

<span class="nc" id="L39">  private val queue = new LinkedBlockingQueue[RedisStat]()</span>
<span class="nc" id="L40">  private val es = java.util.concurrent.Executors.newScheduledThreadPool(2)</span>

<span class="nc bnc" id="L42" title="All 2 branches missed.">  es.submit(new Runnable() { override def run(): Unit = writeQueued() })</span>

  override protected def write(typeName: String, stats: Seq[WritableStat]): Unit = {
<span class="nc" id="L45">    val queued = stats.forall { stat =&gt;</span>
<span class="nc" id="L46">      val keyBytes = metadata.encodeRow(typeName, stat.key)</span>
<span class="nc" id="L47">      val serialized = metadata.serializer.serialize(typeName, stat.stat)</span>
<span class="nc" id="L48">      queue.offer(RedisStat(typeName, stat.key, keyBytes, stat.stat, serialized, stat.merge, 0))</span>
    }
<span class="nc bnc" id="L50" title="All 2 branches missed.">    if (!queued) {</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">      logger.error(s&quot;Could not queue stat for writing - queue size: ${queue.size()}&quot;)</span>
    }
  }

  private def writeQueued(): Unit = {
<span class="nc bnc" id="L56" title="All 2 branches missed.">    while (run) {</span>
<span class="nc" id="L57">      try {</span>
<span class="nc" id="L58">        val stat = queue.poll(1000L, TimeUnit.MILLISECONDS)</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (stat != null) {</span>
<span class="nc" id="L60">          val success = WithClose(ds.connection.getResource) { jedis =&gt;</span>
            // Use Lua script to atomically check, merge if needed, and write the stat
<span class="nc" id="L62">            val script = &quot;&quot;&quot;</span>
              local existing = redis.call('hget', KEYS[1], ARGV[1])
              local write
              if ARGV[3] == '1' then
                if existing then
                  return { existing, 0 } -- need to merge on client side
                else
                  write = ARGV[2]
                end
              else
                write = ARGV[2]
              end
              if write then
                redis.call('hset', KEYS[1], ARGV[1], write)
              end
              return { existing or false, write and 1 or 0 }
            &quot;&quot;&quot;
<span class="nc bnc" id="L79" title="All 2 branches missed.">            val merge = if (stat.merge) &quot;1&quot; else &quot;0&quot;</span>
<span class="nc" id="L80">            val result = jedis.eval(</span>
<span class="nc" id="L81">              script.getBytes(StandardCharsets.UTF_8),</span>
<span class="nc" id="L82">              1,</span>
<span class="nc" id="L83">              metadata.key,</span>
<span class="nc" id="L84">              stat.keyBytes, stat.statBytes, merge.getBytes(StandardCharsets.UTF_8)</span>
            )

<span class="nc" id="L87">            result match {</span>
<span class="nc bnc" id="L88" title="All 4 branches missed.">              case list: java.util.List[_] if !list.isEmpty =&gt;</span>
<span class="nc" id="L89">                val existing = Option(list.get(0)).map {</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">                  case bytes: Array[Byte] =&gt; bytes</span>
<span class="nc" id="L91">                  case _ =&gt; null</span>
                }
<span class="nc" id="L93">                val success = list.get(1) match {</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">                  case i: java.lang.Long =&gt; i.longValue() == 1L</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">                  case i: java.lang.Integer =&gt; i.intValue() == 1</span>
<span class="nc bnc" id="L96" title="All 4 branches missed.">                  case s: String =&gt; s.toInt == 1</span>
<span class="nc" id="L97">                  case _ =&gt; false</span>
                }

<span class="nc bnc" id="L100" title="All 2 branches missed.">                if (success) {</span>
<span class="nc" id="L101">                  true // write was successful</span>
<span class="nc bnc" id="L102" title="All 4 branches missed.">                } else if (existing.isDefined &amp;&amp; stat.merge) {</span>
                  // need to merge and retry
<span class="nc" id="L104">                  val merged = metadata.serializer.serialize(stat.typeName,</span>
<span class="nc" id="L105">                    metadata.serializer.deserialize(stat.typeName, existing.get) + stat.stat)</span>
<span class="nc" id="L106">                  val retryScript = &quot;&quot;&quot;</span>
                    redis.call('hset', KEYS[1], ARGV[1], ARGV[2])
                    return 1
                  &quot;&quot;&quot;
<span class="nc" id="L110">                  val retryResult = jedis.eval(</span>
<span class="nc" id="L111">                    retryScript.getBytes(StandardCharsets.UTF_8),</span>
<span class="nc" id="L112">                    1,</span>
<span class="nc" id="L113">                    metadata.key,</span>
<span class="nc" id="L114">                    stat.keyBytes, merged</span>
                  )
<span class="nc" id="L116">                  retryResult match {</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">                    case i: java.lang.Long =&gt; i == 1L</span>
<span class="nc bnc" id="L118" title="All 4 branches missed.">                    case i: java.lang.Integer =&gt; i == 1</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">                    case s: String =&gt; s.toInt == 1</span>
<span class="nc" id="L120">                    case _ =&gt; false</span>
                  }
                } else {
<span class="nc" id="L123">                  false</span>
                }

<span class="nc" id="L126">              case _ =&gt; false</span>
            }
          }

<span class="nc bnc" id="L130" title="All 2 branches missed.">          if (success) {</span>
            // since we didn't write through the metadata instance, we have to invalidate the cache
<span class="nc" id="L132">            metadata.invalidateCache(stat.typeName, stat.key)</span>
<span class="nc" id="L133">            errors = 0 // reset error count on success</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">          } else if (stat.attempt &lt; retries) {</span>
            // we had a conflict, so backoff and retry
<span class="nc" id="L136">            val delay = TransactionBackoffs.applyOrElse(stat.attempt, (_: Int) =&gt; TransactionBackoffs.last) * pause</span>
<span class="nc" id="L137">            val runnable = new BackoffScheduler(stat.copy(attempt = stat.attempt + 1))</span>
<span class="nc" id="L138">            es.schedule(runnable, delay + rand.nextInt(10), TimeUnit.MILLISECONDS)</span>
          } else {
<span class="nc" id="L140">            throw new RuntimeException(</span>
<span class="nc" id="L141">              s&quot;Could not write stat for ${stat.typeName}:${stat.key} after ${stat.attempt + 1} attempts&quot;)</span>
          }
        }
      } catch {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        case NonFatal(e) =&gt;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">          logger.error(&quot;Error in stat writing thread:&quot;, e)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">          if (errors &gt; 20) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            logger.error(&quot;Terminating stat writing thread due to previous errors&quot;)</span>
<span class="nc" id="L149">            run = false</span>
<span class="nc" id="L150">            throw e</span>
          } else {
<span class="nc" id="L152">            errors += 1</span>
          }
      }
    }
  }

  override def close(): Unit = {
<span class="nc" id="L159">    run = false</span>
<span class="nc" id="L160">    es.shutdown()</span>
<span class="nc" id="L161">    super.close()</span>
  }

<span class="nc bnc" id="L164" title="All 2 branches missed.">  private class BackoffScheduler(stat: RedisStat) extends Runnable {</span>
    override def run(): Unit = {
<span class="nc bnc" id="L166" title="All 2 branches missed.">      if (!queue.offer(stat)) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        logger.error(s&quot;Could not queue stat for writing - queue size: ${queue.size()}&quot;)</span>
      }
    }
  }
}

<span class="nc" id="L173">object RedisGeoMesaStats {</span>

  def apply(ds: RedisDataStore): RedisGeoMesaStats = {
<span class="nc" id="L176">    val serializer = new StatsMetadataSerializer(ds)</span>
<span class="nc" id="L177">    val metadata = new RedisBackedMetadata[Stat](ds.connection, s&quot;${ds.config.catalog}_stats&quot;, serializer)</span>
<span class="nc" id="L178">    new RedisGeoMesaStats(ds, metadata)</span>
  }

<span class="nc bnc" id="L181" title="All 46 branches missed.">  case class RedisStat(</span>
<span class="nc" id="L182">      typeName: String,</span>
<span class="nc" id="L183">      key: String,</span>
<span class="nc" id="L184">      keyBytes: Array[Byte],</span>
<span class="nc" id="L185">      stat: Stat,</span>
<span class="nc" id="L186">      statBytes: Array[Byte],</span>
<span class="nc" id="L187">      merge: Boolean,</span>
<span class="nc" id="L188">      attempt: Int)</span>
<span class="nc" id="L189">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>