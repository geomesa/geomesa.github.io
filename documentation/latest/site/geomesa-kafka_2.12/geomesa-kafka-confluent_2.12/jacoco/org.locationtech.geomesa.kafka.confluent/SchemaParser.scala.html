<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SchemaParser.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Kafka Confluent Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.kafka.confluent</a> &gt; <span class="el_source">SchemaParser.scala</span></div><h1>SchemaParser.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.kafka.confluent

import org.apache.avro.LogicalTypes.{TimestampMicros, TimestampMillis}
import org.apache.avro.Schema
import org.geotools.api.feature.simple.SimpleFeatureType
import org.locationtech.geomesa.utils.geotools.SchemaBuilder
import org.locationtech.geomesa.utils.text.{DateParsing, WKBUtils, WKTUtils}
import org.locationtech.jts.geom._

import java.nio.ByteBuffer
import java.time.format.DateTimeFormatter
import java.util.{Date, Locale}
import scala.annotation.tailrec
import scala.reflect.{ClassTag, classTag}
import scala.util.control.NonFatal

<span class="nc" id="L25">object SchemaParser {</span>

  import scala.collection.JavaConverters._

<span class="nc" id="L29">  private val SkippedPropertyKeys: Set[String] = Set(</span>
<span class="nc" id="L30">    GeoMesaAvroGeomType.KEY,</span>
<span class="nc" id="L31">    GeoMesaAvroGeomFormat.KEY,</span>
<span class="nc" id="L32">    GeoMesaAvroGeomDefault.KEY,</span>
<span class="nc" id="L33">    GeoMesaAvroVisibilityField.KEY,</span>
<span class="nc" id="L34">    GeoMesaAvroExcludeField.KEY</span>
  )

  /**
   * Convert an Avro [[Schema]] into a [[SimpleFeatureType]].
   */
<span class="nc" id="L40">  def schemaToSft(schema: Schema, name: Option[String] = None): SimpleFeatureType = {</span>
<span class="nc" id="L41">    val builder = new SchemaBuilder()</span>

<span class="nc" id="L43">    var defaultGeomField: Option[String] = None</span>
<span class="nc" id="L44">    var visibilityField: Option[String] = None</span>

<span class="nc" id="L46">    schema.getFields.asScala.foreach { field =&gt;</span>
<span class="nc" id="L47">      val metadata = parseMetadata(field)</span>

<span class="nc" id="L49">      metadata.field match {</span>
<span class="nc bnc" id="L50" title="All 4 branches missed.">        case GeometryField(geomType, default) if !metadata.exclude =&gt;</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">          if (default) {</span>
<span class="nc" id="L52">            defaultGeomField.foreach { name =&gt;</span>
<span class="nc" id="L53">              throw new IllegalArgumentException(&quot;There may be only one default geometry field in a schema: &quot; +</span>
<span class="nc" id="L54">                  s&quot;'$name' was already declared as the default&quot;)</span>
            }
<span class="nc" id="L56">            defaultGeomField = Some(field.name)</span>
          }

<span class="nc" id="L59">          addGeometryToBuilder(builder, field.name, geomType, default, metadata.extraProps)</span>

<span class="nc bnc" id="L61" title="All 4 branches missed.">        case DateField(_) if !metadata.exclude =&gt;</span>
<span class="nc" id="L62">          builder.addDate(field.name).withOptions(metadata.extraProps.toSeq: _*)</span>

<span class="nc bnc" id="L64" title="All 2 branches missed.">        case VisibilityField =&gt;</span>
<span class="nc" id="L65">          visibilityField.foreach { name =&gt;</span>
<span class="nc" id="L66">            throw new IllegalArgumentException(s&quot;There may be only one visibility field in a schema: &quot; +</span>
<span class="nc" id="L67">                s&quot;'$name' was already declared as the visibility&quot;)</span>
          }
<span class="nc" id="L69">          visibilityField = Some(field.name)</span>

<span class="nc bnc" id="L71" title="All 2 branches missed.">          if (!metadata.exclude) {</span>
<span class="nc" id="L72">            addFieldToBuilder(builder, field, userData = metadata.extraProps)</span>
          }
<span class="nc" id="L74">          builder.userData(GeoMesaAvroVisibilityField.KEY, field.name)</span>

<span class="nc bnc" id="L76" title="All 4 branches missed.">        case StandardField if !metadata.exclude =&gt;</span>
<span class="nc" id="L77">          addFieldToBuilder(builder, field, userData = metadata.extraProps)</span>

<span class="nc" id="L79">        case _ =&gt;</span>
      }
    }

    // any extra props on the schema go in the SFT user data
<span class="nc bnc" id="L84" title="All 2 branches missed.">    builder.userData.userData(schema.getObjectProps.asScala.map { case (k, v) =&gt; k -&gt; v.toString }.toMap)</span>
<span class="nc" id="L85">    builder.build(name.getOrElse(schema.getName))</span>
  }

  @tailrec
  private def addFieldToBuilder(
      builder: SchemaBuilder,
      field: Schema.Field,
<span class="nc" id="L92">      typeOverride: Option[Schema.Type] = None,</span>
<span class="nc" id="L93">      userData: Map[String, String] = Map.empty): Unit = {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">    lazy val logicalType = if (typeOverride.isDefined) { None } else { Option(field.schema().getLogicalType) }</span>
<span class="nc" id="L95">    typeOverride.getOrElse(field.schema.getType) match {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">      case Schema.Type.STRING  =&gt; builder.addString(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">      case Schema.Type.BOOLEAN =&gt; builder.addBoolean(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">      case Schema.Type.INT     =&gt; builder.addInt(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">      case Schema.Type.DOUBLE  =&gt; builder.addDouble(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      case Schema.Type.LONG    =&gt;</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">        logicalType match {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">          case Some(_: TimestampMillis) =&gt; builder.addDate(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">          case Some(_: TimestampMicros) =&gt; builder.addDate(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc" id="L104">          case _ =&gt; builder.addLong(field.name).withOptions(userData.toSeq: _*)</span>
        }
<span class="nc bnc" id="L106" title="All 2 branches missed.">      case Schema.Type.FLOAT   =&gt; builder.addFloat(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">      case Schema.Type.BYTES   =&gt; builder.addBytes(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">      case Schema.Type.UNION   =&gt;</span>
        // if a union has more than one non-null type, it is not supported
<span class="nc bnc" id="L110" title="All 6 branches missed.">        val types = field.schema.getTypes.asScala.map(_.getType).filter(_ != Schema.Type.NULL).toSet</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (types.size != 1) {</span>
<span class="nc" id="L112">          throw UnsupportedAvroTypeException(types.mkString(&quot;[&quot;, &quot;, &quot;, &quot;]&quot;))</span>
        } else {
<span class="nc" id="L114">          addFieldToBuilder(builder, field, Option(types.head), userData)</span>
        }
<span class="nc bnc" id="L116" title="All 2 branches missed.">      case Schema.Type.ENUM    =&gt; builder.addString(field.name).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">      case Schema.Type.MAP     =&gt; throw UnsupportedAvroTypeException(Schema.Type.MAP.getName)</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">      case Schema.Type.RECORD  =&gt; throw UnsupportedAvroTypeException(Schema.Type.RECORD.getName)</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">      case Schema.Type.ARRAY   =&gt; throw UnsupportedAvroTypeException(Schema.Type.ARRAY.getName)</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">      case Schema.Type.FIXED   =&gt; throw UnsupportedAvroTypeException(Schema.Type.FIXED.getName)</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">      case Schema.Type.NULL    =&gt; throw UnsupportedAvroTypeException(Schema.Type.NULL.getName)</span>
<span class="nc" id="L122">      case _                   =&gt; throw UnsupportedAvroTypeException(&quot;unknown&quot;)</span>
    }
  }

  private def addGeometryToBuilder(
      builder: SchemaBuilder,
      name: String,
      geometry: Class[_],
      default: Boolean,
<span class="nc" id="L131">      userData: Map[String, String] = Map.empty): Unit = {</span>
<span class="nc" id="L132">    geometry match {</span>
<span class="nc bnc" id="L133" title="All 6 branches missed.">      case t if t == classOf[Point] =&gt; builder.addPoint(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L134" title="All 6 branches missed.">      case t if t == classOf[LineString] =&gt; builder.addLineString(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L135" title="All 6 branches missed.">      case t if t == classOf[Polygon] =&gt; builder.addPolygon(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L136" title="All 6 branches missed.">      case t if t == classOf[MultiPoint] =&gt; builder.addMultiPoint(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L137" title="All 6 branches missed.">      case t if t == classOf[MultiLineString] =&gt; builder.addMultiLineString(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L138" title="All 6 branches missed.">      case t if t == classOf[MultiPolygon] =&gt; builder.addMultiPolygon(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L139" title="All 6 branches missed.">      case t if t == classOf[GeometryCollection] =&gt; builder.addGeometryCollection(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc bnc" id="L140" title="All 6 branches missed.">      case t if t == classOf[Geometry] =&gt; builder.addMixedGeometry(name, default).withOptions(userData.toSeq: _*)</span>
<span class="nc" id="L141">      case _ =&gt; throw new IllegalArgumentException(s&quot;Unknown geometry type: $geometry&quot;)</span>
    }
  }

  private def parseMetadata(field: Schema.Field): GeoMesaAvroMetadata = {
<span class="nc bnc" id="L146" title="All 2 branches missed.">    lazy val geomType = GeoMesaAvroGeomType.parse(field)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    lazy val geomDefault = GeoMesaAvroGeomDefault.parse(field).getOrElse(false)</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">    lazy val dateFormat = GeoMesaAvroDateFormat.parse(field)</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">    lazy val visibility = GeoMesaAvroVisibilityField.parse(field).getOrElse(false)</span>

    val metadata =
<span class="nc bnc" id="L152" title="All 2 branches missed.">      if (geomType.isDefined) {</span>
<span class="nc" id="L153">        GeometryField(geomType.get, geomDefault)</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">      } else if (dateFormat.isDefined) {</span>
<span class="nc" id="L155">        DateField(dateFormat.get)</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">      } else if (visibility) {</span>
<span class="nc" id="L157">        VisibilityField</span>
      } else {
<span class="nc" id="L159">        StandardField</span>
      }

    // any field properties that are not one of the defined geomesa avro properties will go in the attribute user data
<span class="nc bnc" id="L163" title="All 4 branches missed.">    val extraProps = field.getObjectProps.asScala.collect {</span>
<span class="nc bnc" id="L164" title="All 8 branches missed.">      case (k, v: String) if !SkippedPropertyKeys.contains(k) =&gt; k -&gt; v</span>
    }

<span class="nc" id="L167">    val exclude = GeoMesaAvroExcludeField.parse(field).getOrElse(false)</span>

<span class="nc" id="L169">    GeoMesaAvroMetadata(metadata, extraProps.toMap, exclude)</span>
  }

<span class="nc bnc" id="L172" title="All 30 branches missed.">  private case class GeoMesaAvroMetadata(field: GeoMesaAvroField, extraProps: Map[String, String], exclude: Boolean)</span>

  private sealed trait GeoMesaAvroField
<span class="nc bnc" id="L175" title="All 23 branches missed.">  private case class GeometryField(typ: Class[_ &lt;: Geometry], default: Boolean) extends GeoMesaAvroField</span>
<span class="nc bnc" id="L176" title="All 18 branches missed.">  private case class DateField(format: String) extends GeoMesaAvroField</span>
<span class="nc" id="L177">  private case object VisibilityField extends GeoMesaAvroField</span>
<span class="nc" id="L178">  private case object StandardField extends GeoMesaAvroField</span>

<span class="nc bnc" id="L180" title="All 18 branches missed.">  case class UnsupportedAvroTypeException(typeName: String)</span>
<span class="nc" id="L181">    extends IllegalArgumentException(s&quot;Type '$typeName' is not supported for SFT conversion&quot;)</span>

  /**
   * A property in an Avro [[Schema.Field]] to provide additional information when generating a [[SimpleFeatureType]].
   *
   * @tparam T the type of the value to be parsed from this property
   */
<span class="nc" id="L188">  trait GeoMesaAvroProperty[T] {</span>
    /**
     * The key in the [[Schema.Field]] for this property.
     */
    val KEY: String

    /**
     * Parse the value from the [[Schema.Field]] properties at this property's `KEY`.
     *
     * @return `None` if the `KEY` does not exist, else the value at the `KEY`
     */
    def parse(field: Schema.Field): Option[T]

    protected final def assertFieldType(field: Schema.Field, typ: Schema.Type): Unit = {
<span class="nc" id="L202">      field.schema.getType match {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        case Schema.Type.UNION =&gt;</span>
          // if a union has more than one non-null type, it should not be converted to an SFT
<span class="nc bnc" id="L205" title="All 6 branches missed.">          val unionTypes = field.schema.getTypes.asScala.map(_.getType).filter(_ != Schema.Type.NULL).toSet</span>
<span class="nc bnc" id="L206" title="All 8 branches missed.">          if (unionTypes.size != 1 || typ != unionTypes.head) {</span>
<span class="nc" id="L207">            throw GeoMesaAvroProperty.InvalidPropertyTypeException(typ.getName, KEY)</span>
          }
<span class="nc bnc" id="L209" title="All 2 branches missed.">        case fieldType: Schema.Type =&gt;</span>
<span class="nc bnc" id="L210" title="All 6 branches missed.">          if (typ != fieldType) {</span>
<span class="nc" id="L211">            throw GeoMesaAvroProperty.InvalidPropertyTypeException(typ.getName, KEY)</span>
          }
      }
    }
  }

<span class="nc" id="L217">  object GeoMesaAvroProperty {</span>
<span class="nc bnc" id="L218" title="All 23 branches missed.">    final case class InvalidPropertyValueException(value: String, key: String)</span>
<span class="nc" id="L219">      extends IllegalArgumentException(s&quot;Unable to parse value '$value' for property '$key'&quot;)</span>

<span class="nc bnc" id="L221" title="All 23 branches missed.">    final case class InvalidPropertyTypeException(typeName: String, key: String)</span>
<span class="nc" id="L222">      extends IllegalArgumentException(s&quot;Fields with property '$key' must have type '$typeName'&quot;)</span>
  }

  /**
   * A [[GeoMesaAvroProperty]] that has a finite set of possible string values.
   *
   * @tparam T the type of the value to be parsed from this property
   */
<span class="nc" id="L230">  trait GeoMesaAvroEnumProperty[T] extends GeoMesaAvroProperty[T] {</span>
    // case clauses to match the values of the enum and possibly check the field type
    protected val valueMatcher: PartialFunction[(String, Schema.Field), T]

    override final def parse(field: Schema.Field): Option[T] = {
<span class="nc" id="L235">      Option(field.getProp(KEY)).map(_.toLowerCase(Locale.US)).map { value =&gt;</span>
<span class="nc" id="L236">        valueMatcher.lift.apply((value, field)).getOrElse {</span>
<span class="nc" id="L237">          throw GeoMesaAvroProperty.InvalidPropertyValueException(value, KEY)</span>
        }
      }
    }
  }

  /**
   * A [[GeoMesaAvroEnumProperty]] that parses to a boolean value.
   */
<span class="nc" id="L246">  trait GeoMesaAvroBooleanProperty extends GeoMesaAvroEnumProperty[Boolean] {</span>
<span class="nc" id="L247">    final val TRUE: String = &quot;true&quot;</span>
<span class="nc" id="L248">    final val FALSE: String = &quot;false&quot;</span>

<span class="nc bnc" id="L250" title="All 10 branches missed.">    override protected val valueMatcher: PartialFunction[(String, Schema.Field), Boolean] = {</span>
<span class="nc bnc" id="L251" title="All 12 branches missed.">      case (TRUE, _) =&gt; true</span>
<span class="nc bnc" id="L252" title="All 12 branches missed.">      case (FALSE, _) =&gt; false</span>
    }
  }

  /**
   * A [[GeoMesaAvroEnumProperty]] with a value that can be deserialized from an Avro [[GenericRecord]].
   *
   * @tparam T the type of the value to be parsed from this property
   * @tparam K the type of the value to be deserialized from this property
   */
  @deprecated(&quot;deprecated with no replacement&quot;)
<span class="nc" id="L263">  abstract class GeoMesaAvroDeserializableEnumProperty[T, K: ClassTag] extends GeoMesaAvroEnumProperty[T] {</span>
    // case clauses to match the value of the enum to a function to deserialize the data
    protected val fieldReaderMatcher: PartialFunction[T, AnyRef =&gt; K]
    protected val fieldWriterMatcher: PartialFunction[T, K =&gt; AnyRef]

    @deprecated(&quot;deprecated with no replacement&quot;)
    final def getFieldReader(schema: Schema, fieldName: String): AnyRef =&gt; K = {
<span class="nc" id="L270">      try {</span>
<span class="nc" id="L271">        parse(schema.getField(fieldName)).map { value =&gt;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">          if (fieldReaderMatcher.isDefinedAt(value)) {</span>
<span class="nc" id="L273">            fieldReaderMatcher.apply(value)</span>
          } else {
<span class="nc" id="L275">            throw GeoMesaAvroProperty.InvalidPropertyValueException(value.toString, KEY)</span>
          }
        }.getOrElse {
<span class="nc" id="L278">          throw GeoMesaAvroDeserializableEnumProperty.MissingPropertyException(fieldName, KEY)</span>
        }
      } catch {
<span class="nc bnc" id="L281" title="All 2 branches missed.">        case NonFatal(ex) =&gt; throw GeoMesaAvroDeserializableEnumProperty.DeserializerException[K](fieldName, ex)</span>
      }
    }

    @deprecated(&quot;deprecated with no replacement&quot;)
    final def getFieldWriter(schema: Schema, fieldName: String): K =&gt; AnyRef = {
<span class="nc" id="L287">      try {</span>
<span class="nc" id="L288">        parse(schema.getField(fieldName)).map { value =&gt;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">          if (fieldWriterMatcher.isDefinedAt(value)) {</span>
<span class="nc" id="L290">            fieldWriterMatcher.apply(value)</span>
          } else {
<span class="nc" id="L292">            throw GeoMesaAvroProperty.InvalidPropertyValueException(value.toString, KEY)</span>
          }
        }.getOrElse {
<span class="nc" id="L295">          throw GeoMesaAvroDeserializableEnumProperty.MissingPropertyException(fieldName, KEY)</span>
        }
      } catch {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        case NonFatal(ex) =&gt; throw GeoMesaAvroDeserializableEnumProperty.DeserializerException[K](fieldName, ex)</span>
      }
    }
  }

  @deprecated(&quot;deprecated with no replacement&quot;)
<span class="nc" id="L304">  object GeoMesaAvroDeserializableEnumProperty {</span>
<span class="nc bnc" id="L305" title="All 23 branches missed.">    final case class MissingPropertyException(fieldName: String, key: String)</span>
<span class="nc" id="L306">      extends RuntimeException(s&quot;Key '$key' is missing from schema for field '$fieldName'&quot;)</span>

<span class="nc bnc" id="L308" title="All 23 branches missed.">    final case class DeserializerException[K: ClassTag](fieldName: String, t: Throwable)</span>
<span class="nc" id="L309">      extends RuntimeException(s&quot;Cannot parse deserializer for field '$fieldName' for type &quot; +</span>
<span class="nc" id="L310">        s&quot;'${classTag[K].runtimeClass.getName}': ${t.getMessage}&quot;)</span>
  }

  /**
   * Indicates that this field should be interpreted as a [[Geometry]] with the given format. This property must be
   * accompanied by the [[GeoMesaAvroGeomType]] property.
   */
<span class="nc" id="L317">  object GeoMesaAvroGeomFormat extends GeoMesaAvroDeserializableEnumProperty[String, Geometry] {</span>

<span class="nc" id="L319">    override val KEY: String = &quot;geomesa.geom.format&quot;</span>

    /**
     * Well-Known Text representation as a [[String]]
     */
<span class="nc" id="L324">    val WKT: String = &quot;wkt&quot;</span>
    /**
     * Well-Known Bytes representation as an [[Array]] of [[Byte]]s
     */
<span class="nc" id="L328">    val WKB: String = &quot;wkb&quot;</span>

<span class="nc bnc" id="L330" title="All 8 branches missed.">    override protected val valueMatcher: PartialFunction[(String, Schema.Field), String] = {</span>
<span class="nc bnc" id="L331" title="All 12 branches missed.">      case (WKT, field) =&gt; assertFieldType(field, Schema.Type.STRING); WKT</span>
<span class="nc bnc" id="L332" title="All 12 branches missed.">      case (WKB, field) =&gt; assertFieldType(field, Schema.Type.BYTES); WKB</span>
    }

<span class="nc" id="L335">    override protected val fieldReaderMatcher: PartialFunction[String, AnyRef =&gt; Geometry] = {</span>
<span class="nc bnc" id="L336" title="All 12 branches missed.">      case WKT =&gt; data =&gt; WKTUtils.read(data.toString)</span>
<span class="nc bnc" id="L337" title="All 12 branches missed.">      case WKB =&gt; data =&gt; WKBUtils.read(unwrap(data.asInstanceOf[ByteBuffer]))</span>
    }

<span class="nc" id="L340">    override protected val fieldWriterMatcher: PartialFunction[String, Geometry =&gt; AnyRef] = {</span>
<span class="nc bnc" id="L341" title="All 12 branches missed.">      case WKT =&gt; geom =&gt; WKTUtils.write(geom)</span>
<span class="nc bnc" id="L342" title="All 12 branches missed.">      case WKB =&gt; geom =&gt; ByteBuffer.wrap(WKBUtils.write(geom))</span>
    }

    private def unwrap(buf: ByteBuffer): Array[Byte] = {
<span class="nc bnc" id="L346" title="All 6 branches missed.">      if (buf.hasArray &amp;&amp; buf.arrayOffset() == 0 &amp;&amp; buf.limit() == buf.array().length) {</span>
<span class="nc" id="L347">        buf.array()</span>
      } else {
<span class="nc" id="L349">        val array = Array.ofDim[Byte](buf.limit())</span>
<span class="nc" id="L350">        buf.get(array)</span>
<span class="nc" id="L351">        array</span>
      }
    }
  }

  /**
   * Indicates that this field represents a [[Geometry]] with the given type. This property must be accompanied
   * by the [[GeoMesaAvroGeomFormat]] property.
   */
<span class="nc" id="L360">  object GeoMesaAvroGeomType extends GeoMesaAvroEnumProperty[Class[_ &lt;: Geometry]] {</span>
<span class="nc" id="L361">    override val KEY: String = &quot;geomesa.geom.type&quot;</span>

    /**
     * A [[Geometry]]
     */
<span class="nc" id="L366">    val GEOMETRY: String = &quot;geometry&quot;</span>
    /**
     * A [[Point]]
     */
<span class="nc" id="L370">    val POINT: String = &quot;point&quot;</span>
    /**
     * A [[LineString]]
     */
<span class="nc" id="L374">    val LINESTRING: String = &quot;linestring&quot;</span>
    /**
     * A [[Polygon]]
     */
<span class="nc" id="L378">    val POLYGON: String = &quot;polygon&quot;</span>
    /**
     * A [[MultiPoint]]
     */
<span class="nc" id="L382">    val MULTIPOINT: String = &quot;multipoint&quot;</span>
    /**
     * A [[MultiLineString]]
     */
<span class="nc" id="L386">    val MULTILINESTRING: String = &quot;multilinestring&quot;</span>
    /**
     * A [[MultiPolygon]]
     */
<span class="nc" id="L390">    val MULTIPOLYGON: String = &quot;multipolygon&quot;</span>
    /**
     * A [[GeometryCollection]]
     */
<span class="nc" id="L394">    val GEOMETRYCOLLECTION: String = &quot;geometrycollection&quot;</span>

<span class="nc bnc" id="L396" title="All 32 branches missed.">    override protected val valueMatcher: PartialFunction[(String, Schema.Field), Class[_ &lt;: Geometry]] = {</span>
<span class="nc bnc" id="L397" title="All 12 branches missed.">      case (GEOMETRY, _) =&gt; classOf[Geometry]</span>
<span class="nc bnc" id="L398" title="All 12 branches missed.">      case (POINT, _) =&gt; classOf[Point]</span>
<span class="nc bnc" id="L399" title="All 12 branches missed.">      case (LINESTRING, _) =&gt; classOf[LineString]</span>
<span class="nc bnc" id="L400" title="All 12 branches missed.">      case (POLYGON, _) =&gt; classOf[Polygon]</span>
<span class="nc bnc" id="L401" title="All 12 branches missed.">      case (MULTIPOINT, _) =&gt; classOf[MultiPoint]</span>
<span class="nc bnc" id="L402" title="All 12 branches missed.">      case (MULTILINESTRING, _) =&gt; classOf[MultiLineString]</span>
<span class="nc bnc" id="L403" title="All 12 branches missed.">      case (MULTIPOLYGON, _) =&gt; classOf[MultiPolygon]</span>
<span class="nc bnc" id="L404" title="All 12 branches missed.">      case (GEOMETRYCOLLECTION, _) =&gt; classOf[GeometryCollection]</span>
    }
  }

  /**
   * Indicates that this field is the default [[Geometry]] for this [[SimpleFeatureType]]. This property must be
   * accompanied by the [[GeoMesaAvroGeomFormat]] and [[GeoMesaAvroGeomType]] properties, and there may only be one
   * of these properties for a given schema.
   */
<span class="nc" id="L413">  object GeoMesaAvroGeomDefault extends GeoMesaAvroBooleanProperty {</span>
<span class="nc" id="L414">    override val KEY: String = &quot;geomesa.geom.default&quot;</span>
  }

  /**
   * Indicates that the field should be interpreted as a [[Date]] in the given format.
   */
<span class="nc" id="L420">  object GeoMesaAvroDateFormat extends GeoMesaAvroDeserializableEnumProperty[String, Date] {</span>
<span class="nc" id="L421">    override val KEY: String = &quot;geomesa.date.format&quot;</span>

    /**
     * Milliseconds since the Unix epoch as a [[Long]]
     */
<span class="nc" id="L426">    val EPOCH_MILLIS: String = &quot;epoch-millis&quot;</span>
    /**
     * A [[String]] with generic ISO date format
     */
<span class="nc" id="L430">    val ISO_DATE: String = &quot;iso-date&quot;</span>
    /**
     * A [[String]] with generic ISO datetime format
     */
<span class="nc" id="L434">    val ISO_DATETIME: String = &quot;iso-datetime&quot;</span>

<span class="nc bnc" id="L436" title="All 12 branches missed.">    override protected val valueMatcher: PartialFunction[(String, Schema.Field), String] = {</span>
<span class="nc bnc" id="L437" title="All 12 branches missed.">      case (EPOCH_MILLIS, field) =&gt; assertFieldType(field, Schema.Type.LONG); EPOCH_MILLIS</span>
<span class="nc bnc" id="L438" title="All 12 branches missed.">      case (ISO_DATE, field) =&gt; assertFieldType(field, Schema.Type.STRING); ISO_DATE</span>
<span class="nc bnc" id="L439" title="All 12 branches missed.">      case (ISO_DATETIME, field) =&gt; assertFieldType(field, Schema.Type.STRING); ISO_DATETIME</span>
    }

<span class="nc" id="L442">    override protected val fieldReaderMatcher: PartialFunction[String, AnyRef =&gt; Date] = {</span>
<span class="nc bnc" id="L443" title="All 12 branches missed.">      case EPOCH_MILLIS =&gt; data =&gt; new Date(data.asInstanceOf[java.lang.Long])</span>
<span class="nc bnc" id="L444" title="All 12 branches missed.">      case ISO_DATE =&gt; data =&gt; DateParsing.parseDate(data.toString, DateTimeFormatter.ISO_DATE)</span>
<span class="nc bnc" id="L445" title="All 12 branches missed.">      case ISO_DATETIME =&gt; data =&gt; DateParsing.parseDate(data.toString, DateTimeFormatter.ISO_DATE_TIME)</span>
    }

<span class="nc" id="L448">    override protected val fieldWriterMatcher: PartialFunction[String, Date =&gt; AnyRef] = {</span>
<span class="nc bnc" id="L449" title="All 12 branches missed.">      case EPOCH_MILLIS =&gt; date =&gt; Long.box(date.getTime)</span>
<span class="nc bnc" id="L450" title="All 12 branches missed.">      case ISO_DATE =&gt; date =&gt; DateParsing.formatDate(date, DateTimeFormatter.ISO_DATE)</span>
<span class="nc bnc" id="L451" title="All 12 branches missed.">      case ISO_DATETIME =&gt; date =&gt; DateParsing.formatDate(date, DateTimeFormatter.ISO_DATE_TIME)</span>
    }
  }

  /**
   * Specifies that the value of this field should be used as the visibility for features of this [[SimpleFeatureType]].
   * There may only be one of these properties for a given schema.
   */
<span class="nc" id="L459">  object GeoMesaAvroVisibilityField extends GeoMesaAvroBooleanProperty {</span>
<span class="nc" id="L460">    override val KEY: String = &quot;geomesa.visibility.field&quot;</span>

<span class="nc bnc" id="L462" title="All 8 branches missed.">    override protected val valueMatcher: PartialFunction[(String, Schema.Field), Boolean] = {</span>
<span class="nc bnc" id="L463" title="All 12 branches missed.">      case (TRUE, field) =&gt; assertFieldType(field, Schema.Type.STRING); true</span>
<span class="nc bnc" id="L464" title="All 12 branches missed.">      case (FALSE, field) =&gt; assertFieldType(field, Schema.Type.STRING); false</span>
    }
  }

  /**
   * Specifies whether this field should be excluded from the [[SimpleFeatureType]].
   */
<span class="nc" id="L471">  object GeoMesaAvroExcludeField extends GeoMesaAvroBooleanProperty {</span>
<span class="nc" id="L472">    override val KEY: String = &quot;geomesa.exclude.field&quot;</span>
  }
<span class="nc" id="L474">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>