<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaTimestampExtractor.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Kafka Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.kafka.streams</a> &gt; <span class="el_source">GeoMesaTimestampExtractor.scala</span></div><h1>GeoMesaTimestampExtractor.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.kafka.streams

import org.apache.kafka.clients.consumer.ConsumerRecord
import org.apache.kafka.streams.processor.TimestampExtractor
import org.geotools.api.feature.simple.SimpleFeatureType
import org.geotools.api.filter.expression.Expression
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.kafka.data.KafkaDataStoreParams
import org.locationtech.geomesa.kafka.index.FeatureStateFactory

import java.util.concurrent.ConcurrentHashMap

<span class="nc" id="L21">object GeoMesaTimestampExtractor {</span>

  /**
   * Get a timestamp extractor based on the data store config
   *
   * @param params data store params
   * @return
   */
  def apply(params: java.util.Map[String, _]): TimestampExtractor = {
<span class="nc" id="L30">    val paramsWithLazyFeatures = new java.util.HashMap[String, Any](params)</span>
    // set lazy features so we don't deserialize the whole message just to get the timestamp
<span class="nc" id="L32">    paramsWithLazyFeatures.put(KafkaDataStoreParams.LazyFeatures.key, &quot;true&quot;)</span>
    // disable consumers if not already done
<span class="nc" id="L34">    paramsWithLazyFeatures.put(KafkaDataStoreParams.ConsumerCount.key, 0)</span>

    // check for event time config
<span class="nc bnc" id="L37" title="All 2 branches missed.">    val eventTime = if (!KafkaDataStoreParams.EventTimeOrdering.lookup(params)) { None } else {</span>
<span class="nc" id="L38">      KafkaDataStoreParams.EventTime.lookupOpt(params)</span>
    }
<span class="nc" id="L40">    eventTime match {</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">      case None =&gt; new DefaultDateExtractor(paramsWithLazyFeatures)</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">      case Some(e) =&gt; new EventTimestampExtractor(e, paramsWithLazyFeatures)</span>
    }
  }

  /**
   * Timestamp extractor that will pull the timestamp from the serialized feature
   *
   * @param expression expression for the timestamp
   * @param params data store params
   */
<span class="nc" id="L52">  class EventTimestampExtractor(expression: String, params: java.util.Map[String, _])</span>
<span class="nc" id="L53">      extends FeatureTimestampExtractor(params) {</span>
    override protected def loadExpression(sft: SimpleFeatureType): Option[Expression] =
<span class="nc" id="L55">      Option(FastFilterFactory.toExpression(sft, expression))</span>
  }

  /**
   * Timestamp extractor that will pull the timestamp from the serialized feature
   *
   * @param params data store params
   */
<span class="nc" id="L63">  class DefaultDateExtractor(params: java.util.Map[String, _]) extends FeatureTimestampExtractor(params) {</span>

    import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

    override protected def loadExpression(sft: SimpleFeatureType): Option[Expression] =
<span class="nc" id="L68">      sft.getDtgField.map(FastFilterFactory.toExpression(sft, _))</span>
  }

  /**
   * Base class for extracting timestamps from simple features
   *
   * @param params data store params
   */
<span class="nc" id="L76">  private[streams] abstract class FeatureTimestampExtractor(params: java.util.Map[String, _])</span>
<span class="nc" id="L77">      extends TimestampExtractor {</span>

<span class="nc" id="L79">    private val cache = new SerializerCache(params.asInstanceOf[java.util.Map[String, Any]])</span>
<span class="nc" id="L80">    private val expressions = new ConcurrentHashMap[String, Option[Expression]]</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">    private val expressionLoader = new java.util.function.Function[String, Option[Expression]]() {</span>
      override def apply(topic: String): Option[Expression] =
<span class="nc" id="L84">        loadExpression(cache.serializer(topic).sft)</span>
    }

    // track last-used serializer so we don't have to look them up by hash each
    // time if we're just reading/writing to one topic (which is the standard use-case)
    @volatile
<span class="nc" id="L90">    private var last: (String, Option[Expression]) = (&quot;&quot;, null)</span>

    protected def loadExpression(sft: SimpleFeatureType): Option[Expression]

    override def extract(record: ConsumerRecord[AnyRef, AnyRef], previousTimestamp: Long): Long = {
<span class="nc" id="L95">      record.value() match {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        case null =&gt;</span>
<span class="nc" id="L97">          record.timestamp()</span>

<span class="nc bnc" id="L99" title="All 8 branches missed.">        case m: GeoMesaMessage if m.action == MessageAction.Upsert =&gt;</span>
<span class="nc" id="L100">          val topic = record.topic()</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">          val (lastTopic, lastExpression) = last</span>
<span class="nc bnc" id="L102" title="All 6 branches missed.">          val expression = if (lastTopic == topic) { lastExpression } else {</span>
<span class="nc" id="L103">            val expression = expressions.computeIfAbsent(topic, expressionLoader)</span>
            // should be thread-safe due to volatile
<span class="nc" id="L105">            last = (topic, expression)</span>
<span class="nc" id="L106">            expression</span>
          }
<span class="nc" id="L108">          expression match {</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">            case None =&gt; record.timestamp()</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            case Some(e) =&gt; FeatureStateFactory.time(e, cache.serializer(topic).wrap(m))</span>
          }

<span class="nc bnc" id="L113" title="All 8 branches missed.">        case m: GeoMesaMessage if m.action == MessageAction.Delete =&gt;</span>
<span class="nc" id="L114">          record.timestamp()</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">        case _: GeoMesaMessage =&gt;</span>
<span class="nc" id="L117">          throw new UnsupportedOperationException() // if we forget to handle a message action</span>

        case v =&gt;
<span class="nc" id="L120">          throw new IllegalArgumentException(s&quot;Expected a GeoMesaMessage but got: ${v.getClass.getName} $v&quot;)</span>
      }
    }
  }
<span class="nc" id="L124">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>