<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>package.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Kafka Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.kafka.streams</a> &gt; <span class="el_source">package.scala</span></div><h1>package.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.kafka

import org.apache.kafka.streams.processor.StreamPartitioner
import org.geotools.api.data.DataStoreFinder
import org.geotools.api.feature.`type`.{AttributeDescriptor, Name}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.feature.{GeometryAttribute, Property}
import org.geotools.api.filter.identity.FeatureId
import org.geotools.api.geometry.BoundingBox
import org.locationtech.geomesa.features.SimpleFeatureSerializer
import org.locationtech.geomesa.kafka.data.KafkaDataStore
import org.locationtech.geomesa.kafka.utils.GeoMessageSerializer
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.io.WithClose

import java.nio.charset.StandardCharsets
import java.util.concurrent.ConcurrentHashMap
import scala.collection.mutable.ArrayBuffer

<span class="nc" id="L28">package object streams {</span>

  /**
   * Trait for provided metadata about a feature type topic
   */
  trait HasTopicMetadata {

    /**
     * Gets the topic associated with a feature type
     *
     * @param typeName feature type name
     * @return
     */
    def topic(typeName: String): String

    /**
     * Gets the partitioning associated with a feature type
     *
     * @param typeName feature type name
     * @return true if Kafka default partitioning is used, false if custom partitioning is used
     */
    def usesDefaultPartitioning(typeName: String): Boolean
  }

  /**
   * Kafka partitioner for GeoMesa messages, to make sure all updates for a given
   * feature go to the same partition
   */
<span class="nc" id="L56">  class GeoMessageStreamPartitioner extends StreamPartitioner[String, GeoMesaMessage] {</span>
    override def partition(
        topic: String,
        key: String,
        value: GeoMesaMessage,
        numPartitions: Int): Integer = {
<span class="nc" id="L62">      GeoMessageSerializer.partition(numPartitions,</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">        if (key == null) { null } else { key.getBytes(StandardCharsets.UTF_8) })</span>
    }
  }

  /**
   * Cache for serializers and topic names
   *
   * @param params data store params
   */
<span class="nc" id="L72">  class SerializerCache(params: java.util.Map[String, _]) extends HasTopicMetadata {</span>

<span class="nc" id="L74">    private val metadataByTypeName = new ConcurrentHashMap[String, SchemaMetadata]()</span>
<span class="nc" id="L75">    private val serializersByTopic = new ConcurrentHashMap[String, GeoMesaMessageSerializer]()</span>

<span class="nc bnc" id="L77" title="All 2 branches missed.">    private val metadataLoader = new java.util.function.Function[String, SchemaMetadata]() {</span>
<span class="nc" id="L78">      override def apply(typeName: String): SchemaMetadata = loadMetadata(typeName)</span>
    }

<span class="nc bnc" id="L81" title="All 2 branches missed.">    private val serializerLoader = new java.util.function.Function[String, GeoMesaMessageSerializer]() {</span>
<span class="nc" id="L82">      override def apply(topic: String): GeoMesaMessageSerializer = loadSerializer(topic)</span>
    }

    // track last-used serializer so we don't have to look them up by hash each
    // time if we're just reading/writing to one topic (which is the standard use-case)
    @volatile
<span class="nc" id="L88">    private var last: (String, GeoMesaMessageSerializer) = (&quot;&quot;, null)</span>

<span class="nc" id="L90">    override def topic(typeName: String): String = metadataByTypeName.computeIfAbsent(typeName, metadataLoader).topic</span>

    override def usesDefaultPartitioning(typeName: String): Boolean =
<span class="nc" id="L93">      metadataByTypeName.computeIfAbsent(typeName, metadataLoader).usesDefaultPartitioning</span>

    /**
     * Gets the serializer associated with a topic
     *
     * @param topic kafka topic name
     * @return
     */
    def serializer(topic: String): GeoMesaMessageSerializer = {
<span class="nc bnc" id="L102" title="All 2 branches missed.">      val (lastTopic, lastSerializer) = last</span>
<span class="nc bnc" id="L103" title="All 6 branches missed.">      if (lastTopic == topic) { lastSerializer } else {</span>
<span class="nc" id="L104">        val serializer = serializersByTopic.computeIfAbsent(topic, serializerLoader)</span>
        // should be thread-safe due to volatile
<span class="nc" id="L106">        last = (topic, serializer)</span>
<span class="nc" id="L107">        serializer</span>
      }
    }

    private def loadMetadata(typeName: String): SchemaMetadata = {
<span class="nc" id="L112">      withDataStore { ds =&gt;</span>
<span class="nc" id="L113">        ds.getSchema(typeName) match {</span>
<span class="nc" id="L114">          case sft =&gt; SchemaMetadata(KafkaDataStore.topic(sft), KafkaDataStore.usesDefaultPartitioning(sft))</span>
          case null =&gt;
            throw new IllegalArgumentException(
              s&quot;Schema '$typeName' does not exist in the configured store. &quot; +
                  s&quot;Available schemas: ${ds.getTypeNames.mkString(&quot;, &quot;)}&quot;)
        }
      }
    }

<span class="nc" id="L123">    private def loadSerializer(topic: String): GeoMesaMessageSerializer = {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">      withDataStore { ds =&gt;</span>
<span class="nc" id="L125">        val topics = ArrayBuffer.empty[String]</span>
        // order so that we check the most likely ones first
<span class="nc bnc" id="L127" title="All 2 branches missed.">        val typeNames = ds.getTypeNames.partition(_.contains(topic)) match {</span>
<span class="nc" id="L128">          case (left, right) =&gt; left ++ right</span>
        }
<span class="nc" id="L130">        var i = 0</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        while (i &lt; typeNames.length) {</span>
<span class="nc" id="L132">          val sft = ds.getSchema(typeNames(i))</span>
<span class="nc" id="L133">          KafkaDataStore.topic(sft) match {</span>
<span class="nc bnc" id="L134" title="All 6 branches missed.">            case t if t == topic =&gt;</span>
<span class="nc" id="L135">              val internal = ds.serialization(sft).serializer</span>
<span class="nc" id="L136">              return new GeoMesaMessageSerializer(sft, internal)</span>

<span class="nc" id="L138">            case t =&gt; topics += t</span>
          }
<span class="nc" id="L140">          i += 1</span>
        }
<span class="nc" id="L142">        throw new IllegalArgumentException(</span>
<span class="nc" id="L143">          s&quot;Topic '$topic' does not exist in the configured store. Available topics: ${topics.mkString(&quot;, &quot;)}&quot;)</span>
      }
    }

    private def withDataStore[T](fn: KafkaDataStore =&gt; T): T = {
<span class="nc" id="L148">      WithClose(DataStoreFinder.getDataStore(params)) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        case ds: KafkaDataStore =&gt; fn(ds)</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        case null =&gt; throw new IllegalArgumentException(&quot;Could not load data store with provided params&quot;)</span>
<span class="nc" id="L151">        case ds =&gt; throw new IllegalArgumentException(s&quot;Expected a KafkaDataStore but got ${ds.getClass.getName}&quot;)</span>
      }
    }

<span class="nc bnc" id="L155" title="All 33 branches missed.">    private case class SchemaMetadata(topic: String, usesDefaultPartitioning: Boolean)</span>
  }

  /**
   * Serializer for GeoMesaMessages
   *
   * @param sft feature type
   * @param internal nested serializer
   */
<span class="nc" id="L164">  class GeoMesaMessageSerializer(val sft: SimpleFeatureType, val internal: SimpleFeatureSerializer) {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L168">    private val converters: Array[AnyRef =&gt; AnyRef] =</span>
<span class="nc" id="L169">      sft.getAttributeDescriptors.toArray(Array.empty[AttributeDescriptor]).map { d =&gt;</span>
<span class="nc" id="L170">        val binding = d.getType.getBinding.asInstanceOf[Class[_ &lt;: AnyRef]]</span>
<span class="nc" id="L171">        (in: AnyRef) =&gt; FastConverter.convert(in, binding)</span>
      }

    def serialize(data: GeoMesaMessage): Array[Byte] = {
<span class="nc" id="L175">      data.action match {</span>
<span class="nc bnc" id="L176" title="All 6 branches missed.">        case MessageAction.Upsert =&gt; internal.serialize(wrap(data))</span>
<span class="nc bnc" id="L177" title="All 6 branches missed.">        case MessageAction.Delete =&gt; null</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        case null =&gt; throw new NullPointerException(&quot;action is null&quot;)</span>
<span class="nc" id="L179">        case _ =&gt; throw new UnsupportedOperationException(s&quot;No serialization implemented for action '${data.action}'&quot;)</span>
      }
    }

    def deserialize(data: Array[Byte]): GeoMesaMessage = {
<span class="nc bnc" id="L184" title="All 4 branches missed.">      if (data == null || data.isEmpty) { GeoMesaMessage.delete() } else {</span>
<span class="nc" id="L185">        val feature = internal.deserialize(data)</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        val userData = if (feature.getUserData.isEmpty) { Map.empty[String, String] } else {</span>
<span class="nc" id="L187">          val builder = Map.newBuilder[String, String]</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">          feature.getUserData.asScala.foreach {</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">            case (k: String, v: String) =&gt; builder += k -&gt; v</span>
<span class="nc" id="L190">            case (k, v) =&gt; builder += k.toString -&gt; v.toString</span>
          }
<span class="nc" id="L192">          builder.result</span>
        }
<span class="nc" id="L194">        GeoMesaMessage.upsert(feature.getAttributes.asScala.toSeq, userData)</span>
      }
    }

    /**
     * Wrap a message as a simple feature
     *
     * @param message message
     * @return
     */
    def wrap(message: GeoMesaMessage): SimpleFeature =
<span class="nc" id="L205">      new SerializableFeature(converters, message.attributes.toIndexedSeq, message.userData)</span>
  }

  /**
   * SimpleFeature skeleton that only provides the methods required for GeoMesa serialization, which are:
   *   * `def getAttribute(i: Int): AnyRef`
   *   * `def getUserData: java.util.Map[AnyRef, AnyRef]`
   *
   * See
   *   * @see [[org.locationtech.geomesa.features.kryo.impl.KryoFeatureSerialization#writeFeature]]
   *   * @see [[org.locationtech.geomesa.features.avro.serialization.SimpleFeatureDatumWriter#write]]
   *
   * @param converters attribute converters to enforce feature type schema
   * @param attributes message attributes
   */
  // noinspection NotImplementedCode
<span class="nc" id="L221">  private[streams] class SerializableFeature(</span>
<span class="nc" id="L222">      converters: Array[AnyRef =&gt; AnyRef],</span>
<span class="nc" id="L223">      attributes: IndexedSeq[AnyRef],</span>
<span class="nc" id="L224">      userData: Map[String, String]</span>
<span class="nc" id="L225">    ) extends SimpleFeature {</span>

    import scala.collection.JavaConverters._

<span class="nc" id="L229">    override def getAttribute(i: Int): AnyRef = converters(i).apply(attributes(i))</span>
    override def getUserData: java.util.Map[AnyRef, AnyRef] =
<span class="nc" id="L231">      userData.asJava.asInstanceOf[java.util.Map[AnyRef, AnyRef]]</span>

<span class="nc" id="L233">    override def getID: String = throw new UnsupportedOperationException()</span>
<span class="nc" id="L234">    override def getType: SimpleFeatureType = throw new UnsupportedOperationException()</span>
<span class="nc" id="L235">    override def getFeatureType: SimpleFeatureType = throw new UnsupportedOperationException()</span>
<span class="nc" id="L236">    override def getAttributes: java.util.List[AnyRef] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L237">    override def setAttributes(list:java.util.List[AnyRef]): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L238">    override def setAttributes(objects: Array[AnyRef]): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L239">    override def getAttribute(s: String): AnyRef = throw new UnsupportedOperationException()</span>
<span class="nc" id="L240">    override def setAttribute(s: String, o: Any): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L241">    override def getAttribute(name: Name): AnyRef = throw new UnsupportedOperationException()</span>
<span class="nc" id="L242">    override def setAttribute(name: Name, o: Any): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L243">    override def setAttribute(i: Int, o: Any): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L244">    override def getAttributeCount: Int = throw new UnsupportedOperationException()</span>
<span class="nc" id="L245">    override def getDefaultGeometry: AnyRef = throw new UnsupportedOperationException()</span>
<span class="nc" id="L246">    override def setDefaultGeometry(o: Any): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L247">    override def getIdentifier: FeatureId = throw new UnsupportedOperationException()</span>
<span class="nc" id="L248">    override def getBounds: BoundingBox = throw new UnsupportedOperationException()</span>
<span class="nc" id="L249">    override def getDefaultGeometryProperty: GeometryAttribute = throw new UnsupportedOperationException()</span>
<span class="nc" id="L250">    override def setDefaultGeometryProperty(geometryAttribute: GeometryAttribute): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L251">    override def setValue(collection:java.util.Collection[Property]): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L252">    override def getValue:java.util.Collection[_ &lt;: Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L253">    override def getProperties(name: Name):java.util.Collection[Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L254">    override def getProperty(name: Name): Property = throw new UnsupportedOperationException()</span>
<span class="nc" id="L255">    override def getProperties(s: String):java.util.Collection[Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L256">    override def getProperties:java.util.Collection[Property] = throw new UnsupportedOperationException()</span>
<span class="nc" id="L257">    override def getProperty(s: String): Property = throw new UnsupportedOperationException()</span>
<span class="nc" id="L258">    override def validate(): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L259">    override def getDescriptor: AttributeDescriptor = throw new UnsupportedOperationException()</span>
<span class="nc" id="L260">    override def setValue(o: Any): Unit = throw new UnsupportedOperationException()</span>
<span class="nc" id="L261">    override def getName: Name = throw new UnsupportedOperationException()</span>
<span class="nc" id="L262">    override def isNillable: Boolean = throw new UnsupportedOperationException()</span>
  }
<span class="nc" id="L264">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>