<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeoMesaStreamsBuilder.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Kafka Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.kafka.streams</a> &gt; <span class="el_source">GeoMesaStreamsBuilder.scala</span></div><h1>GeoMesaStreamsBuilder.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.kafka.streams

import org.apache.kafka.clients.consumer.ConsumerConfig
import org.apache.kafka.common.serialization.Serde
import org.apache.kafka.streams.Topology
import org.apache.kafka.streams.Topology.AutoOffsetReset
import org.apache.kafka.streams.kstream.GlobalKTable
import org.apache.kafka.streams.processor.TimestampExtractor
import org.apache.kafka.streams.scala.kstream._
import org.apache.kafka.streams.scala.{ByteArrayKeyValueStore, StreamsBuilder}
import org.locationtech.geomesa.kafka.data.KafkaDataStoreFactory

import scala.concurrent.duration.Duration

/**
 * Wrapper for a kafka streams builder that will configure serialization based on a GeoMesa Kafka feature store
 *
 * @param wrapped streams builder
 * @param serde serialization for geomesa messages
 * @param timestampExtractor timestamp extractor
 * @param resetPolicy reset policy
 */
<span class="nc" id="L31">class GeoMesaStreamsBuilder(</span>
<span class="nc" id="L32">    val wrapped: StreamsBuilder,</span>
<span class="nc" id="L33">    serde: GeoMesaSerde,</span>
    timestampExtractor: TimestampExtractor,
    resetPolicy: Option[AutoOffsetReset]) {

  import org.apache.kafka.streams.scala.Serdes.String

<span class="nc" id="L39">  private implicit val s: GeoMesaSerde = serde</span>

<span class="nc" id="L41">  implicit val consumed: Consumed[String, GeoMesaMessage] = resetPolicy match {</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">    case None =&gt; Consumed.`with`(timestampExtractor)</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    case Some(p) =&gt; Consumed.`with`(timestampExtractor, p)</span>
  }

  /**
   * Gets a serde for the given feature type
   *
   * @param typeName feature type name
   * @return
   */
<span class="nc" id="L52">  def serde(typeName: String): Serde[GeoMesaMessage] = serde.forType(typeName)</span>

  /**
   * Create a stream of updates for a given feature type
   *
   * @param typeName feature type name
   * @return
   */
<span class="nc" id="L60">  def stream(typeName: String): KStream[String, GeoMesaMessage] = wrapped.stream(serde.topic(typeName))</span>

  /**
   * Create a table for a given feature type
   *
   * @param typeName feature type name
   * @return
   */
<span class="nc" id="L68">  def table(typeName: String): KTable[String, GeoMesaMessage] = wrapped.table(serde.topic(typeName))</span>

  /**
   * Create a table for a given feature type
   *
   * @param typeName feature type name
   * @param materialized materialized
   * @return
   */
  def table(
      typeName: String,
      materialized: Materialized[String, GeoMesaMessage, ByteArrayKeyValueStore]): KTable[String, GeoMesaMessage] =
<span class="nc" id="L80">    wrapped.table(serde.topic(typeName), materialized)</span>

  /**
   * Create a global table for a given feature type
   *
   * @param typeName feature type name
   * @return
   */
  def globalTable(typeName: String): GlobalKTable[String, GeoMesaMessage] =
<span class="nc" id="L89">    wrapped.globalTable(serde.topic(typeName))</span>

  /**
   * Create a global table for a given feature type
   *
   * @param typeName feature type name
   * @param materialized materialized
   * @return
   */
  def globalTable(
      typeName: String,
      materialized: Materialized[String, GeoMesaMessage, ByteArrayKeyValueStore]): GlobalKTable[String, GeoMesaMessage] =
<span class="nc" id="L101">    wrapped.globalTable(serde.topic(typeName), materialized)</span>

  /**
   * Write the stream to the given feature type, which must already exist. The messages
   * must conform to the feature type schema
   *
   * @param typeName feature type name
   * @param stream stream to persist
   */
  def to(typeName: String, stream: KStream[String, GeoMesaMessage]): Unit = {
    implicit val produced: Produced[String, GeoMesaMessage] =
<span class="nc bnc" id="L112" title="All 2 branches missed.">      if (serde.usesDefaultPartitioning(typeName)) {</span>
<span class="nc" id="L113">        Produced.`with`</span>
      } else {
<span class="nc" id="L115">        Produced.`with`(new GeoMessageStreamPartitioner())</span>
      }
<span class="nc" id="L117">    stream.to(serde.topic(typeName))</span>
  }

  /**
   * Convenience method to build the underlying topology
   *
   * @return
   */
<span class="nc" id="L125">  def build(): Topology = wrapped.build()</span>
}

<span class="nc" id="L128">object GeoMesaStreamsBuilder {</span>

  import scala.collection.JavaConverters._

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @return
   */
  def apply(params: Map[String, String]): GeoMesaStreamsBuilder =
<span class="nc" id="L139">    apply(params, null, null, null)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param streamsBuilder underlying streams builder to use
   * @return
   */
  def apply(
      params: Map[String, String],
      streamsBuilder: StreamsBuilder): GeoMesaStreamsBuilder =
<span class="nc" id="L151">    apply(params, null, null, streamsBuilder)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param timestampExtractor timestamp extractor for message stream
   * @return
   */
  def apply(
      params: Map[String, String],
      timestampExtractor: TimestampExtractor): GeoMesaStreamsBuilder =
<span class="nc" id="L163">    apply(params, timestampExtractor, null, null)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param timestampExtractor timestamp extractor for message stream
   * @param streamsBuilder underlying streams builder to use
   * @return
   */
  def apply(
      params: Map[String, String],
      timestampExtractor: TimestampExtractor,
      streamsBuilder: StreamsBuilder): GeoMesaStreamsBuilder =
<span class="nc" id="L177">    apply(params, timestampExtractor, null, streamsBuilder)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param resetPolicy auto offset reset for reading existing topics
   * @return
   */
  def apply(
      params: Map[String, String],
      resetPolicy: AutoOffsetReset): GeoMesaStreamsBuilder =
<span class="nc" id="L189">    apply(params, null, resetPolicy, null)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param resetPolicy auto offset reset for reading existing topics
   * @param streamsBuilder underlying streams builder to use
   * @return
   */
  def apply(
      params: Map[String, String],
      resetPolicy: AutoOffsetReset,
      streamsBuilder: StreamsBuilder): GeoMesaStreamsBuilder =
<span class="nc" id="L203">    apply(params, null, resetPolicy, streamsBuilder)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param timestampExtractor timestamp extractor for message stream
   * @param resetPolicy auto offset reset for reading existing topics
   * @return
   */
  def apply(
      params: Map[String, String],
      timestampExtractor: TimestampExtractor,
      resetPolicy: AutoOffsetReset): GeoMesaStreamsBuilder =
<span class="nc" id="L217">    apply(params, timestampExtractor, resetPolicy, null)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param timestampExtractor timestamp extractor for message stream
   * @param resetPolicy auto offset reset for reading existing topics
   * @param streamsBuilder underlying streams builder to use
   * @return
   */
  def apply(
      params: Map[String, String],
      timestampExtractor: TimestampExtractor,
      resetPolicy: AutoOffsetReset,
      streamsBuilder: StreamsBuilder): GeoMesaStreamsBuilder =
<span class="nc" id="L233">    apply(params.asJava, timestampExtractor, resetPolicy, streamsBuilder)</span>

  /**
   * Create a streams builder
   *
   * @param params data store parameters
   * @param timestampExtractor timestamp extractor for message stream
   * @param resetPolicy auto offset reset for reading existing topics
   * @param streamsBuilder underlying streams builder to use
   * @return
   */
  def apply(
      params: java.util.Map[String, String],
      timestampExtractor: TimestampExtractor,
      resetPolicy: AutoOffsetReset,
      streamsBuilder: StreamsBuilder): GeoMesaStreamsBuilder = {
<span class="nc" id="L249">    val serde = new GeoMesaSerde()</span>
<span class="nc" id="L250">    serde.configure(params, isKey = false)</span>
<span class="nc" id="L251">    val builder = Option(streamsBuilder).getOrElse(new StreamsBuilder())</span>
<span class="nc" id="L252">    val timestamps = Option(timestampExtractor).getOrElse(GeoMesaTimestampExtractor(params))</span>
<span class="nc" id="L253">    val reset = Option(resetPolicy).orElse(resetConfig(params))</span>
<span class="nc" id="L254">    new GeoMesaStreamsBuilder(builder, serde, timestamps, reset)</span>
  }

  private def resetConfig(params: java.util.Map[String, String]): Option[AutoOffsetReset] = {
<span class="nc" id="L258">    val config = KafkaDataStoreFactory.buildConfig(params.asInstanceOf[java.util.Map[String, java.io.Serializable]])</span>
<span class="nc" id="L259">    config.consumers.properties.get(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG).map {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      case r if r.equalsIgnoreCase(AutoOffsetReset.EARLIEST.name()) =&gt; AutoOffsetReset.EARLIEST</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">      case r if r.equalsIgnoreCase(AutoOffsetReset.LATEST.name()) =&gt; AutoOffsetReset.LATEST</span>
<span class="nc" id="L262">      case r =&gt; throw new IllegalArgumentException(s&quot;Invalid ${ConsumerConfig.AUTO_OFFSET_RESET_CONFIG}: $r&quot;)</span>
    }.orElse {
<span class="nc bnc" id="L264" title="All 12 branches missed.">      config.consumers.readBack.collect { case Duration.Inf =&gt; AutoOffsetReset.EARLIEST }</span>
    }
  }
<span class="nc" id="L267">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>