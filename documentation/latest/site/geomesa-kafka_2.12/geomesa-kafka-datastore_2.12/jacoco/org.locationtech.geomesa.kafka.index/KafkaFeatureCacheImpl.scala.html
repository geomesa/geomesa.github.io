<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KafkaFeatureCacheImpl.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Kafka Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.kafka.index</a> &gt; <span class="el_source">KafkaFeatureCacheImpl.scala</span></div><h1>KafkaFeatureCacheImpl.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.kafka.index

import io.micrometer.core.instrument.{Metrics, Tags}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.locationtech.geomesa.kafka.data.KafkaDataStore
import org.locationtech.geomesa.kafka.data.KafkaDataStore.{IndexConfig, LayerView}
import org.locationtech.geomesa.kafka.index.FeatureStateFactory.{FeatureExpiration, FeatureState}
import org.locationtech.geomesa.memory.cqengine.GeoCQIndex
import org.locationtech.geomesa.memory.cqengine.utils.CQIndexType
import org.locationtech.geomesa.memory.index.SimpleFeatureSpatialIndex
import org.locationtech.geomesa.memory.index.impl.{BucketIndex, SizeSeparatedBucketIndex}
import org.locationtech.geomesa.metrics.micrometer.utils.GaugeUtils

import java.util.concurrent._

/**
 * Feature cache implementation
 *
 * @param sft simple feature type
 * @param config index config
 * @param layerViews layer views
 */
<span class="nc" id="L32">class KafkaFeatureCacheImpl(sft: SimpleFeatureType, config: IndexConfig, layerViews: Seq[LayerView] = Seq.empty, tags: Tags = Tags.empty())</span>
<span class="nc" id="L33">    extends KafkaFeatureCache with FeatureExpiration {</span>

  import org.locationtech.geomesa.kafka.index.KafkaFeatureCacheImpl.MetricsPrefix
  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  // keeps location and expiry keyed by feature ID (we need a way to retrieve a feature based on ID for
  // update/delete operations). to reduce contention, we never iterate over this map
<span class="nc" id="L40">  private val state = GaugeUtils.mapSizeGauge(s&quot;$MetricsPrefix.size&quot;, tags, new ConcurrentHashMap[String, FeatureState]())</span>

<span class="nc" id="L42">  private val spatialIndex = createIndex(sft)</span>

<span class="nc" id="L44">  private val factory = FeatureStateFactory(sft, spatialIndex, config.expiry, this, config.executor)</span>

<span class="nc" id="L46">  override val views: Seq[KafkaFeatureCacheView] =</span>
<span class="nc" id="L47">    layerViews.map(view =&gt; KafkaFeatureCacheView(view, createIndex(view.viewSft)))</span>

<span class="nc" id="L49">  private val expirations = Metrics.counter(s&quot;$MetricsPrefix.expirations&quot;, tags)</span>

<span class="nc bnc" id="L51" title="All 2 branches missed.">  logger.debug(s&quot;Initialized KafkaFeatureCache with factory $factory and support $spatialIndex&quot;)</span>

  /**
    * Note: this method is not thread-safe. The `state` and `index` can get out of sync if the same feature
    * is updated simultaneously from two different threads
    *
    * In our usage, this isn't a problem, as a given feature ID is always operated on by a single thread
    * due to kafka consumer partitioning
    */
  override def put(feature: SimpleFeature): Unit = {
<span class="nc bnc" id="L61" title="All 2 branches missed.">    if (feature.getDefaultGeometry == null) {</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">      logger.warn(s&quot;Null geometry detected for feature ${feature.getID}. Skipping loading into cache.&quot;)</span>
<span class="nc" id="L63">      return</span>
    }
<span class="nc" id="L65">    val featureState = factory.createState(feature)</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">    logger.trace(s&quot;${featureState.id} adding feature $featureState&quot;)</span>
<span class="nc" id="L67">    val old = state.put(featureState.id, featureState)</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">    if (old == null) {</span>
<span class="nc" id="L69">      featureState.insertIntoIndex()</span>
<span class="nc" id="L70">      views.foreach(_.put(feature))</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">    } else if (old.time &lt;= featureState.time) {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">      logger.trace(s&quot;${featureState.id} removing old feature&quot;)</span>
<span class="nc" id="L73">      old.removeFromIndex()</span>
<span class="nc" id="L74">      featureState.insertIntoIndex()</span>
<span class="nc" id="L75">      views.foreach { view =&gt;</span>
<span class="nc" id="L76">        view.remove(featureState.id)</span>
<span class="nc" id="L77">        view.put(feature)</span>
      }
    } else {
<span class="nc bnc" id="L80" title="All 2 branches missed.">      logger.trace(s&quot;${featureState.id} ignoring out of sequence feature&quot;)</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      if (!state.replace(featureState.id, featureState, old)) {</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        logger.warn(s&quot;${featureState.id} detected inconsistent state... spatial index may be incorrect&quot;)</span>
<span class="nc" id="L83">        old.removeFromIndex()</span>
<span class="nc" id="L84">        views.foreach(_.remove(featureState.id))</span>
      }
    }
<span class="nc bnc" id="L87" title="All 2 branches missed.">    logger.trace(s&quot;Current index size: ${state.size()}/${spatialIndex.size()}&quot;)</span>
  }

  /**
    * Note: this method is not thread-safe. The `state` and `index` can get out of sync if the same feature
    * is updated simultaneously from two different threads
    *
    * In our usage, this isn't a problem, as a given feature ID is always operated on by a single thread
    * due to kafka consumer partitioning
    */
  override def remove(id: String): Unit = {
<span class="nc bnc" id="L98" title="All 2 branches missed.">    logger.trace(s&quot;$id removing feature&quot;)</span>
<span class="nc" id="L99">    val old = state.remove(id)</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">    if (old != null) {</span>
<span class="nc" id="L101">      old.removeFromIndex()</span>
<span class="nc" id="L102">      views.foreach(_.remove(id))</span>
    }
<span class="nc bnc" id="L104" title="All 2 branches missed.">    logger.trace(s&quot;Current index size: ${state.size()}/${spatialIndex.size()}&quot;)</span>
  }

  override def expire(featureState: FeatureState): Unit = {
<span class="nc bnc" id="L108" title="All 2 branches missed.">    logger.trace(s&quot;${featureState.id} expiring from index&quot;)</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">    if (state.remove(featureState.id, featureState)) {</span>
<span class="nc" id="L110">      featureState.removeFromIndex()</span>
<span class="nc" id="L111">      views.foreach(_.remove(featureState.id))</span>
<span class="nc" id="L112">      expirations.increment()</span>
    }
<span class="nc bnc" id="L114" title="All 2 branches missed.">    logger.trace(s&quot;Current index size: ${state.size()}/${spatialIndex.size()}&quot;)</span>
  }

  override def clear(): Unit = {
<span class="nc bnc" id="L118" title="All 2 branches missed.">    logger.trace(&quot;Clearing index&quot;)</span>
<span class="nc" id="L119">    state.clear()</span>
<span class="nc" id="L120">    spatialIndex.clear()</span>
<span class="nc" id="L121">    views.foreach(_.clear())</span>
  }

<span class="nc" id="L124">  override def size(): Int = state.size()</span>

  // optimized for filter.include
<span class="nc bnc" id="L127" title="All 6 branches missed.">  override def size(f: Filter): Int = if (f == Filter.INCLUDE) { size() } else { query(f).length }</span>

  override def query(id: String): Option[SimpleFeature] =
<span class="nc" id="L130">    Option(state.get(id)).flatMap(f =&gt; Option(f.retrieveFromIndex()))</span>

<span class="nc" id="L132">  override def query(filter: Filter): Iterator[SimpleFeature] = spatialIndex.query(filter)</span>

<span class="nc" id="L134">  override def close(): Unit = factory.close()</span>

  private def createIndex(sft: SimpleFeatureType): SimpleFeatureSpatialIndex = {
<span class="nc bnc" id="L137" title="All 2 branches missed.">    if (config.cqAttributes.nonEmpty) {</span>
      val attributes =
<span class="nc bnc" id="L139" title="All 6 branches missed.">        if (config.cqAttributes == Seq(KafkaDataStore.CqIndexFlag)) {</span>
          // deprecated boolean config to enable indices based on the stored simple feature type
<span class="nc" id="L141">          CQIndexType.getDefinedAttributes(sft) ++ Option(sft.getGeomField).map((_, CQIndexType.GEOMETRY))</span>
        } else {
<span class="nc" id="L143">          config.cqAttributes</span>
        }
      // note: CQEngine handles points vs non-points internally
<span class="nc" id="L146">      new GeoCQIndex(sft, attributes, config.resolution.x, config.resolution.y)</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    } else if (sft.isPoints) {</span>
<span class="nc" id="L148">      BucketIndex(sft, config.resolution.x, config.resolution.y)</span>
    } else {
<span class="nc" id="L150">      SizeSeparatedBucketIndex(sft, config.ssiTiers, config.resolution.x / 360d, config.resolution.y / 180d)</span>
    }
  }
}

<span class="nc" id="L155">object KafkaFeatureCacheImpl {</span>
<span class="nc" id="L156">  private val MetricsPrefix = s&quot;${KafkaDataStore.MetricsPrefix}.index&quot;</span>
<span class="nc" id="L157">}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>