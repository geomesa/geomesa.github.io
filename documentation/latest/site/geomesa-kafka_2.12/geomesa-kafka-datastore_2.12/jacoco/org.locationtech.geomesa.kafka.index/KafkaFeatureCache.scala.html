<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KafkaFeatureCache.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Kafka Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.kafka.index</a> &gt; <span class="el_source">KafkaFeatureCache.scala</span></div><h1>KafkaFeatureCache.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.kafka.index

import com.typesafe.scalalogging.LazyLogging
import io.micrometer.core.instrument.Tags
import org.geotools.api.data.{FeatureListener, SimpleFeatureSource}
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.filter.expression.Expression
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.kafka.data.KafkaDataStore._

import java.io.Closeable
import java.util.concurrent._

trait KafkaFeatureCache extends KafkaListeners with Closeable {
  def put(feature: SimpleFeature): Unit
  def remove(id: String): Unit
  def clear(): Unit
  def size(): Int
  def size(filter: Filter): Int
  def query(id: String): Option[SimpleFeature]
  def query(filter: Filter): Iterator[SimpleFeature]
  def views: Seq[KafkaFeatureCacheView]
}

<span class="nc bnc" id="L34" title="All 4 branches missed.">object KafkaFeatureCache extends LazyLogging {</span>

  /**
   * Create a standard feature cache
   *
   * @param sft simple feature type
   * @param config cache config
   * @param views layer view config
   * @return
   */
<span class="nc" id="L44">  def apply(sft: SimpleFeatureType, config: IndexConfig, views: Seq[LayerView] = Seq.empty, tags: Tags = Tags.empty()): KafkaFeatureCache = {</span>
<span class="nc bnc" id="L45" title="All 6 branches missed.">    if (config.expiry == ImmediatelyExpireConfig) {</span>
<span class="nc" id="L46">      new NoOpFeatureCache(views.map(v =&gt; KafkaFeatureCacheView.empty(v.viewSft)))</span>
    } else {
<span class="nc" id="L48">      new KafkaFeatureCacheImpl(sft, config, views, tags)</span>
    }
  }

  /**
    * No-op cache
    *
    * @return
    */
<span class="nc" id="L57">  def empty(views: Seq[LayerView] = Seq.empty): KafkaFeatureCache =</span>
<span class="nc" id="L58">    new EmptyFeatureCache(views.map(v =&gt; KafkaFeatureCacheView.empty(v.viewSft)))</span>

  /**
    * Cache that won't spatially index the features
    *
    * @param sft simple feature type
    * @param ordering feature ordering
    * @return
    */
<span class="nc" id="L67">  def nonIndexing(sft: SimpleFeatureType, ordering: ExpiryTimeConfig = NeverExpireConfig): KafkaFeatureCache = {</span>
<span class="nc" id="L68">    val event: PartialFunction[ExpiryTimeConfig, String] = {</span>
<span class="nc bnc" id="L69" title="All 8 branches missed.">      case EventTimeConfig(_, exp, true) =&gt; exp</span>
    }

<span class="nc" id="L72">    val ord = ordering match {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">      case o if event.isDefinedAt(o) =&gt; Some(event.apply(o))</span>
      // all filters use the same event time ordering
<span class="nc bnc" id="L75" title="All 4 branches missed.">      case FilteredExpiryConfig(filters) if event.isDefinedAt(filters.head._2) =&gt; Some(event.apply(filters.head._2))</span>
<span class="nc" id="L76">      case _ =&gt; None</span>
    }

<span class="nc" id="L79">    ord.map(FastFilterFactory.toExpression(sft, _)) match {</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">      case None =&gt; new NonIndexingFeatureCache()</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">      case Some(exp) =&gt; new NonIndexingEventTimeFeatureCache(exp)</span>
    }
  }

  /**
    * Non-indexing feature cache that just tracks the most recent feature
    */
<span class="nc" id="L88">  private class NonIndexingFeatureCache extends KafkaFeatureCache {</span>

<span class="nc" id="L90">    private val state = new ConcurrentHashMap[String, SimpleFeature]</span>

<span class="nc" id="L92">    override def put(feature: SimpleFeature): Unit = state.put(feature.getID, feature)</span>

<span class="nc" id="L94">    override def remove(id: String): Unit = state.remove(id)</span>

<span class="nc" id="L96">    override def clear(): Unit = state.clear()</span>

<span class="nc" id="L98">    override def close(): Unit = {}</span>

<span class="nc" id="L100">    override def size(): Int = state.size()</span>

<span class="nc" id="L102">    override def size(filter: Filter): Int = query(filter).length</span>

<span class="nc" id="L104">    override def query(id: String): Option[SimpleFeature] = Option(state.get(id))</span>

    override def query(filter: Filter): Iterator[SimpleFeature] = {
      import scala.collection.JavaConverters._
<span class="nc" id="L108">      val features = state.asScala.valuesIterator</span>
<span class="nc bnc" id="L109" title="All 6 branches missed.">      if (filter == Filter.INCLUDE) { features } else {</span>
<span class="nc" id="L110">        features.filter(filter.evaluate)</span>
      }
    }

<span class="nc" id="L114">    override def views: Seq[KafkaFeatureCacheView] = Seq.empty</span>
  }

  /**
    * Non-indexing feature cache that just tracks the most recent feature, based on event time
    *
    * @param time event time expression
    */
<span class="nc" id="L122">  private class NonIndexingEventTimeFeatureCache(time: Expression) extends KafkaFeatureCache {</span>

<span class="nc" id="L124">    private val state = new ConcurrentHashMap[String, (SimpleFeature, Long)]</span>

    /**
      * Note: this method is not thread-safe. The `state` and can fail to replace the correct values
      * if the same feature is updated simultaneously from two different threads
      *
      * In our usage, this isn't a problem, as a given feature ID is always operated on by a single thread
      * due to kafka consumer partitioning
      */
    override def put(feature: SimpleFeature): Unit = {
<span class="nc" id="L134">      val tuple = (feature, FeatureStateFactory.time(time, feature))</span>
<span class="nc" id="L135">      val old = state.put(feature.getID, tuple)</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">      if (old != null &amp;&amp; old._2 &gt; tuple._2) {</span>
<span class="nc" id="L137">        state.replace(feature.getID, tuple, old)</span>
      }
    }

<span class="nc" id="L141">    override def remove(id: String): Unit = state.remove(id)</span>

<span class="nc" id="L143">    override def clear(): Unit = state.clear()</span>

<span class="nc" id="L145">    override def close(): Unit = {}</span>

<span class="nc" id="L147">    override def size(): Int = state.size()</span>

<span class="nc" id="L149">    override def size(filter: Filter): Int = query(filter).length</span>

<span class="nc" id="L151">    override def query(id: String): Option[SimpleFeature] = Option(state.get(id)).map(_._1)</span>

    override def query(filter: Filter): Iterator[SimpleFeature] = {
      import scala.collection.JavaConverters._
<span class="nc" id="L155">      val features = state.asScala.valuesIterator.map(_._1)</span>
<span class="nc bnc" id="L156" title="All 6 branches missed.">      if (filter == Filter.INCLUDE) { features } else {</span>
<span class="nc" id="L157">        features.filter(filter.evaluate)</span>
      }
    }

<span class="nc" id="L161">    override def views: Seq[KafkaFeatureCacheView] = Seq.empty</span>
  }

<span class="nc" id="L164">  class EmptyFeatureCache(val views: Seq[KafkaFeatureCacheView]) extends KafkaFeatureCache {</span>
<span class="nc" id="L165">    override def put(feature: SimpleFeature): Unit = throw new UnsupportedOperationException(&quot;Empty feature cache&quot;)</span>
<span class="nc" id="L166">    override def remove(id: String): Unit = throw new UnsupportedOperationException(&quot;Empty feature cache&quot;)</span>
<span class="nc" id="L167">    override def clear(): Unit = throw new UnsupportedOperationException(&quot;Empty feature cache&quot;)</span>
<span class="nc" id="L168">    override def size(): Int = 0</span>
<span class="nc" id="L169">    override def size(filter: Filter): Int = 0</span>
<span class="nc" id="L170">    override def query(id: String): Option[SimpleFeature] = None</span>
<span class="nc" id="L171">    override def query(filter: Filter): Iterator[SimpleFeature] = Iterator.empty</span>
<span class="nc" id="L172">    override def close(): Unit = {}</span>
<span class="nc" id="L173">    override def addListener(source: SimpleFeatureSource, listener: FeatureListener): Unit = {}</span>
<span class="nc" id="L174">    override def removeListener(source: SimpleFeatureSource, listener: FeatureListener): Unit = {}</span>
  }

<span class="nc" id="L177">  private class NoOpFeatureCache(val views: Seq[KafkaFeatureCacheView]) extends KafkaFeatureCache {</span>
<span class="nc" id="L178">    override def put(feature: SimpleFeature): Unit = {}</span>
<span class="nc" id="L179">    override def remove(id: String): Unit = {}</span>
<span class="nc" id="L180">    override def clear(): Unit = {}</span>
<span class="nc" id="L181">    override def size(): Int = 0</span>
<span class="nc" id="L182">    override def size(filter: Filter): Int = 0</span>
<span class="nc" id="L183">    override def query(id: String): Option[SimpleFeature] = None</span>
<span class="nc" id="L184">    override def query(filter: Filter): Iterator[SimpleFeature] = Iterator.empty</span>
<span class="nc" id="L185">    override def close(): Unit = {}</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>