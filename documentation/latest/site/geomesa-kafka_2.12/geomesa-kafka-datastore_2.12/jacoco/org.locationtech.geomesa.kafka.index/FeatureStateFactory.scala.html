<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FeatureStateFactory.scala</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoMesa Kafka Datastore</a> &gt; <a href="index.source.html" class="el_package">org.locationtech.geomesa.kafka.index</a> &gt; <span class="el_source">FeatureStateFactory.scala</span></div><h1>FeatureStateFactory.scala</h1><pre class="source lang-java linenums">/***********************************************************************
 * Copyright (c) 2013-2025 General Atomics Integrated Intelligence, Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 ***********************************************************************/

package org.locationtech.geomesa.kafka.index

import com.github.benmanes.caffeine.cache.Ticker
import com.typesafe.scalalogging.LazyLogging
import org.geotools.api.feature.simple.{SimpleFeature, SimpleFeatureType}
import org.geotools.api.filter.Filter
import org.geotools.api.filter.expression.Expression
import org.geotools.filter.text.ecql.ECQL
import org.locationtech.geomesa.filter.factory.FastFilterFactory
import org.locationtech.geomesa.kafka.data.KafkaDataStore._
import org.locationtech.geomesa.kafka.index.FeatureStateFactory.FeatureState
import org.locationtech.geomesa.memory.index.SpatialIndex
import org.locationtech.geomesa.utils.geotools.converters.FastConverter
import org.locationtech.geomesa.utils.io.CloseWithLogging
import org.locationtech.jts.geom.Geometry

import java.io.Closeable
import java.util.Date
import java.util.concurrent.{ScheduledExecutorService, ScheduledFuture, ScheduledThreadPoolExecutor, TimeUnit}
import scala.util.control.NonFatal

/**
  * Factory trait for creating feature states
  */
trait FeatureStateFactory extends Closeable {
  def createState(feature: SimpleFeature): FeatureState
}

<span class="nc bnc" id="L37" title="All 4 branches missed.">object FeatureStateFactory extends LazyLogging {</span>

  import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType

  def apply(
      sft: SimpleFeatureType,
      index: SpatialIndex[SimpleFeature],
      expiry: ExpiryTimeConfig,
      expiration: FeatureExpiration,
      executor: Option[(ScheduledExecutorService, Ticker)]): FeatureStateFactory = {

<span class="nc" id="L48">    val geom = sft.getGeomIndex</span>

<span class="nc bnc" id="L50" title="All 4 branches missed.">    lazy val (es, ticker) = executor.getOrElse {</span>
<span class="nc" id="L51">      val es = new ScheduledThreadPoolExecutor(2)</span>
      // don't keep running scheduled tasks after shutdown
<span class="nc" id="L53">      es.setExecuteExistingDelayedTasksAfterShutdownPolicy(false)</span>
      // remove tasks when canceled, otherwise they will only be removed from the task queue
      // when they would be executed. we expect frequent cancellations due to feature updates
<span class="nc" id="L56">      es.setRemoveOnCancelPolicy(true)</span>
<span class="nc" id="L57">      (es, CurrentTimeTicker)</span>
    }

<span class="nc" id="L60">    expiry match {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">      case NeverExpireConfig =&gt;</span>
<span class="nc" id="L62">        new BasicFactory(index, geom)</span>

<span class="nc bnc" id="L64" title="All 2 branches missed.">      case IngestTimeConfig(ex) =&gt;</span>
<span class="nc" id="L65">        new ExpiryFactory(index, geom, expiration, es, ex.toMillis)</span>

<span class="nc bnc" id="L67" title="All 2 branches missed.">      case EventTimeConfig(ex, time, ordering) =&gt;</span>
<span class="nc" id="L68">        val expression = FastFilterFactory.toExpression(sft, time)</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">        if (!ex.isFinite &amp;&amp; ordering) {</span>
<span class="nc" id="L70">          new EventTimeFactory(index, geom, expression)</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        } else if (ordering) {</span>
<span class="nc" id="L72">          new EventTimeOrderedExpiryFactory(index, geom, expression, expiration, es, ticker, ex.toMillis)</span>
        } else {
<span class="nc" id="L74">          new EventTimeExpiryFactory(index, geom, expression, expiration, es, ticker, ex.toMillis)</span>
        }

<span class="nc bnc" id="L77" title="All 2 branches missed.">      case FilteredExpiryConfig(ex) =&gt;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        val delegates = ex.map { case (ecql, e) =&gt;</span>
<span class="nc" id="L79">          FastFilterFactory.toFilter(sft, ecql) -&gt; apply(sft, index, e, expiration, Some(es -&gt; ticker))</span>
        }
<span class="nc" id="L81">        new FilteredExpiryFactory(delegates)</span>

<span class="nc bnc" id="L83" title="All 2 branches missed.">      case ImmediatelyExpireConfig =&gt;</span>
<span class="nc" id="L84">        throw new IllegalStateException(&quot;Can't use feature state with immediate expiration&quot;)</span>
    }
  }

  def time(expression: Expression, feature: SimpleFeature): Long = {
<span class="nc" id="L89">    try {</span>
<span class="nc" id="L90">      expression.evaluate(feature) match {</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        case d: Date   =&gt; d.getTime</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        case d: Number =&gt; d.longValue()</span>
<span class="nc" id="L93">        case d =&gt; Option(FastConverter.convert(d, classOf[Date])).map(_.getTime).getOrElse(0L)</span>
      }
    } catch {
<span class="nc bnc" id="L96" title="All 4 branches missed.">      case NonFatal(e) =&gt; logger.error(s&quot;Error evaluating event time for $feature&quot;, e); 0L</span>
    }
  }

  /**
    * Trait for expiring features
    */
  trait FeatureExpiration {
    def expire(featureState: FeatureState): Unit
  }

  /**
    * Holder for our key feature values
    */
  trait FeatureState {

    def id: String
    def time: Long

    def insertIntoIndex(): Unit
    def retrieveFromIndex(): SimpleFeature
    def removeFromIndex(): SimpleFeature
  }

  /**
    * Basic state, handles inserts and updates to the spatial index
    *
    * @param feature feature
    * @param index spatial index
    * @param geom geometry attribute index
    * @param time feature time
    */
<span class="nc" id="L128">  class BasicState(feature: SimpleFeature, index: SpatialIndex[SimpleFeature], geom: Int, val time: Long)</span>
<span class="nc" id="L129">      extends FeatureState {</span>

<span class="nc" id="L131">    private val g = feature.getAttribute(geom).asInstanceOf[Geometry]</span>

<span class="nc" id="L133">    override val id: String = feature.getID</span>
<span class="nc" id="L134">    override def insertIntoIndex(): Unit = index.insert(g, id, feature)</span>
<span class="nc" id="L135">    override def removeFromIndex(): SimpleFeature = index.remove(g, id)</span>
<span class="nc" id="L136">    override def retrieveFromIndex(): SimpleFeature = index.get(g, id)</span>

<span class="nc" id="L138">    override def toString: String = s&quot;FeatureState($feature)&quot;</span>
  }

  /**
    * Handles time-based expiration
    *
    * @param feature feature
    * @param index spatial index
    * @param geom geometry attribute index
    * @param time feature time
    * @param expiration callback for expiration
    * @param executor executor used to schedule expiration callback
    * @param expiry expiry in milliseconds
    */
<span class="nc" id="L152">  class ExpiryState(feature: SimpleFeature,</span>
                    index: SpatialIndex[SimpleFeature],
                    geom: Int,
                    time: Long,
<span class="nc" id="L156">                    expiration: FeatureExpiration,</span>
<span class="nc" id="L157">                    executor: ScheduledExecutorService,</span>
<span class="nc" id="L158">                    expiry: Long) extends BasicState(feature, index, geom, time) with Runnable {</span>

<span class="nc" id="L160">    private var future: ScheduledFuture[_] = _</span>

<span class="nc" id="L162">    override def run(): Unit = expiration.expire(this)</span>

    override def insertIntoIndex(): Unit = {
<span class="nc" id="L165">      super.insertIntoIndex()</span>
<span class="nc" id="L166">      future = executor.schedule(this, expiry, TimeUnit.MILLISECONDS)</span>
    }

    override def removeFromIndex(): SimpleFeature = {
<span class="nc" id="L170">      future.cancel(false)</span>
<span class="nc" id="L171">      super.removeFromIndex()</span>
    }

<span class="nc" id="L174">    override def toString: String = s&quot;ExpiryState($feature)&quot;</span>
  }

  /**
    * Already expired state - will short-circuit inserting and then expiring itself
    *
    * @param feature feature
    * @param time feature time
    * @param expiration expiration callback
    */
<span class="nc" id="L184">  class ExpiredState(feature: SimpleFeature, val time: Long, expiration: FeatureExpiration) extends FeatureState {</span>
<span class="nc" id="L185">    override val id: String = feature.getID</span>
<span class="nc" id="L186">    override def insertIntoIndex(): Unit = expiration.expire(this)</span>
<span class="nc" id="L187">    override def retrieveFromIndex(): SimpleFeature = null</span>
<span class="nc" id="L188">    override def removeFromIndex(): SimpleFeature = null</span>
<span class="nc" id="L189">    override def toString: String = s&quot;ExpiredState($feature)&quot;</span>
  }


  /**
    * Basic feature state factory
    *
    * @param index spatial index
    * @param geom geometry attribute index
    */
<span class="nc" id="L199">  class BasicFactory(index: SpatialIndex[SimpleFeature], geom: Int) extends FeatureStateFactory {</span>
<span class="nc" id="L200">    override def createState(feature: SimpleFeature): FeatureState = new BasicState(feature, index, geom, 0L)</span>
<span class="nc" id="L201">    override def close(): Unit = {}</span>
<span class="nc" id="L202">    override def toString: String = s&quot;BasicFactory[geom:$geom]&quot;</span>
  }

  /**
    * Feature state factory with timed expiration
    *
    * @param index spatial index
    * @param geom geometry attribute index
    * @param expiration expiration callback
    * @param executor executor service
    * @param expiry expiry in millis
    */
<span class="nc" id="L214">  class ExpiryFactory(index: SpatialIndex[SimpleFeature],</span>
<span class="nc" id="L215">                      geom: Int,</span>
<span class="nc" id="L216">                      expiration: FeatureExpiration,</span>
<span class="nc" id="L217">                      executor: ScheduledExecutorService,</span>
<span class="nc" id="L218">                      expiry: Long) extends FeatureStateFactory {</span>

    override def createState(feature: SimpleFeature): FeatureState =
<span class="nc" id="L221">      new ExpiryState(feature, index, geom, 0L, expiration, executor, expiry)</span>

<span class="nc" id="L223">    override def close(): Unit = executor.shutdownNow()</span>

<span class="nc" id="L225">    override def toString: String = s&quot;ExpiryFactory[geom:$geom,expiry:$expiry]&quot;</span>
  }

  /**
    * Feature state factory with event time ordering
    *
    * @param index spatial index
    * @param geom geometry attribute
    * @param eventTime event time expression
    */
<span class="nc bnc" id="L235" title="All 4 branches missed.">  class EventTimeFactory(index: SpatialIndex[SimpleFeature], geom: Int, eventTime: Expression)</span>
<span class="nc" id="L236">      extends FeatureStateFactory with LazyLogging {</span>

    override def createState(feature: SimpleFeature): FeatureState =
<span class="nc" id="L239">      new BasicState(feature, index, geom, FeatureStateFactory.time(eventTime, feature))</span>

<span class="nc" id="L241">    override def close(): Unit = {}</span>

<span class="nc" id="L243">    override def toString: String = s&quot;EventTimeFactory[geom:$geom,eventTime:${ECQL.toCQL(eventTime)}]&quot;</span>
  }

  /**
    * Feature state factory with event time expiration but message time ordering
    *
    * @param index spatial index
    * @param geom geometry attribute
    * @param eventTime event time expression
    * @param expiration expiration callback
    * @param executor executor
    * @param ticker scheduler
    * @param expiry expiry in millis
    */
<span class="nc" id="L257">  class EventTimeExpiryFactory(index: SpatialIndex[SimpleFeature],</span>
<span class="nc" id="L258">                               geom: Int,</span>
<span class="nc" id="L259">                               eventTime: Expression,</span>
<span class="nc" id="L260">                               expiration: FeatureExpiration,</span>
<span class="nc" id="L261">                               executor: ScheduledExecutorService,</span>
<span class="nc" id="L262">                               ticker: Ticker,</span>
<span class="nc" id="L263">                               expiry: Long) extends FeatureStateFactory {</span>

    override def createState(feature: SimpleFeature): FeatureState = {
<span class="nc" id="L266">      val expiry = FeatureStateFactory.time(eventTime, feature) + this.expiry - (ticker.read() / 1000000L)</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      if (expiry &lt; 1L) {</span>
<span class="nc" id="L268">        new ExpiredState(feature, 0L, expiration)</span>
      } else {
<span class="nc" id="L270">        new ExpiryState(feature, index, geom, 0L, expiration, executor, expiry)</span>
      }
    }

<span class="nc" id="L274">    override def close(): Unit = executor.shutdownNow()</span>

    override def toString: String =
<span class="nc" id="L277">      s&quot;EventTimeExpiryFactory[geom:$geom,eventTime:${ECQL.toCQL(eventTime)},expiry:$expiry]&quot;</span>
  }

  /**
    * Feature state factory with event time ordering and expiration
    *
    * @param index spatial index
    * @param geom geometry attribute
    * @param eventTime event time expression
    * @param expiration expiration callback
    * @param executor executor
    * @param ticker scheduler
    * @param expiry expiry in millis
    */
<span class="nc" id="L291">  class EventTimeOrderedExpiryFactory(index: SpatialIndex[SimpleFeature],</span>
<span class="nc" id="L292">                                      geom: Int,</span>
<span class="nc" id="L293">                                      eventTime: Expression,</span>
<span class="nc" id="L294">                                      expiration: FeatureExpiration,</span>
<span class="nc" id="L295">                                      executor: ScheduledExecutorService,</span>
<span class="nc" id="L296">                                      ticker: Ticker,</span>
<span class="nc" id="L297">                                      expiry: Long) extends FeatureStateFactory {</span>

    override def createState(feature: SimpleFeature): FeatureState = {
<span class="nc" id="L300">      val time = FeatureStateFactory.time(eventTime, feature)</span>
<span class="nc" id="L301">      val expiry = time + this.expiry - (ticker.read() / 1000000L)</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">      if (expiry &lt; 1L) {</span>
<span class="nc" id="L303">        new ExpiredState(feature, time, expiration)</span>
      } else {
<span class="nc" id="L305">        new ExpiryState(feature, index, geom, time, expiration, executor, expiry)</span>
      }
    }

<span class="nc" id="L309">    override def close(): Unit = executor.shutdownNow()</span>

    override def toString: String =
<span class="nc" id="L312">      s&quot;EventTimeOrderedExpiryFactory[geom:$geom,eventTime:${ECQL.toCQL(eventTime)},expiry:$expiry]&quot;</span>
  }

<span class="nc" id="L315">  class FilteredExpiryFactory(delegates: Seq[(Filter, FeatureStateFactory)]) extends FeatureStateFactory {</span>

<span class="nc bnc" id="L317" title="All 6 branches missed.">    require(delegates.last._1 == Filter.INCLUDE,</span>
<span class="nc" id="L318">      &quot;Filter feature state factory requires a fall back Filter.INCLUDE entry&quot;)</span>

<span class="nc" id="L320">    override def createState(feature: SimpleFeature): FeatureState = {</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">      val opt = delegates.collectFirst {</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">        case (f, factory) if f.evaluate(feature) =&gt; factory.createState(feature)</span>
      }
<span class="nc" id="L324">      opt.get // should always get a result due to the Filter.INCLUDE</span>
    }

<span class="nc" id="L327">    override def close(): Unit = CloseWithLogging(delegates.map(_._2))</span>

    override def toString: String =
<span class="nc bnc" id="L330" title="All 2 branches missed.">      s&quot;FilteredExpiryFactory[delegates:${delegates.map { case (f, d) =&gt; s&quot;${ECQL.toCQL(f)}-&gt;$d&quot;}.mkString(&quot;,&quot;)}]&quot;</span>
  }

<span class="nc" id="L333">  object CurrentTimeTicker extends Ticker {</span>
<span class="nc" id="L334">    override def read(): Long = System.currentTimeMillis() * 1000000L</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>